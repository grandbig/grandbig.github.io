
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Takahiro Octopress Blog</title>
  <meta name="author" content="Takahiro">

  
  <meta name="description" content="NSURLConnectionで同期・非同期通信をしてみる さて、1ヶ月ぶりでしょうか&hellip;.。久々にブログを更新します。
本日は、もはやObjective-c開発者なら誰しも使うであろうNSURLConnectionでの同期・非同期通信について書きたいと思います。 &hellip;">
  
  <meta name="google-site-verification" content="h2JWV1Gq5wVvtkoCC7o7IEPIVqaLWigK5aaxuRom6os" />

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://grandbig.github.io/blog/page/24/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="Takahiro Octopress Blog" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-44313398-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Takahiro Octopress Blog</a></h1>
  
    <h2>-1から始める情弱プログラミング</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:grandbig.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      


    <article class="post">
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/09/07/async-and-sync/">Objective-cで改めて同期・非同期について考えてみる</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-09-07T21:30:00+09:00" pubdate data-updated="true">Sep 7<span>th</span>, 2014</time>
        
         | <a href="/blog/2014/09/07/async-and-sync/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>NSURLConnectionで同期・非同期通信をしてみる</h3>

<p>さて、1ヶ月ぶりでしょうか&hellip;.。久々にブログを更新します。<br/>
本日は、もはやObjective-c開発者なら誰しも使うであろうNSURLConnectionでの同期・非同期通信について書きたいと思います。</p>

<p>NSURLConnectionで同期通信を行う場合、 <strong>sendSynchronousRequest</strong> を利用します。一方、非同期通信を行う場合、 <strong>sendAsynchronousRequest</strong> を利用します。<br/>
この2つの通信のどちらを利用するかについてはまさに <strong>使いドコロ</strong> によります。<br/>
同期通信の場合、メインスレッドでの実行のため、通信先サーバで処理の遅延があると、その間はアプリのUI操作ができなくなります。そのため、通信中はアプリの操作が発生し得ない場合に適していると言えます。<br/>
逆に、通信頻度が多いアプリの場合、UI操作を滞らせることがないように非同期通信を利用するべきです。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2014/09/07/async-and-sync/">Read on &rarr;</a>
    </footer>
  

</article>


    <article class="post">
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/08/02/didupdatetolocation3/">iOS7とNSTimerと位置情報の取得について</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-08-02T00:19:00+09:00" pubdate data-updated="true">Aug 2<span>nd</span>, 2014</time>
        
         | <a href="/blog/2014/08/02/didupdatetolocation3/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>iOS7で定期間隔での位置情報取得</h3>

<p>本日は一言メモ程度に書きます。<br/>
<a href="http://grandbig.github.io/blog/2013/09/27/location-nstimer/">Backgroundで位置情報を取得しよう！</a>で紹介した<strong>NSTimerで定期時間ごとに位置情報を取得してみよう！</strong>の部分についてiOS7での注意しなければいけないことがありました。</p>

<p>Background起動で位置情報の取得を可能な設定にしておくと、NSTimerが永続的に動くことについては以前お伝えしました。<br/>
このNSTimerで設定した定期間隔ごとに下記のように位置情報の取得ができました。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="n">CLLocation</span> <span class="o">*</span><span class="n">location</span> <span class="o">=</span> <span class="p">[</span><span class="n">locationManager</span> <span class="n">location</span><span class="p">];</span>
</span><span class='line'><span class="n">CLLocationCoordinate2D</span> <span class="n">coordinate</span> <span class="o">=</span> <span class="p">[</span><span class="n">location</span> <span class="n">coordinate</span><span class="p">];</span><span class="c1">// 座標を取得</span>
</span><span class='line'><span class="n">NSString</span> <span class="o">*</span><span class="n">lat</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSString</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithFormat:</span><span class="s">@&quot;%f&quot;</span><span class="p">,</span> <span class="n">coordinate</span><span class="p">.</span><span class="n">latitude</span><span class="p">];</span>  <span class="c1">// 経度を取得</span>
</span><span class='line'><span class="n">NSString</span> <span class="o">*</span><span class="n">lng</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSString</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithFormat:</span><span class="s">@&quot;%f&quot;</span><span class="p">,</span> <span class="n">coordinate</span><span class="p">.</span><span class="n">longitude</span><span class="p">];</span> <span class="c1">// 緯度を取得</span>
</span><span class='line'><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;+++++ [デリゲートによらない場合]緯度,经度: %@, %@&quot;</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">lng</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>しかし、iOS7ではある記述をしないとうまくいかないことがわかりました。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2014/08/02/didupdatetolocation3/">Read on &rarr;</a>
    </footer>
  

</article>


    <article class="post">
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/07/17/ios-google-oauth2-2/">iOSでGoogle OAuth認証がしたい〜OAuth2Clientを使う〜</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-07-17T00:08:00+09:00" pubdate data-updated="true">Jul 17<span>th</span>, 2014</time>
        
         | <a href="/blog/2014/07/17/ios-google-oauth2-2/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>OAuth2Clientを利用したOAuth認証をやってみる</h3>

<p>前回は<strong>gtm-oauth2</strong>ライブラリを利用したOAuth認証について説明しました。<br/>
このライブラリは非常に使いやすく、WebViewの実装もやってくれるので楽です。<br/>
ただ、１つだけ気になるのが、『このアプリが次のリクエストを許可しています』画面で<strong>承認するボタン</strong>を押した後に下記のような画面が出てしまうことです。<br/>
<img src="/images/goauth2-1.png" alt="気になる画面" /><br/>
これは格好悪いですね&hellip;。できれば、この画面を出したくない&hellip;。<br/>
そもそもこの画面が表示される理由は、redirectURIに<strong>urn:ietf:wg:oauth:2.0:oob</strong>を設定した場合だそうです。<br/>
詳しくは<a href="http://d.hatena.ne.jp/iad_otomamay/20130213/1360753743">山本大＠クロノスの日記 &ndash; GoogleAPI利用のためにOAuth2.0を使う</a>を確認してください。<br/>
gtm-oauth2ではredirectURIを開発者側で設定することなく、ライブラリが自動でやってくれるため、どうにもできないんですね&hellip;。<br/>
ま、ドメインのあるアドレスも持ってないですけど&hellip;。</p>

<p>そこで、<strong>OAuth2Client</strong>を使ってみることにしました。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2014/07/17/ios-google-oauth2-2/">Read on &rarr;</a>
    </footer>
  

</article>


    <article class="post">
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/07/13/ios-google-oauth2/">iOSでGoogle OAuth認証がしたい</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-07-13T00:17:00+09:00" pubdate data-updated="true">Jul 13<span>th</span>, 2014</time>
        
         | <a href="/blog/2014/07/13/ios-google-oauth2/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>iOSネイティブアプリにGoogle OAuth認証機能を実装する方法</h3>

<p>Google OAuth認証はWebアプリであれば多くの情報が載っているのですが、なぜかiOSネイティブアプリになると情報が全然見つからない&hellip;。<br/>
ということでその方法をまとめてみることにした。</p>

<p>まず、ネット上で検索してみるとiOSでOAuth認証をするためのライブラリは幾つか作られているようでした。<br/>
その中でも、Googleが提供している<strong>gtm-oauth2</strong>がよく使われているらしい。<br/>
ま、Googleが提供しているのであれば、安心して使えるだろうということで、ここでは<strong>gtm-oauth2</strong>を使った方法で説明します。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2014/07/13/ios-google-oauth2/">Read on &rarr;</a>
    </footer>
  

</article>


    <article class="post">
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/07/12/osx-server/">OS X Serverを使ってみよう</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-07-12T19:51:00+09:00" pubdate data-updated="true">Jul 12<span>th</span>, 2014</time>
        
         | <a href="/blog/2014/07/12/osx-server/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>初めてOSX Serverを使ってみた</h3>

<p>本日は少し、趣向を変えてみます。<br/>
筆者はこれまでWeb共有をSitesフォルダを作成してApacheの設定書いてApacheを再起動して&hellip;という定番のあれをやっていました。<br/>
しかし、<strong>iOS Developer契約をしている開発者であればOS X Serverを無料で利用できる</strong>と聞いたので、実際に使ってみたくなったのです。<br/>
あまり、ハマる人はいないかもしれないのですが、<strong>定番のWeb共有からOS X Serverに乗り換えたい</strong>という人のために手順をまとめたいと思います。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2014/07/12/osx-server/">Read on &rarr;</a>
    </footer>
  

</article>


    <article class="post">
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/28/ios8-new-sdk/">今一度Webアプリ開発者を振り向かせるiOS8の新SDK</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-28T18:50:00+09:00" pubdate data-updated="true">Jun 28<span>th</span>, 2014</time>
        
         | <a href="/blog/2014/06/28/ios8-new-sdk/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>iOS8の新機能とは？</h3>

<p>さて、今月初めにWWDC 2014が開催されました。毎年楽しみにされているAppleファンの方、新技術大好きなエンジニアの方にとっては今回の発表はどのように映ったのでしょうか？<br/>
さて、だいぶiOS8の新機能が世の中に知れ渡ってきた昨今ではありますが、あえて私個人の切り口でiOS8の新機能について着目していきたいと思います。<br/>
難しいことは言わずに、素人目に見て、使ってみたいとか/待ってました！！みたいなことを少し書ければと思います。<br/>
では、初めに一体全体何が新しく追加されたのか見て行きましょう！！</p>

<p>まずは、筆者注目の一覧。<br/>
※今回紹介するのは<strong>Swift</strong>と<strong>WKWebView</strong>に限ります。<br/>
・Swift: 言わずと知れた新言語<br/>
・Health Kit: これからは健康・医療の時代だ！そんなアプリが作れる！？<br/>
・Home Kit: もうリモコンなんて要らない！そう、iPhoneさえあれば&hellip;なんて言いたくなる！？<br/>
・Touch ID: アプリへのログインID？パスワード？そんな時間あるなら開発しようぜ！！はい、指紋認証<br/>
・Hand off: あぁ、時間がない(汗) 続きはお手元のiPhoneで！！的なファイル共有機能<br/>
・WKWebView: Webアプリの救世主！？ 超高速Webを実現<br/>
などなど</p>

<p>では、早速、注目のSwiftから見て行きましょう。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2014/06/28/ios8-new-sdk/">Read on &rarr;</a>
    </footer>
  

</article>


    <article class="post">
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/22/productionanddevelopment/">iOSアプリを開発する上で気をつけよう！ProductionとDevelopment</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-22T20:46:00+09:00" pubdate data-updated="true">Jun 22<span>nd</span>, 2014</time>
        
         | <a href="/blog/2014/06/22/productionanddevelopment/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>iOSアプリの開発で失敗しないためのお約束</h3>

<p>お久しぶりです！！最近はインターネットを使えない状況だったため、ブログの更新が滞っていました。しかし、本日からブログ再開したいと思います。<br/>
とは言うものの、約１ヶ月ぶりなため、リハビリを兼ねて今日は軽い内容にしておきたいと思います。</p>

<p>本日のお題は<strong>iOSアプリの開発で失敗しないために何を確認すべきか</strong>です。<br/>
開発者が自分のアプリを開発し、Appleに申請するのであれば、まず間違えることはないでしょう。<br/>
しかし、証明書を自身で発行せずに、他者が発行した証明書を用いてipaファイルもしくはappファイルを作成する場合は気をつけておかないとハマってしまうことがあります。</p>

<p>それは各種証明書が<strong>Production</strong>、<strong>Development</strong>のどちらで作成されたものかということです。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2014/06/22/productionanddevelopment/">Read on &rarr;</a>
    </footer>
  

</article>


    <article class="post">
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/18/backgroundfetch2/">Background FetchとBackground Transferについて</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-18T21:43:00+09:00" pubdate data-updated="true">May 18<span>th</span>, 2014</time>
        
         | <a href="/blog/2014/05/18/backgroundfetch2/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Background FetchとBackground Transferの違いについて</h3>

<p>今回はBackground FetchとBackground Transferについて筆者が混同していたことについて書こうと思います。Background Fetchのできることや使いどころは<a href="http://grandbig.github.io/blog/2014/05/13/backgroundfetch1/">前回</a>書きましたので、そちらをご覧下さい。<br/>
もともと筆者がBackground Transferに着目した理由はBackground Fetchでは不可能な長い時間の処理を実現させたいからでした。Background Transferでは見事にその想いを実現できる！！っと思っていました。<br/>
しかし、どうやら根本的に理解が間違っていたようなのです&hellip;。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2014/05/18/backgroundfetch2/">Read on &rarr;</a>
    </footer>
  

</article>


    <article class="post">
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/13/backgroundfetch1/">Background Fetch completionHandlerの実行タイミングについて</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-13T22:51:00+09:00" pubdate data-updated="true">May 13<span>th</span>, 2014</time>
        
         | <a href="/blog/2014/05/13/backgroundfetch1/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Background Fetchで気をつけること</h3>

<p>本日はBackground fetchについて書きたいと思います。時間の都合上、何回かに分けて書く予定です笑<br/>
Background fetchは既に皆さんもご存知の通りiOS7から加わった新機能です。通常、アプリをBackground起動にしたとき、アプリ内処理に許される時間は5秒間です。iOS6まではBackground起動中に継続して処理可能な機能は決まっていました。(位置情報の取得, 音楽の再生, 電話の3つ)<br/>
従って、これまでは<strong>beginBackgroundTaskWithExpirationHandler</strong>と<strong>setKeepAliveTimeout</strong>を用いて最大10分間の処理を継続して実行していました。(しかし、iOS7ではこの方法ができないらしいです。)<br/>
これに対してBackground fetchは30秒の制限はあるものの、OSが実行すべきと思ったタイミングで複数回実行されます。継続して実行する必要はないものの、どこかのタイミングで実行しておきたいというときには有効に使うことができるでしょう。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2014/05/13/backgroundfetch1/">Read on &rarr;</a>
    </footer>
  

</article>


    <article class="post">
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/10/submit-ios-app3/">iPhoneアプリを申請しました(3)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-10T00:39:00+09:00" pubdate data-updated="true">May 10<span>th</span>, 2014</time>
        
         | <a href="/blog/2014/05/10/submit-ios-app3/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>iPhoneアプリのバージョンアップ申請をしました</h3>

<p>本日、<strong>BLEMeasure 2.0</strong>を公開しました。昨年から公開しているBLEメジャーのバージョンアップとなります。今回はバージョンアップまでの道のりを紹介したいと思います。<br/>
<img src="/images/blemeasure_v2.png" alt="BLEMeasure 2.0" /><br/>
下記からダウンロードページにいけます<br/>
<a href="https://itunes.apple.com/jp/app/blemeja/id741597546?mt=8&uo=4" target="itunes_store"style="display:inline-block;overflow:hidden;background:url(https://linkmaker.itunes.apple.com/htmlResources/assets/ja_jp//images/web/linkmaker/badge_appstore-lrg.png) no-repeat;width:135px;height:40px;@media only screen{background-image:url(https://linkmaker.itunes.apple.com/htmlResources/assets/ja_jp//images/web/linkmaker/badge_appstore-lrg.svg);}"></a></p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2014/05/10/submit-ios-app3/">Read on &rarr;</a>
    </footer>
  

</article>

<nav id="pagenavi">
    
        <a href="/blog/page/23/" class="prev">Prev</a>
    
    
        <a href="/blog/page/25/" class="next">Next</a>
    
    <div class="center"><a href="/blog/archives">Blog Archives</a></div>
</nav>
    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2019 - Takahiro -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
  - <span class="credit">Theme by <a href="http://www.gehaxelt.in">Gehaxelt</a></span>
  <span class="credit">and <a href="http://www.it-solutions-neef.de">IT Solutions Neef</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'takahirooctopressblog';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>



<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/all.js#appId=212934732101925&xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>


Included file 'google_plus_one.html' not found in _includes directory

  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
