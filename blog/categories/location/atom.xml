<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: location | Takahiro Octopress Blog]]></title>
  <link href="http://grandbig.github.io/blog/categories/location/atom.xml" rel="self"/>
  <link href="http://grandbig.github.io/"/>
  <updated>2015-09-20T00:27:49+09:00</updated>
  <id>http://grandbig.github.io/</id>
  <author>
    <name><![CDATA[Takahiro]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Swiftを使って、位置情報を取得してみよう！]]></title>
    <link href="http://grandbig.github.io/blog/2014/10/19/developing-cllocation-app-by-using-swift/"/>
    <updated>2014-10-19T22:41:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2014/10/19/developing-cllocation-app-by-using-swift</id>
    <content type="html"><![CDATA[<h3>Swiftを使って位置情報を使ってみよう</h3>

<p>今日はSwiftを使った位置情報の取得を試してみたいと思います。<br/>
今日もObjective-Cの書式と比較しながら進めてみます。</p>

<h4>ライブラリのimport</h4>

<ul>
<li>Objective-Cの場合</li>
</ul>


<p>```objective-c
// ViewController.hファイル</p>

<h1>import &lt;UIKit/UIKit.h></h1>

<p>```</p>

<p>```objective-c
// ViewController.mファイル</p>

<h1>import &ldquo;ViewController.h&rdquo;</h1>

<h1>import &lt;CoreLocation/CoreLocation.h></h1>

<p>```</p>

<ul>
<li>Swiftの場合</li>
</ul>


<p><code>
// ViewController.swiftファイル
import UIKit
import CoreLocation
</code></p>

<!--more-->


<h4>インスタンス変数の宣言</h4>

<ul>
<li>Objective-Cの場合</li>
</ul>


<p>```objective-c
// ViewController.mファイル
@interface ViewController ()</p>

<p>@property (strong, nonatomic) CLLocationManager *lm;</p>

<p>@end
```
* Swiftの場合</p>

<p>```
// ViewController.swiftファイル
class ViewController: UIViewController {</p>

<pre><code>var lm:CLLocationManager?

.....
</code></pre>

<p>}</p>

<p>```</p>

<h4>Delegate Protocolの宣言</h4>

<ul>
<li>Objective-Cの場合</li>
</ul>


<p>```objective-c
// ViewController.mファイル
@interface ViewController() <CLLocationManagerDelegate> {</p>

<pre><code>......
</code></pre>

<p>}
```</p>

<ul>
<li>Swiftの場合</li>
</ul>


<p>```
// ViewController.swiftファイル
class ViewController: UIViewController, CLLocationManagerDelegate {</p>

<pre><code>......
</code></pre>

<p>}
```</p>

<h4>viewDidLoadメソッド</h4>

<ul>
<li>Objective-Cの場合</li>
</ul>


<p>```objective-c
// ViewController.mファイル
&ndash; (void)viewDidLoad {</p>

<pre><code>[super viewDidLoad];

if([self.lm respondToSelector:@selector(requestAlwaysAuthorization)]) {
    [self.lm requestAlwaysAuthorization];
}
</code></pre>

<p>}
```</p>

<ul>
<li>Swiftの場合</li>
</ul>


<p>```
override func viewDidLoad() {</p>

<pre><code>super.viewDidLoad()

if((self.lm?.respondToSelector("requestAlwaysAuthorization")) != nil) {
    self.lm?.requestAlwaysAuthorization()
}
</code></pre>

<p>}
```</p>

<h4>CLLocationManagerDelegateメソッド</h4>

<ul>
<li>Objective-Cの場合</li>
</ul>


<p>```objective-c
// ViewController.mファイル
// 位置情報の許可設定
&ndash; (void)locationManager:(CLLocationManager *)manager didChangeAuthorizationStatus:(CLAuthorizationStatus)status
{</p>

<pre><code>if (status == kCLAuthorizationStatusNotDetermined) {
} else if(status == kCLAuthorizationStatusAuthorizedAlways) {
    [self.lm startUpdatingLocation];
} else if(status == kCLAuthorizationStatusAuthorizedWhenInUse) {
    [self.lm startUpdatingLocation];
}
</code></pre>

<p>}</p>

<p>// 位置情報の更新ハンドリング処理
&ndash; (void)locationManager:(CLLocationManager <em>)manager didUpdateLocations:(NSArray </em>)locations {</p>

<pre><code>CLLocation *currentLocation = locations.lastObject;
CLLocationDegrees lat = currentLocation.coordinate.latitude;
CLLocationDegrees lng = currentLocation.coordinate.longitude;
CLLocationDegrees alt = currentLocation.altitude;
CLLocationDirection course = currentLocation.course;
CLLocationSpeed spd = currentLocation.speed;
CLLocationAccuracy hacc = currentLocation.horizontalAccuracy;
CLLocationAccuracy vacc = currentLocation.verticalAccuracy;
NSDate *dt = currentLocation.timestamp;
</code></pre>

<p>}
```</p>

<ul>
<li>Swiftの場合</li>
</ul>


<p>```
// ViewController.swiftファイル
// 位置情報の許可設定
func locationManager(manager: CLLocationManager!, didChangeAuthorizationStatus status: CLAuthorizationStatus) {</p>

<pre><code>if(status == .NotDetermined) {
} else if(status == .Authorized) {
    self.lm?.startUpdatingLocation()
} else if(status == .AuthorizedWhenInUse) {
    self.lm?.startUpdatingLocation()
}
</code></pre>

<p>}</p>

<p>// 位置情報の更新ハンドリング処理
func locationManager(manager: CLLocationManager!, didUpdateLocations locations: [AnyObject]!) {</p>

<pre><code>var currentLocation:CLLocation? = locations.last as? CLLocation
var lat:CLLocationDegrees? = currentLocation?.coordinate.latitude
var lng:CLLocationDegrees? = currentLocation?.coordinate.longitude
var alt:CLLocationDegrees? = currentLocation?.altitude
var course:CLLocationDirection? = currentLocation?.course
var spd:CLLocationSpeed? = currentLocation?.speed
var hacc:CLLocationAccuracy? = currentLocation?.horizontalAccuracy
var vacc:CLLocationAccuracy? = currentLocation?.verticalAccuracy
var dt:NSDate! = currentLocation?.timestamp
</code></pre>

<p>}
```</p>

<p>これでコーディングは完了です。<br/>
Swiftでも位置情報が取得できるようになりました。<br/>
次回はSwiftで何を書こうかな。<br/>
といったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS7とNSTimerと位置情報の取得について]]></title>
    <link href="http://grandbig.github.io/blog/2014/08/02/didupdatetolocation3/"/>
    <updated>2014-08-02T00:19:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2014/08/02/didupdatetolocation3</id>
    <content type="html"><![CDATA[<h3>iOS7で定期間隔での位置情報取得</h3>

<p>本日は一言メモ程度に書きます。<br/>
<a href="http://grandbig.github.io/blog/2013/09/27/location-nstimer/">Backgroundで位置情報を取得しよう！</a>で紹介した<strong>NSTimerで定期時間ごとに位置情報を取得してみよう！</strong>の部分についてiOS7での注意しなければいけないことがありました。</p>

<p>Background起動で位置情報の取得を可能な設定にしておくと、NSTimerが永続的に動くことについては以前お伝えしました。<br/>
このNSTimerで設定した定期間隔ごとに下記のように位置情報の取得ができました。</p>

<p><code>objective-c
CLLocation *location = [locationManager location];
CLLocationCoordinate2D coordinate = [location coordinate];// 座標を取得
NSString *lat = [NSString alloc] initWithFormat:@"%f", coordinate.latitude];  // 経度を取得
NSString *lng = [NSString alloc] initWithFormat:@"%f", coordinate.longitude]; // 緯度を取得
NSLog(@"+++++ [デリゲートによらない場合]緯度,经度: %@, %@", lat, lng);
</code></p>

<p>しかし、iOS7ではある記述をしないとうまくいかないことがわかりました。</p>

<!--more-->


<p>それは<strong>didUpdateLocationsメソッド</strong>です。<br/>
つまり、</p>

<p>```
&ndash; (void)locationManager:(CLLocationManager *)manager</p>

<pre><code> didUpdateLocations:(NSArray *)locations
</code></pre>

<p>{</p>

<p>}
```
の記述が必要なんです。<br/>
これがなかったとしても、NSTimer自体は動くので、処理は定期的に実行されます。<br/>
が、<strong>位置情報の値が全く更新されません</strong>。<br/>
iPhoneを持って移動したとしても、１回目に取得した位置情報の値から変化がないのです。</p>

<p>もし、<strong>NSTimerを使った定期間隔での位置情報の取得をiOS7で行う</strong>のであれば、このことには十分に注意してください。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[didUpdateLocationsを軽く調べてみる]]></title>
    <link href="http://grandbig.github.io/blog/2014/04/08/didupdatetolocation2/"/>
    <updated>2014-04-08T23:03:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2014/04/08/didupdatetolocation2</id>
    <content type="html"><![CDATA[<h3>didUpdateLocationsのNSArray型の引数が気になる！！</h3>

<p>さて、今日はざっくり調べたことを書きます。ほんの数行です！</p>

<!--more-->


<p><a href="http://grandbig.github.io/blog/2014/04/05/didupdatetolocation/">前回</a>、書きましたdidUpdateLocationsを使ってみました。<br/>
最も気になったのが、NSArray型の引数であるlocationsの中身には何が入っているのか？ということです。<br/>
下記のようにソースを書きます。</p>

<p>```objective-c
&ndash; (void)locationManager:(CLLocationManager *)manager</p>

<pre><code> didUpdateLocations:(NSArray *)locations
</code></pre>

<p>{</p>

<pre><code>CLLocation *currentLocation = locations.lastObject;
NSInteger cnt = [locations count];
CLLocationDegrees lat = currentLocation.coordinate.latitude;
CLLocationDegrees lng = currentLocation.coordinate.longitude;

NSLog(@"cnt: %ld,lat: %f, lng: %f", (long)cnt, lat, lng);
</code></pre>

<p>}
```
実際にログを出力してみた結果はというと&hellip;<br/>
2014-04-08 23:02:35.371 LocationPractice[11243:60b] cnt: 1,lat: 35.933374, lng: 139.619913<br/>
2014-04-08 23:02:36.837 LocationPractice[11243:60b] cnt: 1,lat: 35.933351, lng: 139.619884<br/>
2014-04-08 23:02:37.428 LocationPractice[11243:60b] cnt: 1,lat: 35.933327, lng: 139.619856<br/>
&hellip;&hellip;</p>

<p>の繰り返しでした。<br/>
NSArray型のlocationsには最新の位置情報しか入らないようです。<br/>
う〜む。なんでNSArray型なんでしょうか&hellip;。ただ、よくよく考えるとNSMutableArray型でないから要素増えないんでしょうか&hellip;。何て思ったりしました。<br/>
はい。短いけど、今日はここまで。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CLLocationManagerDelegateのdidUpdateToLocationがDeprecated!?]]></title>
    <link href="http://grandbig.github.io/blog/2014/04/05/didupdatetolocation/"/>
    <updated>2014-04-05T11:25:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2014/04/05/didupdatetolocation</id>
    <content type="html"><![CDATA[<h3>didUpdateToLocationではなくdidUpdateLocationsを使うべき!?</h3>

<p>久々に更新します。今日は位置情報サービスで変更があった点に注目してみます。筆者は昨日まで、この変更を気にせずに普通にこれまで通りの方法で位置情報の取得をしていました。<br/>
しかし、よくよく<a href="https://developer.apple.com/library/ios/documentation/CoreLocation/Reference/CLLocationManagerDelegate_Protocol/CLLocationManagerDelegate/CLLocationManagerDelegate.html">AppleのCLLocationManagerDelegate Protocol Reference</a>を見てみると、『locationManager:didUpdateToLocation:fromLocation:』に<strong>Deprecated in iOS 6.0</strong>の文字が&hellip;。<br/>
そして代わりに『locationManager:didUpdateLocations:』というものがありました。<br/>
う〜む&hellip;どうやら今はこちらを使った方が良いようですね。</p>

<!--more-->


<p>しかし、最新のXcode5.1でDeployment Targetを6.0に設定して下記をソースに書いたとしてもDeprecatedとWarningが出ることはありません。<br/>
```objective-c
&ndash; (void)locationManager:(CLLocationManager*)manager</p>

<pre><code>didUpdateToLocation:(CLLocation *)newLocation
       fromLocation:(CLLocation *)oldLocation
</code></pre>

<p>{</p>

<pre><code>CLLocationDegrees lat = [newLocation coordinate].latitude; // 緯度
CLLocationDegrees lng = [newLocation coordinate].longitude; // 経度
CLLocationDistance altitude = newLocation.altitude; // 高度
CLLocationDirection course = newLocation.course; // 方角
CLLocationSpeed speed = newLocation.speed; // 速度
CLLocationAccuracy horizontalAccuracy = newLocation.horizontalAccuracy; //水平方向の精度
CLLocationAccuracy verticalAccuracy = newLocation.verticalAccuracy; //垂直方向の精度
</code></pre>

<p>}
```</p>

<p>これではDeprecatedになっていることに気づかないですよね&hellip;。ま、新iOSがリリースされるごとにリファレンスをきちんと読むべきってことですね。<br/>
はい！では今度からこう書きましょう。</p>

<p>```objective-c
&ndash; (void)locationManager:(CLLocationManager *)manager</p>

<pre><code> didUpdateLocations:(NSArray *)locations
</code></pre>

<p>{</p>

<pre><code>CLLocation *currentLocation = locations.lastObject;
CLLocationDegrees lat = currentLocation.coordinate.latitude; // 緯度
CLLocationDegrees lng = currentLocation.coordinate.longitude; // 経度
CLLocationDistance altitude = currentLocation.altitude; // 高度
CLLocationDirection course = currentLocation.course; // 方角
CLLocationSpeed speed = currentLocation.speed; // 速度
CLLocationAccuracy horizontalAccuracy = currentLocation.horizontalAccuracy; // 水平方向の精度
CLLocationAccuracy verticalAccuracy = currentLocation.verticalAccuracy; // 水ty区方向の精度
</code></pre>

<p>}
```
古い方で位置情報を取得しても少なくともiOS6では問題ありませんでした。が、iOS7ではまだ未検証なので、試してみます。とは言え、新しい方を使うべきだと思いますが&hellip;。<br/>
と言ったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Backgroundで位置情報を取得しよう！]]></title>
    <link href="http://grandbig.github.io/blog/2013/09/27/location-nstimer/"/>
    <updated>2013-09-27T22:54:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2013/09/27/location-nstimer</id>
    <content type="html"><![CDATA[<h3>アプリがBackground起動のときでも位置情報を取得しよう！</h3>

<p>本日は位置情報を使ったアプリの開発について紹介します。<br/>
皆さんはiPhoneを使うとき果たして位置情報サービスをONにされてますでしょうか？<br/>
スマートフォンが多くの人に普及した近年では、その電池使用量の多さから『電池の使用を抑えるためには位置情報サービスをOFFにしましょう！』と言った声が現実にもネットにもあふれんばかりです。確かに位置情報サービスをONにしているとGPSを使うため、通常よりも電池を消費してしまいます。しかしながら、それ以上に非常に便利で役立つお得なアプリがどんどん世の中に出てきています。また、iOS7からiBeaconをサポートするため、その勢いは留まることを知らないでしょう。<br/>
そう、今後は位置情報サービスをONにすることへの抵抗が下がっていく可能性があるのです。では早速、開発について話を進めていきましょう！</p>

<!--more-->


<h4>簡単に位置情報を習得してみよう！</h4>

<p>まず、以前紹介した<a href="http://grandbig.github.io/blog/2013/09/13/lets-create-an-iphone-app/">Let&rsquo;s Create an iPhone App</a>のときと同様に下記状態までプロジェクト作成を進めて下さい。<br/>
<img src="/images/locationpractice.png" alt="LocationPractice.xcodeprojを作成" /><br/>
『Let&rsquo;s Create an iPhone App』のとき作成したようにViewControllerを追加し、今回は<strong>CoreLocation.framework</strong>というライブラリを追加しましょう。</p>

<p>位置情報の取得をするためにはCoreLocation.frameworkの中で定義されている<strong>CLLocationManagerクラス</strong>を利用します。<br/>
ViewController.mファイル内でCLLocationManagerクラスを使うためにViewController.hファイルで以下を定義しましょう。</p>

<p>```
// ViewController.hファイルの内容</p>

<h1>import &lt;UIKit/UIKit.h></h1>

<p>// ①CoreLocationのimportを書く</p>

<h1>import &lt;CoreLocation/CoreLocation.h></h1>

<p>// ②DelegateにCLLocationManagerDelegateを設定
@interface ViewController : UIViewController <CLLocationManagerDelegate> {</p>

<pre><code>// ③メンバ変数を定義
IBOutlet CLLocationManager *locationManager;
</code></pre>

<p>}
```
①CoreLocation.frameworkをViewController.m内で利用するためにimportする<br/>
②CLLocationManager関係の処理はCLLocationManagerクラスに任せてしまいたいのでDelegateを設定<br/>
※深く考えこまずにframwork使うときはDelegateを設定するようにしましょう。<br/>
③メンバ変数としてCLLocationManagerを定義します。</p>

<p>次にViewController.mファイルを編集します。
```
// ViewController.mファイルの内容</p>

<p>&hellip;
&ndash; (void)viewDidLoad {</p>

<pre><code>[super viewDidLoad];
// ①locationManager初期化
locationManager = [[CLLocationManager alloc] init];
// ②位置情報サービスのON/OFFで挙動を分岐
if ([CLLocationManager locationServicesEnabled]) {
    // ③locationManagerの各プロパティを設定
    locationManager.delegate = self;
    locationManager.desiredAccuracy = kCLLocationAccuracyHundredMeters;
    locationManager.activityType = CLActivityTypeFitness;
    locationManager.pausesLocationUpdatesAutomatically = NO;
    locationManager.distanceFilter = 100.0;
    // ④位置情報の取得開始
    [locationManager startUpdatingLocation];
} else {
    NSLog(@"Location services not available.");
}
</code></pre>

<p>}
&hellip;
// ⑤位置情報更新時
&ndash; (void)locationManager:(CLLocationManager *)manager</p>

<pre><code>didUpdateToLocation:(CLLocation *)newLocation
           fromLocation:(CLLocation *)oldLocation {
// ⑥ログを出力
NSLog(@"didUpdateToLocation latitude=%f, longitude=%f, accuracy=%f, time=%@",
    [newLocation coordinate].latitude,
    [newLocation coordinate].longitude,
    newLocation.horizontalAccuracy,
    newLocation.timestamp);
</code></pre>

<p>}
```
①当然のごとく初期化<br/>
②位置情報サービスの設定がON/OFFの場合で挙動を分けるために条件分岐を用意<br/>
③locationManagerの各プロパティを設定しましょう。<br/>
・desireAccuracy：位置情報の取得精度の設定です。6種類の中から選択します。<br/>
　kCLLocationAccuracyBestForNavigation：iOS4以降から使用可能です。最高精度。<br/>
　kCLLocationAccuracyBest：iOS3までの最高精度設定でした。<br/>
　kCLLocationAccuracyNearestTenMeters：誤差10mの設定<br/>
　kCLLocationAccuracyHundredMeters：誤差100mの設定<br/>
　kCLLocationAccuracyKilometer：誤差1kmの設定<br/>
　kCLLocationAccuracyThreeKilometers：誤差3kmの設定<br/>
・activityType：ユーザの移動タイプに合わせて位置情報の更新頻度を設定可能です。(iOS6以降から使用可能)<br/>
　CLActivityTypeFitness：ユーザが歩行移動のときに最適<br/>
　CLActivityTypeAutomotiveNavigation：ユーザが車で移動するときに最適<br/>
　CLActivityTypeOtherNavigation：ユーザがボート/電車/飛行機で移動するときに最適<br/>
　CLActivityTypeOther：その他<br/>
・pausesLocationUpdatesAutomatically：位置情報が自動的にOFFになる設定(iOS6以降から使用可能)<br/>
　アプリがBackground起動中に位置情報の更新が15分以上ない場合に自動でGPS起動がOFFになります。NOを設定することで回避できます。<br/>
・distanceFilter：ここで設定した距離以上移動した場合に位置情報を取得する設定<br/>
　単位は[m]です。<br/>
④位置情報の取得を開始します。<br/>
　停止する場合はstopUpdatingLocationになります。<br/>
⑤位置情報が更新されたときに実行される関数です。<br/>
⑥位置情報が正しく取得されていることを確認するためにログを出力しましょう。<br/>
　latitude, longitude: 緯度, 経度<br/>
　verticalAccuracy: 海抜高度の精度<br/>
　horizontalAccuracy：水平精度(マップを見たときの縦横の精度)  <br/>
　timestamp：位置情報の取得時刻<br/>
　speed：速度<br/>
　cource：方角</p>

<p>たったこれだけのことでiPhoneの位置情報を取得することができるようになります。</p>

<h4>NSTimerで定期時間ごとに位置情報を取得してみよう！</h4>

<p>先ほどdidUpdateToLocationを紹介しました。これは位置情報が更新された際に実行されます。逆に言えば、いつ位置情報を使った処理を実行できるかがわからないということになります。もし、5分毎に位置情報を使った処理を実行したいということがあればNSTimerを使う必要があります。<br/>
それではNSTimerを使って先ほどのソースを書き直してみます。</p>

<p>```
// ViewController.hファイルの内容</p>

<h1>import &lt;UIKit/UIKit.h></h1>

<h1>import &lt;CoreLocation/CoreLocation.h></h1>

<p>@interface ViewController : UIViewController <CLLocationManagerDelegate> {</p>

<pre><code>IBOutlet CLLocationManager *locationManager;
// NSTimerを定義
IBOutlet NSTimer *timer;
</code></pre>

<p>}
```</p>

<p>```
// ViewController.mファイルの内容
&hellip;
&ndash; (void)viewDidLoad {</p>

<pre><code>[super viewDidLoad];
locationManager = [[CLLocationManager alloc] init];
if ([CLLocationManager locationServicesEnabled]) {
    locationManager.delegate = self;
    locationManager.desiredAccuracy = kCLLocationAccuracyHundredMeters;
    locationManager.activityType = CLActivityTypeFitness;
    locationManager.pausesLocationUpdatesAutomatically = NO;
    locationManager.distanceFilter = 100.0;
    [locationManager startUpdatingLocation];
    // 5分ごとに繰り返しgetGpsDataを実行するようにタイマーを設定
    timer = [NSTimer scheduledTimerWithTimeInterval:300 target:self selector:@selector(getGpsData:)userInfo:nil repeats:YES];
} else {
    NSLog(@"Location services not available.");
}
</code></pre>

<p>}
&hellip;
&ndash; (void)getGpsData:(NSTimer *)theTimer {</p>

<pre><code>CLLocation *location = [locationManager location];
CLLocationCoordinate2D coordinate = [location coordinate];// 座標を取得
NSString *lat = [NSString alloc] initWithFormat:@"%f", coordinate.latitude];  // 経度を取得
NSString *lng = [NSString alloc] initWithFormat:@"%f", coordinate.longitude]; // 緯度を取得
NSLog(@"+++++ [デリゲートによらない場合]緯度,经度: %@, %@", lat, lng);
[lat release];
[lng release];
</code></pre>

<p>}
```</p>

<h4>Backgroundでも位置情報サービスを使えるように設定しよう！</h4>

<p>せっかくNSTimerを使って、定期間隔ごとに位置情報を利用した処理を実行することができるようになったので、アプリをBackground起動したときにも処理が実行されるように設定していきましょう。<br/>
①プロジェクトのCapabilityのBackgrounds Modeを設定(Xcode5から設定が必要)<br/>
プロジェクト > ターゲット > Capability > Background Modeの<strong>Location updates</strong>にチェックを入れる<br/>
<img src="/images/locationpractice2.png" alt="Location updatesにチェック" /><br/>
②plistの編集(どのXcodeのバージョンでも設定が必要)<br/>
Add Rowで<strong>Required Background Modes</strong>を追加して下さい。次にその値として<strong>App registers for location updates</strong>を選択して下さい。<br/>
<img src="/images/locationpractice3.png" alt="Required Background Modesを追加" /></p>

<p>これで端末をPCに繋いでプロジェクトを実行している状態で、ログの出力を確認して下さい。アプリがForeground起動のときでもBackground起動のときでもログが出力されることを確認できるはずです。</p>

<p>ここで重要なことを追記致します。NSTimerを用いてBackgroundで位置情報を定期的に取得できるのは<strong>標準位置情報サービス(startUpdatingLocation)</strong>のときのみです。<strong>大幅変更位置情報サービス(startMonitoringSignificantLocationChanges)</strong>ではできません。これは忘れがちなので注意が必要です。</p>

<p>因みに、Foreground, Backgroundと聞き慣れないかもしれないので説明しておくと<br/>
・Foreground起動：端末にアプリの起動画面が表示されている状態<br/>
・Background起動：端末にアプリの画面は表示されていないが、ホームボタン２回押しでアプリのアイコン(iOS6以前)またはアプリの画面(iOS7以降)が確認できる状態<br/>
ということです。<br/>
<img src="/images/ios_bg_app.png" alt="アプリのBackground起動" /></p>

<h4>最後に</h4>

<p>以上、少しは参考になったでしょうか。
そのうち本日、紹介した機能を使って実際にアプリを開発してみようと思います。では今日はこの辺で。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<!-- 広告2 -->


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
</feed>
