<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: redux | Takahiro Octopress Blog]]></title>
  <link href="http://grandbig.github.io/blog/categories/redux/atom.xml" rel="self"/>
  <link href="http://grandbig.github.io/"/>
  <updated>2017-01-01T12:54:20+09:00</updated>
  <id>http://grandbig.github.io/</id>
  <author>
    <name><![CDATA[Takahiro]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOSエンジニアが苦しんだReduxの基礎(2)]]></title>
    <link href="http://grandbig.github.io/blog/2017/01/01/redux-base-2/"/>
    <updated>2017-01-01T00:41:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2017/01/01/redux-base-2</id>
    <content type="html"><![CDATA[<h3>はじめに</h3>

<p>早くも2017年になってしまいましたね。<br/>
本年もよろしくお願い致します。</p>

<p>今回は<a href="http://grandbig.github.io/blog/2016/12/31/redux-base-1/">iOSエンジニアが苦しんだReduxの基礎(1)</a>の続きを書いていきたいと思います。<br/>
前回はReduxのみを利用したWebサイトの実装について話をしましたが、今回はReactと組み合わせて行きたいと思います。<br/>
では早速見ていきましょう。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h3>Counterサンプルで学ぼう！</h3>

<p><a href="http://redux.js.org/docs/introduction/Examples.html">公式ReduxページのExample</a>の先頭に書かれている <strong>Counter</strong> を見ていきましょう。<br/>
実現するWebサイトは <strong>Counter Vanilla</strong> と同じで下図のようになります。</p>

<p><img src="/images/redux_base_1.png" alt="Counter Example画面" /></p>

<p>実装されている機能としては下記の4つになります。</p>

<ul>
<li>「+」ボタンを選択するとClick数が+1される</li>
<li>「-」ボタンを選択するとClick数が-1される</li>
<li>「Increment if odd」ボタンを選択するとClick数が奇数のときのみ+1される</li>
<li>「Increment async」ボタンを選択すると1秒後にClick数が+1される</li>
</ul>


<p>前回と異なるのはViewに <strong>React</strong> を利用しているという点です。<br/>
では1つ1つ見ていきましょう。</p>

<h4>フォルダ構成</h4>

<p>まずはフォルダ構成を見ていきます。<br/>
(説明のために一部変更を加えています。)</p>

<p>```javascript
counter
├── public
│     └── index.html
└── src</p>

<pre><code> ├── index.js
 ├── actions
 │     └── index.js
 ├── reducers
 │     └── index.js
 ├── components
 │     └── Counter.js
 └── node_modules
</code></pre>

<p>```</p>

<h4>Actions</h4>

<p>今回<code>Actions</code>は<code>actions/index.js</code>にまとめています。<br/>
<code>Actions</code>と<code>Action Creators</code>について復習しておきます。</p>

<ul>
<li><code>Actions</code>

<ul>
<li>何をするアクションなのかを表すオブジェクト</li>
<li><code>type</code>プロパティを必ず持つ</li>
</ul>
</li>
<li><code>Action Creators</code>

<ul>
<li><code>Action</code>を作成するメソッド</li>
</ul>
</li>
</ul>


<p>```javascript
// actions/index.js
const INCREMENT = { type: &lsquo;INCREMENT&rsquo; }
const DECREMENT = { type: &lsquo;DECREMENT&rsquo; }</p>

<p>export function increment() {
  return INCREMENT;
}
export function decrement() {
  return DECREMENT;
}
```</p>

<h4>Reducers</h4>

<p>今回<code>Reducers</code>は<code>reducers/index.js</code>にまとめています。<br/>
<code>Reducers</code>についても復習しておきます。</p>

<ul>
<li><code>Action</code>と<code>State</code>から新たな<code>State</code>を作成して返す</li>
<li>ポイントは<code>State</code>を更新するのではなく、 新しく作成した<code>State</code> を返すということ</li>
</ul>


<p>```javascript
// reducers/index.js
export default (state = 0, action) => {
  // stateの初期値を0に設定
  switch (action.type) {</p>

<pre><code>case 'INCREMENT':
  return state + 1
case 'DECREMENT':
  return state - 1
default:
  return state
</code></pre>

<p>  }
}
```</p>

<h4>Components</h4>

<p>今回は<code>React</code>を利用するので、描画部分を表現する<code>Components</code>を作成する必要があります。<br/>
<code>Components</code>には<code>Presentational Component</code>と<code>Container Component</code>の2種類が存在します。</p>

<ul>
<li><code>Presentational Component</code>

<ul>
<li>画面の描画を担当する<code>Component</code></li>
</ul>
</li>
<li><code>Container Component</code>

<ul>
<li><code>Presentational Component</code>にデータやコールバックを渡す<code>Component</code></li>
</ul>
</li>
</ul>


<p>本記事のExampleは簡単なため、<code>Presentational Component</code>のみ利用しています。<br/>
<code>Presentational Component</code>は<code>components/Counter.js</code>が該当します。<br/>
ソースコードは下記の通りです。</p>

<p>```javascript
// components/Counter.js
import React, { Component, PropTypes } from &lsquo;react&rsquo;</p>

<p>class Counter extends Component {
  static propTypes = {</p>

<pre><code>value: PropTypes.number.isRequired,
onIncrement: PropTypes.func.isRequired,
onDecrement: PropTypes.func.isRequired
</code></pre>

<p>  }</p>

<p>  incrementIfOdd = () => {</p>

<pre><code>if (this.props.value % 2 !== 0) {
  // valueが奇数の場合のみonIncrementを実行
  this.props.onIncrement()
}
</code></pre>

<p>  }</p>

<p>  incrementAsync = () => {</p>

<pre><code>// 1秒後にonIncrementを実行
setTimeout(this.props.onIncrement, 1000)
</code></pre>

<p>  }</p>

<p>  render() {</p>

<pre><code>// 描画処理
const { value, onIncrement, onDecrement } = this.props
return (
  &lt;p&gt;
    Clicked: {value} times
    {' '}
    &lt;button onClick={onIncrement}&gt;
      +
    &lt;/button&gt;
    {' '}
    &lt;button onClick={onDecrement}&gt;
      -
    &lt;/button&gt;
    {' '}
    &lt;button onClick={this.incrementIfOdd}&gt;
      Increment if odd
    &lt;/button&gt;
    {' '}
    &lt;button onClick={this.incrementAsync}&gt;
      Increment async
    &lt;/button&gt;
  &lt;/p&gt;
)
</code></pre>

<p>  }
}</p>

<p>export default Counter
```</p>

<p><code>Counter Component</code>で最も重要なポイントは、<br/>
『描画には<code>value</code>, <code>onIncrement</code>, <code>onDecrement</code>の3つが必須』という点です。</p>

<h3>Store</h3>

<p>今回<code>Store</code>は<code>src/index.js</code>にまとめられています。<br/>
<code>Store</code>についても復習しておきましょう。</p>

<ul>
<li>アプリ内で必ず1つの存在</li>
<li>アプリの状態を管理する</li>
<li><code>State</code>を更新するための<code>dispatch</code>を提供する

<ul>
<li>言い換えれば<code>dispatch(action)</code>をすることで<code>Store</code>に<code>State</code>の変更を知らせられる</li>
</ul>
</li>
<li><code>State</code>の状態を追えるように<code>subscribe</code>を提供する

<ul>
<li>言い換えれば<code>subscribe(listener)</code>をすることで<code>listener</code>は<code>getState</code>を通して<code>State</code>の状態を取得できる</li>
</ul>
</li>
</ul>


<p>```javascript
// src/index.js
import React from &lsquo;react&rsquo;
import ReactDOM from &lsquo;react-dom&rsquo;
import { createStore } from &lsquo;redux&rsquo;
import Counter from &lsquo;./components/Counter&rsquo;
import counter from &lsquo;./reducers&rsquo;
import { increment, decrement } from &lsquo;./actions&rsquo;</p>

<p>const store = createStore(counter)
const rootEl = document.getElementById(&lsquo;root&rsquo;)</p>

<p>const render = () => ReactDOM.render(
  &lt;Counter</p>

<pre><code>value={store.getState()}
onIncrement={() =&gt; store.dispatch(increment())}
onDecrement={() =&gt; store.dispatch(decrement())}
</code></pre>

<p>  />,
  rootEl
)</p>

<p>render()
store.subscribe(render)
```</p>

<p>少し詳しくポイントを見ていきましょう。<br/>
冒頭で必要なモジュールを読み込んでいます。</p>

<p><code>javascript
import React from 'react'
import ReactDOM from 'react-dom'
import { createStore } from 'redux'
import Counter from './components/Counter'        // Component
import counter from './reducers'                  // Reducer
import { increment, decrement } from './actions'  // Action
</code></p>

<p>そして、下記のように<code>store</code>を作成しています。</p>

<p><code>javascript
// カウントアップ・ダウンのReducerを引数にStoreを生成
const store = createStore(counter)
</code></p>

<p>また、前回は<code>HTML</code>に全て構成を書いていましたが、今回は<code>React</code>を利用していますので、下記のように描画をしています。</p>

<p>```javascript
// id=&ldquo;root"のDOMを取得
const rootEl = document.getElementById(&lsquo;root&rsquo;)</p>

<p>// 描画メソッド
const render = () => ReactDOM.render(
  {/<em> Counter Componentの呼び出し </em>/}
  &lt;Counter</p>

<pre><code>value={store.getState()}
onIncrement={() =&gt; store.dispatch(increment)}
onDecrement={() =&gt; store.dispatch(decrement)}
</code></pre>

<p>  />,
  rootEl
)</p>

<p>// 初期描画処理
render()
```</p>

<p><code>Counter Component</code>の3つの必須<code>propTypes</code>に下記を渡しています。</p>

<ul>
<li>value: <code>State</code>の値(<code>store.getState()</code>)</li>
<li>onIncrement: <code>Store</code>に<code>State</code>の増加を通知(<code>() =&gt; store.dispatch(increment)</code>)</li>
<li>onDecrement: <code>Store</code>に<code>State</code>の減少を通知(<code>() =&gt; store.dispatch(decrement)</code>)</li>
</ul>


<p>上記のようにすることで、<br/>
クリックしたタイミングで<code>store.dispatch</code>に<code>Action Creators</code>である<code>increment</code>および<code>decrement</code>で作成した<code>Actions</code>を渡せるようになりました。<br/>
これにより、『 <strong>StoreにStateの変更を知らせる</strong> 』ことができます。</p>

<p>その後、<code>render()</code>で描画処理を実行しています。</p>

<p>最後に、<code>listener</code>処理です。</p>

<p><code>javascript
// subscribeの第一引数にrenderメソッドを指定
store.subscribe(render)
</code></p>

<p>上記のように、<code>store.subscribe</code>に<code>render</code>メソッドを渡すことで、<code>dispatch</code>実行して<code>State</code>の状態が変化したときに、毎回<code>render</code>メソッドが実行されることになります。<br/>
こうすることで、『 <strong>Stateの変更結果として描画に反映させる</strong> 』ことができます。</p>

<h3>まとめ</h3>

<p>さて、前回の素のReduxから、『ReactとReduxをそれぞれ素で利用する』ところまで進んできました。<br/>
ここまで割りとすんなり理解できたのであれば、<code>connect()</code>を利用したReact&amp;Reduxの実装の理解までもう少しだと思います。<br/>
Reduxの理解を促進する上で重要なのは、</p>

<ul>
<li>ユーザの操作結果を<code>Store</code>に伝えること</li>
<li><code>Store</code>の変更に応じて画面を再描画すること</li>
</ul>


<p>だと思っています。<br/>
ここまでの流れさえ理解できてしまえば、応用的な内容も躓かずに理解できるはずです。<br/>
さて次回はいよいよ<code>connect()</code>を利用したReact&amp;Reduxの実装について見ていきます。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOSエンジニアが苦しんだReduxの基礎(1)]]></title>
    <link href="http://grandbig.github.io/blog/2016/12/31/redux-base-1/"/>
    <updated>2016-12-31T01:17:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2016/12/31/redux-base-1</id>
    <content type="html"><![CDATA[<h3>はじめに</h3>

<p>今年も残すところ1日となりましたね。<br/>
筆者にとって2016年は新しいことだらけの1年となりました。<br/>
技術的にもこれまで触ってこなかったものに挑戦する機会を得ることができました。<br/>
その1つは本日のお題である <strong>Redux</strong> です。<br/>
実は現在進行系で理解に苦しんでいる途中なので、休暇中に理解を促進する意味も込めて記事を書きたいと思います。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h3>Reduxは難しい！？</h3>

<p>ここ最近、iOSエンジニアとして活動してきた筆者にとって <strong>なぜReduxが難しいと感じたのか</strong> について語りたいと思います。<br/>
結論から言うと、 <strong>ReactとReduxを組み合わせた場合の実装から入ったため</strong> 難しく感じたのではないかと思っています。<br/>
具体的には、ReactとReduxの公式ページや様々な紹介ページを読むと必ず出てくる <strong>connect()</strong> がかなり難しいと感じました。</p>

<p>プロジェクトに参画するタイミングによっては悠長に勉強をしている場合ではないと思いますが、<br/>
まずは素のReduxを理解することが最も近道だと実体験として感じました。</p>

<p>では、素のReduxはどうやって学べば良いのでしょうか？<br/>
Reduxで検索をしてもほとんどの場合、Reactと一緒に使われている記事しか出てこないと思います。<br/>
答えは簡単です！<br/>
(当たり前ではあるのですが、)公式のExampleを勉強すれば良いのです。</p>

<h3>Counter Vanilla サンプルで学ぼう！</h3>

<p><a href="http://redux.js.org/docs/introduction/Examples.html">公式ReduxページのExample</a>の先頭に書かれている <strong>Counter Vanilla</strong> を見ていきましょう。<br/>
ソースコードは下記のようになっています。<br/>
(少々、Reduxの原則と照らし合わせられるようにソースコードを改変しています。)</p>

<p>```javascript</p>

<!-- index.html -->


<p>&lt;!DOCTYPE html>
<html>
  <head></p>

<pre><code>&lt;title&gt;Redux basic example&lt;/title&gt;
&lt;script src="https://unpkg.com/redux@latest/dist/redux.min.js"&gt;&lt;/script&gt;
</code></pre>

<p>  </head>
  <body></p>

<pre><code>&lt;div&gt;
  &lt;p&gt;
    Clicked: &lt;span id="value"&gt;0&lt;/span&gt; times
    &lt;button id="increment"&gt;+&lt;/button&gt;
    &lt;button id="decrement"&gt;-&lt;/button&gt;
    &lt;button id="incrementIfOdd"&gt;Increment if odd&lt;/button&gt;
    &lt;button id="incrementAsync"&gt;Increment async&lt;/button&gt;
  &lt;/p&gt;
&lt;/div&gt;
&lt;script&gt;
  const INCREMENT = { type: 'INCREMENT' };
  const DECREMENT = { type: 'DECREMENT' };

  function increment() {
    return INCREMENT;
  }
  function decrement() {
    return DECREMENT;
  }

  function counter(state, action) {
    if (typeof state === 'undefined') {
      return 0
    }

    switch (action.type) {
      case 'INCREMENT':
        return state + 1
      case 'DECREMENT':
        return state - 1
      default:
        return state
    }
  }

  var store = Redux.createStore(counter)
  var valueEl = document.getElementById('value')

  function render() {
    valueEl.innerHTML = store.getState().toString()
  }

  render()
  store.subscribe(render)

  document.getElementById('increment')
    .addEventListener('click', function () {
      store.dispatch(increment())
    })

  document.getElementById('decrement')
    .addEventListener('click', function () {
      store.dispatch(decrement())
    })

  document.getElementById('incrementIfOdd')
    .addEventListener('click', function () {
      if (store.getState() % 2 !== 0) {
        store.dispatch(increment())
      }
    })

  document.getElementById('incrementAsync')
    .addEventListener('click', function () {
      setTimeout(function () {
        store.dispatch(increment())
      }, 1000)
    })
&lt;/script&gt;
</code></pre>

<p>  </body>
</html>
```</p>

<p>ブラウザに表示される画面は下記のようになります。<br/>
<img src="/images/redux_base_1.png" alt="Counter Example画面" /></p>

<p>実装されている機能としては下記の4つになります。</p>

<ul>
<li>「+」ボタンを選択するとClick数が+1される</li>
<li>「-」ボタンを選択するとClick数が-1される</li>
<li>「Increment if odd」ボタンを選択するとClick数が奇数のときのみ+1される</li>
<li>「Increment async」ボタンを選択すると1秒後にClick数が+1される</li>
</ul>


<p>これだけを見せられても実装内容がよくわからない(かもしれない)ですよね？<br/>
そこで1つ1つReduxの原則と照らし合わせつつ見ていきましょう。</p>

<h4>Actions</h4>

<p><code>Actions</code>とは</p>

<ul>
<li>何をするアクションなのかを表すオブジェクト</li>
<li><code>type</code>プロパティを必ず持つ</li>
</ul>


<p>です。<br/>
Exampleでは、下記に当たります。</p>

<p><code>javascript
const INCREMENT = { type: 'INCREMENT' }
const DECREMENT = { type: 'DECREMENT' }
</code></p>

<h4>Action Creators</h4>

<p><code>Action Creators</code>とは</p>

<ul>
<li><code>Action</code>を作成するメソッド</li>
</ul>


<p>です。<br/>
Exampleでは、下記に当たります。</p>

<p><code>javascript
function increment() {
  return INCREMENT
}
function decrement() {
  return DECREMENT
}
</code></p>

<h4>Reducers</h4>

<p><code>Reducers</code>とは</p>

<ul>
<li><code>Action</code>と<code>State</code>から新たな<code>State</code>を作成して返す</li>
<li>ポイントは<code>State</code>を更新するのではなく、 新しく作成した<code>State</code> を返すということ</li>
</ul>


<p>です。<br/>
Exampleでは、下記に当たります。<br/>
※Counter Exampleのため、<code>state</code>は <strong>カウント数</strong> を表します。</p>

<p>```javascript
function counter(state, action) {
  if (typeof state === &lsquo;undefined&rsquo;) {</p>

<pre><code>// 初期値は0として返却する
return 0
</code></pre>

<p>  }</p>

<p>  switch (action.type) {</p>

<pre><code>case 'INCREMENT':
  return state + 1
case 'DECREMENT':
  return state - 1
default:
  return state
</code></pre>

<p>  }
}
```</p>

<h4>Store</h4>

<p><code>Store</code>とは</p>

<ul>
<li>アプリ内で必ず1つの存在</li>
<li>アプリの状態を管理する</li>
<li><code>State</code>を更新するための<code>dispatch</code>を提供する

<ul>
<li>言い換えれば<code>dispatch(action)</code>をすることで<code>Store</code>に<code>State</code>の変更を知らせられる</li>
</ul>
</li>
<li><code>State</code>の状態を追えるように<code>subscribe</code>を提供する

<ul>
<li>言い換えれば<code>subscribe(listener)</code>をすることで<code>listener</code>は<code>getState</code>を通して<code>State</code>の状態を取得できる</li>
</ul>
</li>
</ul>


<p>です。<br/>
Exampleでは下記のように<code>store</code>を作成しています。</p>

<p><code>javascript
// Storeを作成するためのcreateStoreメソッドの第一引数にReducerを渡す
var store = Redux.createStore(counter)
</code></p>

<p>今回はCounter Exampleであるため、</p>

<ul>
<li>「+」ボタンを選択したら「+1」された結果が表示される</li>
<li>「-」ボタンを選択したら「-1」された結果が表示される</li>
</ul>


<p>ようになっています。<br/>
よって、「+ / -」ボタンをクリックしたタイミングで</p>

<ul>
<li>Storeに<code>state</code>の変更を知らせる</li>
<li><code>state</code>の変更を結果として描画に反映させる</li>
</ul>


<p>必要があります。<br/>
これはStore項目の冒頭で書いた<code>dispatch</code>と<code>listener</code>を利用することで達成できます。</p>

<p>まずは<code>dispatch</code>から見ていきましょう。</p>

<p>```javascript
// 「+」ボタンを選択した場合
document.getElementById(&lsquo;increment&rsquo;)
  .addEventListener(&lsquo;click&rsquo;, function () {</p>

<pre><code>store.dispatch(increment())
</code></pre>

<p>  })</p>

<p>// 「-」ボタンを選択した場合
document.getElementById(&lsquo;decrement&rsquo;)
  .addEventListener(&lsquo;click&rsquo;, function () {</p>

<pre><code>store.dispatch(decrement())
</code></pre>

<p>  })
```</p>

<p>上記のようにクリックしたタイミングで<code>store.dispatch</code>に<code>Action Creators</code>である<code>increment()</code>および<code>decrement()</code>で作成した<code>Actions</code>を渡しています。<br/>
こうすることで、『 <strong>Storeにstateの変更を知らせる</strong> 』ことができます。</p>

<p>次に<code>listener</code>から見ていきましょう。</p>

<p><code>javascript
// Click数を示すDOMの取得
var valueEl = document.getElementById('value')
// 最新のstateの状態をClick数に反映するメソッド
function render() {
  valueEl.innerHTML = store.getState().toString()
}
// 初期状態を表示するために実行
render()
// subscribeの第一引数にrenderメソッドを指定
store.subscribe(render)
</code></p>

<p>上記のように、<code>store.subscribe</code>に<code>render</code>メソッドを渡すことで、<code>dispatch</code>実行して<code>state</code>の状態が変化したときに、毎回<code>render</code>メソッドが実行されることになります。<br/>
こうすることで、『 <strong>stateの変更結果として描画に反映させる</strong> 』ことができます。<br/>
<code>subscribe</code>は<code>state</code>の状態を監視する役割を持っていることがわかると思います。</p>

<h3>まとめ</h3>

<p>さて如何でしたでしょうか？<br/>
今回はReduxの本質を理解するために、あえてReactを利用するExampleは選択しませんでした。<br/>
「React&amp;Reduxが全然わからん！！」という方はゆっくりと時間をとってReduxからチャレンジしてみることをオススメします。<br/>
次回はReactとの組み合わせを見ていきたいと思います。</p>

<p>参考:</p>

<ul>
<li><a href="http://redux.js.org/docs/introduction/Examples.html">公式ReduxページのExample</a></li>
<li><a href="http://grandbig.github.io/blog/2016/12/06/reswift-2/">ReSwiftを勉強してみよう(2)</a></li>
</ul>


<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ReSwiftを勉強してみよう！(2)]]></title>
    <link href="http://grandbig.github.io/blog/2016/12/06/reswift-2/"/>
    <updated>2016-12-06T00:00:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2016/12/06/reswift-2</id>
    <content type="html"><![CDATA[<h3>はじめに</h3>

<p>こちらは<a href="http://qiita.com/advent-calendar/2016/ios2">iOS その2 Advent Calendar 2016</a> 6日目の記事です。</p>

<p>今年は仕事でiOSを触る機会がめっきりと減ってしまったのですが、<br/>
「やはり１年を振り返るのならiOS Advent Calendarは欠かせないでしょう」ということで投稿することにしました。</p>

<p>最近、筆者が仕事で着手し始めた <strong>Redux</strong> に関連するということで <strong>ReSwift</strong> について見ていきたいと思います。<br/>
タイトルが <strong>(2)</strong> になっているのは、<br/>
以前に興味を持って自主的に取り組んでみた<a href="http://grandbig.github.io/blog/2016/09/03/reswift-1/">ReSwiftを勉強してみよう！(1)</a>の続きという意味です。<br/>
しかし、Advent Calendarの記事でもあるので本記事のみで完結する形で書きたいと思います。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<p>今回は公式GitHubに上がっている<a href="https://github.com/ReSwift/CounterExample-Navigation-TimeTravel">CounterExample-Navigation-TimeTravel</a>を元にReSwiftを勉強していきたいと思います。</p>

<h3>ReSwiftに出てくるモノと役割</h3>

<p>ReSwiftに出てくるモノと役割について改めて見直しをしてみましょう。</p>

<ul>
<li>Store

<ul>
<li>アプリ内で必ず1つの存在</li>
<li>アプリの状態を管理する</li>
<li>Stateを更新するための<code>dispatch</code>を提供する

<ul>
<li>言い換えれば<code>dispatch(action)</code>をすることでStoreにStateの変更を知らせられる</li>
</ul>
</li>
<li>Stateの状態を追えるように<code>subscribe</code>を提供する

<ul>
<li>言い換えれば<code>subscribe(listener)</code>をすることでlistenerは<code>getState</code>を通してStateの状態を取得できる</li>
</ul>
</li>
</ul>
</li>
</ul>


<p>サンプルでは下記が該当します。<br/>
Storeの宣言は下記のようになります。</p>

<p>```objective-c
// AppDelegate.swift
var mainStore = RecordingMainStore<AppState>(</p>

<pre><code>  reducer: AppReducer(),
  state: nil,
  typeMaps:[counterActionTypeMap, ReSwiftRouter.typeMap],
  recording: "recording.json"
</code></pre>

<p>)
```</p>

<p>このサンプルでは<a href="https://github.com/ReSwift/ReSwift-Recorder">ReSwiftRecorder</a>モジュールを利用しているため通常のStore宣言とは異なります。<br/>
ですが、重要なのは、<code>reducer</code>に<code>AppReducer()</code>を指定していることと、Storeが管理するStateの初期値を<code>state: nil</code>としているということです。</p>

<ul>
<li>State

<ul>
<li>アプリの状態</li>
</ul>
</li>
</ul>


<p>サンプルでは下記の通りです。</p>

<p>```objective-c
// AppState.swift
struct AppState: StateType, HasNavigationState {</p>

<pre><code>var counter: Int
var navigationState: NavigationState
</code></pre>

<p>}
```</p>

<p>サンプルでは<code>CounterViewController</code>でカウント数の増加および減少をさせる処理が実装されており、<br/>
<code>tabBarController</code>や<code>Button</code>のアクションなどで表示される画面を切り替える処理が実装されているため上記のように<code>counter</code>と<code>navigationState</code>の2つでアプリの状態を表すと定義しています。</p>

<ul>
<li>Action

<ul>
<li>何をするアクションなのかを表すオブジェクト</li>
<li><code>type</code>プロパティを必ず持つ</li>
</ul>
</li>
<li>ActionCreator

<ul>
<li>Actionを作成するメソッド</li>
</ul>
</li>
</ul>


<p>サンプルでは下記の通りです。</p>

<p>```objective-c
// CounterAction.swift
struct CounterActionIncrease: StandardActionConvertible {</p>

<pre><code>static let type = "COUNTER_ACTION_INCREASE"

init() {}
init(_ standardAction: StandardAction) {}

func toStandardAction() -&gt; StandardAction {
    return StandardAction(type: CounterActionIncrease.type, payload: [:], isTypedAction: true)
}
</code></pre>

<p>}
```</p>

<p>サンプルの<code>CounterAction.swift</code>の<code>CounterActionIncrease</code>はActionおよびActionCreatorの役割を兼ねています。</p>

<ul>
<li>Reducer

<ul>
<li>ActionとStateから新たなStateを作成して返す</li>
<li>ポイントはStateを更新するのではなく、 <strong>新しく作成したState</strong> を返すということ</li>
</ul>
</li>
</ul>


<p>サンプルでは下記の通りです。</p>

<p>```objective-c
// CounterReducer.swift
struct AppReducer: Reducer {</p>

<pre><code>func handleAction(action: Action, state: AppState?) -&gt; AppState {
    return AppState(
        counter: counterReducer(action: action, counter: state?.counter),
        navigationState: NavigationReducer.handleAction(action, state: state?.navigationState)
    )
}
</code></pre>

<p>}</p>

<p>func counterReducer(action: Action, counter: Int?) &ndash;> Int {</p>

<pre><code>var counter = counter ?? 0

switch action {
case _ as CounterActionIncrease:
    counter += 1
case _ as CounterActionDecrease:
    counter -= 1
default:
    break
}

return counter
</code></pre>

<p>}
```</p>

<p>サンプルでは、<code>handleAction</code>メソッドで「引数として受け取った<code>action</code>と<code>state</code>から作成した<code>AppState</code>を返却」しています。<br/>
カウントアップの処理がReducerに伝わった場合には、<br/>
<code>counterReducer</code>メソッドでそのActionに合わせて新たに必要なStateの情報を生成しています。<br/>
(カウントアップの場合は<code>CounterActionIncrease</code>アクションなので<code>counter += 1</code>しています。)</p>

<h3>ReSwiftに出てくるモノ同士の連携</h3>

<p>1個1個のモノと役割については理解が進みました。<br/>
続いて、それらの連携について見ていきましょう。<br/>
そのためには<code>ViewController</code>を見ていくのがわかりやすいかなと思います。</p>

<h4>カウントアップ・ダウンに見る連携</h4>

<p>まずは<code>CounterViewController</code>ですが、<br/>
「+」や「-」ボタンをタップすることで画面中央に表示されたカウントを増減させる画面です。</p>

<p>```objective-c
// CounterViewController.swift
import UIKit
import ReSwift
import ReSwiftRouter</p>

<p>class CounterViewController: UIViewController, StoreSubscriber, Routable {</p>

<p>  static let identifier = &ldquo;CounterViewController&rdquo;</p>

<p>  @IBOutlet var counterLabel: UILabel!</p>

<p>  override func viewWillAppear(_ animated: Bool) {</p>

<pre><code>mainStore.subscribe(self)
</code></pre>

<p>  }</p>

<p>  override func viewWillDisappear(_ animated: Bool) {</p>

<pre><code>mainStore.unsubscribe(self)
</code></pre>

<p>  }</p>

<p>  func newState(state: AppState) {</p>

<pre><code>// 新規Stateをキャッチ
// 画面のラベルを更新
counterLabel.text = "\(state.counter)"
</code></pre>

<p>  }</p>

<p>  @IBAction func increaseButtonTapped(_ sender: Any) {</p>

<pre><code>mainStore.dispatch(
  CounterActionIncrease()
)
</code></pre>

<p>  }</p>

<p>  @IBAction func decreaseButtonTapped(_ sender: Any) {</p>

<pre><code>mainStore.dispatch(
  CounterActionDecrease()
)
</code></pre>

<p>  }
}
```</p>

<p>細かく見ていきましょう。<br/>
Storeの役割で説明した「Stateの状態を追えるように<code>subscribe</code>を提供する」に相当する部分が、</p>

<p>```objective-c
override func viewWillAppear(_ animated: Bool) {
  mainStore.subscribe(self)
}</p>

<p>override func viewWillDisappear(_ animated: Bool) {
  mainStore.unsubscribe(self)
}
```</p>

<p>になります。<br/>
<code>viewWillAppear</code>で<code>subscribe</code>を実行することで、その画面が表示されるときにStateの監視を開始して、<code>viewWillDisappear</code>で<code>unsubscribe</code>を実行することで、その画面が非表示になるときにStateの監視を終了することにしています。</p>

<p>また、「Stateを更新するための<code>dispatch</code>を提供する」に相当する部分が、</p>

<p>```objective-c
@IBAction func increaseButtonTapped(_ sender: Any) {
  mainStore.dispatch(</p>

<pre><code>CounterActionIncrease()
</code></pre>

<p>  )
}</p>

<p>@IBAction func decreaseButtonTapped(_ sender: Any) {
  mainStore.dispatch(</p>

<pre><code>CounterActionDecrease()
</code></pre>

<p>  )
}
```</p>

<p>になります。<br/>
ユーザが「+」ボタンをタップしたときに<code>increaseButtonTapped</code>が呼び出されます。<br/>
そのときに上記アクションが実行されたことを<code>dispatch</code>を実行することでStoreに知らせています。<br/>
<code>decreaseButtonTapped</code>も同様です。</p>

<h4>画面切り替えに見る連携</h4>

<p>続いて<code>tabBarController</code>による画面の切り替えですが、これもこのサンプルでは状態変化として扱っています。<br/>
ただし、<code>ReSwiftRouter</code>モジュールで役割を担っているので、これを利用すれば開発者が新たに書く部分は非常に少なくなります。</p>

<p><code>UITabBarControllerDelegate</code>を利用してタブをタップしたタイミングをキャッチします。
そのときに、<code>ReSwiftRouter</code>の<code>SetRouteAction</code>を利用してタブによる画面切り替えのアクションをStoreに伝えています。</p>

<p>```objective-c
// AppDelegate.swift
extension AppDelegate: UITabBarControllerDelegate {</p>

<p>  func tabBarController(_ tabBarController: UITabBarController,</p>

<pre><code>shouldSelect viewController: UIViewController) -&gt; Bool {

if viewController is CounterViewController {

  mainStore.dispatch(
    SetRouteAction(["TabBarViewController", CounterViewController.identifier])
  )
} else if viewController is StatsViewController {
  mainStore.dispatch(
    SetRouteAction(["TabBarViewController", StatsViewController.identifier])
  )
}
    return false
</code></pre>

<p>  }
}
```</p>

<p>因みに、<code>SetRouteAction</code>は下記のように定義されています。</p>

<p>```objective-c
public struct SetRouteAction: StandardActionConvertible {</p>

<p>  let route: Route
  let animated: Bool
  public static let type = &ldquo;RE_SWIFT_ROUTER_SET_ROUTE&rdquo;</p>

<p>  public init (_ route: Route, animated: Bool = true) {</p>

<pre><code>self.route = route
self.animated = animated
</code></pre>

<p>  }</p>

<p>  public init(_ action: StandardAction) {</p>

<pre><code>self.route = action.payload!["route"] as! Route
self.animated = action.payload!["animated"] as! Bool
</code></pre>

<p>  }</p>

<p>  public func toStandardAction() &ndash;> StandardAction {</p>

<pre><code>return StandardAction(
  type: SetRouteAction.type,
  payload: ["route": route as AnyObject, "animated": animated as AnyObject],
  isTypedAction: true
)
</code></pre>

<p>  }<br/>
}
```</p>

<p>中身を見てみると<code>CounterAction</code>と同様に<code>toStandardAction</code>を利用しているのがわかります。<br/>
デバッグしていくとわかりますが、<code>tabBarController</code>を通した画面の切り替えでは、カウントアップやカウントダウンは無関係であるため<code>AppReducer</code>ではcountの状態を増減させることはありません。<br/>
変化するのは<code>AppState.navigationState</code>のみです。<br/>
こちらも追っていくとわかるのですが、下記の<code>NavigationReducer</code>に処理が引き継がれています。</p>

<p>```objective-c
public struct NavigationReducer {</p>

<p>  public static func handleAction(_ action: Action, state: NavigationState?) &ndash;> NavigationState {</p>

<pre><code>let state = state ?? NavigationState()

switch action {
case let action as SetRouteAction:
  return setRoute(state, setRouteAction: action)
case let action as SetRouteSpecificData:
  return setRouteSpecificData(state, route: action.route, data: action.data)
default:
  break
}

return state
</code></pre>

<p>  }</p>

<p>  static func setRoute(_ state: NavigationState, setRouteAction: SetRouteAction) &ndash;> NavigationState {</p>

<pre><code>var state = state

state.route = setRouteAction.route
state.changeRouteAnimated = setRouteAction.animated

return state
</code></pre>

<p>  }</p>

<pre><code>&lt;省略&gt;
</code></pre>

<p>}
```</p>

<p>このように、<code>NavigationReducer</code>の中で<code>NavigationState</code>型のオブジェクトを生成して返しています。<br/>
なので、アプリの状態である<code>AppState</code>が持つのは、</p>

<ul>
<li>counter: アプリのカウント状態</li>
<li>navigationState: アプリの画面状態</li>
</ul>


<p>と言えます。</p>

<h3>まとめ</h3>

<p>相変わらず、(流行っていないというのもあるかもしれませんが&hellip;)ReSwiftに関する日本語の記事が少ないですね。<br/>
恐らく、Web業界のようにFluxやReduxが実際のサービスに取り入れられているとは言い難いのでしょう。<br/>
その理由として考えられるのは、iOSの場合はデフォルトとしてStoryboardやViewControllerというものが存在し、Appleもそれをそのまま利用することを推奨しているからかもしれません。<br/>
しかしながら、複雑なアプリが世の中で求められるようになるに従って『ViewControllerの肥大化』や『複数人での開発による統一性の崩れ』といった課題により真剣に考えざるを得なくなってきました
。<br/>
必ずしも、これらの課題を解決するためにReSwiftを使わなければならないということはないのですが、1つの方法論として知っておくことで選択肢も増えてきます。<br/>
ただ、WebでReact&amp;Reduxを取り入れるのと同様に理解するためのハードルが高くもあるので現場で嫌がられることもあるかもしれません。<br/>
また、保守性として高いとは決して言えません。開発メンバーの入れ替えが発生したときにReSwiftを勉強するコストが発生します。<br/>
Webと違ってそこまで浸透しているとは言えないため、より導入が難しいと言えるでしょう。<br/>
ここにある種の矛盾が生じているわけですね&hellip;</p>

<p>筆者がちょうどReact&amp;Reduxに触れる機会が増えてきたため、良い機会だと思って、iOSでのReSwiftの利用メリットなどを合わせて考えていきたいと思っています。<br/>
そろそろ個人でのアプリ開発も復活させたい気持ちもありますし、その際には積極的に導入してみようかな&hellip;</p>

<p>と言ったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ReSwiftを勉強してみよう！(1)]]></title>
    <link href="http://grandbig.github.io/blog/2016/09/03/reswift-1/"/>
    <updated>2016-09-03T19:51:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2016/09/03/reswift-1</id>
    <content type="html"><![CDATA[<h3>はじめに</h3>

<p>本日は最近JavaScript界では浸透してきている<code>Redux</code>についてSwiftを通して勉強していきたいと思います。<br/>
<code>Redux</code>に関する日本語の記事はそれなりにあるもののSwift版ライブラリである<code>ReSwift</code>に関する日本語の記事は少ないため、筆者が少しでも記事を増やせたら良いなという思いがあります。<br/>
と言いつつも、いきなり有効性の高い有良記事を書くことはハードルが高いため、簡単な勉強から始めて行く次第です。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h3>ReSwiftとは</h3>

<p><code>ReSwift</code>とは<code>Redux</code>のSwift版ライブラリです。<br/>
<a href="https://github.com/ReSwift/ReSwift">GitHub: ReSwift/ReSwift</a>が公式ページとなります。</p>

<p>上記公式ページのイントロをざっくり訳すと&hellip;<br/>
(意味が間違っていたらごめんなさい&hellip;)</p>

<p>ReSwiftはSwiftで<a href="https://github.com/reactjs/redux">Redux</a>ライクな一方向のデータフローアーキテクチャを実装したものです。ReSwiftを使うことで、次の3つの関係性でアプリを構成することを手助けします。</p>

<ul>
<li><strong>State</strong> : 全てのアプリの状態を管理します。複雑な状態の管理やデバッグのし易さを手助けするなど、メリットは数多くあります。</li>
<li><strong>Views</strong> : 状態変化したときにViewを更新します。状態に対してシンプルなビジュアルを実現します。</li>
<li><strong>State Changes</strong> : <code>actions</code>を通した状態変化の実行のみを担当します。<code>actions</code>は状態変化を表現する小さなモジュールを指します。限られた状態変化を担うため、大人数で開発する際にアプリを簡単に理解することができるメリットがあります。</li>
</ul>


<p>また、ReSwiftは下記の3つの原則に従って構成されます。</p>

<ul>
<li><strong>The Store</strong> : アプリの状態(State)を保持するアプリ内で唯一の存在です。StoreにActionsが発送されることによってのみ状態(State)は変化します。状態(State)が変化したら必ず、Storeが全てのオブザーバに通知します。</li>
<li><strong>Actions</strong> : アプリの状態(State)がどんな変化なのかを宣言します。Storeによって消費され、Reducerに渡されます。Reducerは各Actionで引き起こされる異なる状態変化を実装することによってActionを扱います。</li>
<li><strong>Reducers</strong> : 現在のActionとStateに基いて、新しいStateを生成する純粋な関数を提供します。</li>
</ul>


<p>というように、何となく、この辺りを理解すれば良さそうですね。<br/>
まずは、公式ページに載っている最も簡単な『Counterサンプルアプリ』から上記の内容を直にコードで理解していきたいと思います。</p>

<h3>CounterサンプルアプリからReSwiftを理解しよう</h3>

<p>公式ページのREADMEには<a href="https://github.com/ReSwift/CounterExample">CounterExample</a>が紹介されています。<br/>
公開されているサンプルアプリの中で最も簡単なサンプルなはずなので、これを見ていきたいと思います。</p>

<p>最終的なフォルダ構成は下記になります。<br/>
(関係のないファイルは除いています。)</p>

<p><code>objective-c
ReSwiftSample
┣━━ State
┃   ┗━━ AppState.swift
┣━━ Actions
┃   ┗━━ CounterActions.swift
┣━━ Reducers
┃   ┗━━ CounterReducers.swift
┣━━ ViewController.swift
┣━━ AppDelegate.swift
┗━━ Main.storyboard
</code></p>

<p>では早速、1つずつ見ていきましょう。</p>

<h4>ReSwiftをCocoaPodsでインストール</h4>

<p>例によってCocoaPodsでインストールします。</p>

<p>```objective-c
use_frameworks!</p>

<p>target &lsquo;ReSwiftSample&rsquo; do</p>

<pre><code>pod 'ReSwift'
</code></pre>

<p>end</p>

<p>target &lsquo;ReSwiftSampleTests&rsquo; do</p>

<pre><code>pod 'ReSwift'
</code></pre>

<p>end</p>

<p>target &lsquo;ReSwiftSampleUITests&rsquo; do</p>

<pre><code>pod 'ReSwift'
</code></pre>

<p>end
```</p>

<p>これで<code>pod install</code>すればOKです。</p>

<h4>State</h4>

<p>準備が整ったところでコードを具体的に見ていきましょう。
まずは<code>AppState.swift</code>を見ていきます。</p>

<p>```objective-c
//AppState.swift
import Foundation
import ReSwift</p>

<p>struct AppState: StateType {</p>

<pre><code>var counter: Int
</code></pre>

<p>}
```</p>

<p>今回のアプリは単純なカウントアップアプリなので、上記では<code>AppState</code>の1つのプロパティとして <strong>カウントの状態(counter)</strong> を定義しています。</p>

<h4>Action</h4>

<p>続いて<code>CounterActions.swift</code>を見ていきます。</p>

<p>```objective-c
// CounterActions.swift
import Foundation
import ReSwift</p>

<p>struct CounterActionIncrease: Action {}
struct CounterActionDecrease: Action {}
```</p>

<p>カウントアップの動作には <strong>『増加(Increase)』</strong> と <strong>『減少(Decrease)』</strong> の2つがあるため、それぞれのActionを定義します。<br/>
ここで注意したいのはActionは関数(<code>func</code>)ではなく構造体(<code>struct</code>)であるということです。<br/>
先に述べたようにActionは状態の宣言であり、Reducerに渡されて、処理を判別するために利用されるからです。</p>

<h4>Reducer</h4>

<p>そして、<code>CounterReducers.swift</code>を見ていきます。</p>

<p>```objective-c
// CounterReducers.swift
struct CounterReducer: Reducer {</p>

<pre><code>func handleAction(action: Action, state: AppState?) -&gt; AppState {
    var state = state ?? AppState()

    switch action {
        case _ as CounterActionIncrease:
            state.counter += 1
        case _ as CounterActionDecrease:
            state.counter -= 1
        default:
            break
    }

    return state
}
</code></pre>

<p>}
```</p>

<p>先に述べましたが、Reducerは引数として渡されたStateとActionの2つから新規のStateを返却します。<br/>
重要なのは、 <strong>新規のStateを返却する</strong> ということです。<br/>
これは<code>var state = state ?? AppState()</code>を見るとわかるかと思います。<br/>
既に<code>state</code>オブジェクトがある場合は値渡しで新規<code>AppState</code>型に内容を格納しています。<br/>
もし、<code>state</code>オブジェクトがなければ、初期化して作成しています。</p>

<p>そして<code>switch</code>文で各Actionごとに最適な処理を実行しています。<br/>
(今回の場合は『Increase』と『Decrease』)</p>

<h4>Store</h4>

<p>モジュールの作成が完了したので、実装していきます。<br/>
先に述べたように<code>Store</code>はアプリの状態(State)を保持するアプリ内で <strong>唯一の存在</strong> です。<br/>
よって、<code>AppDelegate.swift</code>で次のように定義します。</p>

<p>```objective-c
// AppDelegate.swift
import UIKit
import ReSwift</p>

<p>let mainStore = Store<AppState>(</p>

<pre><code>reducer: CounterReducer(),
state: nil
</code></pre>

<p>)</p>

<p>@UIApplicationMain
class AppDelegate: UIResponder, UIApplicationDelegate {</p>

<pre><code>...
</code></pre>

<p>}
```</p>

<p>上記では<code>Store</code>型の<code>mainStore</code>を定義しています。<br/>
Reducerとして<code>CounterReducer</code>を定義しています。<br/>
Stateは初期値<code>nil</code>として定義しています。</p>

<h4>View層への実装</h4>

<p>最後にユーザの操作が走った際の処理の実装について見ていきます。<br/>
状態変化の監視開始/終了を下記で実施します。</p>

<p>```objective-c
// ViewController.swift
import UIKit
import ReSwift</p>

<p>class ViewController: UIViewController, StoreSubscriber {</p>

<pre><code>override func viewWillAppear(animated: Bool) {
    super.viewWillAppear(animated)
    mainStore.subscribe(self)   // 状態変化の監視開始
}

override func viewWillDisappear(animated: Bool) {
    super.viewWillDisappear(animated)
    mainStore.unsubscribe(self) // 状態変化の監視終了
}

...
</code></pre>

<p>}
```</p>

<p>続いて、ユーザ操作からのReducerへのAction発送部分です。</p>

<p>```objective-c
// ViewController.swift
@IBAction func increaseButtonTapped(sender: AnyObject) {</p>

<pre><code>mainStore.dispatch(
    CounterActionIncrease()
)
</code></pre>

<p>}</p>

<p>@IBAction func decreaseButtonTapped(sender: AnyObject) {</p>

<pre><code>mainStore.dispatch(
    CounterActionDecrease()
)
</code></pre>

<p>}
```</p>

<ul>
<li>『増加』ボタンタップ時にStoreが『CounterActionIncreaseというAction』をReducerへdispatch(発送)します。</li>
<li>『減少』ボタンタップ時にStoreが『CounterActionDecreaseというAction』をReducerへdispatch(発送)します。</li>
</ul>


<p>そして、新しいStateが返却された際に実行すべき処理を書くために<code>StoreSubscriber</code>プロトコルに<code>newState</code>メソッドが定義されています。<br/>
よって、</p>

<p>```objective-c
// ViewController.swift
class ViewController: UIViewController, StoreSubscriber {</p>

<pre><code>@IBOutlet weak var counterLabel: UILabel!

...

func newState(state: AppState) {
    counterLabel.text = "\(state.counter)"
}
...
</code></pre>

<p>}
```</p>

<p>のように実装することで<code>newState</code>メソッド内で任意の処理を書くことができます。</p>

<h3>まとめ</h3>

<p>さて、如何でしたでしょうか？<br/>
今回は公式の最も簡単なサンプルについて見ていきましたが、少々ReSwiftの扱い方が見えてきた気がします。<br/>
また、ReSwiftが有能であるが故にReduxであればもっと自分で書かなければいけなさそうなところもカバーしてくれているように見えました。<br/>
実践での活用なRxSwift同様にいろいろなリスク管理的な意味で難しいのかもしれませんが、もっとReSwiftを理解することで想定を上回るメリットを示し、実践で利用できるかもしれません。</p>

<p>そんなことを夢見ながら今後は、別の公式サンプルを見つつ理解を深めていきたい思います。<br/>
と言ったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
</feed>
