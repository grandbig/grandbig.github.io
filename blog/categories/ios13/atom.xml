<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ios13 | Takahiro Octopress Blog]]></title>
  <link href="http://grandbig.github.io/blog/categories/ios13/atom.xml" rel="self"/>
  <link href="http://grandbig.github.io/"/>
  <updated>2019-10-19T20:30:06+09:00</updated>
  <id>http://grandbig.github.io/</id>
  <author>
    <name><![CDATA[Takahiro]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS13で密かに追加されたUserDefaultsへの保存制限]]></title>
    <link href="http://grandbig.github.io/blog/2019/10/19/ios13-userdefaults/"/>
    <updated>2019-10-19T16:49:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2019/10/19/ios13-userdefaults</id>
    <content type="html"><![CDATA[<h3>はじめに</h3>

<p>先日ふと調べ物をしていたところ、<br/>
<a href="https://forums.developer.apple.com/thread/121527">iOS 13 &ndash; Attempting to store >= 4194304 bytes of data in CFPreferences/NSUserDefaults on this platform is invalid</a>
という何やら気になる話を見つけました。</p>

<p>どうも <code>iOS13</code> からは、 <code>UserDefaults</code> に保存できる容量が <code>4194304 bytes</code> と制限が追加されたようだと言うのです。<br/>
これは実際にやってみるっきゃない！ということで実験をしてみました。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h3>実験</h3>

<p>実際に筆者が実行した実験内容は下記の通りです。</p>

<ul>
<li><code>iOS13.1.3</code> の端末を用いて、 <code>UserDefaults</code> への保存の合計容量が <code>4194304 bytes</code> を超過すると怒られるのか</li>
</ul>


<p>それでは実際に見ていきましょう。</p>

<h4>実験に利用したソースコード</h4>

<p>制限が <code>4194304 bytes</code> であるため、文字列を保存するのは手間がかかりそうだったので、<br/>
<code>Assets.xcassets</code> に予め用意した画像を <code>Data</code> 型に変換後、 <code>UserDefaults</code> に保存することにしました。</p>

<p>用意した画像は下記になります。</p>

<ul>
<li>サイズが <code>262KB</code> の画像</li>
</ul>


<p>実験に利用したソースコードは下記になります。</p>

<p>```objective-c
// ViewController.swift
import UIKit</p>

<p>class ViewController: UIViewController {</p>

<pre><code>override func viewDidLoad() {
    super.viewDidLoad()
}

@IBAction func saveImage(_ sender: Any) {
    let image = UIImage(named: "test1")
    if let data = image?.pngData() {
        let keyName = "test\(Int.random(in: 1 ... 100))"
        print("\(data) , keyName: \(keyName)")
        UserDefaults.standard.set(data, forKey: keyName)
        UserDefaults.standard.synchronize()
    }
}
</code></pre>

<p>}
```</p>

<h4>実験結果</h4>

<p>早速、実験結果について見てみましょう。</p>

<p>1回の保存サイズが <code>350129 bytes</code> だったため、12回で <code>4201548 bytes</code> となり、<br/>
宣言である <code>4194304 bytes</code> を超えることになります。</p>

<p>今回の実験では、 <code>print</code> 文で『ランダムなキー名とバイト数』を出力するように組み込み、<br/>
端末の該当アプリに対して <code>Download Container...</code> から <code>UserDefaults</code> の中身を取得し比較してみました。</p>

<p>出力結果は、</p>

<p><code>objective-c
350129 bytes , keyName: test59
350129 bytes , keyName: test50
350129 bytes , keyName: test51
350129 bytes , keyName: test7
350129 bytes , keyName: test58
350129 bytes , keyName: test7
350129 bytes , keyName: test91
350129 bytes , keyName: test83
350129 bytes , keyName: test54
350129 bytes , keyName: test90
350129 bytes , keyName: test80
350129 bytes , keyName: test71
350129 bytes , keyName: test25
2019-10-19 16:47:19.645111+0900 AppSample[1048:193781] [User Defaults] CFPrefsPlistSource&lt;0x2821a5600&gt; (Domain: com.xxx.AppSample, User: kCFPreferencesCurrentUser, ByHost: No, Container: (null), Contents Need Refresh: Yes): Attempting to store &gt;= 4194304 bytes of data in CFPreferences/NSUserDefaults on this platform is invalid. This is a bug in NotificationSample or a library it uses
2019-10-19 16:47:19.645273+0900 AppSample[1048:193781] [User Defaults] CFPrefsPlistSource&lt;0x2821a5600&gt; (Domain: com.xxx.AppSample, User: kCFPreferencesCurrentUser, ByHost: No, Container: (null), Contents Need Refresh: No): Transitioning into direct mode
350129 bytes , keyName: test21
350129 bytes , keyName: test32
</code></p>

<p>となり、 <strong>13個目</strong> の保存時にエラーが出力されました。
(途中キー名が被っており、上書きとなるため、その回数はスキップしています。)</p>

<p><code>Download Container...</code> で取得した <code>UserDefaults</code> の中身はどうなっているかと言うと、</p>

<p><img src="/images/ios13-userdefaults.png" alt="UserDefaultsに保存された内容" /></p>

<p>となっており、12個目までは保存されているようでした。</p>

<p>厳密には少々超える分には、許容されているように見えましたが、少なくとも、はっきりと超えた場合は保存されないことがわかりました。</p>

<h3>まとめ</h3>

<p>さて如何でしたでしょうか？<br/>
<code>UserDefaults</code> は大量の重要データを保存するのには不向きであることは、これまで通り自明であったと思いますが、<br/>
それがより厳密化されたと言えるのではないでしょうか。</p>

<p>今後に備えて、データの保存方法を今一度見直すにはいい機会かなと思います。<br/>
と言ったところで本日はここまで。</p>

<p>参考URL：</p>

<ul>
<li><a href="https://forums.developer.apple.com/thread/121527">Apple Developer Forums: iOS 13 &ndash; Attempting to store >= 4194304 bytes of data in CFPreferences/NSUserDefaults on this platform is invalid</a></li>
</ul>


<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS13から対応する『Sign In with Apple』〜サードパーティアカウントでOAuth認証によるログインを備えたアプリで迷わないように。〜]]></title>
    <link href="http://grandbig.github.io/blog/2019/10/06/sign-in-with-apple/"/>
    <updated>2019-10-06T17:05:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2019/10/06/sign-in-with-apple</id>
    <content type="html"><![CDATA[<h3>はじめに</h3>

<p>今回はiOS13から導入された <code>Sign In with Apple</code> について見ていきたいと思います。</p>

<p>もし、 <code>Facebook / Google / Twitter</code> などのアカウントを用いたログインを可能とする機能をアプリが持っている場合、<br/>
Appleが新たに提唱した <code>Sign In with Apple</code> の機能を実装する必要性が出てきたようです。</p>

<p>一方で <code>Facebook / Google / Twitter</code> などの本家のアプリでは恐らく実装する必要はないと思われます。<br/>
(ログイン機能を実装するのであれば、 <code>Sign In with Apple</code> が必須という話ではなく、サードパーティ製のログイン機能を持つアプリに限るようです。 )</p>

<p>とは言え、「急にそんなことを言われても対応工数がかかるし、他に実装したい機能もあるし&hellip;」と困るエンジニアもいるかもしれません。</p>

<p>ですが、 <code>Apple</code> が要求する以上、 iOSアプリを開発し続ける上で避けては通れない問題ですので、簡単に対応方法を紹介したいと思います。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h3>Apple Developer Programでの対応</h3>

<p>まずは、コードを書く前に、 <code>Sign In with Apple</code> の機能を有効にした <code>App ID</code> を作成し、 <code>Provisioning Profile</code> に紐付ける必要があります。</p>

<h4>App IDの作成</h4>

<p>下記手順で <code>Sign In with Apple</code> 対応の <code>App ID</code> を作成します。</p>

<p>まずは、 <a href="https://developer.apple.com/account/resources/identifiers/list">Apple Developer Program > Certificates, Identifiers &amp; Profiles > Identifiers</a> にアクセスします。</p>

<p>追加するための「＋」ボタンを選択後に表示される下記の画面で <code>App IDs</code> を選択します。<br/>
<img src="/images/sign-in-with-apple_1.png" alt="App IDsを選択" /></p>

<p>必要事項を入力します。<br/>
<img src="/images/sign-in-with-apple_2.png" alt="DescriptionとBundle IDを入力" /></p>

<p>入力例)</p>

<ul>
<li>Description: <code>SignInWithAppleSample</code></li>
<li>Bundle ID: <code>com.xxx.SignInWithAppleSample</code></li>
</ul>


<p>下にスクロールすると <code>Sign In with Apple</code> の項目が追加されているので、チェックをつけます。<br/>
<img src="/images/sign-in-with-apple_3.png" alt="Sign In with Appleにチェック" /></p>

<p>上記状態で次に進み、確認画面で問題ないことを確認すれば、 <code>Register</code> ボタンを選択するだけで作成完了です。<br/>
<img src="/images/sign-in-with-apple_4.png" alt="確認完了後、Registerボタンを選択" /></p>

<h4>Provisioning Profileへの紐付け</h4>

<p>下記手順で <code>App ID</code> を紐付けて <code>Provisioning Profile</code> を作成します。</p>

<p><a href="https://developer.apple.com/account/resources/profiles/list">Apple Developer Program > Certificates, Identifiers &amp; Profiles > Profiles</a>にアクセスします。</p>

<p>追加するための「＋」ボタンを選択後に表示される下記の画面で <code>iOS App Development</code> を選択します。<br/>
(開発時を想定しているため、リリース時であれば、 <code>App Store</code> など適切なものを選択してください。)<br/>
<img src="/images/sign-in-with-apple_5.png" alt="iOS App Developmentを選択" /></p>

<p>先程作成した <code>App ID</code> を選択します。<br/>
<img src="/images/sign-in-with-apple_6.png" alt="App IDを選択" /></p>

<p>必要な <code>Certificate</code> を選択します。<br/>
<img src="/images/sign-in-with-apple_7.png" alt="Certificateを選択" /></p>

<p>利用したいデバイスを選択します。<br/>
<img src="/images/sign-in-with-apple_8.png" alt="Deviceを選択" /></p>

<p><code>Provisioning Profile</code> の名前を決めます。<br/>
<img src="/images/sign-in-with-apple_9.png" alt="Provisioning Profileの名前を入力" /></p>

<p><code>Generate</code> ボタンを選択すれば作成完了です。</p>

<h3>Xcode11の設定</h3>

<p><code>Apple Developer Program</code> 上での準備が整ったら、 <code>Xcode11</code> で <code>Sign In with Apple</code> の <code>Capability</code> を追加しましょう。</p>

<p>プロジェクトを選択し、 <code>Signing &amp; Capabilities</code> タブから追加します。<br/>
<img src="/images/sign-in-with-apple_10.png" alt="Sign In with AppleのCapabilityを追加" /></p>

<h3>ソースコードの実装</h3>

<p>ソースコードを書いていきましょう。<br/>
これは <code>Apple</code> が公開しているサンプルを一部抜粋して説明します。<br/>
サンプルは<a href="https://developer.apple.com/documentation/authenticationservices/adding_the_sign_in_with_apple_flow_to_your_app">こちら</a>からダウンロードできます。</p>

<p><code>Sign In with Apple</code> は <code>AuthenticationServices</code> の各種メソッドを利用するため、<br/>
まずは <code>AuthenticationServices</code> をインポートします。</p>

<p>```objective-c
import UIKit
import AuthenticationServices</p>

<p>class LoginViewController: UIViewController {</p>

<pre><code>...
</code></pre>

<p>}
```</p>

<p>続いて、ログイン画面に <code>Sign In with Apple</code> のボタンを配置します。</p>

<p>```objective-c
class LoginViewController: UIViewController {</p>

<pre><code>/// Sign In with Appleボタンを追加するためのUIStackView
@IBOutlet weak var loginProviderStackView: UIStackView!

override func viewDidLoad() {
    super.viewDidLoad()

    // Sign In with Appleボタンを配置します
    setupProviderLoginView()
}

...

/// Sign In with Appleのボタンを配置
func setupProviderLoginView() {
    let authorizationButton = ASAuthorizationAppleIDButton()
    authorizationButton.addTarget(self, action: #selector(handleAuthorizationAppleIDButtonPress), for: .touchUpInside)
    self.loginProviderStackView.addArrangedSubview(authorizationButton)
}

...

/// Sign In with Appleボタンタップ後のアクション
@objc
func handleAuthorizationAppleIDButtonPress() {
    let appleIDProvider = ASAuthorizationAppleIDProvider()
    let request = appleIDProvider.createRequest()
    request.requestedScopes = [.fullName, .email]

    let authorizationController = ASAuthorizationController(authorizationRequests: [request])
    authorizationController.delegate = self
    authorizationController.presentationContextProvider = self
    authorizationController.performRequests()
}
</code></pre>

<p>}
```</p>

<p>上記を見てわかるように、タップ時に呼び出すメソッドを定義して、その中で必要なリクエストを生成し、実行しています。</p>

<p><code>requestedScopes</code> は必要なアクセス情報の範囲を定義するようですが、<br/>
今のところは <code>.fullName</code> と <code>.email</code> しか用意されていないようです。</p>

<p>また、 <code>delegate</code> と <code>presentationContextProvider</code> を呼び出す必要があります。<br/>
これは、</p>

<ul>
<li><code>ASAuthorizationControllerDelegate</code> の <code>authorizationController:didCompleteWithAuthorization:</code> で認証完了をキャッチする</li>
<li><code>ASAuthorizationControllerPresentationContextProviding</code> の <code>presentationAnchorForAuthorizationController:</code> で認証画面に必要な画面の提示場所を設定する</li>
</ul>


<p>ためです。</p>

<p>```objective-c
extension LoginViewController: ASAuthorizationControllerDelegate {</p>

<pre><code>func authorizationController(controller: ASAuthorizationController, didCompleteWithAuthorization authorization: ASAuthorization) {
    ...
}
</code></pre>

<p>}</p>

<p>extension LoginViewController: ASAuthorizationControllerPresentationContextProviding {</p>

<pre><code>func presentationAnchor(for controller: ASAuthorizationController) -&gt; ASPresentationAnchor {
    return self.view.window!
}
</code></pre>

<p>}
```</p>

<h3>動作確認</h3>

<p>ここまで実装した内容で、どんな動きになるのかを見てみます。</p>

<h4>iPhone上でAppleIDでサインインしていない場合</h4>

<p>あまりケースとして多くはないかもしれませんが、普通にありえるので実装時に考慮が必要です。<br/>
この場合、 <code>performRequests()</code> を実行した時点で『設定アプリでAppleIDアカウントでサインインするかどうか』を聞かれます。</p>

<p><img src="/images/sign-in-with-apple_11.png" alt="設定アプリでAppleIDアカウントでサインインするかどうか聞かれます" /></p>

<p>サインイン後に、改めてアプリに戻りログインを実行することで先に進めるようになります。</p>

<h4>iPhone上でAppleIDでサインイン済みの場合</h4>

<p>改めて <code>Sign In with Apple</code> のボタンをタップすると、以下の画面が表示されます。</p>

<p><img src="/images/sign-in-with-apple_12.png" alt="Sign In with Appleの画面" /></p>

<p><code>Continue</code> ボタンのタップで先に進むと、以下の画面が表示されます。</p>

<p><img src="/images/sign-in-with-apple_13.png" alt="Share My Email / Hide My Email選択画面" /></p>

<p>ここで <code>Share My Email</code> または <code>Hide My Email</code> のどちらかを選択することになります。<br/>
<code>Hide My Email</code> はよりユーザにとってセキュアな状態を保つために用意されており、以下の特徴があります。</p>

<ul>
<li>実際のメールアドレスとは異なるメールアドレスが発行される</li>
<li>そのメールアドレスは、認証時に利用したAppleIDのメールアドレスとリンクしている</li>
<li>アプリに実際のメールアドレスを渡さないで済む</li>
</ul>


<p>上記選択した上で <code>Continuer with Password</code> ボタンをタップして次に進むと、以下の画面が表示されます。</p>

<p><img src="/images/sign-in-with-apple_14.png" alt="パスワード入力画面" /></p>

<p>パスワード入力して次に進むと、二段階認証を求められます。</p>

<p><img src="/images/sign-in-with-apple_15.png" alt="二段階認証画面" /></p>

<p>二段階認証してやっと認証が完了となります。</p>

<h3>まとめ</h3>

<p>さて如何でしたでしょうか。<br/>
アプリの機能次第で対応必須な内容ですので、今からでも知っておいて損はないかなと思います。<br/>
<code>SDK</code> 自体は非常に簡単に扱えますので、アプリ側の実装は早めに目処をつけておいて、データ構成など課題がある部分にフォーカスした方が良いでしょう。</p>

<p>と言ったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS13におけるプッシュ通知に必要なデバイストークンの取得方法]]></title>
    <link href="http://grandbig.github.io/blog/2019/09/28/ios-devicetoken-2/"/>
    <updated>2019-09-28T16:12:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2019/09/28/ios-devicetoken-2</id>
    <content type="html"><![CDATA[<h3>はじめに</h3>

<p>今回はiOS13のプッシュ通知用デバイストークンについて見ていきたいと思います。<br/>
<code>Swift</code> に関して言えば、歴史的変遷から、問題のない現場が多いと思うのですが、<br/>
<code>Objective-C</code> を中心に活用している現場では注意が必要かもしれません。</p>

<p>具体的には後述しますが、<br/>
<code>description</code> を利用してデバイストークンを取得する方式は <code>iOS13</code> から見直す必要がありそうです。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h3>プッシュ通知の受信処理の実装</h3>

<p>折角なので、基本的な設定についても説明していきます。</p>

<h4>Xcode11の設定</h4>

<p>まずは、Xcode11上で下図の状態まで設定します。</p>

<p><strong>▼確認観点</strong><br/>
* <code>Team ID</code> が利用想定のものであること<br/>
* <code>Bundle Identifier</code> が利用想定のものであること<br/>
* <code>Signing Certificate</code> が利用想定のものであること<br/>
* <code>Provisioning Profile</code> の <code>Capabilities</code> に <code>Push Notifications</code> が含まれている<br/>
* <code>Capability</code> として <code>Push Notifications</code> が追加すること</p>

<p><img src="/images/ios-devicetoken-2_1.png" alt="Signing &amp; Capabilities" /></p>

<h4>AppDelegateの実装</h4>

<p>続いて、 <code>AppDelegate.swift</code> 上の実装です。</p>

<p>基本的なステップは4つです。</p>

<p>① プッシュ通知の利用許可のリクエストを送信します<br/>
② 利用許可を得た場合に、プッシュ通知の利用登録を実行します<br/>
③ プッシュ通知の利用登録が成功したことをキャッチする <code>Delegate</code> メソッドを書きます<br/>
④ プッシュ通知の利用登録が失敗したことをキャッチする <code>Delegate</code> メソッドを書きます</p>

<p>```objective-c
import UIKit
import UserNotifications</p>

<p>@UIApplicationMain
class AppDelegate: UIResponder, UIApplicationDelegate {</p>

<pre><code>func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool {
    // Override point for customization after application launch.

    // ① プッシュ通知の利用許可のリクエスト送信
    UNUserNotificationCenter.current().requestAuthorization(options: [.alert, .sound, .badge]) { granted, error in
        guard granted else { return }

        DispatchQueue.main.async {
            // ② プッシュ通知利用の登録
            UIApplication.shared.registerForRemoteNotifications()
        }
    }

    return true
}
...
</code></pre>

<p>}</p>

<p>extension AppDelegate {</p>

<pre><code>// ③ プッシュ通知の利用登録が成功した場合
func application(_ application: UIApplication,
                 didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {
    let token = deviceToken.map { String(format: "%.2hhx", $0) }.joined()
    print("Device token: \(token)")
}

// ④ プッシュ通知の利用登録が失敗した場合
func application(_ application: UIApplication,
                 didFailToRegisterForRemoteNotificationsWithError error: Error) {
    print("Failed to register to APNs: \(error)")
}
</code></pre>

<p>}
```</p>

<h3>旧来のデバイストークンの取得方法</h3>

<p>さて本題に入ります。<br/>
<code>Objective-C</code> 時代に主流と言われていたデバイストークンの取得方法は、以下のような <code>description</code> を利用した手法でした。</p>

<p>```objective-c
NSString *token = [[[[deviceToken description] stringByReplacingOccurrencesOfString:@&ldquo;&lt;"withString:@&rdquo;&ldquo;]</p>

<pre><code>               stringByReplacingOccurrencesOfString:@"&gt;" withString:@""]
               stringByReplacingOccurrencesOfString: @" " withString: @""];
</code></pre>

<p>```</p>

<p>これは、 <code>[deviceToken description]</code> で取得される値が、<br/>
<code>&lt;7097978d 1e438923 ... 6fdbf111&gt;</code> というような先頭と末尾を <code>&lt;&gt;</code> で括られていたためです。<br/>
そして、1文で書けるというのも当時から魅力的だったのかもしれません。</p>

<p><code>Swift</code> に言語が変わってからも、上記手法が多くの場面で使われてきたことと思います。<br/>
しかし、 <code>Swift3</code> になったタイミングで、状況が変わりました。</p>

<p>プッシュ通知の利用登録成功時の <code>Delegate</code> メソッドの <code>deviceToken</code> が <code>NSData</code> 型から <code>Data</code> 型に変わったことで、この手法が利用できなくなったのです。</p>

<p>この時点で</p>

<p><code>objective-c
let token = deviceToken.map { String(format: "%.2hhx", $0) }.joined()
</code></p>

<p>という書き方がデバイストークン取得の主流に完全に取って代わったと思います。</p>

<p>もしかしたら、 <code>Data</code> 型を <code>NSData</code> 型に変換することで、<br/>
引き続き旧来の手法を利用している現場があるかもしれませんが、<br/>
その場合は、即刻デバイストークンの取得方法を見直しましょう。</p>

<p>これはあくまでも <code>Swift</code> におけるデバイストークンの取得の変遷であって、<br/>
<code>Objective-C</code> は何ら変わることがなかったため、<br/>
旧来の書き方が続いている現場がまだまだ多い気がしています。</p>

<p>しかし、 <code>iOS13</code> からはどうやら見直しが必須になったようです。<br/>
というのも、 <code>description</code> を利用すると</p>

<p><code>
{ length = 32, bytes = 7097978d 1e438923 ... 6fdbf111 }
</code></p>

<p>のような形で返ってきてしまうため、<br/>
<code>&lt;&gt;</code> を除去することでデバイストークンを取得することができなくなったようなんです。</p>

<ul>
<li><a href="https://forums.developer.apple.com/thread/117545">Apple Developer Forums: iOS13 PKPushCredentials broken</a></li>
<li><a href="https://forums.developer.apple.com/thread/119111">Apple Developer Forums: NSData description and NSString stringWithFormat have different return results when compiled with Xcode 11 versus Xcode 10</a></li>
</ul>


<p>では、 <code>Swift</code> は先程書いた通り1行で書けますが、<br/>
<code>Objective-C</code> ではどう書いていくべきなのでしょうか。<br/>
安心してください。 <code>Facebook</code> が1つの解を示してくれています。</p>

<p>```objective-c
// ↓ dataにDelegateメソッドに渡ってきたdeviceTokenを渡します
(NSString <em>)hexadecimalStringFromData:(NSData </em>)data<br/>
{</p>

<pre><code>NSUInteger dataLength = data.length;  
if (dataLength == 0) {  
    return nil;  
}  

const unsigned char *dataBuffer = data.bytes;  
NSMutableString *hexString  = [NSMutableString stringWithCapacity:(dataLength * 2)];  
for (int i = 0; i &lt; dataLength; ++i) {  
    [hexString appendFormat:@"%02x", dataBuffer[i]];  
}  
return [hexString copy];  
</code></pre>

<p>}
```</p>

<p>流石に1行で済ませることは難しいですが、<br/>
これで <code>Objective-C</code> でも正しくデバイストークンを取得できるようになりました。</p>

<h3>まとめ</h3>

<p>さて如何でしたでしょうか。<br/>
iOS13は細かいところも含めて様々な変更が入っているため、日々最新情報をキャッチしつつ、自身でも積極的に使い倒していく必要がありますね。</p>

<p>と言ったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS13から利用できるBackgroundTasksを使ってみよう！]]></title>
    <link href="http://grandbig.github.io/blog/2019/09/22/backgroundtasks/"/>
    <updated>2019-09-22T17:09:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2019/09/22/backgroundtasks</id>
    <content type="html"><![CDATA[<h3>はじめに</h3>

<p>今回はiOS13で新たに追加された <code>BackgroundTasks Framework</code> について見ていきたいと思います。<br/>
基本的には、 <a href="https://developer.apple.com/videos/play/wwdc2019/707/">WWDC2019動画の『Advances in App Background Execution』</a>を見ながら実践してみました。</p>

<p>ですが、微妙に躓くところもあったのでメモとして残しておきたいと思います。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h3>BackgroundTasksとは</h3>

<p>まず、 <code>BackgroundTasks</code> の説明です。<br/>
<code>BackgroundTasks</code> はiOS13から利用できる新しいFrameworkになります。<br/>
<code>BackgroundTasks</code> には大きく分けて下記2つのAPIが存在します。</p>

<ol>
<li>Background Processing Tasks</li>
<li>Background App Refresh Tasks</li>
</ol>


<h4>Background Processing Tasks</h4>

<p><code>Background Processing Tasks</code> は以下シーンでの利用が想定されています。</p>

<ul>
<li>(急を要しない)後々の実行で良いメンテナンス処理</li>
<li>Core MLを利用した機械学習のトレーニング処理</li>
</ul>


<p>そのため、 <strong>数分間</strong> の処理実行が許されています。<br/>
また、 <code>requiresExternalPower</code> というフラグを <code>true</code> にすることで、CPU消耗によるプロセスキルをさせないよう制御することができます。<br/>
(iOSの世界でこれって結構スゴイ気がしますね。)</p>

<h4>Background App Refresh Tasks</h4>

<p><code>Background App Refresh Tasks</code> は以下シーンでの利用が想定されています。</p>

<ul>
<li>30秒以内で完了できる処理</li>
<li>1日を通してアプリを最新に保つために必要な処理</li>
</ul>


<p>これまで上記のような対応をする際には <code>Background Fetch</code> を利用していたことと思いますが、<br/>
今回の新APIの発表により、旧APIはdeprecatedになったそうです。</p>

<p><code>objective-c
// deprecated対象
UIApplication.setMinimumBackgroundFetchInterval(_:)
UIApplicationDelegate.application(_:performFetchWithCompletionHandler:)
</code></p>

<h3>BackgroundTasksの使い方</h3>

<p>続いて具体的な使い方を見ていきます。</p>

<h4>ソースコードを書き始めるまでの下準備</h4>

<p><strong>① Xccode上でCapabilityを追加します</strong><br/>
バックグラウンド処理を利用する場合はこれまで通り <code>Capability</code> の <code>Background Modes</code> が必要になります。<br/>
Xcode11で追加する方法が少々変わっているので気をつけましょう。</p>

<p><img src="/images/backgroundtasks_1.png" alt="Background Modesを追加します" /></p>

<p><strong>② Background Modesにチェックを入れます</strong><br/>
今回は、 <code>Background Processing Tasks</code> と <code>Background App Refresh Tasks</code> なので下図の通りです。</p>

<p><img src="/images/backgroundtasks_2.png" alt="必要なBackground Modesにチェックを入れます" /></p>

<p><strong>③ Info.plistにIdentifierを登録します</strong><br/>
<code>Info.plist</code> に <code>Permitted background task scheduler identifiers</code> を追加します。<br/>
また、 <code>Background Processing Tasks</code> と <code>Background App Refresh Tasks</code> 用にそれぞれ <code>Identifier</code> を定義します。</p>

<p>因みに、この <code>Identifier</code> は例によってユニークであることが求められるので、<br/>
<code>com.xxxx.XXXXSample.process</code> , <code>com.xxxx.XXXXSample.refresh</code> といったDNSの逆書きが推奨されています。</p>

<p><img src="/images/backgroundtasks_3.png" alt="Info.plistに必要なIdentifierを登録します" /></p>

<h4>ソースコードの実装</h4>

<p>ここまででソースコード以外の準備は完了です。<br/>
続いて、ソースコードを書いていきましょう。</p>

<p><code>Background Processing Tasks</code> と <code>Background App Refresh Tasks</code> それぞれ記載します。</p>

<h5>Background Processing Tasks</h5>

<p><strong>① BackgroundTasksをimportします</strong></p>

<p><code>objective-c
// AppDelegate.swift
import UIKit
import BackgroundTasks
</code></p>

<p><strong>② didFinishLaunchWithOptions内にバックグラウンドタスクを登録します</strong></p>

<p>```objective-c
// AppDelegate.swift
@UIApplicationMain
class AppDelegate: UIResponder, UIApplicationDelegate {</p>

<pre><code>...
func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool {
    // Override point for customization after application launch.

    // 第一引数: Info.plistで定義したIdentifierを指定
    // 第二引数: タスクを実行するキューを指定。nilの場合は、デフォルトのバックグラウンドキューが利用されます。
    // 第三引数: 実行する処理
    BGTaskScheduler.shared.register(forTaskWithIdentifier: "com.MeasurementSample.refresh", using: nil) { task in
        // バックグラウンド処理したい内容 ※後述します
        self.handleAppProcessing(task: task as! BGProcessingTask)
    }
    return true
</code></pre>

<p>  }
}
```</p>

<p><strong>③ バックグラウンドタスクにスケジューリングします</strong></p>

<p>```objective-c
private func scheduleAppProcessing() {</p>

<pre><code>// Info.plistで定義したIdentifierを指定
let request = BGProcessingTaskRequest(identifier: "com.MeasurementSample.refresh")
// 通信が発生するか否かを指定
request.requiresNetworkConnectivity = false
// CPU監視の必要可否を設定
request.requiresExternalPower = true

do {
    // スケジューラーに実行リクエストを登録
    try BGTaskScheduler.shared.submit(request)
} catch {
    print("Could not schedule app processing: \(error)")
}
</code></pre>

<p>}</p>

<p>func applicationDidEnterBackground(_ application: UIApplication) {</p>

<pre><code>// バックグラウンド起動に移ったときにルケジューリング登録
scheduleAppProcessing()
</code></pre>

<p>}
```</p>

<p><strong>④ 実際に実行する処理を定義します</strong></p>

<p>```objective-c
// AppDelegate.swift
// サンプル用のOperation
class PrintOperation: Operation {</p>

<pre><code>let id: Int

init(id: Int) {
    self.id = id
}

override func main() {
    print("this operation id is \(self.id)")
}
</code></pre>

<p>}</p>

<p>@UIApplicationMain
class AppDelegate: UIResponder, UIApplicationDelegate {
  &hellip;
  private func handleAppProcessing(task: BGProcessingTask) {</p>

<pre><code>  // 1日の間、何度も実行したい場合は、1回実行するごとに新たにスケジューリングに登録します
  scheduleAppRefresh()

  let queue = OperationQueue()
  queue.maxConcurrentOperationCount = 1

  // 時間内に実行完了しなかった場合は、処理を解放します
  // バックグラウンドで実行する処理は、次回に回しても問題ない処理のはずなので、これでOK
  task.expirationHandler = {
      queue.cancelAllOperations()
  }

  // サンプルの処理をキューに詰めます
  let array = [1, 2, 3, 4, 5]
  array.enumerated().forEach { arg in
      let (offset, value) = arg
      let operation = PrintOperation(id: value)
      if offset == array.count - 1 {
          operation.completionBlock = {
              // 最後の処理が完了したら、必ず完了したことを伝える必要があります
              task.setTaskCompleted(success: operation.isFinished)
          }
      }
      queue.addOperation(operation)
  }
</code></pre>

<p>  }
}
```</p>

<h5>Background App Refresh Tasks</h5>

<p><strong>① BackgroundTasksをimportします</strong></p>

<p><code>objective-c
// AppDelegate.swift
import UIKit
import BackgroundTasks
</code></p>

<p><strong>② didFinishLaunchWithOptions内にバックグラウンドタスクを登録します</strong></p>

<p>```objective-c
// AppDelegate.swift
@UIApplicationMain
class AppDelegate: UIResponder, UIApplicationDelegate {</p>

<pre><code>...
func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool {
    // Override point for customization after application launch.

    // 第一引数: Info.plistで定義したIdentifierを指定
    // 第二引数: タスクを実行するキューを指定。nilの場合は、デフォルトのバックグラウンドキューが利用されます。
    // 第三引数: 実行する処理
    BGTaskScheduler.shared.register(forTaskWithIdentifier: "com.MeasurementSample.refresh", using: nil) { task in
        // バックグラウンド処理したい内容 ※後述します
        self.handleAppRefresh(task: task as! BGAppRefreshTask)
    }
    return true
</code></pre>

<p>  }
}
```</p>

<p><strong>③ バックグラウンドタスクにスケジューリングします</strong></p>

<p>```objective-c
private func scheduleAppRefresh() {</p>

<pre><code>// Info.plistで定義したIdentifierを指定
let request = BGAppRefreshTaskRequest(identifier: "com.MeasurementSample.refresh")
// 最低で、どの程度の期間を置いてから実行するか指定
request.earliestBeginDate = Date(timeIntervalSinceNow: 15 * 60)

do {
    // スケジューラーに実行リクエストを登録
    try BGTaskScheduler.shared.submit(request)
} catch {
    print("Could not schedule app refresh: \(error)")
}
</code></pre>

<p>}</p>

<p>func applicationDidEnterBackground(_ application: UIApplication) {</p>

<pre><code>// バックグラウンド起動に移ったときにルケジューリング登録
scheduleAppRefresh()
</code></pre>

<p>}
```</p>

<p><strong>④ 実際に実行する処理を定義します</strong></p>

<p>```objective-c
// AppDelegate.swift
// サンプル用のOperation
class PrintOperation: Operation {</p>

<pre><code>let id: Int

init(id: Int) {
    self.id = id
}

override func main() {
    print("this operation id is \(self.id)")
}
</code></pre>

<p>}</p>

<p>@UIApplicationMain
class AppDelegate: UIResponder, UIApplicationDelegate {
  &hellip;
  private func handleAppRefresh(task: BGAppRefreshTask) {</p>

<pre><code>  // 1日の間、何度も実行したい場合は、1回実行するごとに新たにスケジューリングに登録します
  scheduleAppRefresh()

  let queue = OperationQueue()
  queue.maxConcurrentOperationCount = 1

  // 時間内に実行完了しなかった場合は、処理を解放します
  // バックグラウンドで実行する処理は、次回に回しても問題ない処理のはずなので、これでOK
  task.expirationHandler = {
      queue.cancelAllOperations()
  }

  // サンプルの処理をキューに詰めます
  let array = [1, 2, 3, 4, 5]
  array.enumerated().forEach { arg in
      let (offset, value) = arg
      let operation = PrintOperation(id: value)
      if offset == array.count - 1 {
          operation.completionBlock = {
              // 最後の処理が完了したら、必ず完了したことを伝える必要があります
              task.setTaskCompleted(success: operation.isFinished)
          }
      }
      queue.addOperation(operation)
  }
</code></pre>

<p>  }
}
```</p>

<h3>BackgroundTasksのデバッグ方法</h3>

<p>上記で実装が完了しました。<br/>
実際に挙動を試すためには、特別な手順が必要になります。</p>

<p>① アプリを起動します<br/>
② アプリをバックグラウンドに移します(登録トリガーのためです)<br/>
③ 再度アプリを起動します<br/>
④ Xcodeで <code>Pause Program Execution</code> をタップします</p>

<p><img src="/images/backgroundtasks_4.png" alt="Pause Program Executionをタップします" /></p>

<p>⑤ LLDBに以下コマンドを入力して実行します</p>

<p>```objective-c
// Background Processing Tasksの場合
e -l objc &mdash; (void)[[BGTaskScheduler sharedScheduler] _simulateLaunchForTaskWithIdentifier:@&ldquo;com.MeasurementSample.process&rdquo;]</p>

<p>// Background App Refresh Tasksの場合
e -l objc &mdash; (void)[[BGTaskScheduler sharedScheduler] _simulateLaunchForTaskWithIdentifier:@&ldquo;com.MeasurementSample.refresh&rdquo;]
```</p>

<p>⑥ 再度、Xcodeで <code>Pause Program Execution</code> をタップします</p>

<p>以上で実際の実行処理が見れるようになるはずです。</p>

<p>因みに、実行処理の期限切れを試したい場合は、以下のように⑤のLLDBで以下を入力して実行します</p>

<p>```objective-c
// Background Processing Tasksの場合
e -l objc &mdash; (void)[[BGTaskScheduler sharedScheduler] _simulateExpirationForTaskWithIdentifier:@&ldquo;com.MeasurementSample.process&rdquo;]</p>

<p>// Background App Refresh Tasksの場合
e -l objc &mdash; (void)[[BGTaskScheduler sharedScheduler] _simulateExpirationForTaskWithIdentifier:@&ldquo;com.MeasurementSample.refresh&rdquo;]
```</p>

<h3>ハマったところ</h3>

<p>筆者が試しに実装してハマったところを参考までに載せておこうと思います。<br/>
筆者の場合、なぜかシミュレータで実行しようとすると、以下のエラーが発生してしまいました。</p>

<p><code>objective-c
BGTaskSchedulerErrorDomain Code=1 "(null)"
</code></p>

<p>これは、<a href="https://developer.apple.com/documentation/backgroundtasks/refreshing_and_maintaining_your_app_using_background_tasks">サンプルコード</a>で試しても同様でした。<br/>
ただ、実機で試したところ問題なく通ったんですよね&hellip;</p>

<h3>まとめ</h3>

<p>さて如何でしたでしょうか。<br/>
iOS13で追加された新APIは旧バージョンサポートのため、
すぐには利用されないかもしれませんが、iOS13の普及に伴い、利用シーンは確実に増えていくことでしょう。<br/>
そのため、サンプル程度の実装でも、使い方を学んでおくことは今後の役に立つと思っています。</p>

<p>と言ったところで本日はここまで。</p>

<ul>
<li>参考URL:

<ul>
<li><a href="https://developer.apple.com/videos/play/wwdc2019/707/">WWDC2019 &ndash; Advances in App Background Execution</a></li>
<li><a href="https://developer.apple.com/documentation/backgroundtasks">Apple Documentation &ndash; BackgroundTasks</a></li>
</ul>
</li>
</ul>


<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
</feed>
