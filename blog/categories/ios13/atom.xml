<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ios13 | Takahiro Octopress Blog]]></title>
  <link href="http://grandbig.github.io/blog/categories/ios13/atom.xml" rel="self"/>
  <link href="http://grandbig.github.io/"/>
  <updated>2020-02-22T17:53:48+09:00</updated>
  <id>http://grandbig.github.io/</id>
  <author>
    <name><![CDATA[Takahiro]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS13におけるCoreLocationの変更点〜常に許可/使用中のみ許可/一時的に許可〜]]></title>
    <link href="http://grandbig.github.io/blog/2019/12/22/ios13-core-location/"/>
    <updated>2019-12-22T00:00:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2019/12/22/ios13-core-location</id>
    <content type="html"><![CDATA[<h3>はじめに</h3>

<p>「<a href="https://qiita.com/advent-calendar/2019/ios-2">iOS #2 Advent Calendar 2019</a>」の22日目の記事です。</p>

<p>筆者がiOSアプリの開発を始めたのは、約8年ほど前でしょうか。<br/>
iOS史上でも初期から強力な機能だったこともあってか、当時はiOSアプリに位置情報の機能を載せることが流行っており、<br/>
筆者も漏れなく位置情報に関する調査や機能実装を永遠とこなしていた気がします。</p>

<p>今年でiOSもバージョン <code>13</code> となり、昔はなかった機能がたくさん登場しています。<br/>
新しい機能は当然、開発者の意欲を掻き立て、未知の世界をユーザに届けることに寄与することでしょう。<br/>
ただ、位置情報に人一倍強い思いがあることを自負している筆者ですから、<br/>
iOS13が出た今でも位置情報に関する仕様変更があることには感動もひとしおです。</p>

<p>今日は、iOS13からの位置情報に関する仕様変更を『<a href="https://developer.apple.com/videos/play/wwdc2019/705/">WWDC2019 &ndash; What&rsquo;s New in Core Location</a>』を元に紹介して1年を締めくくりたいと思います。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h3>位置情報とプライバシーについて</h3>

<p>約8年前は位置情報に関する様々な国内での取り決め事がまだまだ調整途中だったかと思います。<br/>
ただし、当時から「電池の消耗が激しいこと」と同じくらい「自身の位置情報を知られたくない」というプライバシーに対する強い意識があった気がします。<br/>
(もちろん現在の方がプライバシー意識は劇的に高まっていると思います。)</p>

<p>一方で、企業側としては、位置情報を利用した新しい便利な体験をユーザに提供するために、<br/>
位置情報を積極的に許可してほしい気持ちがあったかと思います。</p>

<p>これまでiOSはそんなユーザとアプリ提供者側の双方の立場を考慮して改善を進めてきました。<br/>
例えば、初め「常に許可」「許可しない」の2つの選択肢しかなかったところに、<br/>
「使用中のみ許可」が加わったりといった取り組みです。</p>

<p>iOS13では、この取り組みが更に一歩進んだ形になります。</p>

<h3>位置情報の利用確認ダイアログに「常に許可」の選択肢がない</h3>

<p>iOS12までは、</p>

<p>```objective-c
var locationManager = CLLocationManager()</p>

<p>locationManager.delegate = self</p>

<p>locationManager.requestAlwaysAuthorization()
```</p>

<p>とした際に、</p>

<ul>
<li>「常に許可」</li>
<li>「使用中のみ許可」</li>
<li>「許可しない」</li>
</ul>


<p>の3つの選択肢を持つ確認ダイアログが表示されていました。</p>

<p>これがiOS13では、</p>

<ul>
<li>「使用中のみ許可」</li>
<li>「一時的に許可」</li>
<li>「許可しない」</li>
</ul>


<p>の3つの選択肢に変更となりました。<br/>
一見すると、アプリ開発者にとって辛い仕様に思えるのですが、「常に許可」がなくなったわけではありません。</p>

<p><strong>「常に許可」を求めるタイミングが変更になった</strong></p>

<p>というのが正しい解釈となります。</p>

<p>因みに、ここで「使用中のみ許可」を選択した場合、<br/>
<code>CLAuthorizationStatus</code> は実は <code>.authorizedAlways</code> になります。</p>

<h3>「常に許可」に変更するタイミング</h3>

<p>どういうことなのか詳しく説明しましょう。</p>

<p>先程の「使用中のみ許可 / 一時的に許可 / 許可しない」の3つの選択肢から <strong>「使用中のみ許可」</strong> を選択した場合、OSがユーザが忙しくない時を自動的に狙って、</p>

<ul>
<li>「使用中のみ許可のままにする」</li>
<li>「常に許可に変更する」</li>
</ul>


<p>かを問いかけてくれます。</p>

<p><img src="/images/ios13-core-location_1.jpg" alt="常に許可に変更する確認ダイアログ" /></p>

<p>ここで「常に許可に変更する」を選択して初めて、「常に許可」状態に設定することができます。</p>

<p>この仕様がアプリ提供元の企業やアプリ開発者に対して、何を問うているのでしょうか。</p>

<p>筆者は、</p>

<ul>
<li>ユーザに「アプリの利用価値を伝え、位置情報を利用することの有用性を体感してもらう」ことが必要</li>
<li>ユーザに「アプリで利用する位置情報は、プライバシーが守られていることを伝える」ことが必要</li>
</ul>


<p>という大前提に加えて、</p>

<ul>
<li>アプリが最大価値を発揮するのは、Foreground起動中であるべき</li>
<li>ユーザがアプリを初めて利用する場面は、必ずForeground起動であるはず</li>
</ul>


<p>という釘を差しているようにも捉えています。</p>

<p>後者は、OSや純正アプリによって担保されていますが、前者はAppleの審査やそもそもの規約があるものの、作り手の仕組みにも依存する側面は完璧には拭えないでしょう。</p>

<p>因みに、<br/>
「使用中のみ許可のままにする / 常に許可に変更する」かの確認は1度のみであるため、<br/>
これを逃すと、ユーザが自主的に設定画面から設定を変更しない限り「常に許可」に変更する導線がなくなります。</p>

<h3>「使用中のみ許可」の変更点</h3>

<p>iOS12ではユーザが「使用中のみ許可」を選択した場合、下記のようにできることが限られていました。</p>

<ul>
<li>位置情報を取得すること</li>
<li>iBeaconを監視すること</li>
<li>Backgroundで位置情報を継続して取得すること</li>
</ul>


<p>もし、ユーザが「常に許可」を選択すれば、上記に加えて下記も利用することができるようになります。</p>

<ul>
<li>位置情報の取得の「開始」</li>
<li>大幅変更位置情報サービスを利用すること</li>
<li>領域監視を利用すること</li>
<li>滞在情報監視を利用すること</li>
</ul>


<p><img src="/images/ios13-core-location_2.png" alt="iOS12: 常に許可/使用中のみ許可の違い表" /><br/>
※WWDC2019の資料から該当箇所を抜粋して紹介させて頂いています。
<a href="https://developer.apple.com/videos/play/wwdc2019/705/">https://developer.apple.com/videos/play/wwdc2019/705/</a></p>

<p>このため、アプリ開発者は、『どんな機能をアプリに持たせたいか』次第で「常に許可」「使用中のみ許可」のどちらをユーザに求めるべきかを決めていました。</p>

<p>これがiOS13では非常にシンプルになりました。</p>

<p><img src="/images/ios13-core-location_3.png" alt="iOS13: 常に許可/使用中のみ許可の違い表" /><br/>
※WWDC2019の資料から該当箇所を抜粋して紹介させて頂いています。
<a href="https://developer.apple.com/videos/play/wwdc2019/705/">https://developer.apple.com/videos/play/wwdc2019/705/</a></p>

<p>つまり、機能間の差異をなくして、『ユーザに求めた許可状態に即したタイミングで機能を提供する』ことが可能になったということです。</p>

<p>「常に許可」な状態はアプリがForeground/Background起動に関わらず、常に機能を利用できる状態であることがわかるかと思いますが、<br/>
「使用中のみ許可」な状態とは具体的にどんな状態を指すのでしょうか。</p>

<p>ここで簡単なサンプルアプリを作成して説明してみます。</p>

<h3>「使用中のみ許可」の「使用中」の状態とは</h3>

<p>下記のような簡単なサンプルアプリを作成してみました。</p>

<h4>機能</h4>

<p>実験のためのアプリなので、機能は下記のみです。</p>

<ul>
<li>「常に許可」設定をユーザに求める</li>
<li>「使用中のみ許可」設定をユーザに求める</li>
<li>BackgroundモードはOFFで位置情報取得を開始する</li>
<li>BackgroundモードはOFFで位置情報取得を終了する</li>
<li>BackgroundモードはONで位置情報取得を開始する</li>
<li>BackgroundモードはONで位置情報取得を終了する</li>
</ul>


<h4>画面キャプチャ</h4>

<p>実際の画面は下記の通りです。</p>

<p><img src="/images/ios13-core-location_1.jpg" alt="サンプルアプリの画面" /></p>

<h4>ソースコード</h4>

<p>実際のソースコードは下記の通りです。</p>

<p>```objective-c
import UIKit
import CoreLocation</p>

<p>class ViewController: UIViewController {
  // MARK: &ndash; Properties
  var locationManager = CLLocationManager()</p>

<p>  // MARK: &ndash; Lifecycle
  override func viewDidLoad() {</p>

<pre><code>super.viewDidLoad()

configureLocationManager()
</code></pre>

<p>  }</p>

<p>  // MARK: &ndash; Configure
  private func configureLocationManager() {</p>

<pre><code>locationManager.delegate = self
locationManager.desiredAccuracy = kCLLocationAccuracyBestForNavigation
locationManager.activityType = CLActivityType.fitness
locationManager.pausesLocationUpdatesAutomatically = false
</code></pre>

<p>  }</p>

<p>  // MARK: &ndash; IBActions
  @IBAction private func didTapRequestAlwaysAuthorizationButton(_ sender: Any) {</p>

<pre><code>locationManager.requestAlwaysAuthorization()
</code></pre>

<p>  }</p>

<p>  @IBAction private func didTapRequestWhenInUseAuthorizationButton(_ sender: Any) {</p>

<pre><code>locationManager.requestWhenInUseAuthorization()
</code></pre>

<p>  }</p>

<p>  @IBAction private func didTapStartUpdatingLocationButton(_ sender: Any) {</p>

<pre><code>locationManager.startUpdatingLocation()
</code></pre>

<p>  }</p>

<p>  @IBAction private func didTapStopUpdatingLocationButton(_ sender: Any) {</p>

<pre><code>locationManager.stopUpdatingLocation()
</code></pre>

<p>  }</p>

<p>  @IBAction private func didTapStartUpdatingLocationAllowsBackgroundButton(_ sender: Any) {</p>

<pre><code>locationManager.allowsBackgroundLocationUpdates = true
locationManager.startUpdatingLocation()
</code></pre>

<p>  }</p>

<p>  @IBAction private func didTapStopUpdatingLocationAllowsBackgroundButton(_ sender: Any) {</p>

<pre><code>locationManager.allowsBackgroundLocationUpdates = false
locationManager.stopUpdatingLocation()
</code></pre>

<p>  }
}</p>

<p>// MARK: &ndash; CLLocationManagerDelegate
extension ViewController: CLLocationManagerDelegate {</p>

<p>  func locationManager(_ manager: CLLocationManager, didChangeAuthorization status: CLAuthorizationStatus) {</p>

<pre><code>switch status {
case .notDetermined:
  print("未決定の場合")
case .authorizedAlways:
  print("常に許可した場合")
case .authorizedWhenInUse:
  print("使用中のみ許可した場合")
case .denied:
  print("許可しない場合")
case .restricted:
  print("位置情報を利用できない制限がある場合")
@unknown default:
  fatalError("CLAuthorizationStatusの種類が増えているので、条件を見直す必要があります。")
}
</code></pre>

<p>  }</p>

<p>  func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {</p>

<pre><code>guard let location = locations.first else { return }
print("location: \(location.coordinate)")
</code></pre>

<p>  }
}
```</p>

<h4>実験</h4>

<p>では、具体的に「使用中」状態を見るための実験をしてきましょう。</p>

<h5>実験１：BackgroundモードOFFの位置情報取得</h5>

<p>まずは、「使用中のみ許可」設定をしてから、 <strong>BackgroundモードOFFの位置情報取得開始</strong> を実行してみましょう。</p>

<p>```objective-c
// 使用中のみ許可を求める
locationManager.requestWhenInUseAuthorization()</p>

<p>// 位置情報の取得を開始する
locationManager.startUpdatingLocation()
```</p>

<p>この結果、アプリがForeground起動の場合、 <code>didUpdateLocations</code> が呼び出され、最新の位置情報を取得できます。<br/>
しかし、アプリをBackground起動にした場合、 <code>didUpdateLocations</code> が呼び出されることはなくなりました。</p>

<p>※タイミングによっては呼び出されることがありますが、それはアプリはBackgroundで数秒Foregroundと同じ扱いになるOS仕様のためです。</p>

<p>上記の例では、この <strong>Foreground起動中が「使用中」</strong> に当たります。</p>

<p>そのため、再び、Foreground起動にアプリを戻すと「使用中」状態に戻るため、 <code>didUpdateLocations</code> が呼び出されるようになります。</p>

<h5>実験２：BackgroundモードONの位置情報取得</h5>

<p>続いて、 <strong>BackgroundモードONの位置情報取得開始</strong> を実行してみましょう。</p>

<p>```objective-c
// 使用中のみ許可を求める
locationManager.requestWhenInUseAuthorization()</p>

<p>// Backgroundでの位置情報の更新を許可する
locationManager.allowsBackgroundLocationUpdates = true
// 位置情報の取得を開始する
locationManager.startUpdatingLocation()
```</p>

<p>このとき、アプリがForeground起動の場合、 <code>didUpdateLocations</code> が呼び出され、最新の位置情報を取得できます。<br/>
それに加えて、アプリをBackground起動にした場合でも、 <code>didUpdateLocations</code> が呼び出され続けます。</p>

<p>この場合の例では、 <strong>ForegroundおよびBackgroundともに「使用中」</strong> に当たります。</p>

<p>Backgroundで位置情報を利用していることが、ユーザにも伝わるように、ステータスバーの左側に青色で囲まれた矢印マークが表示されます。</p>

<p><img src="/images/ios13-core-location_5.jpg" alt="Backgroundで位置情報を利用している状態" /></p>

<h3>「使用中のみ許可」ユーザが使用中でない場合へのアプローチ</h3>

<p>これで <strong>使用中</strong> とはどういった状態を指すのか、おわかり頂けたかと思います。</p>

<p>基本的にはアプリはユーザが利用したい時に利用することになると思いますが、<br/>
アプリ提供元がアプリを利用する最適な場面を知らせたいといったこともあるでしょう。</p>

<p>そういった時には、 <code>UNLocationNotificationTrigger</code> を使ったジオフェンスによるローカルプッシュが役に立つかもしれません。</p>

<p>特定の場所にジオフェンスを仕掛けておくことで、<br/>
領域侵入 or 領域退出時にローカルプッシュでユーザを気づかせ、<br/>
アプリを起動してもらうことで <strong>使用中</strong> 状態に誘導し、更なる価値提供を狙えることでしょう。</p>

<p>参考までに <code>UNLocationNotificationTrigger</code> の利用方法も記載しておきます。</p>

<p>まずは、 <code>AppDelegate.swift</code> で最低限の準備をしておきましょう。</p>

<p>```objective-c
// AppDelegate.swift
class AppDelegate: UIResponder, UIApplicationDelegate {</p>

<p>  func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) &ndash;> Bool {</p>

<pre><code>let center = UNUserNotificationCenter.current()
center.delegate = self

// 通知の許可を求める
center.requestAuthorization(options: [.sound, .alert, .badge]) { (result, error) in
  print(result)
}
return true
</code></pre>

<p>  }</p>

<p>  &hellip;</p>

<p>}</p>

<p>// MARK: &ndash; UNUserNotificationCenterDelegate
extension AppDelegate: UNUserNotificationCenterDelegate {</p>

<p>  // 未起動 or Background起動時にローカルプッシュを受信した場合
  func userNotificationCenter(_ center: UNUserNotificationCenter, didReceive response: UNNotificationResponse, withCompletionHandler completionHandler: @escaping () &ndash;> Void) {</p>

<pre><code>completionHandler()
</code></pre>

<p>  }</p>

<p>  // Foreground起動時にローカルプッシュを受信した場合
  func userNotificationCenter(_ center: UNUserNotificationCenter, willPresent notification: UNNotification, withCompletionHandler completionHandler: @escaping (UNNotificationPresentationOptions) &ndash;> Void) {</p>

<pre><code>completionHandler(.alert)
</code></pre>

<p>  }
}
```</p>

<p>続いて、ジオフェンスを設定します。</p>

<p>```objective-c
// ViewController.swift
class ViewController: UIViewController {</p>

<pre><code>...
private func configureLocationNotificationTrigger() {
    let content = UNMutableNotificationContent()
    content.title = "お知らせ！"
    content.body = "今、アプリを利用するとお得な情報をGETできます！"
    content.sound = UNNotificationSound.default

    let center = CLLocationCoordinate2D(latitude: 35.0, longitude: 139.7)
    let region = CLCircularRegion(center: center, radius: 200, identifier: "特定の場所")
    region.notifyOnEntry = true
    region.notifyOnExit = true
    let trigger = UNLocationNotificationTrigger(region: region, repeats: true)
    let request = UNNotificationRequest(identifier: "ジオフェンス", content: content, trigger: trigger)
    let notificationCenter = UNUserNotificationCenter.current()
    notificationCenter.add(request)
}
</code></pre>

<p>}</p>

<p>// MARK: &ndash; CLLocationManagerDelegate
extension ViewController: CLLocationManagerDelegate {</p>

<p>  func locationManager(_ manager: CLLocationManager, didChangeAuthorization status: CLAuthorizationStatus) {</p>

<pre><code>switch status {
case .notDetermined:
  print("未決定の場合")
case .authorizedAlways:
  print("常に許可した場合")
case .authorizedWhenInUse:
  print("使用中のみ許可した場合")
  configureLocationNotificationTrigger()
case .denied:
  print("許可しない場合")
case .restricted:
  print("位置情報を利用できない制限がある場合")
@unknown default:
  fatalError("CLAuthorizationStatusの種類が増えているので、条件を見直す必要があります。")
}
</code></pre>

<p>  }
  &hellip;
}
```</p>

<p>上記のように、「使用中のみ許可」の場合にのみ <code>UNLocationNotificationTrigger</code> を仕掛けておくことも一つの手です。</p>

<p>「常に許可」は既にユーザから最大限の承諾を得ているため、更なる価値を届けるためのプッシュ通知という意味では特に意味を持たないためです。</p>

<h3>「一時的に許可」とは</h3>

<p>さて、ここまで「常に許可」「使用中のみ許可」について説明してきましたが、<br/>
iOS13からは「一時的に許可」という選択肢が新たに追加になりました。</p>

<p>「一時的に許可」とは文字通り、 <strong>その時の使用中の間のみ許可をする</strong> ということです。<br/>
よって、 <code>CLAuthorizationStatus</code> も <code>.authorizedWhenInUse</code> になります。</p>

<p>また、 <strong>その時の使用中の間のみ許可する</strong> の「使用中のみ」は、「使用中のみ許可」と同じ定義になります。</p>

<p>つまり、</p>

<ul>
<li><code>allowsBackgroundLocationUpdates=false</code> で <code>locationManager.startUpdatingLocation()</code> するとForeground起動中が「使用中」に当たります</li>
<li><code>allowsBackgroundLocationUpdates=true</code> で <code>locationManager.startUpdatingLocation()</code> するとBackground起動中も「使用中」に当たります</li>
</ul>


<p>ということです。</p>

<p><strong>その時の使用中の間のみ許可する</strong> ため、「使用中」状態が終了したタイミングで <strong>「未設定」状態に戻ります</strong> 。<br/>
実際に、 <code>CLAuthorizationStatus</code> も <code>.notDetermined</code> に戻ります。</p>

<p>一度「未設定」状態に戻ると、改めて位置情報の利用許可を求めなければ、位置情報サービスを利用することができません。</p>

<p>この「改めて位置情報の利用許可を求めるタイミング」ですが、アプリのフローに密接に結びつくため、非常に重要です。<br/>
全く関係のないタイミングで位置情報の利用許可を求めると、ユーザに不信感を持たれたり、煩わしさから離れていってしまう可能性もあるでしょう。</p>

<p>では、最適なタイミングとはいつになるのでしょうか？<br/>
それは、ユーザが再び「位置情報を利用する機能を使いたい」と思ったタイミングになります。</p>

<p>例えば、レストランの検索アプリの場合、「検索開始ボタンをタップしたタイミング」となるでしょう。</p>

<p>大事なことは、<br/>
<strong>『適切なタイミングで、ユーザが位置情報サービスを承諾するまで問いかける導線を用意しておく』</strong><br/>
ということになります。</p>

<p>因みに、「一時的に許可」を選択した後で、『設定アプリ > プライバシー > 位置情報サービス』を見ると、 <strong>『次回確認』</strong> が設定されています。</p>

<p><img src="/images/ios13-core-location_6.jpg" alt="設定 &gt; プライバシー &gt; 位置情報サービスの設定状態" /></p>

<h3>まとめ</h3>

<p>さて如何でしたでしょうか。<br/>
iOS13で仕様がシンプルになったからこそ、「位置情報サービスの利用許可を求める最適なタイミング」をしっかりと考える必要が出てきました。<br/>
また、この仕様変更は、アプリ提供元だけでなくユーザにとっても、わかりやすい仕様になったと言えるのではないでしょうか。</p>

<p>昔からある機能で慣れ親しみがあるものの、その機能全てがユーザに受け入れられているわけではありません。<br/>
少なからず、デメリットを感じてしまう側面もあることでしょう。<br/>
でも、だからこそ、継続して安心安全な機能提供をブラッシュアップしていくことは非常に大切なのでしょう。</p>

<p>我々、アプリ開発者もそういったことを十分に理解した上で、より良い形でユーザに価値を提供し続けていけると良いですね。</p>

<p>といったところで本日はここまで。</p>

<h3>参考</h3>

<ul>
<li><a href="https://developer.apple.com/videos/play/wwdc2019/705/">WWDC2019 &ndash; What&rsquo;s New in Core Location</a></li>
</ul>


<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS13で密かに追加されたUserDefaultsへの保存制限]]></title>
    <link href="http://grandbig.github.io/blog/2019/10/19/ios13-userdefaults/"/>
    <updated>2019-10-19T16:49:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2019/10/19/ios13-userdefaults</id>
    <content type="html"><![CDATA[<h3>はじめに</h3>

<p>先日ふと調べ物をしていたところ、<br/>
<a href="https://forums.developer.apple.com/thread/121527">iOS 13 &ndash; Attempting to store >= 4194304 bytes of data in CFPreferences/NSUserDefaults on this platform is invalid</a>
という何やら気になる話を見つけました。</p>

<p>どうも <code>iOS13</code> からは、 <code>UserDefaults</code> に保存できる容量が <code>4194304 bytes</code> と制限が追加されたようだと言うのです。<br/>
これは実際にやってみるっきゃない！ということで実験をしてみました。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h3>実験</h3>

<p>実際に筆者が実行した実験内容は下記の通りです。</p>

<ul>
<li><code>iOS13.1.3</code> の端末を用いて、 <code>UserDefaults</code> への保存の合計容量が <code>4194304 bytes</code> を超過すると怒られるのか</li>
</ul>


<p>それでは実際に見ていきましょう。</p>

<h4>実験に利用したソースコード</h4>

<p>制限が <code>4194304 bytes</code> であるため、文字列を保存するのは手間がかかりそうだったので、<br/>
<code>Assets.xcassets</code> に予め用意した画像を <code>Data</code> 型に変換後、 <code>UserDefaults</code> に保存することにしました。</p>

<p>用意した画像は下記になります。</p>

<ul>
<li>サイズが <code>262KB</code> の画像</li>
</ul>


<p>実験に利用したソースコードは下記になります。</p>

<p>```objective-c
// ViewController.swift
import UIKit</p>

<p>class ViewController: UIViewController {</p>

<pre><code>override func viewDidLoad() {
    super.viewDidLoad()
}

@IBAction func saveImage(_ sender: Any) {
    let image = UIImage(named: "test1")
    if let data = image?.pngData() {
        let keyName = "test\(Int.random(in: 1 ... 100))"
        print("\(data) , keyName: \(keyName)")
        UserDefaults.standard.set(data, forKey: keyName)
        UserDefaults.standard.synchronize()
    }
}
</code></pre>

<p>}
```</p>

<h4>実験結果</h4>

<p>早速、実験結果について見てみましょう。</p>

<p>1回の保存サイズが <code>350129 bytes</code> だったため、12回で <code>4201548 bytes</code> となり、<br/>
宣言である <code>4194304 bytes</code> を超えることになります。</p>

<p>今回の実験では、 <code>print</code> 文で『ランダムなキー名とバイト数』を出力するように組み込み、<br/>
端末の該当アプリに対して <code>Download Container...</code> から <code>UserDefaults</code> の中身を取得し比較してみました。</p>

<p>出力結果は、</p>

<p><code>objective-c
350129 bytes , keyName: test59
350129 bytes , keyName: test50
350129 bytes , keyName: test51
350129 bytes , keyName: test7
350129 bytes , keyName: test58
350129 bytes , keyName: test7
350129 bytes , keyName: test91
350129 bytes , keyName: test83
350129 bytes , keyName: test54
350129 bytes , keyName: test90
350129 bytes , keyName: test80
350129 bytes , keyName: test71
350129 bytes , keyName: test25
2019-10-19 16:47:19.645111+0900 AppSample[1048:193781] [User Defaults] CFPrefsPlistSource&lt;0x2821a5600&gt; (Domain: com.xxx.AppSample, User: kCFPreferencesCurrentUser, ByHost: No, Container: (null), Contents Need Refresh: Yes): Attempting to store &gt;= 4194304 bytes of data in CFPreferences/NSUserDefaults on this platform is invalid. This is a bug in NotificationSample or a library it uses
2019-10-19 16:47:19.645273+0900 AppSample[1048:193781] [User Defaults] CFPrefsPlistSource&lt;0x2821a5600&gt; (Domain: com.xxx.AppSample, User: kCFPreferencesCurrentUser, ByHost: No, Container: (null), Contents Need Refresh: No): Transitioning into direct mode
350129 bytes , keyName: test21
350129 bytes , keyName: test32
</code></p>

<p>となり、 <strong>13個目</strong> の保存時にエラーが出力されました。
(途中キー名が被っており、上書きとなるため、その回数はスキップしています。)</p>

<p><code>Download Container...</code> で取得した <code>UserDefaults</code> の中身はどうなっているかと言うと、</p>

<p><img src="/images/ios13-userdefaults.png" alt="UserDefaultsに保存された内容" /></p>

<p>となっており、12個目までは保存されているようでした。</p>

<p>厳密には少々超える分には、許容されているように見えましたが、少なくとも、はっきりと超えた場合は保存されないことがわかりました。</p>

<h3>まとめ</h3>

<p>さて如何でしたでしょうか？<br/>
<code>UserDefaults</code> は大量の重要データを保存するのには不向きであることは、これまで通り自明であったと思いますが、<br/>
それがより厳密化されたと言えるのではないでしょうか。</p>

<p>今後に備えて、データの保存方法を今一度見直すにはいい機会かなと思います。<br/>
と言ったところで本日はここまで。</p>

<p>参考URL：</p>

<ul>
<li><a href="https://forums.developer.apple.com/thread/121527">Apple Developer Forums: iOS 13 &ndash; Attempting to store >= 4194304 bytes of data in CFPreferences/NSUserDefaults on this platform is invalid</a></li>
</ul>


<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS13から対応する『Sign In with Apple』〜サードパーティアカウントでOAuth認証によるログインを備えたアプリで迷わないように。〜]]></title>
    <link href="http://grandbig.github.io/blog/2019/10/06/sign-in-with-apple/"/>
    <updated>2019-10-06T17:05:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2019/10/06/sign-in-with-apple</id>
    <content type="html"><![CDATA[<h3>はじめに</h3>

<p>今回はiOS13から導入された <code>Sign In with Apple</code> について見ていきたいと思います。</p>

<p>もし、 <code>Facebook / Google / Twitter</code> などのアカウントを用いたログインを可能とする機能をアプリが持っている場合、<br/>
Appleが新たに提唱した <code>Sign In with Apple</code> の機能を実装する必要性が出てきたようです。</p>

<p>一方で <code>Facebook / Google / Twitter</code> などの本家のアプリでは恐らく実装する必要はないと思われます。<br/>
(ログイン機能を実装するのであれば、 <code>Sign In with Apple</code> が必須という話ではなく、サードパーティ製のログイン機能を持つアプリに限るようです。 )</p>

<p>とは言え、「急にそんなことを言われても対応工数がかかるし、他に実装したい機能もあるし&hellip;」と困るエンジニアもいるかもしれません。</p>

<p>ですが、 <code>Apple</code> が要求する以上、 iOSアプリを開発し続ける上で避けては通れない問題ですので、簡単に対応方法を紹介したいと思います。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h3>Apple Developer Programでの対応</h3>

<p>まずは、コードを書く前に、 <code>Sign In with Apple</code> の機能を有効にした <code>App ID</code> を作成し、 <code>Provisioning Profile</code> に紐付ける必要があります。</p>

<h4>App IDの作成</h4>

<p>下記手順で <code>Sign In with Apple</code> 対応の <code>App ID</code> を作成します。</p>

<p>まずは、 <a href="https://developer.apple.com/account/resources/identifiers/list">Apple Developer Program > Certificates, Identifiers &amp; Profiles > Identifiers</a> にアクセスします。</p>

<p>追加するための「＋」ボタンを選択後に表示される下記の画面で <code>App IDs</code> を選択します。<br/>
<img src="/images/sign-in-with-apple_1.png" alt="App IDsを選択" /></p>

<p>必要事項を入力します。<br/>
<img src="/images/sign-in-with-apple_2.png" alt="DescriptionとBundle IDを入力" /></p>

<p>入力例)</p>

<ul>
<li>Description: <code>SignInWithAppleSample</code></li>
<li>Bundle ID: <code>com.xxx.SignInWithAppleSample</code></li>
</ul>


<p>下にスクロールすると <code>Sign In with Apple</code> の項目が追加されているので、チェックをつけます。<br/>
<img src="/images/sign-in-with-apple_3.png" alt="Sign In with Appleにチェック" /></p>

<p>上記状態で次に進み、確認画面で問題ないことを確認すれば、 <code>Register</code> ボタンを選択するだけで作成完了です。<br/>
<img src="/images/sign-in-with-apple_4.png" alt="確認完了後、Registerボタンを選択" /></p>

<h4>Provisioning Profileへの紐付け</h4>

<p>下記手順で <code>App ID</code> を紐付けて <code>Provisioning Profile</code> を作成します。</p>

<p><a href="https://developer.apple.com/account/resources/profiles/list">Apple Developer Program > Certificates, Identifiers &amp; Profiles > Profiles</a>にアクセスします。</p>

<p>追加するための「＋」ボタンを選択後に表示される下記の画面で <code>iOS App Development</code> を選択します。<br/>
(開発時を想定しているため、リリース時であれば、 <code>App Store</code> など適切なものを選択してください。)<br/>
<img src="/images/sign-in-with-apple_5.png" alt="iOS App Developmentを選択" /></p>

<p>先程作成した <code>App ID</code> を選択します。<br/>
<img src="/images/sign-in-with-apple_6.png" alt="App IDを選択" /></p>

<p>必要な <code>Certificate</code> を選択します。<br/>
<img src="/images/sign-in-with-apple_7.png" alt="Certificateを選択" /></p>

<p>利用したいデバイスを選択します。<br/>
<img src="/images/sign-in-with-apple_8.png" alt="Deviceを選択" /></p>

<p><code>Provisioning Profile</code> の名前を決めます。<br/>
<img src="/images/sign-in-with-apple_9.png" alt="Provisioning Profileの名前を入力" /></p>

<p><code>Generate</code> ボタンを選択すれば作成完了です。</p>

<h3>Xcode11の設定</h3>

<p><code>Apple Developer Program</code> 上での準備が整ったら、 <code>Xcode11</code> で <code>Sign In with Apple</code> の <code>Capability</code> を追加しましょう。</p>

<p>プロジェクトを選択し、 <code>Signing &amp; Capabilities</code> タブから追加します。<br/>
<img src="/images/sign-in-with-apple_10.png" alt="Sign In with AppleのCapabilityを追加" /></p>

<h3>ソースコードの実装</h3>

<p>ソースコードを書いていきましょう。<br/>
これは <code>Apple</code> が公開しているサンプルを一部抜粋して説明します。<br/>
サンプルは<a href="https://developer.apple.com/documentation/authenticationservices/adding_the_sign_in_with_apple_flow_to_your_app">こちら</a>からダウンロードできます。</p>

<p><code>Sign In with Apple</code> は <code>AuthenticationServices</code> の各種メソッドを利用するため、<br/>
まずは <code>AuthenticationServices</code> をインポートします。</p>

<p>```objective-c
import UIKit
import AuthenticationServices</p>

<p>class LoginViewController: UIViewController {</p>

<pre><code>...
</code></pre>

<p>}
```</p>

<p>続いて、ログイン画面に <code>Sign In with Apple</code> のボタンを配置します。</p>

<p>```objective-c
class LoginViewController: UIViewController {</p>

<pre><code>/// Sign In with Appleボタンを追加するためのUIStackView
@IBOutlet weak var loginProviderStackView: UIStackView!

override func viewDidLoad() {
    super.viewDidLoad()

    // Sign In with Appleボタンを配置します
    setupProviderLoginView()
}

...

/// Sign In with Appleのボタンを配置
func setupProviderLoginView() {
    let authorizationButton = ASAuthorizationAppleIDButton()
    authorizationButton.addTarget(self, action: #selector(handleAuthorizationAppleIDButtonPress), for: .touchUpInside)
    self.loginProviderStackView.addArrangedSubview(authorizationButton)
}

...

/// Sign In with Appleボタンタップ後のアクション
@objc
func handleAuthorizationAppleIDButtonPress() {
    let appleIDProvider = ASAuthorizationAppleIDProvider()
    let request = appleIDProvider.createRequest()
    request.requestedScopes = [.fullName, .email]

    let authorizationController = ASAuthorizationController(authorizationRequests: [request])
    authorizationController.delegate = self
    authorizationController.presentationContextProvider = self
    authorizationController.performRequests()
}
</code></pre>

<p>}
```</p>

<p>上記を見てわかるように、タップ時に呼び出すメソッドを定義して、その中で必要なリクエストを生成し、実行しています。</p>

<p><code>requestedScopes</code> は必要なアクセス情報の範囲を定義するようですが、<br/>
今のところは <code>.fullName</code> と <code>.email</code> しか用意されていないようです。</p>

<p>また、 <code>delegate</code> と <code>presentationContextProvider</code> を呼び出す必要があります。<br/>
これは、</p>

<ul>
<li><code>ASAuthorizationControllerDelegate</code> の <code>authorizationController:didCompleteWithAuthorization:</code> で認証完了をキャッチする</li>
<li><code>ASAuthorizationControllerPresentationContextProviding</code> の <code>presentationAnchorForAuthorizationController:</code> で認証画面に必要な画面の提示場所を設定する</li>
</ul>


<p>ためです。</p>

<p>```objective-c
extension LoginViewController: ASAuthorizationControllerDelegate {</p>

<pre><code>func authorizationController(controller: ASAuthorizationController, didCompleteWithAuthorization authorization: ASAuthorization) {
    ...
}
</code></pre>

<p>}</p>

<p>extension LoginViewController: ASAuthorizationControllerPresentationContextProviding {</p>

<pre><code>func presentationAnchor(for controller: ASAuthorizationController) -&gt; ASPresentationAnchor {
    return self.view.window!
}
</code></pre>

<p>}
```</p>

<h3>動作確認</h3>

<p>ここまで実装した内容で、どんな動きになるのかを見てみます。</p>

<h4>iPhone上でAppleIDでサインインしていない場合</h4>

<p>あまりケースとして多くはないかもしれませんが、普通にありえるので実装時に考慮が必要です。<br/>
この場合、 <code>performRequests()</code> を実行した時点で『設定アプリでAppleIDアカウントでサインインするかどうか』を聞かれます。</p>

<p><img src="/images/sign-in-with-apple_11.png" alt="設定アプリでAppleIDアカウントでサインインするかどうか聞かれます" /></p>

<p>サインイン後に、改めてアプリに戻りログインを実行することで先に進めるようになります。</p>

<h4>iPhone上でAppleIDでサインイン済みの場合</h4>

<p>改めて <code>Sign In with Apple</code> のボタンをタップすると、以下の画面が表示されます。</p>

<p><img src="/images/sign-in-with-apple_12.png" alt="Sign In with Appleの画面" /></p>

<p><code>Continue</code> ボタンのタップで先に進むと、以下の画面が表示されます。</p>

<p><img src="/images/sign-in-with-apple_13.png" alt="Share My Email / Hide My Email選択画面" /></p>

<p>ここで <code>Share My Email</code> または <code>Hide My Email</code> のどちらかを選択することになります。<br/>
<code>Hide My Email</code> はよりユーザにとってセキュアな状態を保つために用意されており、以下の特徴があります。</p>

<ul>
<li>実際のメールアドレスとは異なるメールアドレスが発行される</li>
<li>そのメールアドレスは、認証時に利用したAppleIDのメールアドレスとリンクしている</li>
<li>アプリに実際のメールアドレスを渡さないで済む</li>
</ul>


<p>上記選択した上で <code>Continuer with Password</code> ボタンをタップして次に進むと、以下の画面が表示されます。</p>

<p><img src="/images/sign-in-with-apple_14.png" alt="パスワード入力画面" /></p>

<p>パスワード入力して次に進むと、二段階認証を求められます。</p>

<p><img src="/images/sign-in-with-apple_15.png" alt="二段階認証画面" /></p>

<p>二段階認証してやっと認証が完了となります。</p>

<h3>まとめ</h3>

<p>さて如何でしたでしょうか。<br/>
アプリの機能次第で対応必須な内容ですので、今からでも知っておいて損はないかなと思います。<br/>
<code>SDK</code> 自体は非常に簡単に扱えますので、アプリ側の実装は早めに目処をつけておいて、データ構成など課題がある部分にフォーカスした方が良いでしょう。</p>

<p>と言ったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS13におけるプッシュ通知に必要なデバイストークンの取得方法]]></title>
    <link href="http://grandbig.github.io/blog/2019/09/28/ios-devicetoken-2/"/>
    <updated>2019-09-28T16:12:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2019/09/28/ios-devicetoken-2</id>
    <content type="html"><![CDATA[<h3>はじめに</h3>

<p>今回はiOS13のプッシュ通知用デバイストークンについて見ていきたいと思います。<br/>
<code>Swift</code> に関して言えば、歴史的変遷から、問題のない現場が多いと思うのですが、<br/>
<code>Objective-C</code> を中心に活用している現場では注意が必要かもしれません。</p>

<p>具体的には後述しますが、<br/>
<code>description</code> を利用してデバイストークンを取得する方式は <code>iOS13</code> から見直す必要がありそうです。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h3>プッシュ通知の受信処理の実装</h3>

<p>折角なので、基本的な設定についても説明していきます。</p>

<h4>Xcode11の設定</h4>

<p>まずは、Xcode11上で下図の状態まで設定します。</p>

<p><strong>▼確認観点</strong><br/>
* <code>Team ID</code> が利用想定のものであること<br/>
* <code>Bundle Identifier</code> が利用想定のものであること<br/>
* <code>Signing Certificate</code> が利用想定のものであること<br/>
* <code>Provisioning Profile</code> の <code>Capabilities</code> に <code>Push Notifications</code> が含まれている<br/>
* <code>Capability</code> として <code>Push Notifications</code> が追加すること</p>

<p><img src="/images/ios-devicetoken-2_1.png" alt="Signing &amp; Capabilities" /></p>

<h4>AppDelegateの実装</h4>

<p>続いて、 <code>AppDelegate.swift</code> 上の実装です。</p>

<p>基本的なステップは4つです。</p>

<p>① プッシュ通知の利用許可のリクエストを送信します<br/>
② 利用許可を得た場合に、プッシュ通知の利用登録を実行します<br/>
③ プッシュ通知の利用登録が成功したことをキャッチする <code>Delegate</code> メソッドを書きます<br/>
④ プッシュ通知の利用登録が失敗したことをキャッチする <code>Delegate</code> メソッドを書きます</p>

<p>```objective-c
import UIKit
import UserNotifications</p>

<p>@UIApplicationMain
class AppDelegate: UIResponder, UIApplicationDelegate {</p>

<pre><code>func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool {
    // Override point for customization after application launch.

    // ① プッシュ通知の利用許可のリクエスト送信
    UNUserNotificationCenter.current().requestAuthorization(options: [.alert, .sound, .badge]) { granted, error in
        guard granted else { return }

        DispatchQueue.main.async {
            // ② プッシュ通知利用の登録
            UIApplication.shared.registerForRemoteNotifications()
        }
    }

    return true
}
...
</code></pre>

<p>}</p>

<p>extension AppDelegate {</p>

<pre><code>// ③ プッシュ通知の利用登録が成功した場合
func application(_ application: UIApplication,
                 didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {
    let token = deviceToken.map { String(format: "%.2hhx", $0) }.joined()
    print("Device token: \(token)")
}

// ④ プッシュ通知の利用登録が失敗した場合
func application(_ application: UIApplication,
                 didFailToRegisterForRemoteNotificationsWithError error: Error) {
    print("Failed to register to APNs: \(error)")
}
</code></pre>

<p>}
```</p>

<h3>旧来のデバイストークンの取得方法</h3>

<p>さて本題に入ります。<br/>
<code>Objective-C</code> 時代に主流と言われていたデバイストークンの取得方法は、以下のような <code>description</code> を利用した手法でした。</p>

<p>```objective-c
NSString *token = [[[[deviceToken description] stringByReplacingOccurrencesOfString:@&ldquo;&lt;"withString:@&rdquo;&ldquo;]</p>

<pre><code>               stringByReplacingOccurrencesOfString:@"&gt;" withString:@""]
               stringByReplacingOccurrencesOfString: @" " withString: @""];
</code></pre>

<p>```</p>

<p>これは、 <code>[deviceToken description]</code> で取得される値が、<br/>
<code>&lt;7097978d 1e438923 ... 6fdbf111&gt;</code> というような先頭と末尾を <code>&lt;&gt;</code> で括られていたためです。<br/>
そして、1文で書けるというのも当時から魅力的だったのかもしれません。</p>

<p><code>Swift</code> に言語が変わってからも、上記手法が多くの場面で使われてきたことと思います。<br/>
しかし、 <code>Swift3</code> になったタイミングで、状況が変わりました。</p>

<p>プッシュ通知の利用登録成功時の <code>Delegate</code> メソッドの <code>deviceToken</code> が <code>NSData</code> 型から <code>Data</code> 型に変わったことで、この手法が利用できなくなったのです。</p>

<p>この時点で</p>

<p><code>objective-c
let token = deviceToken.map { String(format: "%.2hhx", $0) }.joined()
</code></p>

<p>という書き方がデバイストークン取得の主流に完全に取って代わったと思います。</p>

<p>もしかしたら、 <code>Data</code> 型を <code>NSData</code> 型に変換することで、<br/>
引き続き旧来の手法を利用している現場があるかもしれませんが、<br/>
その場合は、即刻デバイストークンの取得方法を見直しましょう。</p>

<p>これはあくまでも <code>Swift</code> におけるデバイストークンの取得の変遷であって、<br/>
<code>Objective-C</code> は何ら変わることがなかったため、<br/>
旧来の書き方が続いている現場がまだまだ多い気がしています。</p>

<p>しかし、 <code>iOS13</code> からはどうやら見直しが必須になったようです。<br/>
というのも、 <code>description</code> を利用すると</p>

<p><code>
{ length = 32, bytes = 7097978d 1e438923 ... 6fdbf111 }
</code></p>

<p>のような形で返ってきてしまうため、<br/>
<code>&lt;&gt;</code> を除去することでデバイストークンを取得することができなくなったようなんです。</p>

<ul>
<li><a href="https://forums.developer.apple.com/thread/117545">Apple Developer Forums: iOS13 PKPushCredentials broken</a></li>
<li><a href="https://forums.developer.apple.com/thread/119111">Apple Developer Forums: NSData description and NSString stringWithFormat have different return results when compiled with Xcode 11 versus Xcode 10</a></li>
</ul>


<p>では、 <code>Swift</code> は先程書いた通り1行で書けますが、<br/>
<code>Objective-C</code> ではどう書いていくべきなのでしょうか。<br/>
安心してください。 <code>Facebook</code> が1つの解を示してくれています。</p>

<p>```objective-c
// ↓ dataにDelegateメソッドに渡ってきたdeviceTokenを渡します
(NSString <em>)hexadecimalStringFromData:(NSData </em>)data<br/>
{</p>

<pre><code>NSUInteger dataLength = data.length;  
if (dataLength == 0) {  
    return nil;  
}  

const unsigned char *dataBuffer = data.bytes;  
NSMutableString *hexString  = [NSMutableString stringWithCapacity:(dataLength * 2)];  
for (int i = 0; i &lt; dataLength; ++i) {  
    [hexString appendFormat:@"%02x", dataBuffer[i]];  
}  
return [hexString copy];  
</code></pre>

<p>}
```</p>

<p>流石に1行で済ませることは難しいですが、<br/>
これで <code>Objective-C</code> でも正しくデバイストークンを取得できるようになりました。</p>

<h3>まとめ</h3>

<p>さて如何でしたでしょうか。<br/>
iOS13は細かいところも含めて様々な変更が入っているため、日々最新情報をキャッチしつつ、自身でも積極的に使い倒していく必要がありますね。</p>

<p>と言ったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS13から利用できるBackgroundTasksを使ってみよう！]]></title>
    <link href="http://grandbig.github.io/blog/2019/09/22/backgroundtasks/"/>
    <updated>2019-09-22T17:09:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2019/09/22/backgroundtasks</id>
    <content type="html"><![CDATA[<h3>はじめに</h3>

<p>今回はiOS13で新たに追加された <code>BackgroundTasks Framework</code> について見ていきたいと思います。<br/>
基本的には、 <a href="https://developer.apple.com/videos/play/wwdc2019/707/">WWDC2019動画の『Advances in App Background Execution』</a>を見ながら実践してみました。</p>

<p>ですが、微妙に躓くところもあったのでメモとして残しておきたいと思います。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h3>BackgroundTasksとは</h3>

<p>まず、 <code>BackgroundTasks</code> の説明です。<br/>
<code>BackgroundTasks</code> はiOS13から利用できる新しいFrameworkになります。<br/>
<code>BackgroundTasks</code> には大きく分けて下記2つのAPIが存在します。</p>

<ol>
<li>Background Processing Tasks</li>
<li>Background App Refresh Tasks</li>
</ol>


<h4>Background Processing Tasks</h4>

<p><code>Background Processing Tasks</code> は以下シーンでの利用が想定されています。</p>

<ul>
<li>(急を要しない)後々の実行で良いメンテナンス処理</li>
<li>Core MLを利用した機械学習のトレーニング処理</li>
</ul>


<p>そのため、 <strong>数分間</strong> の処理実行が許されています。<br/>
また、 <code>requiresExternalPower</code> というフラグを <code>true</code> にすることで、CPU消耗によるプロセスキルをさせないよう制御することができます。<br/>
(iOSの世界でこれって結構スゴイ気がしますね。)</p>

<h4>Background App Refresh Tasks</h4>

<p><code>Background App Refresh Tasks</code> は以下シーンでの利用が想定されています。</p>

<ul>
<li>30秒以内で完了できる処理</li>
<li>1日を通してアプリを最新に保つために必要な処理</li>
</ul>


<p>これまで上記のような対応をする際には <code>Background Fetch</code> を利用していたことと思いますが、<br/>
今回の新APIの発表により、旧APIはdeprecatedになったそうです。</p>

<p><code>objective-c
// deprecated対象
UIApplication.setMinimumBackgroundFetchInterval(_:)
UIApplicationDelegate.application(_:performFetchWithCompletionHandler:)
</code></p>

<h3>BackgroundTasksの使い方</h3>

<p>続いて具体的な使い方を見ていきます。</p>

<h4>ソースコードを書き始めるまでの下準備</h4>

<p><strong>① Xccode上でCapabilityを追加します</strong><br/>
バックグラウンド処理を利用する場合はこれまで通り <code>Capability</code> の <code>Background Modes</code> が必要になります。<br/>
Xcode11で追加する方法が少々変わっているので気をつけましょう。</p>

<p><img src="/images/backgroundtasks_1.png" alt="Background Modesを追加します" /></p>

<p><strong>② Background Modesにチェックを入れます</strong><br/>
今回は、 <code>Background Processing Tasks</code> と <code>Background App Refresh Tasks</code> なので下図の通りです。</p>

<p><img src="/images/backgroundtasks_2.png" alt="必要なBackground Modesにチェックを入れます" /></p>

<p><strong>③ Info.plistにIdentifierを登録します</strong><br/>
<code>Info.plist</code> に <code>Permitted background task scheduler identifiers</code> を追加します。<br/>
また、 <code>Background Processing Tasks</code> と <code>Background App Refresh Tasks</code> 用にそれぞれ <code>Identifier</code> を定義します。</p>

<p>因みに、この <code>Identifier</code> は例によってユニークであることが求められるので、<br/>
<code>com.xxxx.XXXXSample.process</code> , <code>com.xxxx.XXXXSample.refresh</code> といったDNSの逆書きが推奨されています。</p>

<p><img src="/images/backgroundtasks_3.png" alt="Info.plistに必要なIdentifierを登録します" /></p>

<h4>ソースコードの実装</h4>

<p>ここまででソースコード以外の準備は完了です。<br/>
続いて、ソースコードを書いていきましょう。</p>

<p><code>Background Processing Tasks</code> と <code>Background App Refresh Tasks</code> それぞれ記載します。</p>

<h5>Background Processing Tasks</h5>

<p><strong>① BackgroundTasksをimportします</strong></p>

<p><code>objective-c
// AppDelegate.swift
import UIKit
import BackgroundTasks
</code></p>

<p><strong>② didFinishLaunchWithOptions内にバックグラウンドタスクを登録します</strong></p>

<p>```objective-c
// AppDelegate.swift
@UIApplicationMain
class AppDelegate: UIResponder, UIApplicationDelegate {</p>

<pre><code>...
func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool {
    // Override point for customization after application launch.

    // 第一引数: Info.plistで定義したIdentifierを指定
    // 第二引数: タスクを実行するキューを指定。nilの場合は、デフォルトのバックグラウンドキューが利用されます。
    // 第三引数: 実行する処理
    BGTaskScheduler.shared.register(forTaskWithIdentifier: "com.MeasurementSample.refresh", using: nil) { task in
        // バックグラウンド処理したい内容 ※後述します
        self.handleAppProcessing(task: task as! BGProcessingTask)
    }
    return true
</code></pre>

<p>  }
}
```</p>

<p><strong>③ バックグラウンドタスクにスケジューリングします</strong></p>

<p>```objective-c
private func scheduleAppProcessing() {</p>

<pre><code>// Info.plistで定義したIdentifierを指定
let request = BGProcessingTaskRequest(identifier: "com.MeasurementSample.refresh")
// 通信が発生するか否かを指定
request.requiresNetworkConnectivity = false
// CPU監視の必要可否を設定
request.requiresExternalPower = true

do {
    // スケジューラーに実行リクエストを登録
    try BGTaskScheduler.shared.submit(request)
} catch {
    print("Could not schedule app processing: \(error)")
}
</code></pre>

<p>}</p>

<p>func applicationDidEnterBackground(_ application: UIApplication) {</p>

<pre><code>// バックグラウンド起動に移ったときにルケジューリング登録
scheduleAppProcessing()
</code></pre>

<p>}
```</p>

<p><strong>④ 実際に実行する処理を定義します</strong></p>

<p>```objective-c
// AppDelegate.swift
// サンプル用のOperation
class PrintOperation: Operation {</p>

<pre><code>let id: Int

init(id: Int) {
    self.id = id
}

override func main() {
    print("this operation id is \(self.id)")
}
</code></pre>

<p>}</p>

<p>@UIApplicationMain
class AppDelegate: UIResponder, UIApplicationDelegate {
  &hellip;
  private func handleAppProcessing(task: BGProcessingTask) {</p>

<pre><code>  // 1日の間、何度も実行したい場合は、1回実行するごとに新たにスケジューリングに登録します
  scheduleAppRefresh()

  let queue = OperationQueue()
  queue.maxConcurrentOperationCount = 1

  // 時間内に実行完了しなかった場合は、処理を解放します
  // バックグラウンドで実行する処理は、次回に回しても問題ない処理のはずなので、これでOK
  task.expirationHandler = {
      queue.cancelAllOperations()
  }

  // サンプルの処理をキューに詰めます
  let array = [1, 2, 3, 4, 5]
  array.enumerated().forEach { arg in
      let (offset, value) = arg
      let operation = PrintOperation(id: value)
      if offset == array.count - 1 {
          operation.completionBlock = {
              // 最後の処理が完了したら、必ず完了したことを伝える必要があります
              task.setTaskCompleted(success: operation.isFinished)
          }
      }
      queue.addOperation(operation)
  }
</code></pre>

<p>  }
}
```</p>

<h5>Background App Refresh Tasks</h5>

<p><strong>① BackgroundTasksをimportします</strong></p>

<p><code>objective-c
// AppDelegate.swift
import UIKit
import BackgroundTasks
</code></p>

<p><strong>② didFinishLaunchWithOptions内にバックグラウンドタスクを登録します</strong></p>

<p>```objective-c
// AppDelegate.swift
@UIApplicationMain
class AppDelegate: UIResponder, UIApplicationDelegate {</p>

<pre><code>...
func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool {
    // Override point for customization after application launch.

    // 第一引数: Info.plistで定義したIdentifierを指定
    // 第二引数: タスクを実行するキューを指定。nilの場合は、デフォルトのバックグラウンドキューが利用されます。
    // 第三引数: 実行する処理
    BGTaskScheduler.shared.register(forTaskWithIdentifier: "com.MeasurementSample.refresh", using: nil) { task in
        // バックグラウンド処理したい内容 ※後述します
        self.handleAppRefresh(task: task as! BGAppRefreshTask)
    }
    return true
</code></pre>

<p>  }
}
```</p>

<p><strong>③ バックグラウンドタスクにスケジューリングします</strong></p>

<p>```objective-c
private func scheduleAppRefresh() {</p>

<pre><code>// Info.plistで定義したIdentifierを指定
let request = BGAppRefreshTaskRequest(identifier: "com.MeasurementSample.refresh")
// 最低で、どの程度の期間を置いてから実行するか指定
request.earliestBeginDate = Date(timeIntervalSinceNow: 15 * 60)

do {
    // スケジューラーに実行リクエストを登録
    try BGTaskScheduler.shared.submit(request)
} catch {
    print("Could not schedule app refresh: \(error)")
}
</code></pre>

<p>}</p>

<p>func applicationDidEnterBackground(_ application: UIApplication) {</p>

<pre><code>// バックグラウンド起動に移ったときにルケジューリング登録
scheduleAppRefresh()
</code></pre>

<p>}
```</p>

<p><strong>④ 実際に実行する処理を定義します</strong></p>

<p>```objective-c
// AppDelegate.swift
// サンプル用のOperation
class PrintOperation: Operation {</p>

<pre><code>let id: Int

init(id: Int) {
    self.id = id
}

override func main() {
    print("this operation id is \(self.id)")
}
</code></pre>

<p>}</p>

<p>@UIApplicationMain
class AppDelegate: UIResponder, UIApplicationDelegate {
  &hellip;
  private func handleAppRefresh(task: BGAppRefreshTask) {</p>

<pre><code>  // 1日の間、何度も実行したい場合は、1回実行するごとに新たにスケジューリングに登録します
  scheduleAppRefresh()

  let queue = OperationQueue()
  queue.maxConcurrentOperationCount = 1

  // 時間内に実行完了しなかった場合は、処理を解放します
  // バックグラウンドで実行する処理は、次回に回しても問題ない処理のはずなので、これでOK
  task.expirationHandler = {
      queue.cancelAllOperations()
  }

  // サンプルの処理をキューに詰めます
  let array = [1, 2, 3, 4, 5]
  array.enumerated().forEach { arg in
      let (offset, value) = arg
      let operation = PrintOperation(id: value)
      if offset == array.count - 1 {
          operation.completionBlock = {
              // 最後の処理が完了したら、必ず完了したことを伝える必要があります
              task.setTaskCompleted(success: operation.isFinished)
          }
      }
      queue.addOperation(operation)
  }
</code></pre>

<p>  }
}
```</p>

<h3>BackgroundTasksのデバッグ方法</h3>

<p>上記で実装が完了しました。<br/>
実際に挙動を試すためには、特別な手順が必要になります。</p>

<p>① アプリを起動します<br/>
② アプリをバックグラウンドに移します(登録トリガーのためです)<br/>
③ 再度アプリを起動します<br/>
④ Xcodeで <code>Pause Program Execution</code> をタップします</p>

<p><img src="/images/backgroundtasks_4.png" alt="Pause Program Executionをタップします" /></p>

<p>⑤ LLDBに以下コマンドを入力して実行します</p>

<p>```objective-c
// Background Processing Tasksの場合
e -l objc &mdash; (void)[[BGTaskScheduler sharedScheduler] _simulateLaunchForTaskWithIdentifier:@&ldquo;com.MeasurementSample.process&rdquo;]</p>

<p>// Background App Refresh Tasksの場合
e -l objc &mdash; (void)[[BGTaskScheduler sharedScheduler] _simulateLaunchForTaskWithIdentifier:@&ldquo;com.MeasurementSample.refresh&rdquo;]
```</p>

<p>⑥ 再度、Xcodeで <code>Pause Program Execution</code> をタップします</p>

<p>以上で実際の実行処理が見れるようになるはずです。</p>

<p>因みに、実行処理の期限切れを試したい場合は、以下のように⑤のLLDBで以下を入力して実行します</p>

<p>```objective-c
// Background Processing Tasksの場合
e -l objc &mdash; (void)[[BGTaskScheduler sharedScheduler] _simulateExpirationForTaskWithIdentifier:@&ldquo;com.MeasurementSample.process&rdquo;]</p>

<p>// Background App Refresh Tasksの場合
e -l objc &mdash; (void)[[BGTaskScheduler sharedScheduler] _simulateExpirationForTaskWithIdentifier:@&ldquo;com.MeasurementSample.refresh&rdquo;]
```</p>

<h3>ハマったところ</h3>

<p>筆者が試しに実装してハマったところを参考までに載せておこうと思います。<br/>
筆者の場合、なぜかシミュレータで実行しようとすると、以下のエラーが発生してしまいました。</p>

<p><code>objective-c
BGTaskSchedulerErrorDomain Code=1 "(null)"
</code></p>

<p>これは、<a href="https://developer.apple.com/documentation/backgroundtasks/refreshing_and_maintaining_your_app_using_background_tasks">サンプルコード</a>で試しても同様でした。<br/>
ただ、実機で試したところ問題なく通ったんですよね&hellip;</p>

<h3>まとめ</h3>

<p>さて如何でしたでしょうか。<br/>
iOS13で追加された新APIは旧バージョンサポートのため、
すぐには利用されないかもしれませんが、iOS13の普及に伴い、利用シーンは確実に増えていくことでしょう。<br/>
そのため、サンプル程度の実装でも、使い方を学んでおくことは今後の役に立つと思っています。</p>

<p>と言ったところで本日はここまで。</p>

<ul>
<li>参考URL:

<ul>
<li><a href="https://developer.apple.com/videos/play/wwdc2019/707/">WWDC2019 &ndash; Advances in App Background Execution</a></li>
<li><a href="https://developer.apple.com/documentation/backgroundtasks">Apple Documentation &ndash; BackgroundTasks</a></li>
</ul>
</li>
</ul>


<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
</feed>
