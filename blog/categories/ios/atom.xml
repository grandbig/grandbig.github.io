<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ios | Takahiro Octopress Blog]]></title>
  <link href="http://grandbig.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://grandbig.github.io/"/>
  <updated>2015-08-31T23:36:43+09:00</updated>
  <id>http://grandbig.github.io/</id>
  <author>
    <name><![CDATA[Takahiro]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Kontakt.ioのSmart Beaconのパラメータを書き換えてみよう！]]></title>
    <link href="http://grandbig.github.io/blog/2015/07/20/write-kontakt-beacon/"/>
    <updated>2015-07-20T00:01:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2015/07/20/write-kontakt-beacon</id>
    <content type="html"><![CDATA[<h4>Kontakt.ioのSmart Beaconのパラメータの書き換え方法</h4>

<p>さて、続きを書いていきます。<br/>
前回、Kontakt.ioのSmart Beaconを検知するところまで書きました。<br/>
本記事では、必要に応じて、パラメータを変更する方法について書きたいと思います。</p>

<p>手順は<a href="http://docs.kontakt.io/ios-sdk/quickstart/#beacon-configuration">Kontakt.ioの公式ページのBeacon Configuration</a>に書かれていますが、<code>/device/update</code>に引っかかったり、REST APIを叩こうとしたりすることもあるかもしれないので、紹介します。(筆者は初めきちんと読まずにいろいろと実行してしまいました&hellip;)</p>

<p>では、早速書いていきましょう。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h5>Objective-C編</h5>

<p>さて、まずはObjective-Cです。</p>

<p>```objective-c
// ViewController.m</p>

<h1>import &ldquo;ViewController.h&rdquo;</h1>

<h1>import &ldquo;KontaktSDK.h&rdquo;</h1>

<p>@interface ViewController ()<KTKBluetoothManagerDelegate></p>

<p>@property(strong, nonatomic) KTKBeaconManager <em>bm;
@property(strong, nonatomic) KTKBeaconDevice </em>bd;
@property(assign, nonatomic) BOOL flag;</p>

<p>@end</p>

<p>@implementation ViewController</p>

<ul>
<li><p>(void)viewDidLoad {
  [super viewDidLoad];</p>

<p>  <em>bm = [KTKBeaconManager new];
  </em>bm.delegate = self;
  _flag = NO;
}</p></li>
<li><p>(void)viewDidAppear:(BOOL)animated {
  [super viewDidAppear:animated];</p>

<p>  // iBeaconデバイスの検索開始
  [_bm startFindingDevices];
}</p></li>
<li><p>(void)viewDidDisappear:(BOOL)animated {
  [super viewDidDisappear:animated];</p>

<p>  // iBeaconデバイスの検索停止
  [_bm stopFindingDevices];
}</p></li>
<li><p>(void)didReceiveMemoryWarning {
  [super didReceiveMemoryWarning];
}</p></li>
</ul>


<h1>pragma mark &ndash; KTKBluetoothManagerDelegate</h1>

<ul>
<li><p>(void)bluetoothManager:(KTKBluetoothManager <em>)bluetoothManager didChangeDevices:(NSSet </em>)devices {</p>

<p>  if(!<em>bd) {
      // 利用したいKTKBeaconDeviceが見つかっていない場合
       NSArray <em>deviceArray = [devices allObjects];
       for(id device in deviceArray) {
          KTKBeaconDevice </em>beacon = device;
          if([beacon.uniqueID isEqualToString:@&ldquo;****&rdquo;]) {
              // 利用したいiBeaconを格納
              </em>bd = beacon;
          }
       }
  } else {
      // 利用したいKTKBeaconDeviceが見つかった場合
      KTKCharacteristicDescriptor <em>descriptor;
      descriptor = [_bd characteristicDescriptorWithType:kKTKCharacteristicDescriptorTypeMajor];
      NSError </em>err;
      // iBeaconデバイスに接続
      BOOL connected = [<em>bd connectWithPassword:@&ldquo;****&rdquo; andError:&amp;err];
      if(connected &amp;&amp; !err) {
          // 接続できた場合
          // パラメータ値の取得
          err = [</em>bd readValueForCharacteristicWithDescriptor:descriptor];
          if(!err) {
              NSString *valueString = [_bd stringForCharacteristicWithDescriptor:descriptor];
              NSLog(@&ldquo;value: %@&rdquo;, valueString);</p>

<pre><code>          if(!_flag) {
              // パラメータの書き換え処理
              err = [_bd writeString:@"20053" forCharacteristicWithDescriptor:descriptor];
          }
          // iBeaconデバイスから切断
          [_bd disconnect];
      }
  }
</code></pre>

<p>  }
}</p></li>
</ul>


<p>@end
```</p>

<p>上記処理を実行後、Kontakt.ioの専用アプリで確認すれば、パラメータの値が変更されていることを確認できます。</p>

<h5>Swift編</h5>

<p>続いて、Swiftのコードも書いてみます。</p>

<p>```objective-c
// ViewController.swift
import UIKit</p>

<p>class ViewController: UIViewController, KTKBluetoothManagerDelegate {</p>

<pre><code>let bm:KTKBeaconManager = KTKBeaconManager()
var bd:KTKBeaconDevice? = KTKBeaconDevice()
var flag:Bool = false

override func viewDidLoad() {
    super.viewDidLoad()

    self.bm.delegate = self;
}

override func viewDidAppear(animated: Bool) {
    super.viewDidAppear(animated)

    // iBeaconデバイスの検索開始
    bm.startFindingDevices()
}

override func viewDidDisappear(animated: Bool) {
    super.viewDidDisappear(animated)

    // iBeaconデバイスの検索停止
    bm.stopFindingDevices()
}

override func didReceiveMemoryWarning() {
    super.didReceiveMemoryWarning()
}

func bluetoothManager(bluetoothManager: KTKBluetoothManager!, didChangeDevices devices: Set&lt;NSObject&gt;!) {
    if self.bd?.uniqueID == "****" {
        // 利用したいKTKBeaconDeviceが見つかった場合
        let descriptor:KTKCharacteristicDescriptor = self.bd!.characteristicDescriptorWithType(kKTKCharacteristicDescriptorTypeMajor)
        var err:NSError?
        // iBeaconデバイスに接続
        let connected:Bool = self.bd!.connectWithPassword("****", andError: &amp;err)
        if connected {
            // 接続できた場合
            // パラメータ値の取得
            err = self.bd!.readValueForCharacteristicWithDescriptor(descriptor)
            if err == nil {
                let valueString = self.bd!.stringForCharacteristicWithDescriptor(descriptor)
                println("\(valueString)")
                if self.flag == false {
                    // パラメータの書き換え処理
                    err = self.bd!.writeString("20053", forCharacteristicWithDescriptor: descriptor)
                    self.flag = true;
                }
                // iBeaconデバイスから切断
                self.bd?.disconnect()
            }
        }
    } else {
        // 利用したいKTKBeaconDeviceが見つかっていない場合
        let deviceArray:[AnyObject] = Array(devices)
        for device in deviceArray  {
            let beacon:KTKBeaconDevice = device as! KTKBeaconDevice
            if beacon.uniqueID == "****" {
                // 利用したいiBeaconを格納
                self.bd = beacon
            }
        }
    }
}
</code></pre>

<p>}
```</p>

<p>こちらも専用アプリでパラメータ値が書き換わっていることを確認できました。<br/>
Kontakt.ioの制御特性を活かしたサービスを企画できる可能性を感じました。<br/>
といったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Kontakt.ioのSmart Beaconを使ってみた]]></title>
    <link href="http://grandbig.github.io/blog/2015/07/18/start-kontakt-beacon/"/>
    <updated>2015-07-18T22:40:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2015/07/18/start-kontakt-beacon</id>
    <content type="html"><![CDATA[<h4>Kontakt.ioのSmart Beaconを使ってみよう</h4>

<p>さて、久しぶりの更新です。<br/>
実は先日、以前から気になっていた<a href="https://store.kontakt.io/our-products/1-bluetooth-beacon.html">Kontakt.io Smart Beacon</a>を購入してみました。<br/>
あまり海外の製品を購入することがないので、届くか心配でしたが、ばっちり自宅に届きました笑</p>

<p>なぜ、Kontakt.ioのSmart Beaconに着目していたかというと、筆者が知る限り、最も発信出力(TxPower)を弱くすることが可能なBeaconだからです。<br/>
<a href="https://support.kontakt.io/hc/en-gb/articles/201621521-Transmission-power-Range-and-RSSI">仕様書</a>を見てみると、出力を-30[dBm]にまで下げることができ、その電波距離は実に2[m]程度らしいです。</p>

<p>また、SDKが充実しており、発信出力を自由に変更できるところもポイント高いですね。<br/>
さて、今回は基本的な実装から見て行きましょう！(何回かに分けて記事にしようと思います。)</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h4>SDKをプロジェクトに追加</h4>

<p>まずは、SDKを使える状態に持っていきます。</p>

<h5>Objective-C編</h5>

<p>CocoaPodsで提供されていますので、簡単です。</p>

<ol>
<li>Projectファイルと同じ階層に<code>Podfile</code>を作成します</li>
<li><code>pod 'KontaktSDK'</code>と記載します</li>
<li><code>pod install</code>を実行します</li>
</ol>


<p>以上でプロジェクトへの追加完了です。</p>

<h5>Swift編</h5>

<p>CocoaPods使いましょう！</p>

<ol>
<li>Projectファイルと同じ階層に<code>Podfile</code>を作成します</li>
<li><code>pod 'KontaktSDK'</code>と記載します</li>
<li><code>pod install</code>を実行します</li>
<li>Bridging-Headerファイルを作成します
<code>ProjectName-Bridging-Header.h</code>ファイルを作成し、Build Settings > Swift Compiler > Objective-C Bridging Headerにパスを設定</li>
<li>Bridging-Headerファイルに必要なライブラリを<code>import</code>します</li>
</ol>


<p>下記は、Buid Settingsの設定です。<br/>
<img src="/images/kontakt1.png" alt="Bridging-Headerファイルの設定" /></p>

<p>下記はBridging-Headerファイルの中身です。</p>

<p>```objective-c</p>

<h1>ifndef KontaktSwiftTest_KontaktSwiftTest_Bridging_Header_h</h1>

<h1>define KontaktSwiftTest_KontaktSwiftTest_Bridging_Header_h</h1>

<h1>import &lt;Foundation/Foundation.h></h1>

<h1>import &lt;CoreLocation/CoreLocation.h></h1>

<h1>import &lt;CoreBluetooth/CoreBluetooth.h></h1>

<h1>import &ldquo;KontaktSDK.h&rdquo;</h1>

<h1>endif</h1>

<p>```</p>

<h4>Kontakt.ioのBeaconを検知してみよう</h4>

<p>これで準備が整ったので、実際にソースを書いて、Beaconを検知してみましょう！</p>

<h5>Objective-C編</h5>

<p>ViewController.mにどんどん書いていきます。</p>

<p>```objective-c
// ViewController.m</p>

<h1>import &ldquo;ViewController.h&rdquo;</h1>

<h1>import &ldquo;KontaktSDK.h&rdquo;</h1>

<p>@interface ViewController ()<KTKLocationManagerDelegate></p>

<p>@property(strong, nonatomic) KTKLocationManager *lm;</p>

<p>@end</p>

<p>@implementation ViewController</p>

<ul>
<li><p>(void)viewDidLoad {
  [super viewDidLoad];</p>

<p>  <em>lm = [KTKLocationManager new];
  </em>lm.delegate = self;</p>

<p>  if ([KTKLocationManager canMonitorBeacons]) {
      KTKRegion *region = [KTKRegion alloc] init];
      region.uuid = @&ldquo;AF41A130-E105-4F13-9483-316B7101B0A9&rdquo;;
      [_lm setRegions:@[region]];]
  }
}</p></li>
<li><p>(void)viewDidAppear:(BOOL)animated {
  [super viewDidAppear:animated];</p>

<p>  [_lm startMonitoringBeacons];
}</p></li>
<li><p>(void)viewDidDisappear:(BOOL)animated {
  [super viewDidDisappear:animated];</p>

<p>  [_lm stopMonitoringBeacons];
}</p></li>
<li><p>(void)didReceiveMemoryWarning {
  [super didReceiveMemoryWarning];
}</p></li>
</ul>


<h1>pragma mark &ndash; KTKLocationManagerDelegate</h1>

<ul>
<li><p>(void)locationManager:(KTKLocationManager <em>)locationManager didChangeState:(KTKLocationManagerState)state withError:(NSError </em>)error {
  if(state == KTKLocationManagerStateFailed) {
      NSLog(@&ldquo;Something went wrong with your Location Services settings. Check OS settings.&rdquo;);
  }
}</p></li>
<li><p>(void)locationManager:(KTKLocationManager <em>)locationManager didEnterRegion:(KTKRegion </em>)region {
  NSLog(@&ldquo;Enter region %@&rdquo;, region.uuid);
}</p></li>
<li><p>(void)locationManager:(KTKLocationManager <em>)locationManager didExitRegion:(KTKRegion </em>)region {
  NSLog(@&ldquo;Exit region %@&rdquo;, region.uuid);
}</p></li>
<li><p>(void)locationManager:(KTKLocationManager <em>)locationManager didRangeBeacons:(NSArray </em>)beacons {
  NSLog(@&ldquo;Ranged beacons count: %lu&rdquo;, [beacons count]);
}</p></li>
</ul>


<p>@end</p>

<p>```</p>

<h5>Swift編</h5>

<p><code>ViwController.swift</code>にどんどん書いていきます。</p>

<p>```objective-c
// ViewController.swift
import UIKit</p>

<p>class ViewController: UIViewController, KTKLocationManagerDelegate {</p>

<pre><code>let lm:KTKLocationManager = KTKLocationManager()

override func viewDidLoad() {
    super.viewDidLoad()

    if(KTKLocationManager.canMonitorBeacons()) {
        let region:KTKRegion = KTKRegion()
        region.uuid = "AF41A130-E105-4F13-9483-316B7101B0A9"
        lm.setRegions([region])
        self.lm.delegate = self
    }
}

override func viewDidAppear(animated: Bool) {
    super.viewDidAppear(animated)

    lm.startMonitoringBeacons()
}

override func viewDidDisappear(animated: Bool) {
    super.viewDidDisappear(animated)

    lm.stopMonitoringBeacons()
}

override func didReceiveMemoryWarning() {
    super.didReceiveMemoryWarning()
}

func locationManager(locationManager: KTKLocationManager!, didChangeState state: KTKLocationManagerState, withError error: NSError!) {
    if(state == .Failed) {
        println("Something went wrong with your Location Services settings. Check OS settings.")
    }
}

func locationManager(locationManager: KTKLocationManager!, didEnterRegion region: KTKRegion!) {
    println("Enter region \(region.uuid)")
}

func locationManager(locationManager: KTKLocationManager!, didExitRegion region: KTKRegion!) {
    println("Exit region \(region.uuid)")
}

func locationManager(locationManager: KTKLocationManager!, didRangeBeacons beacons: [AnyObject]!) {
    println("Ranged beacons count: \(beacons.count)")
}
</code></pre>

<p>}
```</p>

<p>これでKontakt.ioのSmart Beaconを検知することができるようになりました。<br/>
次回はAPI連携して、Beaconのパラメータを変えてみたいと思います。<br/>
と言ったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[複数のiBeaconを検知しよう！(別UUIDの場合)]]></title>
    <link href="http://grandbig.github.io/blog/2015/06/14/multi-ibeacon-region/"/>
    <updated>2015-06-14T23:43:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2015/06/14/multi-ibeacon-region</id>
    <content type="html"><![CDATA[<h4>複数のiBeacon(別UUIDのiBeacon)を検知する方法</h4>

<p>さて、本日は別々のUUIDを持ったiBeacon信号を補足したいと思います。<br/>
iBeaconは案外、電波が遠くまで飛ぶため、幾つかのUUIDを補足できるようにしておくことで、うまく<code>didEnterRegion</code>, <code>didExitRegion</code>を使い、レンジングでのみ取得可能な値を効果的に使うことができるかもしれません。<br/>
今回はiOS8以上を対象に下記サンプルソースを書きました。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<p>```objective-c
// ViewController.m</p>

<h1>import &ldquo;ViewController.h&rdquo;</h1>

<p>@interface ViewController ()</p>

<p>@property (strong, nonatomic) CLLocationManager <em>locationManager;
@property (strong, nonatomic) NSUUID </em>proximityUUID1, <em>proximityUUID2;
@property (strong, nonatomic) CLBeaconRegion </em>beaconRegion1, <em>beaconRegion2;
@property (strong, nonatomic) CLBeacon </em>nearestBeacon;
@property (strong, nonatomic) NSString *str;</p>

<p>@end</p>

<ul>
<li><p>(void)viewDidLoad
{
  [super viewDidLoad];</p>

<p>  self.locationManager = [[CLLocationManager alloc] init];
  self.locationManager.delegate = self;</p>

<p>  self.proximityUUID1 = [[NSUUID alloc] initWithUUIDString:@&ldquo;8D4DB809-032F-4771-96F3-99BD5C25F924&rdquo;];
  self.beaconRegion1 = [[CLBeaconRegion alloc] initWithProximityUUID: self.proximityUUID1 identifier:@&ldquo;com.takahiro.ibeaconSample&rdquo;];
  self.proximityUUID2 = [[NSUUID alloc] initWithUUIDString:@&ldquo;1AE93327-B172-4C5D-BBF7-F52B959FD4EB&rdquo;];
  self.beaconRegion2 = [[CLBeaconRegion alloc] initWithProximityUUID: self.proximityUUID1 identifier:@&ldquo;com.takahiro.ibeaconSample2&rdquo;];</p>

<p>  [self.locationManager requestAlwaysAuthorization];
}</p></li>
</ul>


<p>// ユーザの位置情報の許可状態を確認するメソッド
&ndash; (void)locationManager:(CLLocationManager *)manager didChangeAuthorizationStatus:(CLAuthorizationStatus)status
{</p>

<pre><code>if (status == kCLAuthorizationStatusAuthorizedAlways) {
    // Beaconのモニタリングを開始
    [self.locationManager startMonitoringForRegion:self.beaconRegion1];
    [self.locationManager startMonitoringForRegion:self.beaconRegion2];
}
</code></pre>

<p>}</p>

<p>// 指定した領域に入った場合
&ndash; (void)locationManager:(CLLocationManager <em>)manager didEnterRegion:(CLRegion </em>)region
{</p>

<pre><code>[self sendLocalNotificationForMessage:@"Enter Region"];
</code></pre>

<p>}</p>

<p>// 指定した領域から出た場合
&ndash; (void)locationManager:(CLLocationManager <em>)manager didExitRegion:(CLRegion </em>)region
{</p>

<pre><code>[self sendLocalNotificationForMessage:@"Exit Region"];
</code></pre>

<p>}</p>

<p>// iBeacon領域内に既にいるか/いないかの判定
&ndash; (void)locationManager:(CLLocationManager <em>)manager didDetermineState:(CLRegionState)state forRegion:(CLRegion </em>)region
{</p>

<pre><code>switch (state) {
    case CLRegionStateInside:
        if([region isMemberOfClass:[CLBeaconRegion class]] &amp;&amp; [CLLocationManager isRangingAvailable]){
            [self.locationManager startRangingBeaconsInRegion:self.beaconRegion1];
            [self.locationManager startRangingBeaconsInRegion:self.beaconRegion2];
        }
        break;
    case CLRegionStateOutside:
        if([region isMemberOfClass:[CLBeaconRegion class]] &amp;&amp; [CLLocationManager isRangingAvailable]){
        }
        break;
    case CLRegionStateUnknown:
        if([region isMemberOfClass:[CLBeaconRegion class]] &amp;&amp; [CLLocationManager isRangingAvailable]){
        }
        break;
    default:
        break;
}
</code></pre>

<p>}</p>

<p>// Beacon信号を検出した場合
&ndash; (void)locationManager:(CLLocationManager <em>)manager didRangeBeacons:(NSArray </em>)beacons inRegion:(CLBeaconRegion *)region
{</p>

<pre><code>if (beacons.count &gt; 0) {
    self.nearestBeacon = beacons.firstObject;
    NSString *rangeMessage;

    switch(self.nearestBeacon.proximity) {
        case CLProximityImmediate:
            rangeMessage = @"Range Immediate";
            break;
        case CLProximityNear:
            rangeMessage = @"Range Near";
            break;
        case CLProximityFar:
            rangeMessage = @"Range Far";
            break;
        default:
            rangeMessage = @"Range Unknown";
            break;
    }

    self.str = [[NSString alloc] initWithFormat:@"%f [m]", self.nearestBeacon.accuracy];
    [self sendLocalNotificationForMessage:self.str];
}
</code></pre>

<p>}</p>

<p>// ローカルプッシュ
&ndash; (void)sendLocalNotificationForMessage:(NSString *)message
{</p>

<pre><code>UILocalNotification *localNotification = [UILocalNotification new];
localNotification.alertBody = message;
localNotification.fireDate = [NSDate date];
localNotification.soundName = nil;
[[UIApplication sharedApplication] scheduleLocalNotification:localNotification];
</code></pre>

<p>}
```</p>

<p>ローカルプッシュを可能にするために<code>AppDelegate.m</code>に下記書式を追加しましょう。</p>

<p>```objective-c
// AppDelegate.m
&ndash; (BOOL)application:(UIApplication <em>)application didFinishLaunchingWithOptions:(NSDictionary </em>)launchOptions
{</p>

<pre><code>...

if ([UIApplication instancesRespondToSelector:@selector(registerUserNotificationSettings:)]) {
    [[UIApplication sharedApplication] registerUserNotificationSettings:[UIUserNotificationSettings settingsForTypes:UIUserNotificationTypeAlert|UIUserNotificationTypeSound categories:nil]];
}

return YES;
</code></pre>

<p>}
```</p>

<p>ポイントは<code>CLBeaconRegion</code>を作成するときに指定する<code>UUID</code>と<code>identifier</code>が共にユニークであることです。<br/>
<code>UUID</code>のみを別々にしても<code>identifier</code>が同じだと別のiBeacon領域と見なされないので注意が必要です。</p>

<p>別々のiBeacon領域が作成できれば、<code>didEnterRegion</code>, <code>didExitRegion</code>などのデリゲートメソッドはそれぞれのiBeacon領域に対して発生します。<br/>
もし、比較的狭い空間で複数のiBeaconを設置して、アプリをFG起動しない前提で人流解析をしたい場合は複数のiBeacon領域(別々のUUIDを持ったiBeacon領域)を用意することも１つの手だと思います。</p>

<p>と言ったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swiftで継承とカテゴリってどうやってやるの！？]]></title>
    <link href="http://grandbig.github.io/blog/2015/06/07/swift-inheritance-extension/"/>
    <updated>2015-06-07T23:30:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2015/06/07/swift-inheritance-extension</id>
    <content type="html"><![CDATA[<h4>Swiftで継承</h4>

<p>まずはObjective-CとSwiftの継承の書き方の違いを見て行きましょう。</p>

<p>早速、Objective-Cの継承ですが、</p>

<p>```objective-c
// ヘッダーファイル
@interface SampleA:NSObject
// プロパティの定義
@property(strong, nonatomic) NSString *sampleString;
// メソッドの定義
&ndash; (void)sampleMethod;</p>

<p>@end</p>

<p>```</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<p>```objective-c
// モデルファイル
@interface SampleA()</p>

<p>@end</p>

<p>@implementation</p>

<ul>
<li>(void)sampleMethod {
  &hellip;.
}</li>
</ul>


<p>@end</p>

<p>```</p>

<p>といった形で書けます。</p>

<p>これがSwiftだと、</p>

<p>```objective-c
// swiftファイル
class SampleA:NSObject {</p>

<pre><code>// プロパティの定義
var sampleString:String = "サンプル"
// メソッドの定義
func sampleMethod {
    ....
}
</code></pre>

<p>}</p>

<p>```</p>

<p>とかなりシンプルに書けますね！</p>

<h4>Swiftでカテゴリ</h4>

<p>次にSwiftでObjective-Cで言うカテゴリを実装してみます。</p>

<p>Objective-Cでは、</p>

<p>```objective-c
// ヘッダーファイル
@interface NSError(ContextBase)</p>

<ul>
<li>(NSError <em>)createError:(NSString </em>)message code:(NSInteger)code;</li>
</ul>


<p>@end
```</p>

<p>```objective-c
// モデルファイル
@implementation NSError(ContextBase)</p>

<ul>
<li><p>(NSError <em>)createError:(NSString </em>)message code:(NSInteger)code {
 NSDictionary <em>errorUserInfo = @{ NSLocalizedDescriptionKey:message };
 NSError </em>error = [[NSError alloc] initWithDomain:domain code:code userInfo:errorUserInfo];</p>

<p> return error;
}</p></li>
</ul>


<p>@end
```</p>

<p>と書いてきました。<br/>
これがSwiftでは、</p>

<p>```objective-c
// Swiftファイル
extension NSError {</p>

<pre><code>func createError(message:String!, code:Int!) -&gt; NSError {
    let errorUserInfo = [NSLocalizedDescriptionKey: message]
    let error:NSError = NSError(domain: "jp.co.swiftSample", code: code, userInfo: errorUserInfo)

    return error
}
</code></pre>

<p>}
```</p>

<p>と書けます。<br/>
う〜んこれもシンプル！！<br/>
Objective-Cで利用してきた継承はもちろんのこと、カテゴリも残っていて助かりますね！</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SwiftでRealmを使ってみよう！]]></title>
    <link href="http://grandbig.github.io/blog/2015/06/07/swift-realm/"/>
    <updated>2015-06-07T16:35:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2015/06/07/swift-realm</id>
    <content type="html"><![CDATA[<h4>Realmをプロジェクトに追加しよう</h4>

<p>本日は最近、流行っているRealmについて遊んでみたいと思います。<br/>
まずは導入の仕方から見て行きましょう！</p>

<h5>Realmの導入方法</h5>

<p>下記のPodfileを作成しましょう。<br/>
本記事のSwiftプロジェクトとして、<code>SwiftRealm.xcodeproj</code>を作成します。</p>

<p>```objective-c
// Podfile
platform :ios, &lsquo;8.0&rsquo;
source &lsquo;<a href="https://github.com/CocoaPods/Specs.git">https://github.com/CocoaPods/Specs.git</a>&rsquo;</p>

<p>target &lsquo;SwiftRealm&rsquo;, exclusive: true do</p>

<pre><code>pod 'Realm'
</code></pre>

<p>end</p>

<p>target &lsquo;SwiftRealmTests&rsquo;, exclusive: true do</p>

<pre><code>pod 'Realm/Headers'
</code></pre>

<p>end
```</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<p>あとは<code>pod install</code>しましょう。<br/>
すると、<code>SwiftRealm.xcworkspace</code>が作成されるので、Xcodeで起動しましょう。</p>

<p><img src="/images/swift-realm.png" alt="Realmを追加した結果" /></p>

<p>なんと、Objective-C++で書かれていますね！
Swiftで利用するためにはBridging-Headerファイルの設定を行う必要があります。</p>

<p>SwiftRealm-Bridging-Header.hを作成します。<br/>
<img src="/images/swift-realm2.png" alt="ヘッダーファイルの作成" /></p>

<p>TARGETS > SwiftRealm > Build Settings > Swift Compiler &ndash; Code Generation > Objective-C Bridging Header にパスを設定します。<br/>
<img src="/images/swift-realm3.png" alt="パスの設定" /></p>

<p>SwiftRealm-Bridging-Header.hの中身を書きます。</p>

<p>```objective-c</p>

<h1>ifndef SwiftRealm_SwiftRealm_Bridging_Header_h</h1>

<h1>define SwiftRealm_SwiftRealm_Bridging_Header_h</h1>

<h1>import &lt;Realm/Realm.h></h1>

<h1>endif</h1>

<p>```</p>

<p>これでRealmを利用する準備が整いました。<br/>
実際にコードを書いていきましょう。</p>

<h5>保存オブジェクトの生成</h5>

<p>Realmでは保存する対象を<code>RLMObject</code>として作成します。<br/>
SQLiteでいうところのテーブルを生成しているイメージでしょうか。</p>

<p>今回は練習として<code>Engineer.swift</code>内で<code>Engineer</code>クラスを作ってみました。</p>

<p>```objective-c
// Engineer.swift</p>

<p>// Engineerクラス
class Engineer:RLMObject {</p>

<pre><code>// プロパティと初期値の設定
dynamic var id:Int = 0
dynamic var level:Int = 0
dynamic var businessTitle:String = ""
dynamic var skills = RLMArray(objectClassName: "Skills")
dynamic var created:Double = 0
dynamic var updated:Double = 0

// プライマリーキーの設定
override class func primaryKey() -&gt; String? {
    return "id"
}

// インデックスの設定
override class func indexedProperties() -&gt; [AnyObject]? {
    return ["level"]
}
</code></pre>

<p>}</p>

<p>// Skillsクラス
class Skills: RLMObject {</p>

<pre><code>    dynamic var skill:String = ""
</code></pre>

<p>}
```</p>

<p>ポイントとしては、<code>skills</code>のように配列の形で1つの要素に複数の値を割り当てたい場合は、それ単体で別に<code>RLMObject</code>の拡張クラスを作成する必要があります。<br/>
<code>RLMArray</code>を初期化することは許可されていないためです。</p>

<h5>オブジェクトのインサート/アップデート</h5>

<p>続いて、先ほど生成したオブジェクトをインサート/アップデートしてみましょう。</p>

<p>```objective-c
// ViewController.swift
import UIKit</p>

<p>class ViewController: UIViewController {</p>

<pre><code>override func viewDidLoad() {
    super.viewDidLoad()

    // id=0のオブジェクトを検索
    if let engineer = Engineer(forPrimaryKey: 0) {
        // 検索結果がある場合
        println("既にエンジニアが１人います。\(engineer)")

        // アップデート
        let realm = RLMRealm.defaultRealm()
        // 書込みの開始
        realm.beginWriteTransaction()
        // Skillsクラスをインスタンス化
        let skills = Skills()
        // 要素を設定
        skills.skill = "Objective-C"
        // 既存のデータに要素を追加
        engineer.skills.addObject(skills)
        engineer.updated = NSDate().timeIntervalSince1970
        // データのアップデート処理
        realm.addOrUpdateObject(engineer)
        // 書込みの終了
        realm.commitWriteTransaction()
    } else {
        // 検索結果がない場合
        // Engineerクラスをインスタンス化
        let newEngineer = Engineer()
        newEngineer.id = 0
        newEngineer.level = 0
        newEngineer.businessTitle = "新米エンジニア"
        // Skillsクラスをインスタンス化
        let skills = Skills()
        skills.skill = "Swift"
        newEngineer.skills.addObject(skills)
        newEngineer.created = NSDate().timeIntervalSince1970

        // データの新規作成
        let realm = RLMRealm.defaultRealm()
        // 書込みの開始
        realm.beginWriteTransaction()
        // データのインサート処理
        realm.addObject(newEngineer)
        // 書込みの終了
        realm.commitWriteTransaction()
    }
}

override func didReceiveMemoryWarning() {
    super.didReceiveMemoryWarning()
}
</code></pre>

<p>}
```</p>

<p>ここでは、<code>id=0</code>のデータを検索して、見つからない場合は新規データをインサートし、見つかった場合はデータのアップデートをしています。<br/>
書込みにはトランザクションブロックを使った方法もあるようですが、今回は<code>beginWriteTransaction</code>と<code>commitWriteTransaction</code>を利用しました。</p>

<h5>データの確認</h5>

<p>では、データを作成した後に、そのデータを確認したい場合はどうすれば良いのでしょうか？<br/>
実はMac専用のアプリが提供されています。</p>

<p><a href="https://realm.io/jp/docs/java/latest/">こちらのサイト</a>の <strong>Realm Browser</strong> の項目からインストールしましょう。</p>

<p>Realm Browserを使えば、下記のようにデータを見ることができます。</p>

<p><img src="/images/swift-realm4.png" alt="Realm Browserで確認１" /><br/>
<img src="/images/swift-realm5.png" alt="Realm Browserで確認２" /></p>

<p>これからSQLiteよりもRealmの方がスタンダートな保存方法となることでしょう。<br/>
どんどん使い方を勉強していかなくては！！<br/>
と言ったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
</feed>
