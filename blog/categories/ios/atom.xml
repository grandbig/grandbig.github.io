<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ios | Takahiro Octopress Blog]]></title>
  <link href="http://grandbig.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://grandbig.github.io/"/>
  <updated>2015-07-19T00:14:46+09:00</updated>
  <id>http://grandbig.github.io/</id>
  <author>
    <name><![CDATA[Takahiro]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Kontakt.ioのSmart Beaconを使ってみた]]></title>
    <link href="http://grandbig.github.io/blog/2015/07/18/start-kontakt-beacon/"/>
    <updated>2015-07-18T22:40:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2015/07/18/start-kontakt-beacon</id>
    <content type="html"><![CDATA[<h4>Kontakt.ioのSmart Beaconを使ってみよう</h4>

<p>さて、久しぶりの更新です。<br/>
実は先日、以前から気になっていた<a href="https://store.kontakt.io/our-products/1-bluetooth-beacon.html">Kontakt.io Smart Beacon</a>を購入してみました。<br/>
あまり海外の製品を購入することがないので、届くか心配でしたが、ばっちり自宅に届きました笑</p>

<p>なぜ、Kontakt.ioのSmart Beaconに着目していたかというと、筆者が知る限り、最も発信出力(TxPower)を弱くすることが可能なBeaconだからです。<br/>
<a href="https://support.kontakt.io/hc/en-gb/articles/201621521-Transmission-power-Range-and-RSSI">仕様書</a>を見てみると、出力を-30[dBm]にまで下げることができ、その電波距離は実に2[m]程度らしいです。</p>

<p>また、SDKが充実しており、発信出力を自由に変更できるところもポイント高いですね。<br/>
さて、今回は基本的な実装から見て行きましょう！(何回かに分けて記事にしようと思います。)</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h4>SDKをプロジェクトに追加</h4>

<p>まずは、SDKを使える状態に持っていきます。</p>

<h5>Objective-C編</h5>

<p>CocoaPodsで提供されていますので、簡単です。</p>

<ol>
<li>Projectファイルと同じ階層に<code>Podfile</code>を作成します</li>
<li><code>pod 'KontaktSDK'</code>と記載します</li>
<li><code>pod install</code>を実行します</li>
</ol>


<p>以上でプロジェクトへの追加完了です。</p>

<h5>Swift編</h5>

<p>CocoaPods使いましょう！</p>

<ol>
<li>Projectファイルと同じ階層に<code>Podfile</code>を作成します</li>
<li><code>pod 'KontaktSDK'</code>と記載します</li>
<li><code>pod install</code>を実行します</li>
<li>Bridging-Headerファイルを作成します
<code>ProjectName-Bridging-Header.h</code>ファイルを作成し、Build Settings > Swift Compiler > Objective-C Bridging Headerにパスを設定</li>
<li>Bridging-Headerファイルに必要なライブラリを<code>import</code>します</li>
</ol>


<p>下記は、Buid Settingsの設定です。<br/>
<img src="/images/kontakt1.png" alt="Bridging-Headerファイルの設定" /></p>

<p>下記はBridging-Headerファイルの中身です。</p>

<p>```objective-c</p>

<h1>ifndef KontaktSwiftTest_KontaktSwiftTest_Bridging_Header_h</h1>

<h1>define KontaktSwiftTest_KontaktSwiftTest_Bridging_Header_h</h1>

<h1>import &lt;Foundation/Foundation.h></h1>

<h1>import &lt;CoreLocation/CoreLocation.h></h1>

<h1>import &lt;CoreBluetooth/CoreBluetooth.h></h1>

<h1>import &ldquo;KontaktSDK.h&rdquo;</h1>

<h1>endif</h1>

<p>```</p>

<h4>Kontakt.ioのBeaconを検知してみよう</h4>

<p>これで準備が整ったので、実際にソースを書いて、Beaconを検知してみましょう！</p>

<h5>Objective-C編</h5>

<p>ViewController.mにどんどん書いていきます。</p>

<p>```objective-c
// ViewController.m</p>

<h1>import &ldquo;ViewController.h&rdquo;</h1>

<h1>import &ldquo;KontaktSDK.h&rdquo;</h1>

<p>@interface ViewController ()<KTKLocationManagerDelegate></p>

<p>@property(strong, nonatomic) KTKLocationManager *lm;</p>

<p>@end</p>

<p>@implementation ViewController</p>

<ul>
<li><p>(void)viewDidLoad {
  [super viewDidLoad];</p>

<p>  <em>lm = [KTKLocationManager new];
  </em>lm.delegate = self;</p>

<p>  if ([KTKLocationManager canMonitorBeacons]) {
      KTKRegion *region = [KTKRegion alloc] init];
      region.uuid = @&ldquo;AF41A130-E105-4F13-9483-316B7101B0A9&rdquo;;
      [_lm setRegions:@[region]];]
  }
}</p></li>
<li><p>(void)viewDidAppear:(BOOL)animated {
  [super viewDidAppear:animated];</p>

<p>  [_lm startMonitoringBeacons];
}</p></li>
<li><p>(void)viewDidDisappear:(BOOL)animated {
  [super viewDidDisappear:animated];</p>

<p>  [_lm stopMonitoringBeacons];
}</p></li>
<li><p>(void)didReceiveMemoryWarning {
  [super didReceiveMemoryWarning];
}</p></li>
</ul>


<h1>pragma mark &ndash; KTKLocationManagerDelegate</h1>

<ul>
<li><p>(void)locationManager:(KTKLocationManager <em>)locationManager didChangeState:(KTKLocationManagerState)state withError:(NSError </em>)error {
  if(state == KTKLocationManagerStateFailed) {
      NSLog(@&ldquo;Something went wrong with your Location Services settings. Check OS settings.&rdquo;);
  }
}</p></li>
<li><p>(void)locationManager:(KTKLocationManager <em>)locationManager didEnterRegion:(KTKRegion </em>)region {
  NSLog(@&ldquo;Enter region %@&rdquo;, region.uuid);
}</p></li>
<li><p>(void)locationManager:(KTKLocationManager <em>)locationManager didExitRegion:(KTKRegion </em>)region {
  NSLog(@&ldquo;Exit region %@&rdquo;, region.uuid);
}</p></li>
<li><p>(void)locationManager:(KTKLocationManager <em>)locationManager didRangeBeacons:(NSArray </em>)beacons {
  NSLog(@&ldquo;Ranged beacons count: %lu&rdquo;, [beacons count]);
}</p></li>
</ul>


<p>@end</p>

<p>```</p>

<h5>Swift編</h5>

<p><code>ViwController.swift</code>にどんどん書いていきます。</p>

<p>```objective-c
// ViewController.swift
import UIKit</p>

<p>class ViewController: UIViewController, KTKLocationManagerDelegate {</p>

<pre><code>let lm:KTKLocationManager = KTKLocationManager()

override func viewDidLoad() {
    super.viewDidLoad()

    if(KTKLocationManager.canMonitorBeacons()) {
        let region:KTKRegion = KTKRegion()
        region.uuid = "AF41A130-E105-4F13-9483-316B7101B0A9"
        lm.setRegions([region])
        self.lm.delegate = self
    }
}

override func viewDidAppear(animated: Bool) {
    super.viewDidAppear(animated)

    lm.startMonitoringBeacons()
}

override func viewDidDisappear(animated: Bool) {
    super.viewDidDisappear(animated)

    lm.stopMonitoringBeacons()
}

override func didReceiveMemoryWarning() {
    super.didReceiveMemoryWarning()
}

func locationManager(locationManager: KTKLocationManager!, didChangeState state: KTKLocationManagerState, withError error: NSError!) {
    if(state == .Failed) {
        println("Something went wrong with your Location Services settings. Check OS settings.")
    }
}

func locationManager(locationManager: KTKLocationManager!, didEnterRegion region: KTKRegion!) {
    println("Enter region \(region.uuid)")
}

func locationManager(locationManager: KTKLocationManager!, didExitRegion region: KTKRegion!) {
    println("Exit region \(region.uuid)")
}

func locationManager(locationManager: KTKLocationManager!, didRangeBeacons beacons: [AnyObject]!) {
    println("Ranged beacons count: \(beacons.count)")
}
</code></pre>

<p>}
```</p>

<p>これでKontakt.ioのSmart Beaconを検知することができるようになりました。<br/>
次回はAPI連携して、Beaconのパラメータを変えてみたいと思います。<br/>
と言ったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[複数のiBeaconを検知しよう！(別UUIDの場合)]]></title>
    <link href="http://grandbig.github.io/blog/2015/06/14/multi-ibeacon-region/"/>
    <updated>2015-06-14T23:43:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2015/06/14/multi-ibeacon-region</id>
    <content type="html"><![CDATA[<h4>複数のiBeacon(別UUIDのiBeacon)を検知する方法</h4>

<p>さて、本日は別々のUUIDを持ったiBeacon信号を補足したいと思います。<br/>
iBeaconは案外、電波が遠くまで飛ぶため、幾つかのUUIDを補足できるようにしておくことで、うまく<code>didEnterRegion</code>, <code>didExitRegion</code>を使い、レンジングでのみ取得可能な値を効果的に使うことができるかもしれません。<br/>
今回はiOS8以上を対象に下記サンプルソースを書きました。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<p>```objective-c
// ViewController.m</p>

<h1>import &ldquo;ViewController.h&rdquo;</h1>

<p>@interface ViewController ()</p>

<p>@property (strong, nonatomic) CLLocationManager <em>locationManager;
@property (strong, nonatomic) NSUUID </em>proximityUUID1, <em>proximityUUID2;
@property (strong, nonatomic) CLBeaconRegion </em>beaconRegion1, <em>beaconRegion2;
@property (strong, nonatomic) CLBeacon </em>nearestBeacon;
@property (strong, nonatomic) NSString *str;</p>

<p>@end</p>

<ul>
<li><p>(void)viewDidLoad
{
  [super viewDidLoad];</p>

<p>  self.locationManager = [[CLLocationManager alloc] init];
  self.locationManager.delegate = self;</p>

<p>  self.proximityUUID1 = [[NSUUID alloc] initWithUUIDString:@&ldquo;8D4DB809-032F-4771-96F3-99BD5C25F924&rdquo;];
  self.beaconRegion1 = [[CLBeaconRegion alloc] initWithProximityUUID: self.proximityUUID1 identifier:@&ldquo;com.takahiro.ibeaconSample&rdquo;];
  self.proximityUUID2 = [[NSUUID alloc] initWithUUIDString:@&ldquo;1AE93327-B172-4C5D-BBF7-F52B959FD4EB&rdquo;];
  self.beaconRegion2 = [[CLBeaconRegion alloc] initWithProximityUUID: self.proximityUUID1 identifier:@&ldquo;com.takahiro.ibeaconSample2&rdquo;];</p>

<p>  [self.locationManager requestAlwaysAuthorization];
}</p></li>
</ul>


<p>// ユーザの位置情報の許可状態を確認するメソッド
&ndash; (void)locationManager:(CLLocationManager *)manager didChangeAuthorizationStatus:(CLAuthorizationStatus)status
{</p>

<pre><code>if (status == kCLAuthorizationStatusAuthorizedAlways) {
    // Beaconのモニタリングを開始
    [self.locationManager startMonitoringForRegion:self.beaconRegion1];
    [self.locationManager startMonitoringForRegion:self.beaconRegion2];
}
</code></pre>

<p>}</p>

<p>// 指定した領域に入った場合
&ndash; (void)locationManager:(CLLocationManager <em>)manager didEnterRegion:(CLRegion </em>)region
{</p>

<pre><code>[self sendLocalNotificationForMessage:@"Enter Region"];
</code></pre>

<p>}</p>

<p>// 指定した領域から出た場合
&ndash; (void)locationManager:(CLLocationManager <em>)manager didExitRegion:(CLRegion </em>)region
{</p>

<pre><code>[self sendLocalNotificationForMessage:@"Exit Region"];
</code></pre>

<p>}</p>

<p>// iBeacon領域内に既にいるか/いないかの判定
&ndash; (void)locationManager:(CLLocationManager <em>)manager didDetermineState:(CLRegionState)state forRegion:(CLRegion </em>)region
{</p>

<pre><code>switch (state) {
    case CLRegionStateInside:
        if([region isMemberOfClass:[CLBeaconRegion class]] &amp;&amp; [CLLocationManager isRangingAvailable]){
            [self.locationManager startRangingBeaconsInRegion:self.beaconRegion1];
            [self.locationManager startRangingBeaconsInRegion:self.beaconRegion2];
        }
        break;
    case CLRegionStateOutside:
        if([region isMemberOfClass:[CLBeaconRegion class]] &amp;&amp; [CLLocationManager isRangingAvailable]){
        }
        break;
    case CLRegionStateUnknown:
        if([region isMemberOfClass:[CLBeaconRegion class]] &amp;&amp; [CLLocationManager isRangingAvailable]){
        }
        break;
    default:
        break;
}
</code></pre>

<p>}</p>

<p>// Beacon信号を検出した場合
&ndash; (void)locationManager:(CLLocationManager <em>)manager didRangeBeacons:(NSArray </em>)beacons inRegion:(CLBeaconRegion *)region
{</p>

<pre><code>if (beacons.count &gt; 0) {
    self.nearestBeacon = beacons.firstObject;
    NSString *rangeMessage;

    switch(self.nearestBeacon.proximity) {
        case CLProximityImmediate:
            rangeMessage = @"Range Immediate";
            break;
        case CLProximityNear:
            rangeMessage = @"Range Near";
            break;
        case CLProximityFar:
            rangeMessage = @"Range Far";
            break;
        default:
            rangeMessage = @"Range Unknown";
            break;
    }

    self.str = [[NSString alloc] initWithFormat:@"%f [m]", self.nearestBeacon.accuracy];
    [self sendLocalNotificationForMessage:self.str];
}
</code></pre>

<p>}</p>

<p>// ローカルプッシュ
&ndash; (void)sendLocalNotificationForMessage:(NSString *)message
{</p>

<pre><code>UILocalNotification *localNotification = [UILocalNotification new];
localNotification.alertBody = message;
localNotification.fireDate = [NSDate date];
localNotification.soundName = nil;
[[UIApplication sharedApplication] scheduleLocalNotification:localNotification];
</code></pre>

<p>}
```</p>

<p>ローカルプッシュを可能にするために<code>AppDelegate.m</code>に下記書式を追加しましょう。</p>

<p>```objective-c
// AppDelegate.m
&ndash; (BOOL)application:(UIApplication <em>)application didFinishLaunchingWithOptions:(NSDictionary </em>)launchOptions
{</p>

<pre><code>...

if ([UIApplication instancesRespondToSelector:@selector(registerUserNotificationSettings:)]) {
    [[UIApplication sharedApplication] registerUserNotificationSettings:[UIUserNotificationSettings settingsForTypes:UIUserNotificationTypeAlert|UIUserNotificationTypeSound categories:nil]];
}

return YES;
</code></pre>

<p>}
```</p>

<p>ポイントは<code>CLBeaconRegion</code>を作成するときに指定する<code>UUID</code>と<code>identifier</code>が共にユニークであることです。<br/>
<code>UUID</code>のみを別々にしても<code>identifier</code>が同じだと別のiBeacon領域と見なされないので注意が必要です。</p>

<p>別々のiBeacon領域が作成できれば、<code>didEnterRegion</code>, <code>didExitRegion</code>などのデリゲートメソッドはそれぞれのiBeacon領域に対して発生します。<br/>
もし、比較的狭い空間で複数のiBeaconを設置して、アプリをFG起動しない前提で人流解析をしたい場合は複数のiBeacon領域(別々のUUIDを持ったiBeacon領域)を用意することも１つの手だと思います。</p>

<p>と言ったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swiftで継承とカテゴリってどうやってやるの！？]]></title>
    <link href="http://grandbig.github.io/blog/2015/06/07/swift-inheritance-extension/"/>
    <updated>2015-06-07T23:30:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2015/06/07/swift-inheritance-extension</id>
    <content type="html"><![CDATA[<h4>Swiftで継承</h4>

<p>まずはObjective-CとSwiftの継承の書き方の違いを見て行きましょう。</p>

<p>早速、Objective-Cの継承ですが、</p>

<p>```objective-c
// ヘッダーファイル
@interface SampleA:NSObject
// プロパティの定義
@property(strong, nonatomic) NSString *sampleString;
// メソッドの定義
&ndash; (void)sampleMethod;</p>

<p>@end</p>

<p>```</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<p>```objective-c
// モデルファイル
@interface SampleA()</p>

<p>@end</p>

<p>@implementation</p>

<ul>
<li>(void)sampleMethod {
  &hellip;.
}</li>
</ul>


<p>@end</p>

<p>```</p>

<p>といった形で書けます。</p>

<p>これがSwiftだと、</p>

<p>```objective-c
// swiftファイル
class SampleA:NSObject {</p>

<pre><code>// プロパティの定義
var sampleString:String = "サンプル"
// メソッドの定義
func sampleMethod {
    ....
}
</code></pre>

<p>}</p>

<p>```</p>

<p>とかなりシンプルに書けますね！</p>

<h4>Swiftでカテゴリ</h4>

<p>次にSwiftでObjective-Cで言うカテゴリを実装してみます。</p>

<p>Objective-Cでは、</p>

<p>```objective-c
// ヘッダーファイル
@interface NSError(ContextBase)</p>

<ul>
<li>(NSError <em>)createError:(NSString </em>)message code:(NSInteger)code;</li>
</ul>


<p>@end
```</p>

<p>```objective-c
// モデルファイル
@implementation NSError(ContextBase)</p>

<ul>
<li><p>(NSError <em>)createError:(NSString </em>)message code:(NSInteger)code {
 NSDictionary <em>errorUserInfo = @{ NSLocalizedDescriptionKey:message };
 NSError </em>error = [[NSError alloc] initWithDomain:domain code:code userInfo:errorUserInfo];</p>

<p> return error;
}</p></li>
</ul>


<p>@end
```</p>

<p>と書いてきました。<br/>
これがSwiftでは、</p>

<p>```objective-c
// Swiftファイル
extension NSError {</p>

<pre><code>func createError(message:String!, code:Int!) -&gt; NSError {
    let errorUserInfo = [NSLocalizedDescriptionKey: message]
    let error:NSError = NSError(domain: "jp.co.swiftSample", code: code, userInfo: errorUserInfo)

    return error
}
</code></pre>

<p>}
```</p>

<p>と書けます。<br/>
う〜んこれもシンプル！！<br/>
Objective-Cで利用してきた継承はもちろんのこと、カテゴリも残っていて助かりますね！</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SwiftでRealmを使ってみよう！]]></title>
    <link href="http://grandbig.github.io/blog/2015/06/07/swift-realm/"/>
    <updated>2015-06-07T16:35:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2015/06/07/swift-realm</id>
    <content type="html"><![CDATA[<h4>Realmをプロジェクトに追加しよう</h4>

<p>本日は最近、流行っているRealmについて遊んでみたいと思います。<br/>
まずは導入の仕方から見て行きましょう！</p>

<h5>Realmの導入方法</h5>

<p>下記のPodfileを作成しましょう。<br/>
本記事のSwiftプロジェクトとして、<code>SwiftRealm.xcodeproj</code>を作成します。</p>

<p>```objective-c
// Podfile
platform :ios, &lsquo;8.0&rsquo;
source &lsquo;<a href="https://github.com/CocoaPods/Specs.git">https://github.com/CocoaPods/Specs.git</a>&rsquo;</p>

<p>target &lsquo;SwiftRealm&rsquo;, exclusive: true do</p>

<pre><code>pod 'Realm'
</code></pre>

<p>end</p>

<p>target &lsquo;SwiftRealmTests&rsquo;, exclusive: true do</p>

<pre><code>pod 'Realm/Headers'
</code></pre>

<p>end
```</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<p>あとは<code>pod install</code>しましょう。<br/>
すると、<code>SwiftRealm.xcworkspace</code>が作成されるので、Xcodeで起動しましょう。</p>

<p><img src="/images/swift-realm.png" alt="Realmを追加した結果" /></p>

<p>なんと、Objective-C++で書かれていますね！
Swiftで利用するためにはBridging-Headerファイルの設定を行う必要があります。</p>

<p>SwiftRealm-Bridging-Header.hを作成します。<br/>
<img src="/images/swift-realm2.png" alt="ヘッダーファイルの作成" /></p>

<p>TARGETS > SwiftRealm > Build Settings > Swift Compiler &ndash; Code Generation > Objective-C Bridging Header にパスを設定します。<br/>
<img src="/images/swift-realm3.png" alt="パスの設定" /></p>

<p>SwiftRealm-Bridging-Header.hの中身を書きます。</p>

<p>```objective-c</p>

<h1>ifndef SwiftRealm_SwiftRealm_Bridging_Header_h</h1>

<h1>define SwiftRealm_SwiftRealm_Bridging_Header_h</h1>

<h1>import &lt;Realm/Realm.h></h1>

<h1>endif</h1>

<p>```</p>

<p>これでRealmを利用する準備が整いました。<br/>
実際にコードを書いていきましょう。</p>

<h5>保存オブジェクトの生成</h5>

<p>Realmでは保存する対象を<code>RLMObject</code>として作成します。<br/>
SQLiteでいうところのテーブルを生成しているイメージでしょうか。</p>

<p>今回は練習として<code>Engineer.swift</code>内で<code>Engineer</code>クラスを作ってみました。</p>

<p>```objective-c
// Engineer.swift</p>

<p>// Engineerクラス
class Engineer:RLMObject {</p>

<pre><code>// プロパティと初期値の設定
dynamic var id:Int = 0
dynamic var level:Int = 0
dynamic var businessTitle:String = ""
dynamic var skills = RLMArray(objectClassName: "Skills")
dynamic var created:Double = 0
dynamic var updated:Double = 0

// プライマリーキーの設定
override class func primaryKey() -&gt; String? {
    return "id"
}

// インデックスの設定
override class func indexedProperties() -&gt; [AnyObject]? {
    return ["level"]
}
</code></pre>

<p>}</p>

<p>// Skillsクラス
class Skills: RLMObject {</p>

<pre><code>    dynamic var skill:String = ""
</code></pre>

<p>}
```</p>

<p>ポイントとしては、<code>skills</code>のように配列の形で1つの要素に複数の値を割り当てたい場合は、それ単体で別に<code>RLMObject</code>の拡張クラスを作成する必要があります。<br/>
<code>RLMArray</code>を初期化することは許可されていないためです。</p>

<h5>オブジェクトのインサート/アップデート</h5>

<p>続いて、先ほど生成したオブジェクトをインサート/アップデートしてみましょう。</p>

<p>```objective-c
// ViewController.swift
import UIKit</p>

<p>class ViewController: UIViewController {</p>

<pre><code>override func viewDidLoad() {
    super.viewDidLoad()

    // id=0のオブジェクトを検索
    if let engineer = Engineer(forPrimaryKey: 0) {
        // 検索結果がある場合
        println("既にエンジニアが１人います。\(engineer)")

        // アップデート
        let realm = RLMRealm.defaultRealm()
        // 書込みの開始
        realm.beginWriteTransaction()
        // Skillsクラスをインスタンス化
        let skills = Skills()
        // 要素を設定
        skills.skill = "Objective-C"
        // 既存のデータに要素を追加
        engineer.skills.addObject(skills)
        engineer.updated = NSDate().timeIntervalSince1970
        // データのアップデート処理
        realm.addOrUpdateObject(engineer)
        // 書込みの終了
        realm.commitWriteTransaction()
    } else {
        // 検索結果がない場合
        // Engineerクラスをインスタンス化
        let newEngineer = Engineer()
        newEngineer.id = 0
        newEngineer.level = 0
        newEngineer.businessTitle = "新米エンジニア"
        // Skillsクラスをインスタンス化
        let skills = Skills()
        skills.skill = "Swift"
        newEngineer.skills.addObject(skills)
        newEngineer.created = NSDate().timeIntervalSince1970

        // データの新規作成
        let realm = RLMRealm.defaultRealm()
        // 書込みの開始
        realm.beginWriteTransaction()
        // データのインサート処理
        realm.addObject(newEngineer)
        // 書込みの終了
        realm.commitWriteTransaction()
    }
}

override func didReceiveMemoryWarning() {
    super.didReceiveMemoryWarning()
}
</code></pre>

<p>}
```</p>

<p>ここでは、<code>id=0</code>のデータを検索して、見つからない場合は新規データをインサートし、見つかった場合はデータのアップデートをしています。<br/>
書込みにはトランザクションブロックを使った方法もあるようですが、今回は<code>beginWriteTransaction</code>と<code>commitWriteTransaction</code>を利用しました。</p>

<h5>データの確認</h5>

<p>では、データを作成した後に、そのデータを確認したい場合はどうすれば良いのでしょうか？<br/>
実はMac専用のアプリが提供されています。</p>

<p><a href="https://realm.io/jp/docs/java/latest/">こちらのサイト</a>の <strong>Realm Browser</strong> の項目からインストールしましょう。</p>

<p>Realm Browserを使えば、下記のようにデータを見ることができます。</p>

<p><img src="/images/swift-realm4.png" alt="Realm Browserで確認１" /><br/>
<img src="/images/swift-realm5.png" alt="Realm Browserで確認２" /></p>

<p>これからSQLiteよりもRealmの方がスタンダートな保存方法となることでしょう。<br/>
どんどん使い方を勉強していかなくては！！<br/>
と言ったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OAuth2.0認証をUIWebView&WKWebViewで実施しよう！]]></title>
    <link href="http://grandbig.github.io/blog/2015/06/06/custom-oauth-webview/"/>
    <updated>2015-06-06T23:38:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2015/06/06/custom-oauth-webview</id>
    <content type="html"><![CDATA[<h4>最適なWebViewを使って、OAuth2.0認証をしよう！</h4>

<p>本日は、iOSのバージョン毎に最適なWebViewを使ってOAuth2.0認証を実施してみたいと思います。<br/>
やはり、iOS8であればWKWebViewを使いたいですし、iOS7ではUIWebViewしか利用できないという現実があります。</p>

<p>WKWebViewとUIWebViewの使い分け処理に関しては、<a href="http://techblog.yahoo.co.jp/ios/let-uiwebview-as-wkwebview/">let UIWebView as WKWebView</a>を参考にさせて頂きました。<br/>
(あえてObjective-Cで書いています。)</p>

<p>まずは、UIWebViewとWKWebViewの使い分け部分を説明していきます。</p>

<p>共通インターフェースとして<code>WKWebViewProtocol.h</code>を作成します。<br/>
共通化したい処理を書き出しています。</p>

<p>```objective-c
// WKWebViewProtocol.h</p>

<h1>import &lt;UIKit/UIKit.h></h1>

<h1>import &lt;WebKit/WebKit.h></h1>

<p>@protocol WKWebViewProtocol <NSObject></p>

<p>@property (nonatomic, readonly, copy) NSString <em>title;
@property (nonatomic, readonly, copy) NSURL </em>URL;
@property (nonatomic, readonly, getter=isLoading) BOOL loading;
@property (nonatomic, readonly) BOOL canGoBack;
@property (nonatomic, readonly) BOOL canGoForward;</p>

<ul>
<li>(void)loadRequest:(NSURLRequest *)request;</li>
<li>(void)stopLoading;</li>
<li>(void)evaluateJavaScript:(NSString <em>)javaScriptString completionHandler:(void (^)(id, NSError </em>))completionHandler;</li>
<li>(void)goBack;</li>
<li>(void)goForward;</li>
</ul>


<p>@end</p>

<p>```</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<p>次にUIWebViewを拡張した<code>UIWebView+ProtocolConfirmed</code>クラスを作成します。<br/>
基本的にWKWebViewに合わせる形で実装していきます。</p>

<p>```objective-c
// UIWebView+ProtocolConfirmed.h</p>

<h1>import &lt;UIKit/UIKit.h></h1>

<h1>import &ldquo;WKWebViewProtocol.h&rdquo;</h1>

<p>@interface UIWebView(UIWebView_ProtocolConfirmed) <WKWebViewProtocol></p>

<p>@end</p>

<p>```</p>

<p>```objective-c
// UIWebView+ProtocolConfirmed.m</p>

<h1>import &ldquo;UIWebView+ProtocolConfirmed.h&rdquo;</h1>

<p>@implementation UIWebView(UIWebView_ProtocolConfirmed)</p>

<p>// NSURLの取得
&ndash; (NSURL *)URL
{</p>

<pre><code>NSString *URLString = [self stringByEvaluatingJavaScriptFromString:@"document.URL"];
return [NSURL URLWithString:URLString];
</code></pre>

<p>}</p>

<p>// ページのタイトルの取得
&ndash; (NSString *)title
{</p>

<pre><code> return [self stringByEvaluatingJavaScriptFromString:@"document.title"];
</code></pre>

<p>}</p>

<p>// JavaScriptの実行処理
&ndash; (void)evaluateJavaScript:(NSString <em>)javaScriptString completionHandler:(void (^)(id, NSError </em>))completionHandler
{</p>

<pre><code>NSString *result = [self stringByEvaluatingJavaScriptFromString:javaScriptString];
if(completionHandler) {
    completionHandler(result, nil);
}
</code></pre>

<p>}</p>

<p>```</p>

<p>最後にWKWebView側を実装します。<br/>
と言っても、UIWebViewをWKWebViewに合わせるので、何も書くことはありません。</p>

<p>```objective-c
// WKWebView+ProtocolConfirmed.h</p>

<h1>import &lt;WebKit/WebKit.h></h1>

<h1>import &ldquo;WKWebViewProtocol.h&rdquo;</h1>

<p>@interface WKWebView(WKWebView_ProtocolConfirmed) <WKWebViewProtocol></p>

<p>@end</p>

<p>```</p>

<p>```objective-c
// WKWebView+ProtocolConfirmed.m</p>

<h1>import &ldquo;WKWebView+ProtocolConfirmed.h&rdquo;</h1>

<p>@implementation WKWebView(WKWebView_ProtocolConfirmed)</p>

<p>@end</p>

<p>```</p>

<p>では、実際に実装していきましょう。<br/>
OAuth認証の処理に関しては、<a href="http://grandbig.github.io/blog/2015/06/01/custom-oauth/">OAuth2.0認証の処理を自作しよう！</a>を参考にしてください。</p>

<p>```objective-c
// ViewController.m</p>

<h1>import &ldquo;ViewController.h&rdquo;</h1>

<h1>import &ldquo;WKWebViewProtocol.h&rdquo;</h1>

<h1>import &ldquo;WKWebView+ProtocolConfirmed.h&rdquo;</h1>

<h1>import &ldquo;UIWebView+ProtocolConfirmed.h&rdquo;</h1>

<h1>import &ldquo;OAuth2Client.h&rdquo;</h1>

<p>static NSString <em>const clientId = @&ldquo;クライアントID&rdquo;;
static NSString </em>const clientSecret = @&ldquo;クライアントシークレット&rdquo;;
static NSString <em>const authorizationURL = @&ldquo;<a href="https://accounts.google.com/o/oauth2/auth">https://accounts.google.com/o/oauth2/auth</a>&rdquo;;
static NSString </em>const tokenURL = @&ldquo;<a href="https://accounts.google.com/o/oauth2/token">https://accounts.google.com/o/oauth2/token</a>&rdquo;;
static NSString *const scope = @&ldquo;<a href="https://www.googleapis.com/auth/plus.login+https://www.googleapis.com/auth/userinfo.email+https://www.googleapis.com/auth/calendar">https://www.googleapis.com/auth/plus.login+https://www.googleapis.com/auth/userinfo.email+https://www.googleapis.com/auth/calendar</a>&rdquo;;</p>

<p>// UIWebViewおよびWKWebView関連のDelegateを読み込む
@interface ViewController ()&lt;UIWebViewDelegate, WKUIDelegate, WKNavigationDelegate></p>

<p>// UIWebViewとWKWebViewを一纏めにしたWebViewとして下記を定義
@property(nonatomic, assign) id <WKWebViewProtocol> webView;
@property (strong, nonatomic) NSMutableData <em>receivedData;
@property (assign, nonatomic) BOOL </em>isLogin;</p>

<p>@end</p>

<p>@implementation ViewController</p>

<ul>
<li><p>(void)viewDidLoad {
  [super viewDidLoad];</p>

<p>  // WebViewを画面に追加する処理
  [self createWebView];</p>

<p>  NSUserDefaults <em>defaults = [NSUserDefaults standardUserDefaults];
  if([defaults boolForKey:@&ldquo;isLogin&rdquo;]) {
      // 既にOAuth2.0認証実行済みの場合
      [[OAuth2Client sharedInstance] getRefreshAccessToken:^(NSString </em>accessToken) {
          // 成功した場合
          NSLog(@&ldquo;%@&rdquo;, accessToken);
      } failure:^(NSError <em>error) {
          // 失敗した場合
          NSLog(@&ldquo;%@&rdquo;, error);
      }];
  } else {
      // 初めてOAuth2.0認証を実行する場合
      // OAuth2.0認証に必要な各種パラメータの設定
      [[OAuth2Client sharedInstance] setUpOAuth2AccountClientId:clientId clientSecret:clientSecret scope:scope authorizationURL:authorizationURL tokenURL:tokenURL];
      // OAuth2.0認証リクエスト
      [[OAuth2Client sharedInstance] requestAccessToAccount:^(NSURL </em>preparedURL) {
          // リクエスト
          [_webView loadRequest:[NSURLRequest requestWithURL: preparedURL]];
      }
  }</p></li>
</ul>


<p>}</p>

<ul>
<li>(void)didReceiveMemoryWarning {
  [super didReceiveMemoryWarning];
}</li>
</ul>


<p>// WKWebViewまたはUIWebViewをViewに追加する処理
&ndash; (void)createWebView {</p>

<pre><code>if(NSClassFromString(@"WKWebView") != nil) {
    // iOS8の場合
    WKWebView *wkWebView = [[WKWebView alloc] initWithFrame:self.view.bounds];
    wkWebView.navigationDelegate = self;
    wkWebView.UIDelegate = self;
    [self.view addSubview:wkWebView];
    self.webView = wkWebView;
} else {
    // iOS7以下の場合
    UIWebView *uiWebView = [[UIWebView alloc] initWithFrame:self.view.bounds];
    uiWebView.delegate = self;
    [self.view addSubview:uiWebView];
    self.webView = uiWebView;
}
</code></pre>

<p>}</p>

<h1>pragma mark &ndash; UIWebViewDelegate</h1>

<p>// ページの読込みが開始されたときに呼び出される処理
&ndash; (void)webViewDidStartLoad:(UIWebView *)webView {</p>

<pre><code>NSLog(@"webViewDidStartLoad");
</code></pre>

<p>}</p>

<p>// ページを読み終わった後に呼び出される処理
&ndash; (void)webViewDidFinishLoad:(UIWebView *)webView {</p>

<pre><code>NSLog(@"webViewDidFinishLoad");
</code></pre>

<p>}</p>

<p>// エラーが発生したときに呼び出される処理
&ndash; (void)webView:(UIWebView <em>)webView didFailLoadWithError:(NSError </em>)error {</p>

<pre><code>NSLog(@"didFailLoadWithError");
</code></pre>

<p>}</p>

<p>// ページ遷移する前に呼び出される処理
&ndash; (BOOL)webView:(UIWebView <em>)webView shouldStartLoadWithRequest:(NSURLRequest </em>)request navigationType:(UIWebViewNavigationType)navigationType {</p>

<pre><code>NSLog(@"shouldStartLoadWithRequest");

BOOL flag = [[OAuth2Client sharedInstance] checkRedirectURI:request];

if(flag) {
    [[OAuth2Client sharedInstance] getAccessToken:request completionHandler:^(NSString *accessToken){
        // 処理が終了したら呼び出される
        if(accessToken.length &gt; 0) {
            NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];
            [defaults setBool:YES forKey:@"isLogin"];
            [defaults synchronize];
        }
        [webView removeFromSuperview];
    }];

    // ページ遷移しない
    return NO;
}

// ページ遷移する
return YES;
</code></pre>

<p>}</p>

<h1>pragma mark &ndash; WKNavigationDelegate</h1>

<p>// ページの読込みが開始されたときに呼び出される処理
&ndash; (void)webView:(WKWebView <em>)webView didStartProvisionalNavigation:(WKNavigation </em>)navigation
{</p>

<pre><code>NSLog(@"didStartProvisionalNavigation");
</code></pre>

<p>}</p>

<p>// ページを読み終わった後に呼び出される処理
&ndash; (void)webView:(WKWebView <em>)webView didFinishNavigation:(WKNavigation </em>)navigation
{</p>

<pre><code>NSLog(@"didFinishNavigation");
</code></pre>

<p>}</p>

<p>// エラーが発生したときに呼び出される処理
&ndash; (void)webView:(WKWebView <em>)webView didFailProvisionalNavigation:(WKNavigation </em>)navigation withError:(NSError *)error
{</p>

<pre><code>NSLog(@"didFailProvisionalNavigation");
</code></pre>

<p>}</p>

<p>// ページ遷移する前に呼び出される処理
&ndash; (void)webView:(WKWebView <em>)webView decidePolicyForNavigationAction:(WKNavigationAction </em>)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler {</p>

<pre><code>NSLog(@"decidePolicyForNavigationAction");
NSURLRequest *request = navigationAction.request;

BOOL flag = [[OAuth2Client sharedInstance] checkRedirectURI:request];

if(flag) {
    [[OAuth2Client sharedInstance] getAccessToken:request completionHandler:^(NSString *accessToken){
        // 処理が終了したら呼び出される
        if(accessToken.length &gt; 0) {
            NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];
            [defaults setBool:YES forKey:@"isLogin"];
            [defaults synchronize];
        }
        [webView removeFromSuperview];
    }];

    // ページ遷移しない
    decisionHandler(WKNavigationActionPolicyCancel);
}

// ページ遷移する
decisionHandler(WKNavigationActionPolicyAllow);
</code></pre>

<p>}</p>

<p>@end</p>

<p>```</p>

<p>さあ、これでiOS8端末でもiOS7端末でも正しくOAuth認証画面が表示されるかと思います。<br/>
もう今年にはiOS9が発表され、WKWebViewが当然のようになってくるとしたら、UIWebViewは不要になると思いますが、今のところはまだまだ必要でしょう。<br/>
と言ったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
</feed>
