<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ios | Takahiro Octopress Blog]]></title>
  <link href="http://grandbig.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://grandbig.github.io/"/>
  <updated>2015-03-15T23:44:15+09:00</updated>
  <id>http://grandbig.github.io/</id>
  <author>
    <name><![CDATA[Takahiro]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SwiftでGoogle OAuth2認証をしよう！]]></title>
    <link href="http://grandbig.github.io/blog/2015/03/15/gtm-oauth2-in-swift/"/>
    <updated>2015-03-15T22:20:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2015/03/15/gtm-oauth2-in-swift</id>
    <content type="html"><![CDATA[<h4>Swift版 OAuth2認証</h4>

<p>本日は<a href="http://grandbig.github.io/blog/2014/07/13/ios-google-oauth2/">iOSでGoogle OAuth認証がしたい</a>のSwift版を紹介したいと思います。<br/>
Google Play Consoleでの設定やGoogleから配布されているOAuth2認証に必要なソースのダウンロード方法については上記の記事に任せるとして、具体的なソース部分を紹介します。</p>

<p>では早速、Objective-CのソースをSwiftで書きなおしたものを下記に載せます。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<p>```objective-c
// ViewController.swift
import UIKit</p>

<p>class ViewController: UIViewController {</p>

<pre><code>var auth:GTMOAuth2Authentication!
let kKeychainItemName:NSString! = "GOAuthTest"
let scope:NSString! = "https://www.googleapis.com/auth/userinfo.profile https://www.googleapis.com/auth/calendar"
let clientId:NSString! = "Googleから発行されたクライアントID"
let clientSecret:NSString! = "Googleから発行されたクライアントシークレット"
let hasLoggedIn:NSString! = "hasLoggedInKey"

override func viewDidLoad() {
    super.viewDidLoad()
}

override func viewDidAppear(animated: Bool) {
    self.startLogIn()
}

override func didReceiveMemoryWarning() {
    super.didReceiveMemoryWarning()
}

func startLogIn() {
    var defaults:NSUserDefaults? = NSUserDefaults.standardUserDefaults()
    var hasLoggedInFlag:Bool! = defaults?.boolForKey(hasLoggedIn)

    if(hasLoggedInFlag == true) {
        // 認証したことがある場合
        self.auth = GTMOAuth2ViewControllerTouch.authForGoogleFromKeychainForName("Google", clientID: clientId, clientSecret: clientSecret)

        // アクセストークンの取得
        self.authorizeRequest()
    } else {
        // 認証したことがない場合
        var gvc:GTMOAuth2ViewControllerTouch! = GTMOAuth2ViewControllerTouch(scope: scope, clientID: clientId, clientSecret: clientSecret, keychainItemName: "Google", delegate: self, finishedSelector: "viewController:finishedWithAuth:error:")
        self.presentViewController(gvc, animated: true, completion: nil)
    }
}

func viewController(viewController:GTMOAuth2ViewControllerTouch!, finishedWithAuth:GTMOAuth2Authentication!, error:NSError?) {
    if(error != nil) {
        // 認証失敗
    } else {
        // 認証成功
        self.auth = finishedWithAuth
        var defaults = NSUserDefaults.standardUserDefaults()
        defaults.setBool(true, forKey: hasLoggedIn)
        defaults.synchronize()

        // アクセストークンの取得
        self.authorizeRequest()
    }

    // 認証画面を閉じる
    viewController.dismissViewControllerAnimated(true, completion: nil)
}

func authorizeRequest() {
    println(self.auth)
    var req:NSMutableURLRequest! = NSMutableURLRequest(URL: self.auth.tokenURL)
    self.auth.authorizeRequest(req, completionHandler: { (error) -&gt; Void in
        println(self.auth)
    })
}
</code></pre>

<p>}
```</p>

<p>今回のソースは<a href="https://github.com/grandbig/gtm-oauth2-swift">GitHub</a>にアップしています。<br/>
興味があればどしどし使ってみてください。<br/>
ということで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SwiftでWebSocket!]]></title>
    <link href="http://grandbig.github.io/blog/2015/03/11/socketio-in-swift/"/>
    <updated>2015-03-11T14:30:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2015/03/11/socketio-in-swift</id>
    <content type="html"><![CDATA[<h4>socket.io公式クライアントソースを使ったサンプルの作成</h4>

<p>先日、公開された<a href="https://github.com/socketio/socket.io-client-swift">socket.io公式のクライアントソース</a>を使って、サンプルを作成したいと思います。<br/>
公式にも<a href="https://github.com/nuclearace/socket.io-client-swift-example">サンプルコード</a>は公開されているのですが、練習がてら試してみたいと思います。</p>

<p>因みに本件にはサーバ側の説明は特に書いていません。<br/>
下記、内容を試したい場合は<a href="https://github.com/grandbig/socket.io.web">GitHub: socket.io.web</a>からソースをダウンロードしてお使いください。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h5>プログラミング前の準備</h5>

<p>まずは、<a href="https://github.com/square/SocketRocket">SocketRocket</a>をダウンロードしてきましょう。<br/>
READMEに書かれている通り、SocketRocketフォルダごと、自身のフォルダにコピーします。</p>

<p>続いて、下記４つのFrameworkを追加しましょう。</p>

<ul>
<li>libicucore.dylib</li>
<li>CFNetwork.framework</li>
<li>Security.framework</li>
<li>Foundation.framework</li>
</ul>


<p>本プロジェクトはSwiftがベースであるため、このままだと、Objective-Cのクラスを読み込めません。<br/>
そこで、 <strong>Bridge-Header</strong> ファイルを作成する必要があります。</p>

<p>作成手順は下記です。</p>

<ol>
<li>プロジェクトを右クリックでAdd files to &ldquo;プロジェクト名"を選択</li>
<li>TARGETS > Build Settings > Swift Compiler &ndash; Code Generation > Objective-C Bridging Header に作成したBridge-Headerファイルを指定</li>
<li>作成したBridge-Headerファイルに利用したいObjective-Cファイルをimportする</li>
</ol>


<p>そして、socket.io公式のクライアントソースである <strong>SwiftIO</strong> を追加しましょう。</p>

<p>ここまでで準備完了です。<br/>
下記のようなプロジェクト構成になっていることを確認してください。</p>

<p><img src="/images/ws_swift_1.png" alt="プロジェクト構成" /></p>

<h5>プログラミング</h5>

<p>さて、ここからは本格的にプログラミングを書いていきます。<br/>
と言っても、今回作成するサンプルは<a href="http://socket.io/get-started/chat/">socket.io 公式HP > Get Started > Write a chat application</a>を途中まで作成する程度なので、少ししか書きません。</p>

<p>まずは、Storyboardにテキストフィールドとボタンを設置します。</p>

<p><img src="/images/ws_swift_2.png" alt="Storyboardの様子" /></p>

<p>続いて、StoryboardからViewController.swiftにリンク付けします。<br/>
その結果、下記の通りになります。<br/>
(ついでに後々必要となる部分も実装しています。)</p>

<p>```objective-c
// ViewController.swift
import UIKit</p>

<p>class ViewController: UIViewController, UITextFieldDelegate {</p>

<pre><code>// Storyboardからのリンクづけ
@IBOutlet weak var msgField: UITextField!

override func viewDidLoad() {
    super.viewDidLoad()

    // Delegateの設定
    self.msgField.delegate = self
}

override func didReceiveMemoryWarning() {
    super.didReceiveMemoryWarning()
}

func textFieldShouldReturn(textField: UITextField) -&gt; Bool {
    // キーボードのreturnを押下するとキーボードが閉じる処理
    self.msgField.resignFirstResponder()

    return true;
}

@IBAction func sendMessage(sender: AnyObject) {
    // Storyboardからのリンクづけ
    // 後ほど記載
}
</code></pre>

<p>}
```</p>

<p>さて、これでほぼ大詰めです。<br/>
WebSocket処理を書いてみましょう。</p>

<p>```objective-c
// ViewController.swift
import UIKit</p>

<p>class ViewController: UIViewController, UITextFieldDelegate {</p>

<pre><code>// Storyboardからのリンクづけ
@IBOutlet weak var msgField: UITextField!

// クライアント側のSocketコネクションの準備
let socket = SocketIOClient(socketURL: "localhost:3000")

override func viewDidLoad() {
    super.viewDidLoad()

    // Delegateの設定
    self.msgField.delegate = self

    // コネクションの接続
    self.socket.connection()
}

override func didReceiveMemoryWarning() {
    super.didReceiveMemoryWarning()
}

func textFieldShouldReturn(textField: UITextField) -&gt; Bool {
    // キーボードのreturnを押下するとキーボードが閉じる処理
    self.msgField.resignFirstResponder()

    return true;
}

@IBAction func sendMessage(sender: AnyObject) {
    // Storyboardからのリンクづけ
    // テキストフィールド内の文字列をWebSocketで送る処理
    var msg = self.msgField.text
    self.socket.emit("chat message", msg)
}
</code></pre>

<p>}
```</p>

<p>はい。これでクライアント側の実装終了です！<br/>
上記のソースは全て<a href="https://github.com/grandbig/socket.io.ios-swift">GitHub: socket.io.ios-swift</a>にアップしていますので、ご自由にご利用ください。</p>

<p>ということで本日はここまで。</p>

<p>参考:</p>

<ul>
<li><a href="http://socket.io/get-started/chat/">socket.io</a></li>
<li><a href="https://github.com/socketio/socket.io-client-swift">socketio/socket.io-client-swift</a></li>
<li><a href="http://qiita.com/n0bisuke/items/6dc990579b343475a635">SocketRocketでWebSocketを実装してみる</a></li>
<li><a href="http://mk.hatenablog.com/entry/2014/10/16/075841">SwiftからObjective-Cのライブラリ使う</a></li>
</ul>


<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS オールスターズ勉強会に参加しました！]]></title>
    <link href="http://grandbig.github.io/blog/2015/02/14/ios-allstars-study/"/>
    <updated>2015-02-14T13:16:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2015/02/14/ios-allstars-study</id>
    <content type="html"><![CDATA[<h4>iOS オールスターズ勉強会</h4>

<p>本日、<a href="http://eventdots.jp/event/311301">iOSオールスターズ勉強会</a>に参加してきました。<br/>
iOSに特化した勉強会やイベントに参加するのは初めてでしたが、かなりいろいろと勉強になりました。<br/>
そして、まだまだ自分はヒヨッコだと痛感させられました。<br/>
まだまだ-1レベルの情弱プログラマーであることを再認識したところで、いつの日かこのブログを<strong>0から始める情弱プログラミング</strong>に変えてみせたいと思いつつ、勉強会で学んだことを報告したいと思います。</p>

<p>勉強会のテーマは下記の通りです。</p>

<ul>
<li>Adaptive Collection View</li>
<li>Swift製ライブラリの良い書き方を考える</li>
<li>let UIWebView as WKWebView</li>
<li>通信のパフォーマンス改善</li>
<li>効率的なアプリ開発のベストプラクティス</li>
<li>WatchKit を実際にさわってみてわかったこと</li>
<li>長生きするために心臓に悪いリリースはもうやめよう</li>
<li>エンジニア戦記 ~ 小さなチーム 大きな未来 ~</li>
<li>まだiOSでリッチな演出に疲弊してるの？</li>
</ul>


<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h4>Adaptiva Collection View</h4>

<p><a href="https://speakerdeck.com/ishkawa/adaptive-collection-view">本日の資料</a><br/>
<a href="https://github.com/ishkawa">石川さんのGitHub</a>(近々、大きめのライブラリを公開予定とのこと)</p>

<p>下記はメモ</p>

<ul>
<li>iOS8でViewControllerが進化した</li>
<li>セルを並べてアイテムを表示する系のアプリではiPhone, iPadで実装を分けていた。

<ul>
<li>iPhoneはUITableViewを利用</li>
<li>UICollectionViewを利用</li>
</ul>
</li>
<li>UICollectionViewを使えば、iPhone, iPadで実装を分ける必要がなくなる

<ul>
<li>実装はUICollectionViewFlowLayoutを使えば、割りと簡単にできる</li>
<li>UICollectionViewLayoutAttributeをUITableViewに似せる</li>
<li><a href="https://github.com/ishkawa/sandbox">サンプルコード</a></li>
</ul>
</li>
<li>UICollectionViewを使うと、セルの計算がたいへんなのでは？

<ul>
<li>estimatedItemSizeを設定することで、Self Sizing Cellを利用できる(iOS8から)</li>
<li>NSLayoutConstraintを適切に配置するとセルの大きさを自動的に計算してくれる</li>
<li>iOS7はsystemLayoutSizeFittingSize:をitemSizeForIndexPath:で呼べばOK</li>
</ul>
</li>
</ul>


<p>因みに、この手法の優位性に気づいたのは、<br/>
営業: 『急ぎでiPhoneだけで良いので、この機能を実装してください』<br/>
↓<br/>
UICollectionViewを使って開発<br/>
↓<br/>
営業: 『iPad版も実装してくれてありがとうございます！』
↓<br/>
気づいたらiPad版もできていた</p>

<p>まとめ</p>

<ul>
<li>UITableViewはUICollectionViewである</li>
<li>iPhoneはiPadである</li>
<li>同じコードは２度書かない</li>
</ul>


<p>【Q&amp;A】</p>

<p>Q: Cellの並び替え<br/>
A: UITableViewは元々実装されている。UICollectionViewは自分で頑張って実装することになる。<br/>
もしくは諦めてUITableViewを使う</p>

<h4>Swiftで使いやすいAPIを考える</h4>

<p><a href="https://speakerdeck.com/kishikawakatsumi/swiftderaiburariwoshu-kuji-falsepurakuteisu">本日の資料</a><br/>
<a href="https://github.com/kishikawakatsumi">岸川さんGitHub</a></p>

<p>下記はメモ</p>

<ul>
<li><p>Swift製ライブラリの良い書き方を考える</p>

<ul>
<li>人に使われるコードを書くときに、どうすれば良いか</li>
<li>enumが良いという話をすると長くなるので10分でできる話をする</li>
</ul>
</li>
<li><p>Objective-Cとの違い</p>

<ul>
<li>データ型, Optional, オーバーロード, デフォルト引数, メソッドチェーン, エラー処理などの違いがある</li>
</ul>
</li>
<li><p>データ型</p>

<ul>
<li>Class, Struct, Enum, Tuple, Function, Array, Dictionary, Set, Optionalなどがある</li>
<li>Optional型を指定すると、nilを許さない。コンパイル時にわかる(Objective-Cではnilは無視してできていた)</li>
<li>Optionalか否かは明確に設計した方が良い(Swiftは型に厳格な言語なので、明確にして使い方を固めた方が良い)</li>
<li>外に公開しているメソッドは引数にOptionalはつけない(プライベートメソッドはつけても良い)</li>
</ul>
</li>
<li><p>オーバーロード</p>

<ul>
<li>オーバーロードとは引数を変えた同じ名前のメソッドをたくさん用意すること</li>
<li>デフォルト引数は補完がイマイチ</li>
<li>ユーザがメソッドを書いたときに、先に引数の多いメソッドが補完で上がってくると良くない</li>
</ul>
</li>
<li><p>戻り値のオーバーロード</p>

<ul>
<li>戻り値のオーバーロード(NSString, NSData型でそれぞれ返却する場合)はコンパイルエラーが出るので、<code>var let:NSData? = ....</code>と型指定をする</li>
<li>これはリズムが悪いので、メソッド名を分けることにした</li>
</ul>
</li>
<li><p>エラー処理</p>

<ul>
<li>Objective-CならNSErrorのダブルポインタが一般的だけど、Swiftだと実装しにくい</li>
<li>SwiftではEither型を使う(Eitherをユーザが知らないと使えないけど)</li>
<li>自分で定義した型でエラーを返すより、NSErrorを返したほうが良い</li>
</ul>
</li>
<li><p>playground</p>

<ul>
<li>ドキュメントを書くのと一緒にplaygroundをつけてあげると、わかりやすくなって良い</li>
</ul>
</li>
<li><p>Functional style API</p>

<ul>
<li>アドバンストモードで用意すると良い</li>
<li>標準的な書き方と分けて示すと良いと思う</li>
</ul>
</li>
</ul>


<p>【Q&amp;A】</p>

<p>Q: Tupleで返すのは？<br/>
A: EitherでなくてTupleで返すのもあり。<br/>
Tupleで受けると、受けては使いづらい。<br/>
検討した結果、やめた。</p>

<h4>let UIWebView as WKWebView</h4>

<p><a href="http://www.slideshare.net/taketo1024/let-ui-webviewaswkwebview">本日の資料</a></p>

<ul>
<li><p>Swiftについて</p>

<ul>
<li>Swiftは数学と相性が良い</li>
</ul>
</li>
<li><p>UIWebVIewとWKWebViewについて</p>

<ul>
<li>UIWebViewはJavaScriptがSafariよりも遅い</li>
<li>WKWebViewはSafari並に速い</li>
<li>iOS7を切る訳にはいかない&hellip;</li>
<li>毎回、バージョンで条件分岐を書いて、処理を分けるのは美しくない&hellip;</li>
<li>複雑な処理は見えないところに置く方が良い(UIWebViewとWKWebViewのぶん機処理を隠蔽せよ)</li>
<li>iOS7と気持よく別れられるように対応しておくと良い</li>
<li><a href="http://techblog.yahoo.co.jp/ios/let-uiwebview-as-wkwebview/">去年のAdvent Calendar</a>にも載っている</li>
</ul>
</li>
</ul>


<p>個人的には参加前から最も注目していた内容でした。<br/>
WKWebViewは実装で使いたいと思っていたものの、現状、条件分岐が多くなりそうで使っていなかったのですが、これを機会に真似て実装したいと思いました。</p>

<p>【Q&amp;A】</p>

<p>Q: UIWebViewとWKWebViewにおけるDelegateメソッドはどうする？<br/>
A: Delegateはそのまま書いている。<br/>
iOS7をサポートしなくなったときにUIWebViewのDelegateの部分だけ消すことを考えている</p>

<p>Q: UIWebViewと揃えるのであればUIWebViewだけ使えば良いのでは？<br/>
A: WKWebViewの良い所は積極的に使っていきたい(処理が速いところとか)<br/>
iOS8ユーザには体験できる部分は体験してほしいと思っている。</p>

<h4>通信のパフォーマンス改善</h4>

<p><a href="http://www.slideshare.net/susieyy/ios-ios-44665266?ref=http://eventdots.jp/event/311301">本日の資料</a><br/>
<a href="https://github.com/wantedly">wantedlyさんのGItHub</a></p>

<p>下記メモ</p>

<ul>
<li><p>そもそも通信のパフォーマンス改善に取り組んだ理由</p>

<ul>
<li>海外進出する上で通信品質の違いに耐えうるか調べる必要があった</li>
<li>海外の通信品質が悪いので、それに耐えうるパフォーマンス改善に取り組んだ</li>
</ul>
</li>
<li><p>ボトルネックを調べた</p>

<ul>
<li>New Relic Mobileでボトルネックを分析した。(大雑把なボトルネック解析には十分)</li>
<li>Pony Debuggerでもっと細かく分析できるものがあった</li>
</ul>
</li>
<li><p><a href="https://github.com/square/PonyDebugger">Pony Debugger</a>の使い方</p>

<ul>
<li>CocoaPodsでiOSアプリ側にいれる。</li>
<li>サーバ側にもモジュールのインストールが必要。中身はPythonでできている</li>
</ul>
</li>
<li><p>ボトルネック調査の結果</p>

<ul>
<li>画像にボトルネックがあった</li>
<li>画像の処理に関して<a href="https://github.com/rs/SDWebImage">SDWebImage</a>を使っていた</li>
<li>まずは、SDWebImageの仕組みから知る必要がある</li>
<li>SDWebImageのバグを発見して、PullRequestを出したらマージされた</li>
<li><a href="http://agilecatcloud.com/2014/12/02/facebook-%E3%81%8C%E8%AA%9E%E3%82%8B%E3%83%A2%E3%83%90%E3%82%A4%E3%83%AB%EF%BD%A5%E3%83%81%E3%83%A5%E3%83%BC%E3%83%8B%E3%83%B3%E3%82%B0%E3%81%AE%E6%A5%B5%E6%84%8F%EF%BC%9A%E3%81%93%E3%82%8C%E3%81%A7/">Facebookの発展途上国向けの改善施策</a>がネット上に載っていた</li>
</ul>
</li>
<li><p>WebP</p>

<ul>
<li>WebPとはGoogle製のフォーマット(1/3程度のサイズに抑えられる)</li>
<li>SDWebImageはWebPに対応している</li>
<li>wantedlyではサーバはAWSを使っている</li>
<li>WebPに変換する画像サーバを構成するのがたいへんだった</li>
<li><a href="https://github.com/wantedly/nginx-image-server">NginxでWebPに変換するものをGitHubにあげている</a></li>
</ul>
</li>
<li><p>具体的な施策</p>

<ul>
<li>通信帯域により取得する画像サイズを変更する</li>
<li>通信品質は『通信開始・終了の経過時間と受領画像サイズ』から推測</li>
<li>キャッシュ時は計測しない</li>
<li>独自にキャッシュ上に取りに行こうとする画像のサイズよりも大きい物がないか確認するようにしている</li>
<li>実装の可否はデベロッパの通信帯域制限機能で改善結果を確認した</li>
</ul>
</li>
<li><p>他に考えられる対策</p>

<ul>
<li>MessagePackでJSONを圧縮する</li>
<li>SPDYで通信コネクションをまとめる</li>
<li>通信帯域で同時接続数を調整する</li>
</ul>
</li>
</ul>


<h4>効率的なアプリ開発のベストプラクティス</h4>

<p><a href="http://www.slideshare.net/yayugu/ss-44667286">本日の資料</a></p>

<ul>
<li><p>iOSの一大イベントがここ2年連続で実施されている</p>

<ul>
<li>Conference with Developers</li>
</ul>
</li>
<li><p>効率的な開発の必要性</p>

<ul>
<li>メインでない機能を創るときはできる限り効率的に開発したい</li>
</ul>
</li>
<li><p>どうすれば速く開発できるのか</p>

<ul>
<li>やることを減らす</li>
<li>UI, 通信の実装コストを減らす</li>
</ul>
</li>
<li><p>UIの実装コスト</p>

<ul>
<li>端末の性能向上, Auto Layout, Storyboard, Self Sizing Cell</li>
<li>Self Sizing Cellが便利なので、ユーザはiOS8を使って欲しいのが本音</li>
<li>改善の余地としては、React.jsみたいなアプローチ(Viewのdiff &amp; patch)があると良さそう</li>
</ul>
</li>
<li><p>通信の実装コスト</p>

<ul>
<li>仕様に依存。サーバ側が決める。</li>
<li>どちらでも行える処理であれば、サーバ側に処理を任せる。</li>
</ul>
</li>
<li><p>API</p>

<ul>
<li>共通化、RESTにとらわれない</li>
<li>Mantle, JSONModelライブラリの都合に合わせた形で返して欲しい</li>
</ul>
</li>
<li><p>State</p>

<ul>
<li>クライアント側でCacheを持たない</li>
<li>ローカルストアを利用してサーバ側とのdiffがあれば取得しにいく処理はしない</li>
</ul>
</li>
<li><p>サーバ側仕様変更による弊害</p>

<ul>
<li>キレイなRESTful API

<ul>
<li>特化したAPIの作成は断られる。</li>
</ul>
</li>
<li>レガシーサーバ

<ul>
<li>触るのが怖い</li>
<li>リファクタリングするとデグレそう</li>
</ul>
</li>
</ul>
</li>
<li><p>サーバ側担当者の説得の仕方</p>

<ul>
<li>パフォーマンスの向上などメリットを説明</li>
<li>クライアント側の実装の大変さをうったえかける</li>
<li>サーバ側も自分で書く</li>
</ul>
</li>
<li><p>間を取る方法として、中継サーバをたてることも考えられる</p>

<ul>
<li>効率的でないので、やりたくない</li>
<li>中継サーバの処理はClient開発者が書く</li>
<li>ドワンゴはスカラーでProxy Serverを作っていたらしい</li>
</ul>
</li>
</ul>


<p>【Q&amp;A】</p>

<p>Q: サーバ側にどこまで処理を任せているかの線引はあるか<br/>
A: ユーザ体験があがるか、重要な機能かの２つによる<br/>
twitterのツイートはオフラインで見れる ⇒ 意味がある<br/>
設定画面がオンラインでないと見れない ⇒ それで良いのでは？</p>

<h4>WatchKitを実際にさわってみてわかったこと</h4>

<p><a href="http://www.slideshare.net/t26v0748/watch-kit-20150214?ref=http://eventdots.jp/event/311301">本日の資料</a><br/>
<a href="https://github.com/shu223">堤さんのGitHub</a></p>

<ul>
<li><p>自己紹介</p>

<ul>
<li>Over&amp;Out その後: ブログを書いている</li>
<li>iOS7-Sampler, iOS8-Samplerを作っている</li>
<li>iOS9-Samplerのアイコンは作成済み</li>
</ul>
</li>
<li><p>WatchKitについて</p>

<ul>
<li>WatchKitはクラスはたったの15個</li>
<li>Watch ExtensionはiPhone側で実行</li>
<li>Watch Appは基本的に表示だけ</li>
</ul>
</li>
<li><p>動的なイメージの表示</p>

<ul>
<li>タイマーを利用する

<ul>
<li>転送か描画が遅い？ ⇒ 非推奨</li>
</ul>
</li>
<li>キャッシュを使う

<ul>
<li>フレームごとの画像はキャッシュしないようにプログラミングガイドに書いてある</li>
</ul>
</li>
<li>Animated Imageを利用する

<ul>
<li>iOS5から追加されているメソッドが役に立つ</li>
</ul>
</li>
</ul>
</li>
<li><p>テキスト入力</p>

<ul>
<li>presentTextInputControllerWith~を使えば良い

<ul>
<li>テキスト入力のインターフェースを表示するメソッド</li>
</ul>
</li>
</ul>
</li>
<li><p>Smart Replies + 音声入力</p>

<ul>
<li>第一引数にフレーズの履いてる, 第二引数に.Plainを渡す</li>
</ul>
</li>
<li><p>絵文字入力</p>

<ul>
<li>第二引数: .allowEmojiを渡せば良い</li>
<li>シミュレータでは提供されていない</li>
</ul>
</li>
<li><p>カスタムUI</p>

<ul>
<li>WatchKit AppではCore Graphics使えない</li>
<li>Appleの公式を見ると、連番アニメーションだった。</li>
</ul>
</li>
<li><p>カスタムフォント</p>

<ul>
<li>iOSと同様の手順で可能</li>
</ul>
</li>
<li><p>インターフェースのオーバレイ</p>

<ul>
<li>WKInterfaceObjectはUIViewのsubview的にインターフェース同士を重ねられない</li>
<li>WKInterfaceGroupのsetBackgroundImage:を活用すればできる</li>
</ul>
</li>
<li><p>originの調整</p>

<ul>
<li>WKInterfaceGroupを活用(ダミーオブジェクト入れて、グループ化)</li>
</ul>
</li>
<li><p>角丸、Watchの画面サイズ分け対応などなど</p></li>
</ul>


<p>【Q&amp;A】</p>

<p>Q: 手軽にアニメーションするには？<br/>
A: <a href="https://github.com/frosty/Flipbook">Flipbook</a>というOSSがある<br/>
デザイナーが作成したものをアプリに入れるなら、動画としてもらう。<br/>
Flashを使っていた人と仕事をしていたときは連番画像を吐き出してもらっていた</p>

<p>Q: Apple Watchで画像の表示について<br/>
A: AnimatedImageのオブジェクトの生成はiOS側でやるので問題ない<br/>
AnimatedImageをWatch側でレンダリングするのは重い？⇒シミュレータでは問題なかった</p>

<h4>長生きするための心臓に悪いリリースはもうやめよう</h4>

<p><a href="https://speakerdeck.com/tokorom/chang-sheng-kisurutamenixin-zang-nie-iririsuhamouyameyou">本日の資料</a></p>

<ul>
<li><p>アプリの申請について</p>

<ul>
<li>バグが見つかって、月々の課金処理に失敗したとしたら&hellip;.非常に怖い</li>
<li>Internal Testersでの最終チェックすると良い</li>
</ul>
</li>
<li><p>テストの質</p>

<ul>
<li>AppStoreに公開されるものと同じ / 違うアプリのテストなのかどうか</li>
<li>Appleの審査の前後のテストなのかどうか</li>
</ul>
</li>
<li><p>Internal Testers</p>

<ul>
<li>iTunes Connectの新機能</li>
<li>iTunes Connectにサブミットしたアプリをテスト可能</li>
<li>iOS8以降でしか使えない</li>
<li>25人までしか使えない</li>
</ul>
</li>
<li><p>Internal Testers vs CI</p>

<ul>
<li>両方使いましょう(比べるものではない)</li>
</ul>
</li>
<li><p>CIの自動化</p>

<ul>
<li><a href="http://kishikawakatsumi.hatenablog.com/entry/20141022/1413963656">Travis CIでiOSアプリのリリース作業を自動化する</a>という記事が良い</li>
</ul>
</li>
<li><p>万が一の事故に対して&hellip;</p>

<ul>
<li>後から見返せない情報をバックアップしておく

<ul>
<li>Build Details: バージョンが進むと過去のバージョンの情報が見れなくなる。スクショをとっておくと良い。</li>
</ul>
</li>
<li>過去のバージョンのアプリをとっておく

<ul>
<li>iTunesで実際に公開されたアプリをipaで持っておく</li>
<li>それをバージョン毎に保管しておくと良い</li>
<li>コードを見たいのであれば、Gitで良いが、そうでないときもある。</li>
</ul>
</li>
</ul>
</li>
</ul>


<p>【Q&amp;A】</p>

<p>Q: Internal Testers使うと課金できるのか？<br/>
A:実際に購入ができるわけではない。たぶんsandboxに繋がっていると思う。<br/>
厳密に言うと、課金テストはプロモーションコードでテストするしかない。</p>

<p>Q: 自分でリジェクトしてサブミットし直すと速い気がする<br/>
A: 体感的に速く感じることがある。</p>

<h4>エンジニア戦記 ~小さなチーム 大きな未来 ~</h4>

<p><a href="http://www.slideshare.net/yukihirai52/ss-44668339?ref=http://eventdots.jp/event/311301">本日の資料</a></p>

<ul>
<li><p>クラスメソッド</p>

<ul>
<li>Developers.IOを書いている。</li>
<li>月間平均80万PV</li>
<li>ブログを書いている会社だと思われがち</li>
</ul>
</li>
<li><p>iOSエンジニアとWeb-API担当者間で発生した問題</p>

<ul>
<li>APIの返却データにステータスコードが入っている(HTTPステータスコードとは別に)

<ul>
<li>HTTPステータスコードで返すべき</li>
<li>Web APIのレスポンスに独自ステータスコードを持つべきではない</li>
<li>アプリ側でsuccessなのに、エラーハンドリングをしなくてはならない。</li>
</ul>
</li>
<li>1画面で叩くAPIが多い

<ul>
<li>RESTful APIをしたいがために上記のようなことが生じる</li>
<li>複数回APIを実行することで、エラーが発生しやすくなる</li>
</ul>
</li>
</ul>
</li>
<li><p>iOSエンジニアに求められるもの</p>

<ul>
<li>Web APIの知識は必須</li>
<li>改善案を提案できる力が必要</li>
<li><a href="http://www.oreilly.co.jp/books/9784873116860/">Web API The Good Parts</a>を読もう</li>
</ul>
</li>
</ul>


<p>身に染みる話ばかりで考えさせられるテーマでした。<br/>
筆者はクライアント担当としてネイティブとWebの経験があり、サーバ担当としてAPサーバ開発の経験があるので、どっちが良いとは言い難く&hellip;。</p>

<h4>まだiOSでリッチな演出に疲弊しているの？</h4>

<p><a href="https://speakerdeck.com/ryusukefuda/madaiosderitutinayan-chu-nipi-bi-siterufalse">本日の資料</a></p>

<ul>
<li><p>カヤック自社開発アプリ</p>

<ul>
<li>FILTERS</li>
<li>ダンボッコキッチン</li>
</ul>
</li>
<li><p>リッチな演出で何を使う？</p>

<ul>
<li>Core Animation: コードが大量になる。大量オブジェクトを動かすとたいへん</li>
<li>Unity: ネイティブの機能を使うのにプラグインを書くのでたいへん</li>
<li>Cocos2d: Unityと同じ</li>
<li>OSS: いいものが見つからない</li>
</ul>
</li>
<li><p>SpriteKitが良いのでは？</p>

<ul>
<li>iOS7から追加された2Dゲーム用のフレームワーク</li>
<li>パーティクルがXcodeでプレビューしながら編集可能</li>
<li>UIKitと同様に記述できる</li>
<li>SpriteKitがゲーム以外で使えるのか? ⇒ 使える</li>
<li>SKNode, SKScene, SKViewを使う</li>
<li>GUIでパラメータを簡単にいじることで演出を変えられる(コードを書く必要がない)</li>
<li>パーティクル自体にアニメーションをつけることもできる</li>
<li>UIViewのタッチイベントが効くようにするために、SKViewを透明かつタッチイベントを無効化する</li>
<li><a href="https://github.com/ryusukefuda/SpriteKit-Demo">サンプルコード</a></li>
</ul>
</li>
<li><p>SpriteKitを使うメリット</p>

<ul>
<li>Appleが提供している安心感</li>
<li>既存のコードを邪魔することなく導入可能</li>
<li>デザイナーも利用可能</li>
</ul>
</li>
</ul>


<p>SpriteKitとUIKitを組合せた演出はありであるという結論に至っていました。</p>

<p>【Q&amp;A】</p>

<p>Q: SpriteKitを使った理由<br/>
A: マップとかカメラとの組合せを考えると、SpriteKitを選択した。<br/>
3Dの演出をする場合はUnity一択になる。</p>

<p>Q: パーティクルは重くないか？<br/>
A: 重い。シミュレータだとカクついたりする。<br/>
表示する場所を絞る。(SKViewの大きさを小さくするなど)</p>

<p>といったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AFNetworking2.xでWeb-APIを叩いてみた！]]></title>
    <link href="http://grandbig.github.io/blog/2015/02/12/afnetworking/"/>
    <updated>2015-02-12T00:01:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2015/02/12/afnetworking</id>
    <content type="html"><![CDATA[<h3>AFNetworking2.x</h3>

<p>さて、本日は今更ながら超有名ライブラリである <strong>AFNetworking</strong> を使ってみたいと思います。<br/>
ただ、単に使い方を説明するのであれば、他のサイトにお任せすれば良いので、Web-APIを使ってみる形で書きたいと思います。</p>

<p>今回は、<br/>
GETリクエスト: <strong>OpenWeatherMap API</strong><br/>
POSTリクエスト: <strong>VoiceText Web API</strong><br/>
を試してみました。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<p>　</p>

<p><strong>AFNetworking</strong> を使うためにはCocoaPodsでライブラリをインストールして、<br/>
ViewController.mで<code>#import "AFNetworking.h"</code>を書きましょう。</p>

<p>まずは、OpenWeatherMap APIを使って、GETリクエストを投げてみました。</p>

<p>```objective-c
// ViewController.m</p>

<h1>import &ldquo;ViewController.h&rdquo;</h1>

<h1>import &ldquo;AFNetworking.h&rdquo;</h1>

<p>@interface ViewController ()</p>

<p>@end</p>

<p>@implementation ViewController</p>

<ul>
<li><p>(void)viewDidLoad {
  [super viewDidLoad];</p>

<p>  // AFHTTPSessionManagerをインスタンス化
  AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];</p>

<p>  // OpenWeatherMap APIを利用
  [manager GET:@&ldquo;<a href="http://api.openweathermap.org/data/2.5/weather?q=Tokyo,jp">http://api.openweathermap.org/data/2.5/weather?q=Tokyo,jp</a>&rdquo;
    parameters:nil
       success:^(NSURLSessionDataTask <em>task, id responseObject) {
           NSLog(@&ldquo;response: %@&rdquo;, responseObject);
       } failure:^(NSURLSessionDataTask </em>task, NSError *error) {
           NSLog(@&ldquo;error: %@&rdquo;, error);
       }
}
```</p></li>
</ul>


<p>きちんと値が返ってきました。</p>

<p>続いて、<a href="https://cloud.voicetext.jp/webapi">VoiceText Web API</a>を使って、POSTリクエストを投げてみました。<br/>
VoiceText Web APIは無料利用に登録が必要なので、さくっと登録しましょう。<br/>
すぐに登録したメールにAPIキーが来ます。<br/>
これを使って、POSTリクエストを投げてみました。</p>

<p>```objective-c
// ViewController.m</p>

<h1>import &ldquo;ViewController.h&rdquo;</h1>

<h1>import &ldquo;AFNetworking.h&rdquo;</h1>

<p>@interface ViewController ()</p>

<p>@end</p>

<p>@implementation ViewController</p>

<ul>
<li><p>(void)viewDidLoad {
  [super viewDidLoad];</p>

<p>  // AFHTTPSessionManagerをインスタンス化
  AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];</p>

<p>  // APIキーをセット
  NSString *apiKey = @&ldquo;&lt;メールで届いたAPIキー>&rdquo;;
  [manager.requestSerializer setAuthorizationHeaderFieldWithUsername:apiKey password:nil];</p>

<p>  // リクエストパラメータをセット
  NSMutableDictionary <em>params = [NSMutableDictionary alloc] init];
  NSString </em>text = @&ldquo;おはようございます。&rdquo;;
  [params setObject:text forKey:@&ldquo;text&rdquo;];
  [params setObject:@&ldquo;show&rdquo; forKey:@&ldquo;speaker&rdquo;];
  [params setObject:@&ldquo;ogg&rdquo; forKey:@&ldquo;format&rdquo;];]</p>

<p>  // Content-Typeをセット
  [manager setResponseSerializer:[AFHTTPResponseSerializer serializer]];
  manager.responseSerializer.acceptableContentTypes = [NSSet setWithObject:@&ldquo;audio/ogg&rdquo;];</p>

<p>  // OpenWeatherMap APIを利用
  [manager POST:@&ldquo;<a href="https://api.voicetext.jp/v1/tts">https://api.voicetext.jp/v1/tts</a>&rdquo;
     parameters:params
        success:^(NSURLSessionDataTask <em>task, id responseObject) {
            NSLog(@&ldquo;response: %@&rdquo;, responseObject);
        } failure:^(NSURLSessionDataTask </em>task, NSError *error) {
            NSLog(@&ldquo;error: %@&rdquo;, error);
        }
}
```</p></li>
</ul>


<p>注意点は下記です。</p>

<ul>
<li>APIキーの設定
VoiceText Web APIではAPIキーを利用する必要があるので、<code>requestSerializer</code>の<code>authorization</code>にユーザネームとしてAPIキーを設定しましょう。</li>
<li><code>Content-Type</code>の設定
<code>audio/ogg</code>でレスポンスを受け取る必要があるので、<code>responseSerializer</code>を設定しましょう。</li>
</ul>


<p>あとは通常の<code>NSURLSession</code>や<code>NSURLConnection</code>のPOSTリクエストと同様にリクエストパラメータをセットすれば良いのです。
正しく値が返ってきますね。</p>

<p>AFNetworkingの良いところはエラーでも値が返ってくるところでしょうか。<br/>
<code>Content-Type</code>が対応していないので<code>success</code>を通らないということが一目瞭然でした。</p>

<p>今後は、この便利なライブラリを積極的に使っていこうかと思います。<br/>
といったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[REBL600FRの発信パラメータをiOSアプリで変更してみた！]]></title>
    <link href="http://grandbig.github.io/blog/2015/02/11/bl600sample3/"/>
    <updated>2015-02-11T14:23:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2015/02/11/bl600sample3</id>
    <content type="html"><![CDATA[<h4>REBL600FRのパラメータ値を変更</h4>

<p><a href="http://grandbig.github.io/blog/2015/02/08/bl600sample2/">前回</a>はREBL600FRの検知＆パラメータ値の読込みまでやってみました。<br/>
今日はREBL600FRが発信するパラメータ値をiOSアプリから変更してみます。</p>

<p>まず、UIButtonをタップしたときにmajorの値を固定値に変更するメソッドを作成してみます。</p>

<p>```objective-c
// ViewController.m
// 書き込みテスト用のメソッド
&ndash; (IBAction)writeDataTestMethod:(id)sender {</p>

<pre><code>// ① majorの値を4661に設定
NSInteger writeInt = 4661;
// ② 10進数を16進数に変換して文字列にする
NSString *witeString = [NSString stringWithFormat:@"%lX",(long)writeInt];
// ③ 16進数のNSString型をNSData型に変換する処理
NSData *writeData = [witeString dataFromHexString];
NSLog(@"writeData: %@", writeData);

// ④ データの書込み処理
[self.connectedPeripheral writeValue:writeData forCharacteristic:self.majorChar type:CBCharacteristicWriteWithResponse];
</code></pre>

<p>}
```</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<p>上記メソッドの説明をします。<br/>
まず、majorの値を4661に変更したいとします。</p>

<p>【処理の順番】<br/>
① ユーザが入力する際には当然、10進数の値で考えると思うので、初めの入力値は <strong>10進数</strong> の4661とします。<br/>
② 次にREBL600FRが理解できるように16進数に変換する必要があります。<br/>
『NSInteger型かつ10進数』で表された4661を『NSString型かつ16進数』の値に変換します。<br/>
③ 書換えたい値をREBL600FRに送るためにNSData型に変換します。<br/>
④ 書込みたいデータが用意できたので、書込み処理を実行します。<br/>
<code>self.majorChar</code>には予め、major値のキャラクタリスティックを保持しています。</p>

<p>さて、③と④の処理について説明が不十分なので、説明します。<br/>
③ですが、NSString型のクラスを拡張し、 <strong>16進数のNSString型をNSData型に変換する</strong> メソッドを追加します。</p>

<p>```objective-c
// NSString+Conversion.h</p>

<h1>import &lt;Foundation/Foundation.h></h1>

<p>@interface NSString (NSString_Conversion)</p>

<h1>pragma mark &ndash; Data Conversion</h1>

<ul>
<li>(NSData *)dataFromHexString;</li>
</ul>


<p>@end
```</p>

<p>```objective-c
// NSString+Conversion.m</p>

<h1>import &ldquo;NSString+Conversion.h&rdquo;</h1>

<p>@implementation NSString (NSString_Conversion)</p>

<h1>pragma mark &ndash; Data Conversion</h1>

<ul>
<li><p>(NSData <em>)dataFromHexString {
  const char </em>chars = [self UTF8String];
  NSUInteger i = 0, len = self.length;</p>

<p>  NSMutableData *data = [NSMutableData dataWithCapacity:len / 2];
  char byteChars[3] = {&lsquo;\0&rsquo;,&lsquo;\0&rsquo;,&lsquo;\0&rsquo;};
  unsigned long wholeByte;</p>

<p>  while (i &lt; len) {
      byteChars[0] = chars[i++];
      byteChars[1] = chars[i++];
      wholeByte = strtoul(byteChars, NULL, 16);
      [data appendBytes:&amp;wholeByte length:1];
  }</p>

<p>  return data;
}</p></li>
</ul>


<p>@end
```</p>

<p>続いて、④について説明します。<br/>
<code>self.majorChar</code>にmajor値のキャラクタリステックを保持するために、<a href="http://grandbig.github.io/blog/2015/02/08/bl600sample2/">前回</a>の記事で説明した処理を少し書換えます。</p>

<p>```objective-c
// ViewController.m
// Characteristicesが見つかったときに呼び出される処理
&ndash; (void)peripheral:(CBPeripheral <em>)peripheral didDiscoverCharacteristicsForService:(CBService </em>)service error:(NSError *)error {</p>

<pre><code>for(CBCharacteristic *characteristic in service.characteristics) {
    // キャラクタリステックのUUID値を取得
    CBUUID *uuid = characteristic.UUID;
    NSString *uuidString = [NSString alloc] initWithFormat:@"%@", uuid];]

    if([uuidString isEqual:@"569A2013-B87F-490C-92CB-11BA5EA5167C"]) {
        // major値の場合はCharacteristicをメモリに保持
        self.majorChar = characteristic;
    }

    // 値が変わったときに通知を受けたい場合に実行
    [peripheral setNotifyValue:YES forCharacteristic:characteristic];
    // キャラクタリステックのvalueを知りたい場合に実行
    [peripheral readValueForCharacteristic:characteristic];
}
</code></pre>

<p>}
```</p>

<p>上記処理のタイミングで<code>self.majorChar</code>をメモリに保持できるので、<code>writeValue</code>メソッドの引数として指定できます。<br/>
さて、<code>writeValue</code>メソッドを実行したときにエラーが発生する可能性があるので、下記メソッドを追加します。</p>

<p>```objective-c
// Characteristicの書き込み処理が完了した場合に呼び出される処理
&ndash; (void)peripheral:(CBPeripheral <em>)peripheral didWriteValueForCharacteristic:(CBCharacteristic </em>)characteristic error:(NSError *)error
{</p>

<pre><code>if(error) {
    NSLog(@"error: %@", error);
    return;
}
</code></pre>

<p>}</p>

<p>```</p>

<p>以上の処理を実装した上でUIButtonを押して、<a href="https://itunes.apple.com/jp/app/lightblue-bluetooth-low-energy/id557428110?mt=8">LightBlue</a>を使って確認してみると、確かに値が変更されていることがわかります。</p>

<p>これまでのソースは<a href="https://github.com/grandbig/REBL600FR-Central">GitHub</a>にアップしてありますので、興味がある方はご自由にお使いください。</p>

<p>参考:<br/>
<a href="http://tyashushi.blogspot.jp/2012/09/1016.html">10進数と16進数の変換</a><br/>
<a href="http://stackoverflow.com/questions/2501033/nsstring-hex-to-bytes">NSString hex to bytes</a></p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
</feed>
