<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ios | Takahiro Octopress Blog]]></title>
  <link href="http://grandbig.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://grandbig.github.io/"/>
  <updated>2015-06-07T17:38:06+09:00</updated>
  <id>http://grandbig.github.io/</id>
  <author>
    <name><![CDATA[Takahiro]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SwiftでRealmを使ってみよう！]]></title>
    <link href="http://grandbig.github.io/blog/2015/06/07/swift-realm/"/>
    <updated>2015-06-07T16:35:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2015/06/07/swift-realm</id>
    <content type="html"><![CDATA[<h4>Realmをプロジェクトに追加しよう</h4>

<p>本日は最近、流行っているRealmについて遊んでみたいと思います。<br/>
まずは導入の仕方から見て行きましょう！</p>

<h5>Realmの導入方法</h5>

<p>下記のPodfileを作成しましょう。<br/>
本記事のSwiftプロジェクトとして、<code>SwiftRealm.xcodeproj</code>を作成します。</p>

<p>```objective-c
// Podfile
platform :ios, &lsquo;8.0&rsquo;
source &lsquo;<a href="https://github.com/CocoaPods/Specs.git">https://github.com/CocoaPods/Specs.git</a>&rsquo;</p>

<p>target &lsquo;SwiftRealm&rsquo;, exclusive: true do</p>

<pre><code>pod 'Realm'
</code></pre>

<p>end</p>

<p>target &lsquo;SwiftRealmTests&rsquo;, exclusive: true do</p>

<pre><code>pod 'Realm/Headers'
</code></pre>

<p>end
```</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<p>あとは<code>pod install</code>しましょう。<br/>
すると、<code>SwiftRealm.xcworkspace</code>が作成されるので、Xcodeで起動しましょう。</p>

<p><img src="/images/swift-realm.png" alt="Realmを追加した結果" /></p>

<p>なんと、Objective-C++で書かれていますね！
Swiftで利用するためにはBridging-Headerファイルの設定を行う必要があります。</p>

<p>SwiftRealm-Bridging-Header.hを作成します。<br/>
<img src="/images/swift-realm2.png" alt="ヘッダーファイルの作成" /></p>

<p>TARGETS > SwiftRealm > Build Settings > Swift Compiler &ndash; Code Generation > Objective-C Bridging Header にパスを設定します。<br/>
<img src="/images/swift-realm3.png" alt="パスの設定" /></p>

<p>SwiftRealm-Bridging-Header.hの中身を書きます。</p>

<p>```objective-c</p>

<h1>ifndef SwiftRealm_SwiftRealm_Bridging_Header_h</h1>

<h1>define SwiftRealm_SwiftRealm_Bridging_Header_h</h1>

<h1>import &lt;Realm/Realm.h></h1>

<h1>endif</h1>

<p>```</p>

<p>これでRealmを利用する準備が整いました。<br/>
実際にコードを書いていきましょう。</p>

<h5>保存オブジェクトの生成</h5>

<p>Realmでは保存する対象を<code>RLMObject</code>として作成します。<br/>
SQLiteでいうところのテーブルを生成しているイメージでしょうか。</p>

<p>今回は練習として<code>Engineer.swift</code>内で<code>Engineer</code>クラスを作ってみました。</p>

<p>```objective-c
// Engineer.swift</p>

<p>// Engineerクラス
class Engineer:RLMObject {</p>

<pre><code>// プロパティと初期値の設定
dynamic var id:Int = 0
dynamic var level:Int = 0
dynamic var businessTitle:String = ""
dynamic var skills = RLMArray(objectClassName: "Skills")
dynamic var created:Double = 0
dynamic var updated:Double = 0

// プライマリーキーの設定
override class func primaryKey() -&gt; String? {
    return "id"
}

// インデックスの設定
override class func indexedProperties() -&gt; [AnyObject]? {
    return ["level"]
}
</code></pre>

<p>}</p>

<p>// Skillsクラス
class Skills: RLMObject {</p>

<pre><code>    dynamic var skill:String = ""
</code></pre>

<p>}
```</p>

<p>ポイントとしては、<code>skills</code>のように配列の形で1つの要素に複数の値を割り当てたい場合は、それ単体で別に<code>RLMObject</code>の拡張クラスを作成する必要があります。<br/>
<code>RLMArray</code>を初期化することは許可されていないためです。</p>

<h5>オブジェクトのインサート/アップデート</h5>

<p>続いて、先ほど生成したオブジェクトをインサート/アップデートしてみましょう。</p>

<p>```objective-c
// ViewController.swift
import UIKit</p>

<p>class ViewController: UIViewController {</p>

<pre><code>override func viewDidLoad() {
    super.viewDidLoad()

    // id=0のオブジェクトを検索
    if let engineer = Engineer(forPrimaryKey: 0) {
        // 検索結果がある場合
        println("既にエンジニアが１人います。\(engineer)")

        // アップデート
        let realm = RLMRealm.defaultRealm()
        // 書込みの開始
        realm.beginWriteTransaction()
        // Skillsクラスをインスタンス化
        let skills = Skills()
        // 要素を設定
        skills.skill = "Objective-C"
        // 既存のデータに要素を追加
        engineer.skills.addObject(skills)
        engineer.updated = NSDate().timeIntervalSince1970
        // データのアップデート処理
        realm.addOrUpdateObject(engineer)
        // 書込みの終了
        realm.commitWriteTransaction()
    } else {
        // 検索結果がない場合
        // Engineerクラスをインスタンス化
        let newEngineer = Engineer()
        newEngineer.id = 0
        newEngineer.level = 0
        newEngineer.businessTitle = "新米エンジニア"
        // Skillsクラスをインスタンス化
        let skills = Skills()
        skills.skill = "Swift"
        newEngineer.skills.addObject(skills)
        newEngineer.created = NSDate().timeIntervalSince1970

        // データの新規作成
        let realm = RLMRealm.defaultRealm()
        // 書込みの開始
        realm.beginWriteTransaction()
        // データのインサート処理
        realm.addObject(newEngineer)
        // 書込みの終了
        realm.commitWriteTransaction()
    }
}

override func didReceiveMemoryWarning() {
    super.didReceiveMemoryWarning()
}
</code></pre>

<p>}
```</p>

<p>ここでは、<code>id=0</code>のデータを検索して、見つからない場合は新規データをインサートし、見つかった場合はデータのアップデートをしています。<br/>
書込みにはトランザクションブロックを使った方法もあるようですが、今回は<code>beginWriteTransaction</code>と<code>commitWriteTransaction</code>を利用しました。</p>

<h5>データの確認</h5>

<p>では、データを作成した後に、そのデータを確認したい場合はどうすれば良いのでしょうか？<br/>
実はMac専用のアプリが提供されています。</p>

<p><a href="https://realm.io/jp/docs/java/latest/">こちらのサイト</a>の <strong>Realm Browser</strong> の項目からインストールしましょう。</p>

<p>Realm Browserを使えば、下記のようにデータを見ることができます。</p>

<p><img src="/images/swift-realm4.png" alt="Realm Browserで確認１" /><br/>
<img src="/images/swift-realm5.png" alt="Realm Browserで確認２" /></p>

<p>これからSQLiteよりもRealmの方がスタンダートな保存方法となることでしょう。<br/>
どんどん使い方を勉強していかなくては！！<br/>
と言ったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OAuth2.0認証をUIWebView&WKWebViewで実施しよう！]]></title>
    <link href="http://grandbig.github.io/blog/2015/06/06/custom-oauth-webview/"/>
    <updated>2015-06-06T23:38:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2015/06/06/custom-oauth-webview</id>
    <content type="html"><![CDATA[<h4>最適なWebViewを使って、OAuth2.0認証をしよう！</h4>

<p>本日は、iOSのバージョン毎に最適なWebViewを使ってOAuth2.0認証を実施してみたいと思います。<br/>
やはり、iOS8であればWKWebViewを使いたいですし、iOS7ではUIWebViewしか利用できないという現実があります。</p>

<p>WKWebViewとUIWebViewの使い分け処理に関しては、<a href="http://techblog.yahoo.co.jp/ios/let-uiwebview-as-wkwebview/">let UIWebView as WKWebView</a>を参考にさせて頂きました。<br/>
(あえてObjective-Cで書いています。)</p>

<p>まずは、UIWebViewとWKWebViewの使い分け部分を説明していきます。</p>

<p>共通インターフェースとして<code>WKWebViewProtocol.h</code>を作成します。<br/>
共通化したい処理を書き出しています。</p>

<p>```objective-c
// WKWebViewProtocol.h</p>

<h1>import &lt;UIKit/UIKit.h></h1>

<h1>import &lt;WebKit/WebKit.h></h1>

<p>@protocol WKWebViewProtocol <NSObject></p>

<p>@property (nonatomic, readonly, copy) NSString <em>title;
@property (nonatomic, readonly, copy) NSURL </em>URL;
@property (nonatomic, readonly, getter=isLoading) BOOL loading;
@property (nonatomic, readonly) BOOL canGoBack;
@property (nonatomic, readonly) BOOL canGoForward;</p>

<ul>
<li>(void)loadRequest:(NSURLRequest *)request;</li>
<li>(void)stopLoading;</li>
<li>(void)evaluateJavaScript:(NSString <em>)javaScriptString completionHandler:(void (^)(id, NSError </em>))completionHandler;</li>
<li>(void)goBack;</li>
<li>(void)goForward;</li>
</ul>


<p>@end</p>

<p>```</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<p>次にUIWebViewを拡張した<code>UIWebView+ProtocolConfirmed</code>クラスを作成します。<br/>
基本的にWKWebViewに合わせる形で実装していきます。</p>

<p>```objective-c
// UIWebView+ProtocolConfirmed.h</p>

<h1>import &lt;UIKit/UIKit.h></h1>

<h1>import &ldquo;WKWebViewProtocol.h&rdquo;</h1>

<p>@interface UIWebView(UIWebView_ProtocolConfirmed) <WKWebViewProtocol></p>

<p>@end</p>

<p>```</p>

<p>```objective-c
// UIWebView+ProtocolConfirmed.m</p>

<h1>import &ldquo;UIWebView+ProtocolConfirmed.h&rdquo;</h1>

<p>@implementation UIWebView(UIWebView_ProtocolConfirmed)</p>

<p>// NSURLの取得
&ndash; (NSURL *)URL
{</p>

<pre><code>NSString *URLString = [self stringByEvaluatingJavaScriptFromString:@"document.URL"];
return [NSURL URLWithString:URLString];
</code></pre>

<p>}</p>

<p>// ページのタイトルの取得
&ndash; (NSString *)title
{</p>

<pre><code> return [self stringByEvaluatingJavaScriptFromString:@"document.title"];
</code></pre>

<p>}</p>

<p>// JavaScriptの実行処理
&ndash; (void)evaluateJavaScript:(NSString <em>)javaScriptString completionHandler:(void (^)(id, NSError </em>))completionHandler
{</p>

<pre><code>NSString *result = [self stringByEvaluatingJavaScriptFromString:javaScriptString];
if(completionHandler) {
    completionHandler(result, nil);
}
</code></pre>

<p>}</p>

<p>```</p>

<p>最後にWKWebView側を実装します。<br/>
と言っても、UIWebViewをWKWebViewに合わせるので、何も書くことはありません。</p>

<p>```objective-c
// WKWebView+ProtocolConfirmed.h</p>

<h1>import &lt;WebKit/WebKit.h></h1>

<h1>import &ldquo;WKWebViewProtocol.h&rdquo;</h1>

<p>@interface WKWebView(WKWebView_ProtocolConfirmed) <WKWebViewProtocol></p>

<p>@end</p>

<p>```</p>

<p>```objective-c
// WKWebView+ProtocolConfirmed.m</p>

<h1>import &ldquo;WKWebView+ProtocolConfirmed.h&rdquo;</h1>

<p>@implementation WKWebView(WKWebView_ProtocolConfirmed)</p>

<p>@end</p>

<p>```</p>

<p>では、実際に実装していきましょう。<br/>
OAuth認証の処理に関しては、<a href="http://grandbig.github.io/blog/2015/06/01/custom-oauth/">OAuth2.0認証の処理を自作しよう！</a>を参考にしてください。</p>

<p>```objective-c
// ViewController.m</p>

<h1>import &ldquo;ViewController.h&rdquo;</h1>

<h1>import &ldquo;WKWebViewProtocol.h&rdquo;</h1>

<h1>import &ldquo;WKWebView+ProtocolConfirmed.h&rdquo;</h1>

<h1>import &ldquo;UIWebView+ProtocolConfirmed.h&rdquo;</h1>

<h1>import &ldquo;OAuth2Client.h&rdquo;</h1>

<p>static NSString <em>const clientId = @&ldquo;クライアントID&rdquo;;
static NSString </em>const clientSecret = @&ldquo;クライアントシークレット&rdquo;;
static NSString <em>const authorizationURL = @&ldquo;<a href="https://accounts.google.com/o/oauth2/auth">https://accounts.google.com/o/oauth2/auth</a>&rdquo;;
static NSString </em>const tokenURL = @&ldquo;<a href="https://accounts.google.com/o/oauth2/token">https://accounts.google.com/o/oauth2/token</a>&rdquo;;
static NSString *const scope = @&ldquo;<a href="https://www.googleapis.com/auth/plus.login+https://www.googleapis.com/auth/userinfo.email+https://www.googleapis.com/auth/calendar">https://www.googleapis.com/auth/plus.login+https://www.googleapis.com/auth/userinfo.email+https://www.googleapis.com/auth/calendar</a>&rdquo;;</p>

<p>// UIWebViewおよびWKWebView関連のDelegateを読み込む
@interface ViewController ()&lt;UIWebViewDelegate, WKUIDelegate, WKNavigationDelegate></p>

<p>// UIWebViewとWKWebViewを一纏めにしたWebViewとして下記を定義
@property(nonatomic, assign) id <WKWebViewProtocol> webView;
@property (strong, nonatomic) NSMutableData <em>receivedData;
@property (assign, nonatomic) BOOL </em>isLogin;</p>

<p>@end</p>

<p>@implementation ViewController</p>

<ul>
<li><p>(void)viewDidLoad {
  [super viewDidLoad];</p>

<p>  // WebViewを画面に追加する処理
  [self createWebView];</p>

<p>  NSUserDefaults <em>defaults = [NSUserDefaults standardUserDefaults];
  if([defaults boolForKey:@&ldquo;isLogin&rdquo;]) {
      // 既にOAuth2.0認証実行済みの場合
      [[OAuth2Client sharedInstance] getRefreshAccessToken:^(NSString </em>accessToken) {
          // 成功した場合
          NSLog(@&ldquo;%@&rdquo;, accessToken);
      } failure:^(NSError <em>error) {
          // 失敗した場合
          NSLog(@&ldquo;%@&rdquo;, error);
      }];
  } else {
      // 初めてOAuth2.0認証を実行する場合
      // OAuth2.0認証に必要な各種パラメータの設定
      [[OAuth2Client sharedInstance] setUpOAuth2AccountClientId:clientId clientSecret:clientSecret scope:scope authorizationURL:authorizationURL tokenURL:tokenURL];
      // OAuth2.0認証リクエスト
      [[OAuth2Client sharedInstance] requestAccessToAccount:^(NSURL </em>preparedURL) {
          // リクエスト
          [_webView loadRequest:[NSURLRequest requestWithURL: preparedURL]];
      }
  }</p></li>
</ul>


<p>}</p>

<ul>
<li>(void)didReceiveMemoryWarning {
  [super didReceiveMemoryWarning];
}</li>
</ul>


<p>// WKWebViewまたはUIWebViewをViewに追加する処理
&ndash; (void)createWebView {</p>

<pre><code>if(NSClassFromString(@"WKWebView") != nil) {
    // iOS8の場合
    WKWebView *wkWebView = [[WKWebView alloc] initWithFrame:self.view.bounds];
    wkWebView.navigationDelegate = self;
    wkWebView.UIDelegate = self;
    [self.view addSubview:wkWebView];
    self.webView = wkWebView;
} else {
    // iOS7以下の場合
    UIWebView *uiWebView = [[UIWebView alloc] initWithFrame:self.view.bounds];
    uiWebView.delegate = self;
    [self.view addSubview:uiWebView];
    self.webView = uiWebView;
}
</code></pre>

<p>}</p>

<h1>pragma mark &ndash; UIWebViewDelegate</h1>

<p>// ページの読込みが開始されたときに呼び出される処理
&ndash; (void)webViewDidStartLoad:(UIWebView *)webView {</p>

<pre><code>NSLog(@"webViewDidStartLoad");
</code></pre>

<p>}</p>

<p>// ページを読み終わった後に呼び出される処理
&ndash; (void)webViewDidFinishLoad:(UIWebView *)webView {</p>

<pre><code>NSLog(@"webViewDidFinishLoad");
</code></pre>

<p>}</p>

<p>// エラーが発生したときに呼び出される処理
&ndash; (void)webView:(UIWebView <em>)webView didFailLoadWithError:(NSError </em>)error {</p>

<pre><code>NSLog(@"didFailLoadWithError");
</code></pre>

<p>}</p>

<p>// ページ遷移する前に呼び出される処理
&ndash; (BOOL)webView:(UIWebView <em>)webView shouldStartLoadWithRequest:(NSURLRequest </em>)request navigationType:(UIWebViewNavigationType)navigationType {</p>

<pre><code>NSLog(@"shouldStartLoadWithRequest");

BOOL flag = [[OAuth2Client sharedInstance] checkRedirectURI:request];

if(flag) {
    [[OAuth2Client sharedInstance] getAccessToken:request completionHandler:^(NSString *accessToken){
        // 処理が終了したら呼び出される
        if(accessToken.length &gt; 0) {
            NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];
            [defaults setBool:YES forKey:@"isLogin"];
            [defaults synchronize];
        }
        [webView removeFromSuperview];
    }];

    // ページ遷移しない
    return NO;
}

// ページ遷移する
return YES;
</code></pre>

<p>}</p>

<h1>pragma mark &ndash; WKNavigationDelegate</h1>

<p>// ページの読込みが開始されたときに呼び出される処理
&ndash; (void)webView:(WKWebView <em>)webView didStartProvisionalNavigation:(WKNavigation </em>)navigation
{</p>

<pre><code>NSLog(@"didStartProvisionalNavigation");
</code></pre>

<p>}</p>

<p>// ページを読み終わった後に呼び出される処理
&ndash; (void)webView:(WKWebView <em>)webView didFinishNavigation:(WKNavigation </em>)navigation
{</p>

<pre><code>NSLog(@"didFinishNavigation");
</code></pre>

<p>}</p>

<p>// エラーが発生したときに呼び出される処理
&ndash; (void)webView:(WKWebView <em>)webView didFailProvisionalNavigation:(WKNavigation </em>)navigation withError:(NSError *)error
{</p>

<pre><code>NSLog(@"didFailProvisionalNavigation");
</code></pre>

<p>}</p>

<p>// ページ遷移する前に呼び出される処理
&ndash; (void)webView:(WKWebView <em>)webView decidePolicyForNavigationAction:(WKNavigationAction </em>)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler {</p>

<pre><code>NSLog(@"decidePolicyForNavigationAction");
NSURLRequest *request = navigationAction.request;

BOOL flag = [[OAuth2Client sharedInstance] checkRedirectURI:request];

if(flag) {
    [[OAuth2Client sharedInstance] getAccessToken:request completionHandler:^(NSString *accessToken){
        // 処理が終了したら呼び出される
        if(accessToken.length &gt; 0) {
            NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];
            [defaults setBool:YES forKey:@"isLogin"];
            [defaults synchronize];
        }
        [webView removeFromSuperview];
    }];

    // ページ遷移しない
    decisionHandler(WKNavigationActionPolicyCancel);
}

// ページ遷移する
decisionHandler(WKNavigationActionPolicyAllow);
</code></pre>

<p>}</p>

<p>@end</p>

<p>```</p>

<p>さあ、これでiOS8端末でもiOS7端末でも正しくOAuth認証画面が表示されるかと思います。<br/>
もう今年にはiOS9が発表され、WKWebViewが当然のようになってくるとしたら、UIWebViewは不要になると思いますが、今のところはまだまだ必要でしょう。<br/>
と言ったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OAuth2.0認証の処理を自作しよう！]]></title>
    <link href="http://grandbig.github.io/blog/2015/06/01/custom-oauth/"/>
    <updated>2015-06-01T00:56:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2015/06/01/custom-oauth</id>
    <content type="html"><![CDATA[<h4>OAuth2.0認証処理を自分で作ろう！ Objective-C編</h4>

<p>本日は、<a href="https://code.google.com/p/gtm-oauth2/">gtm-oauth</a>や<a href="https://github.com/nxtbgthng/OAuth2Client">OAuth2Client</a>を使わずにOAuth2.0認証処理を自作してみます。</p>

<p>OAuth2.0認証を通すためのGoogle設定は<a href="http://grandbig.github.io/blog/2014/07/13/ios-google-oauth2/">iOSでGoogle OAuth認証がしたい</a>を参照ください。<br/>
筆者が開発したライブラリは単純な下記処理のみ含んでいます。</p>

<ul>
<li>OAuth2.0認証に必要な各種パラメータをKeychain Servicesに保存</li>
<li>アクセストークンを取得する処理</li>
<li>リフレッシュトークンから新規アクセストークンを取得する処理</li>
</ul>


<p>ここで、Keychain Servicesを使うにあたって、<a href="https://github.com/TheLevelUp/LUKeychainAccess">LUKeychainAccess</a>を利用しています。<br/>
これにより、複雑なKeychain ServicesをNSUserDefaultsの感覚で利用することができます。<br/>
また、Googleへの問い合わせなどのHTTP/HTTPSリクエストに<a href="https://github.com/AFNetworking/AFNetworking">AFNetworking</a>を利用しています。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h4>OAuth2.0認証ライブラリの作成</h4>

<p>下記にソースをそのまま載せておきます。</p>

<p>```objective-c</p>

<p>// OAuth2Client.m</p>

<h1>import &ldquo;OAuth2Client.h&rdquo;</h1>

<h1>import &ldquo;LUKeychainAccess.h&rdquo;</h1>

<h1>import &ldquo;AFNetworking.h&rdquo;</h1>

<p>static NSString <em>callback =  @&ldquo;<a href="http://localhost">http://localhost</a>&rdquo;;
static NSString </em>visibleactions = @&ldquo;<a href="http://schemas.google.com/AddActivity">http://schemas.google.com/AddActivity</a>&rdquo;;</p>

<p>@implementation OAuth2Client</p>

<p>// シングルトンのインスタンス取得
+ (OAuth2Client *)sharedInstance {</p>

<pre><code>static OAuth2Client* sharedInstance = nil;
static dispatch_once_t onceToken;
dispatch_once(&amp;onceToken, ^{
    sharedInstance = [OAuth2Client alloc] init];]
});

return sharedInstance;
</code></pre>

<p>}</p>

<p>// OAuth2.0認証に必要なパラメータを設定する処理
&ndash; (void)setUpOAuth2AccountClientId:(NSString <em>)clientId clientSecret:(NSString </em>)clientSecret scope:(NSString <em>)scope authorizationURL:(NSString </em>)authorizationURL tokenURL:(NSString *)tokenURL {</p>

<pre><code>[[LUKeychainAccess standardKeychainAccess] setObject:clientId forKey:@"clientId"];
[[LUKeychainAccess standardKeychainAccess] setObject:clientSecret forKey:@"clientSecret"];
[[LUKeychainAccess standardKeychainAccess] setObject:scope forKey:@"scope"];
[[LUKeychainAccess standardKeychainAccess] setObject:authorizationURL forKey:@"authorizationURL"];
[[LUKeychainAccess standardKeychainAccess] setObject:tokenURL forKey:@"tokenURL"];
</code></pre>

<p>}</p>

<p>// OAuth2.0認証に必要なリクエストを生成する処理
&ndash; (void)requestAccessToAccount:(void (^)(NSURL *preparedURL))withPreparedAuthorizationURLHandler {</p>

<pre><code>NSString *clientId = [[LUKeychainAccess standardKeychainAccess] objectForKey:@"clientId"];
NSString *scope = [[LUKeychainAccess standardKeychainAccess] objectForKey:@"scope"];
NSString *authorizationURL = [[LUKeychainAccess standardKeychainAccess] objectForKey:@"authorizationURL"];

NSString *url = [[NSString stringWithFormat:@"%@?response_type=code&amp;client_id=%@&amp;redirect_uri=%@&amp;scope=%@&amp;data-requestvisibleactions=%@", authorizationURL, clientId, callback, scope, visibleactions];
withPreparedAuthorizationURLHandler([NSURL URLWithString:url]);
</code></pre>

<p>}</p>

<p>// OAuth2.0認証のリダイレクトURIの一致の有無を確認する処理
&ndash; (BOOL)checkRedirectURI:(NSURLRequest *)request
{</p>

<pre><code>// HOSTの取得
NSString *host = [[request URL] host];
if ([host isEqualToString:@"localhost"]) {
    return YES;
} else {
    return NO;
}
</code></pre>

<p>}</p>

<p>// アクセストークンを取得する処理
&ndash; (void)getAccessToken:(NSURLRequest <em>)request completionHandler:(void (^)(NSString </em>accessToken))completionHandler {</p>

<pre><code>NSString *host = [[request URL] host];
if ([host isEqualToString:@"localhost"]) {
    NSString* verifier = nil;
    NSArray* urlParams = [[request URL] query] componentsSeparatedByString:@"&amp;"];
    for (NSString* param in urlParams) {
        NSArray* keyValue = [param componentsSeparatedByString:@"="];
        NSString* key = [keyValue objectAtIndex:0];
        if ([key isEqualToString:@"code"]) {
            verifier = [keyValue objectAtIndex:1];
            break;
        }
    }

    if (verifier) {
        NSString *clientId = [[LUKeychainAccess standardKeychainAccess] objectForKey:@"clientId"];
        NSString *clientSecret = [[LUKeychainAccess standardKeychainAccess] objectForKey:@"clientSecret"];
        NSString *tokenURL = [[LUKeychainAccess standardKeychainAccess] objectForKey:@"tokenURL"];

        // AFHTTPSessionManagerをインスタンス化
        AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];
        // サーバエラー時のContent-Typeにtext/plainを許可(成功時にapplication/jsonが必要なので共に追加)
        manager.responseSerializer.acceptableContentTypes = [NSSet setWithObjects:@"text/plain", @"application/json", nil];
        // パラメータの設定
        NSDictionary *data = @{@"code": verifier, @"client_id": clientId, @"client_secret": clientSecret, @"redirect_uri": callback, @"grant_type": @"authorization_code"};

        [manager POST:tokenURL parameters:data success:^(NSURLSessionDataTask *task, id responseObject) {
            // 成功した場合
            if(responseObject &amp;&amp; [responseObject count] &gt; 0) {
                NSString *accessToken = responseObject[@"access_token"];
                NSString *refreshToken = responseObject[@"refresh_token"];
                [[LUKeychainAccess standardKeychainAccess] setObject:accessToken forKey:@"accessToken"];
                [[LUKeychainAccess standardKeychainAccess] setObject:refreshToken forKey:@"refreshToken"];

                // 処理が終了したときに実行(アクセストークンを返す)
                completionHandler(accessToken);
            }
        } failure:^(NSURLSessionDataTask *task, NSError *error) {
            // 失敗した場合
            NSError *err;
            NSData *data = [error userInfo] objectForKey:@"com.alamofire.serialization.response.error.data"];
            if(data) {
                // エラーの中身がある場合
                [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingAllowFragments error:&amp;err];
            }
            // 失敗を返す
            failure(err);
        }];
    }
} else {
    // HOST名が一致しない場合
}
</code></pre>

<p>}</p>

<p>// リフレッシュトークンから新しいアクセストークンを取得する処理
&ndash; (void)getRefreshAccessToken:(void (^)(NSString <em>accessToken))success failure:(void (^)(NSError </em>error))failure {</p>

<pre><code>NSString *clientId = [[LUKeychainAccess standardKeychainAccess] objectForKey:@"clientId"];
NSString *tokenURL = [[LUKeychainAccess standardKeychainAccess] objectForKey:@"tokenURL"];
NSString *refreshToken = [[LUKeychainAccess standardKeychainAccess] objectForKey:@"refreshToken"];

if(clientId &amp;&amp; tokenURL &amp;&amp; refreshToken) {
    // 必須パラメータがある場合
    // AFHTTPSessionManagerをインスタンス化
    AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];
    // サーバエラー時のContent-Typeにtext/plainを許可(成功時にapplication/jsonが必要なので共に追加)
    manager.responseSerializer.acceptableContentTypes = [NSSet setWithObjects:@"text/plain", @"application/json", nil];

    // パラメータの設定
    NSDictionary *data = @{@"client_id": clientId, @"refresh_token": refreshToken, @"grant_type": @"refresh_token"};

    [manager POST:tokenURL parameters:data success:^(NSURLSessionDataTask *task, id responseObject) {
        // 成功した場合
        if(responseObject &amp;&amp; [responseObject count] &gt; 0) {
            NSString *accessToken = responseObject[@"access_token"];
            NSString *refreshToken = responseObject[@"refresh_token"];
            [[LUKeychainAccess standardKeychainAccess] setObject:accessToken forKey:@"accessToken"];
            [[LUKeychainAccess standardKeychainAccess] setObject:refreshToken forKey:@"refreshToken"];

            // 処理が終了したときに実行(アクセストークンを返す)
            success(accessToken);
        }
    }, failure(NSURLSessionDataTask *task, NSError *error) {
        // 失敗した場合
        NSError *err;
        NSData *data = [error userInfo] objectForKey:@"com.alamofire.serialization.response.error.data"];
        if(data) {
            // エラーの中身がある場合
            [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingAllowFragments error:&amp;err];
        }
        // 失敗を返す
        failure(err);
    }];
} else {
    // 必須パラメータがない場合
    // TODO: エラーオブジェクトを生成して返す
    failure(nil);
}
</code></pre>

<p>}</p>

<p>@end</p>

<p>```</p>

<p>```objective-c</p>

<p>// OAuth2Client.h</p>

<h1>import &lt;Foundation/Foundation.h></h1>

<p>@interface OAuth2Client : NSObject</p>

<p>/// シングルトンのインスタンス取得
+ (OAuth2Client *)sharedInstance;</p>

<p>/<em><em>
 OAuth2.0認証に必要なパラメータを設定する処理
 @param clientId クライアントID
 @param clientSecret クライアントシークレット
 @param scope アクセス範囲
 @param authorizationURL OAuth2.0 認証先URL
 @param tokenURL OAuth2.0 トークン取得先URL
 </em>/
&ndash; (void)setUpOAuth2AccountClientId:(NSString </em>)clientId clientSecret:(NSString <em>)clientSecret scope:(NSString </em>)scope authorizationURL:(NSString <em>)authorizationURL tokenURL:(NSString </em>)tokenURL;</p>

<p>/<em><em>
 OAuth2.0認証に必要なリクエストを生成する処理
 @param withPreparedAuthorizationURLHandler OAuth2.0認証に必要なリクエストを返すBlock構文
 </em>/
&ndash; (void)requestAccessToAccount:(void (^)(NSURL </em>preparedURL))withPreparedAuthorizationURLHandler;</p>

<p>/<em><em>
 OAuth2.0認証のリダイレクトURIの一致の有無を確認する処理
 @param request リクエスト
 @return リダイレクトURIの一致の有無
 </em>/
&ndash; (BOOL)checkRedirectURI:(NSURLRequest </em>)request;</p>

<p>/<em><em>
 アクセストークンを取得する処理
 @param request アクセストークンの取得に必要なリクエスト
 @param completionHandler アクセストークンの取得処理が完了したら実行される処理
 </em>/
&ndash; (void)getAccessToken:(NSURLRequest </em>)request completionHandler:(void (^)(NSString *accessToken))completionHandler;</p>

<p>/<em><em>
 リフレッシュトークンから新しいアクセストークンを取得する処理
 @param success 処理が成功した場合に実行(返却データはアクセストークン)
 @param failure 処理が失敗した場合に実行(返却データはエラーオブジェクト)
 </em>/
&ndash; (void)getRefreshAccessToken:(void (^)(NSString </em>accessToken))success failure:(void (^)(NSError *error))failure;</p>

<p>```</p>

<h4>呼び出し側のソース</h4>

<p>呼び出し側のソースを記載します。</p>

<p>```objective-c</p>

<p>// ViewController.m</p>

<h1>import &ldquo;ViewController.h&rdquo;</h1>

<h1>import &ldquo;OAuth2Client.h&rdquo;</h1>

<p>static NSString <em>const clientId = @&ldquo;&rdquo;;
static NSString </em>const clientSecret = @&ldquo;&rdquo;;
static NSString <em>const authorizationURL = @&ldquo;<a href="https://accounts.google.com/o/oauth2/auth">https://accounts.google.com/o/oauth2/auth</a>&rdquo;;
static NSString </em>const tokenURL = @&ldquo;<a href="https://accounts.google.com/o/oauth2/token">https://accounts.google.com/o/oauth2/token</a>&rdquo;;
static NSString *const scope = @&ldquo;<a href="https://www.googleapis.com/auth/plus.login+https://www.googleapis.com/auth/userinfo.email+https://www.googleapis.com/auth/calendar">https://www.googleapis.com/auth/plus.login+https://www.googleapis.com/auth/userinfo.email+https://www.googleapis.com/auth/calendar</a>&rdquo;;</p>

<p>@interface ViewController ()<UIWebViewDelegate></p>

<p>@property (weak, nonatomic) IBOutlet UIWebView <em>webView;
@property (strong, nonatomic) NSMutableData </em>receivedData;
@property (assign, nonatomic) BOOL *isLogin;</p>

<p>@end</p>

<p>@implementation ViewController</p>

<ul>
<li><p>(void)viewDidLoad {
  [super viewDidLoad];</p>

<p>  <em>webView.delegate = self;
  NSUserDefaults <em>defaults = [NSUserDefaults standardUserDefaults];
  if([defaults boolForKey:@&ldquo;isLogin&rdquo;]) {
      // 既にOAuth2.0認証実行済みの場合
      [[OAuth2Client sharedInstance] getRefreshAccessToken:^(NSString </em>accessToken) {
          // 成功した場合
          NSLog(@&ldquo;%@&rdquo;, accessToken);
      } failure:^(NSError <em>error) {
          // 失敗した場合
          NSLog(@&ldquo;%@&rdquo;, error);
      }];
  } else {
      // 初めてOAuth2.0認証を実行する場合
      // OAuth2.0認証に必要な各種パラメータの設定
      [[OAuth2Client sharedInstance] setUpOAuth2AccountClientId:clientId clientSecret:clientSecret scope:scope authorizationURL:authorizationURL tokenURL:tokenURL];
      // OAuth2.0認証リクエスト
      [[OAuth2Client sharedInstance] requestAccessToAccount:^(NSURL </em>preparedURL) {
          // リクエスト
          [</em>webView loadRequest:[NSURLRequest requestWithURL: preparedURL]];
      }
  }
}</p></li>
<li><p>(void)didReceiveMemoryWarning {
  [super didReceiveMemoryWarning];
}</p></li>
<li><p>(BOOL)webView:(UIWebView <em>)webView shouldStartLoadWithRequest:(NSURLRequest </em>)request navigationType:(UIWebViewNavigationType)navigationType {</p>

<p>  if([OAuth2Client sharedInstance] checkRedirectURI:request]]) {
      [[OAuth2Client sharedInstance] getAccessToken:request completionHandler:^(NSString <em>accessToken){
          // 処理が終了したら呼び出される
          if(accessToken.length > 0) {
              NSUserDefaults </em>defaults = [NSUserDefaults standardUserDefaults];
              [defaults setBool:YES forKey:@&ldquo;isLogin&rdquo;];
              [defaults synchronize];
          }
          [webView removeFromSuperview];
      }];</p>

<pre><code>  return NO;
</code></pre>

<p>  }</p>

<p>  return YES;
}</p></li>
</ul>


<p>@end</p>

<p>```</p>

<p>これで簡単ですが、OAuth2.0認証の自作ライブラリの開発が完了です。<br/>
必要最低限の機能ですが、十分だと思います。<br/>
(もう少し時間をかけてより良いものを作りたいと思います笑。)</p>

<p>参考:</p>

<ul>
<li><a href="http://technogerms.com/login-with-google-using-oauth-2-0-for-ios-xcode-objective-c/">Login with Google using OAuth 2.0 for iOS Xcode Objective-C</a></li>
<li><a href="http://www.ari-hiro.com/blog/2012/12/30/oauth2-summary">OAuth2.0の備忘録的まとめ</a></li>
<li><a href="http://qiita.com/asakahara/items/06abbc0209262d0051ef">iOSでアプリを削除してもデータを保持する方法</a></li>
</ul>


<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift AFNetworkingライブラリを使ってみよう！]]></title>
    <link href="http://grandbig.github.io/blog/2015/05/24/swift-afnetworking/"/>
    <updated>2015-05-24T10:53:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2015/05/24/swift-afnetworking</id>
    <content type="html"><![CDATA[<h4>通信系ライブラリAFNetworkingの使い方を覚えよう！</h4>

<p>さて、本日はObjective-Cの超有名通信系ライブラリの<a href="https://github.com/AFNetworking/AFNetworking">AFNetworking</a>をSwiftで使ってみようと思います。</p>

<h5>導入の仕方</h5>

<p>まずは導入の仕方を見て行きましょう。<br/>
CocoaPodsを使います。<br/>
Podfileを作成し、下記の内容を記載しましょう。</p>

<p><code>objective-c
platform :ios, '7.0'
pod "AFNetworking", "~&gt; 2.0"
</code></p>

<p>これで<code>pod install</code>すればプロジェクトに <strong>AFNetworking</strong> が追加されるはずです。<br/>
ここで注意したいのが、あくまでもObjective-Cで書かれたライブラリなので、Swiftで使うためにはBridgeファイルを用意する必要があります。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<ol>
<li>プロジェクトにヘッダーファイルを追加します。
ProjectName-Bridging-Header.hという形式が推奨されている模様<br/>
今回はSwiftSample-Bridging-Header.hという名前で追加しました。</li>
<li>TARGETS > SwiftSample > Build Settings > Swift Compiler &ndash; Code Generation > Objective-C Bridging Headerにパスを指定
SwiftSample/SwiftSample-Bridging-Header.hを指定しました。</li>
<li>Bridgeファイルにライブラリを<code>import</code>する</li>
<li>ライブラリを利用するファイルにも<code>import</code>を書きましょう(Swiftの書き方で。)</li>
</ol>


<p>下記の画像を参照ください。
<img src="/images/swift-afnetworking.png" alt="Bridgeファイルの用意" /></p>

<p>また、Bridgeファイルへの具体的な内容を書いておきます。</p>

<p>```objective-c</p>

<h1>ifndef SwiftSample_SwiftSample_Bridging_Header_h</h1>

<h1>define SwiftSample_SwiftSample_Bridging_Header_h</h1>

<h1>endif</h1>

<h1>import &lt;AFNetworking/AFNetworking.h></h1>

<p>```</p>

<h5>GETリクエスト</h5>

<p>では、早速、GETリクエストを書いてみましょう。<br/>
以前の<a href="http://grandbig.github.io/blog/2015/02/12/afnetworking/">AFNetworking2.xでWeb-APIを叩いてみた！</a>でも利用した <strong>OpenWeatherMap API</strong> を例として使います。</p>

<p><code>http://api.openweathermap.org/data/2.5/weather?q=Tokyo,jp</code>でリクエストして、<br/>
下記のデータを返してもらうことを想定しています。</p>

<p>```objective-c</p>

<p>{</p>

<pre><code>base:  "stations",
clouds: {
    all: 32
},
cod: 200,
coord: {
    lat: 35.69,
    lon: 139.65
},
dt: 1432394992,
id: 1850147,
main: {
    grnd_level: 1019.97,
    humidity: 88,
    pressure: 1019.97,
    sea_level: 1024.92,
    temp: 290.99,
    temp_max: 290.99,
    temp_min: 290.99
},
name: Tokyo,
sys: {
    country: "JP",
    message: 0.0386,
    sunrise: 1432323041,
    sunset: 1432374314
},
weather: [
    {
        description: "scattered clouds",
        icon: "03n",
        id: 802,
        main: "Clouds"
    }
],
wind: {
    deg: 198.001,
    speed: 5.11
}
</code></pre>

<p>}</p>

<p>```</p>

<p>では、GETリクエストを投げてみましょう。<br/>
返却されたデータの取得方法についても記載します。</p>

<p>```objective-c
// GETリクエスト
let manager = AFHTTPSessionManager()
manager.GET(&ldquo;<a href="http://api.openweathermap.org/data/2.5/weather?q=Tokyo,jp">http://api.openweathermap.org/data/2.5/weather?q=Tokyo,jp</a>&rdquo;, parameters: nil,</p>

<pre><code>success: { (operation, json) -&gt; Void in
    // 処理が成功した場合
    let dict = json as! [String: AnyObject]
    let weatherArray = dict["weather"] as! [AnyObject]
    let weather = weatherArray[0] as! [String: AnyObject]
    let description = weather["description"] as! String
    println(description)
}, failure: { (operation, error) -&gt; Void in
    // エラーが発生した場合
})
</code></pre>

<p>```</p>

<p>Objective-Cでは下記のように書いていたので、対応づけて見るとわかりやすいかもしれません。</p>

<p>```objective-c
AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];
[manager.GET:@&ldquo;<a href="http://api.openweathermap.org/data/2.5/weather?q=Tokyo,jp">http://api.openweathermap.org/data/2.5/weather?q=Tokyo,jp</a>&rdquo;, parameters: nil,</p>

<pre><code>success:^(NSURLSessionDataTask *task, id responseObject) {
    NSArray *weatherArray = [responseObject objectForKey:@"weather"];
    NSDictionary *weather = [weatherArray objectAtIndex:0];
    NSString *description = [weather objectForKey:@"description"];
    NSLog(description);
}, failure:^(NSURLSessionDataTask *task, NSError *error) {
    // エラーが発生した場合
}];
</code></pre>

<p>```</p>

<p><code>success</code>と<code>failure</code>は戻り値が<code>void</code>なので、Swiftでも<code>-&gt; Void</code>と指定しています。<br/>
<code>[String: AnyObject]</code>は <strong>keyがString型</strong> で <strong>valueがAnyObject(何でもあり)型</strong> のDictionary型への変換で、<br/>
<code>[AnyObject]</code>は <strong>要素がAnyObject(何でもあり)型</strong> のArray型への変換です。</p>

<p>Alamofireとはやはり違った書き方となるので、iOSのターゲットなど要件に従って使い分けていくのが良いでしょう。<br/>
と言ったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift Alamofireライブラリを使ってみよう！]]></title>
    <link href="http://grandbig.github.io/blog/2015/05/24/swift-alamofire1/"/>
    <updated>2015-05-24T00:40:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2015/05/24/swift-alamofire1</id>
    <content type="html"><![CDATA[<h4>通信系ライブラリAlamofireの使い方を覚えよう！</h4>

<p>さて、本日は <strong>Alamofire</strong> ライブラリの使い方を勉強します。<br/>
<a href="https://github.com/Alamofire/Alamofire">Alamofire</a>はObjective-Cの超有名通信系ライブラリである<a href="https://github.com/AFNetworking/AFNetworking">AFNetworking</a>のSwift版と思えばよいでしょう。</p>

<h5>導入の仕方</h5>

<p>まずは導入の仕方から見て行きましょう。<br/>
CocoaPodsを使います。<br/>
Podfileを作成し、下記の内容を記載しましょう。</p>

<p>```objective-c
source &lsquo;<a href="https://github.com/CocoaPods/Specs.git">https://github.com/CocoaPods/Specs.git</a>&rsquo;
platform :ios, &lsquo;8.0&rsquo;
use_frameworks!</p>

<p>pod &lsquo;Alamofire&rsquo;, &lsquo;~> 1.2&rsquo;
```</p>

<p>これで<code>pod install</code>すればプロジェクトにAlamofireが追加されるはずです！<br/>
後は利用したいswiftファイルで<code>import Alamofire</code>しましょう。<br/>
SwiftライブラリをCocoaPodsでインストールすると対象iOSが8.0以上である必要が出てくるので、そこだけ注意しましょう。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h5>GETリクエスト(パターン１)</h5>

<p>続いて、GETリクエストのメソッドを書いてみます。<br/>
以前の<a href="http://grandbig.github.io/blog/2015/02/12/afnetworking/">AFNetworking2.xでWeb-APIを叩いてみた！</a>でも利用した <strong>OpenWeatherMap API</strong> を例として使います。</p>

<p><code>http://api.openweathermap.org/data/2.5/weather?q=Tokyo,jp</code>でリクエストして、<br/>
下記のデータを返してもらうことを想定しています。</p>

<p>```objective-c</p>

<p>{</p>

<pre><code>base:  "stations",
clouds: {
    all: 32
},
cod: 200,
coord: {
    lat: 35.69,
    lon: 139.65
},
dt: 1432394992,
id: 1850147,
main: {
    grnd_level: 1019.97,
    humidity: 88,
    pressure: 1019.97,
    sea_level: 1024.92,
    temp: 290.99,
    temp_max: 290.99,
    temp_min: 290.99
},
name: Tokyo,
sys: {
    country: "JP",
    message: 0.0386,
    sunrise: 1432323041,
    sunset: 1432374314
},
weather: [
    {
        description: "scattered clouds",
        icon: "03n",
        id: 802,
        main: "Clouds"
    }
],
wind: {
    deg: 198.001,
    speed: 5.11
}
</code></pre>

<p>}</p>

<p>```</p>

<p>では、GETリクエストを投げてみましょう。<br/>
返却されたデータの取得方法についても記載します。<br/>
幾つか書き方があるのですが、まずは１つ目の書き方です。</p>

<p>```objective-c
// GETリクエスト
Alamofire.request(.GET, &ldquo;<a href="http://api.openweathermap.org/data/2.5/weather">http://api.openweathermap.org/data/2.5/weather</a>&rdquo;, parameters:[&ldquo;q&rdquo;:&ldquo;Tokyo,jp&rdquo;]).response { (request, response, data, error) in</p>

<pre><code>if let data = data as? NSData {
    // AnyObject型をNSData型に変換できた場合に通過
    // NSData型をJSONの形に変換して、AnyObject?型の変数に格納
    var obj: AnyObject? = NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions.AllowFragments, error: nil)

    if let weatherArray = obj["weather"] as? [AnyObject] {
        // objからweatherフィールドを取得。その際、Array型に変換できた場合に通過
        if let weather = weatherArray[0] as? [String: AnyObject] {
            // NSArray型のweatherArrayから要素0番目を取得。その際、Dictionary型に変換できた場合に通過
            if let description = weather["description"] as? String {
                // NSDictionary型のweatherからdescriptionフィールドを取得。その際、String型に変換できた場合に通過
                println(description)
            }

            // NSDictionary型のweatherからdescriptionを指定して取得
            var description2:String? = weather["description"] as? String
            println(description2)
        }
    }
}
</code></pre>

<p>}
```</p>

<p>注意したいのは、responseで返却される<code>data</code>は <strong>NSData型</strong> ではなく、 <strong>AnyObject?型</strong> だということです。<br/>
そのため、直接<code>NSJSONSerialization.JSONObjectWithData</code>の１つ目の引数に<code>data</code>を指定するとNSData型ではないことを示唆するエラーが出ます。<br/>
なので、 <strong>NSData型</strong> に変換する必要があります。</p>

<p>そして、NSData型のままでは各要素を取り出せないので、 <strong>(JSONの形をした)AnyObject?型</strong> に変換させましょう。<br/>
(Dictionary型に変換しても良いのですが、既にJSONの形に変換されているので十分でしょう。)<br/>
後は各フィールドの型に従って変換して取り出していくイメージで書きましょう。</p>

<p>覚えておきたいのは、</p>

<p>```objective-c
if let 定数名 = 要素 as? 定数の型 {</p>

<pre><code>// 指定した定数の型に変換できた場合に、この中を通過する(変換できなかった場合はnilを入れようとするので、この中を通過しない)
</code></pre>

<p>}
```</p>

<p>という変換の書き方です。<br/>
Swiftの場合、JSONの取り扱いで思った以上にコードが長くなり、ネスト化してしまいます。<br/>
それを防ぐため&amp;JavaScriptのような書き方を意識したライブラリがたくさん出ています。<br/>
近いうち使ってみようと思います。</p>

<p>また、変換時に<code>[AnyObject]</code>や<code>[String: AnyObject]</code>と書いているのは、<br/>
前者が<code>Array型</code>に変換していて、後者は<code>Dictionary型</code>に変換しています。<br/>
Swiftではどんな要素を含むArray型なのかを示し、どんなkeyでどんなvalueなのかをDictionary型として明示的に示す必要があります。</p>

<p>もし、Objective-Cの<code>NSArray型</code>や<code>NSDictionary型</code>に変換する場合は中身の形式を考えずに<code>as</code>の後ろに続けて書けばOKです。</p>

<h5>GETリクエスト(パターン２)</h5>

<p>とは言え、少しネストが深いので、別のresoponse形式のパターンで試してみましょう。</p>

<p>```objective-c
// GETリクエスト
Alamofire.request(.GET, &ldquo;<a href="http://api.openweathermap.org/data/2.5/weather?q=Tokyo,jp">http://api.openweathermap.org/data/2.5/weather?q=Tokyo,jp</a>&rdquo;).responseJSON { (<em>, </em>, JSON, _) in</p>

<pre><code>if let weatherArray = JSON!["weather"] as? [AnyObject] {
    // JSONからweatherフィールドを取得。その際、Array型に変換できた場合に通過
    if let weather = weatherArray[0] as? [String: AnyObject] {
        // NSArray型のweatherArrayから要素0番目を取得。その際、Dictionary型に変換できた場合に通過
        if let description = weather["description"] as? String {
            // NSDictionary型のweatherからdescriptionフィールドを取得。その際、String型に変換できた場合に通過
            println(description)
        }

        // NSDictionary型のweatherからdescriptionを指定して取得
        var description2:String? = weather["description"] as? String
        println(description2)
    }
}
</code></pre>

<p>}
```</p>

<p>これは、レスポンスメソッドに<code>responseJSON</code>を指定することで、<br/>
1つ目に上げた<code>AnyObject?型 ⇒ NSData型</code>への変換と<code>NSData型 ⇒ JSONの形をしたAnyObject?型</code>への変換は不要となります。<br/>
既に<code>responseJSON</code>の中でやってくれています。<br/>
少しネストが浅くなりましたね！</p>

<h5>GETリクエスト(パターン３)</h5>

<p>まだ、ネストが深いって？<br/>
よし！思い切ってネストをなくしましょう！</p>

<p>```objective-c
// GETリクエスト
Alamofire.request(.GET, &ldquo;<a href="http://api.openweathermap.org/data/2.5/weather?q=Tokyo,jp">http://api.openweathermap.org/data/2.5/weather?q=Tokyo,jp</a>&rdquo;).response { (request, response, data, error) in</p>

<pre><code>// AnyObject?型をNSData型に変換。さらにJSONの形をしたNSDictionary型に変換。
let json = NSJSONSerialization.JSONObjectWithData(data as! NSData, options: NSJSONReadingOptions.MutableContainers, error: nil) as! [String: AnyObject]
let weatherArray = json["weather"] as! [AnyObject]
let weather = weatherArray[0] as! [String: AnyObject]
let description = weather["description"] as! String
println(description)
</code></pre>

<p>}
```</p>

<p>う〜ん。ネストは確かになくなったのですが、Unwrapの手法を <strong>Implicitly Unwrapped Optional</strong> にしたため、nilが発生した段階でエラーが発生して落ちます&hellip;。<br/>
値がない場合には空オブジェクトを返すAPIである場合には問題ないと思います。</p>

<p>だんだんとSwiftの基礎含めて理解が進んできた気がします。<br/>
と言ったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
</feed>
