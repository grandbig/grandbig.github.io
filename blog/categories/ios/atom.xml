<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ios | Takahiro Octopress Blog]]></title>
  <link href="http://grandbig.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://grandbig.github.io/"/>
  <updated>2015-06-07T00:17:39+09:00</updated>
  <id>http://grandbig.github.io/</id>
  <author>
    <name><![CDATA[Takahiro]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[OAuth2.0認証をUIWebView&WKWebViewで実施しよう！]]></title>
    <link href="http://grandbig.github.io/blog/2015/06/06/custom-oauth-webview/"/>
    <updated>2015-06-06T23:38:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2015/06/06/custom-oauth-webview</id>
    <content type="html"><![CDATA[<h4>最適なWebViewを使って、OAuth2.0認証をしよう！</h4>

<p>本日は、iOSのバージョン毎に最適なWebViewを使ってOAuth2.0認証を実施してみたいと思います。<br/>
やはり、iOS8であればWKWebViewを使いたいですし、iOS7ではUIWebViewしか利用できないという現実があります。</p>

<p>WKWebViewとUIWebViewの使い分け処理に関しては、<a href="http://techblog.yahoo.co.jp/ios/let-uiwebview-as-wkwebview/">let UIWebView as WKWebView</a>を参考にさせて頂きました。<br/>
(あえてObjective-Cで書いています。)</p>

<p>まずは、UIWebViewとWKWebViewの使い分け部分を説明していきます。</p>

<p>共通インターフェースとして<code>WKWebViewProtocol.h</code>を作成します。<br/>
共通化したい処理を書き出しています。</p>

<p>```objective-c
// WKWebViewProtocol.h</p>

<h1>import &lt;UIKit/UIKit.h></h1>

<h1>import &lt;WebKit/WebKit.h></h1>

<p>@protocol WKWebViewProtocol <NSObject></p>

<p>@property (nonatomic, readonly, copy) NSString <em>title;
@property (nonatomic, readonly, copy) NSURL </em>URL;
@property (nonatomic, readonly, getter=isLoading) BOOL loading;
@property (nonatomic, readonly) BOOL canGoBack;
@property (nonatomic, readonly) BOOL canGoForward;</p>

<ul>
<li>(void)loadRequest:(NSURLRequest *)request;</li>
<li>(void)stopLoading;</li>
<li>(void)evaluateJavaScript:(NSString <em>)javaScriptString completionHandler:(void (^)(id, NSError </em>))completionHandler;</li>
<li>(void)goBack;</li>
<li>(void)goForward;</li>
</ul>


<p>@end</p>

<p>```</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<p>次にUIWebViewを拡張した<code>UIWebView+ProtocolConfirmed</code>クラスを作成します。<br/>
基本的にWKWebViewに合わせる形で実装していきます。</p>

<p>```objective-c
// UIWebView+ProtocolConfirmed.h</p>

<h1>import &lt;UIKit/UIKit.h></h1>

<h1>import &ldquo;WKWebViewProtocol.h&rdquo;</h1>

<p>@interface UIWebView(UIWebView_ProtocolConfirmed) <WKWebViewProtocol></p>

<p>@end</p>

<p>```</p>

<p>```objective-c
// UIWebView+ProtocolConfirmed.m</p>

<h1>import &ldquo;UIWebView+ProtocolConfirmed.h&rdquo;</h1>

<p>@implementation UIWebView(UIWebView_ProtocolConfirmed)</p>

<p>// NSURLの取得
&ndash; (NSURL *)URL
{</p>

<pre><code>NSString *URLString = [self stringByEvaluatingJavaScriptFromString:@"document.URL"];
return [NSURL URLWithString:URLString];
</code></pre>

<p>}</p>

<p>// ページのタイトルの取得
&ndash; (NSString *)title
{</p>

<pre><code> return [self stringByEvaluatingJavaScriptFromString:@"document.title"];
</code></pre>

<p>}</p>

<p>// JavaScriptの実行処理
&ndash; (void)evaluateJavaScript:(NSString <em>)javaScriptString completionHandler:(void (^)(id, NSError </em>))completionHandler
{</p>

<pre><code>NSString *result = [self stringByEvaluatingJavaScriptFromString:javaScriptString];
if(completionHandler) {
    completionHandler(result, nil);
}
</code></pre>

<p>}</p>

<p>```</p>

<p>最後にWKWebView側を実装します。<br/>
と言っても、UIWebViewをWKWebViewに合わせるので、何も書くことはありません。</p>

<p>```objective-c
// WKWebView+ProtocolConfirmed.h</p>

<h1>import &lt;WebKit/WebKit.h></h1>

<h1>import &ldquo;WKWebViewProtocol.h&rdquo;</h1>

<p>@interface WKWebView(WKWebView_ProtocolConfirmed) <WKWebViewProtocol></p>

<p>@end</p>

<p>```</p>

<p>```objective-c
// WKWebView+ProtocolConfirmed.m</p>

<h1>import &ldquo;WKWebView+ProtocolConfirmed.h&rdquo;</h1>

<p>@implementation WKWebView(WKWebView_ProtocolConfirmed)</p>

<p>@end</p>

<p>```</p>

<p>では、実際に実装していきましょう。<br/>
OAuth認証の処理に関しては、<a href="http://grandbig.github.io/blog/2015/06/01/custom-oauth/">OAuth2.0認証の処理を自作しよう！</a>を参考にしてください。</p>

<p>```objective-c
// ViewController.m</p>

<h1>import &ldquo;ViewController.h&rdquo;</h1>

<h1>import &ldquo;WKWebViewProtocol.h&rdquo;</h1>

<h1>import &ldquo;WKWebView+ProtocolConfirmed.h&rdquo;</h1>

<h1>import &ldquo;UIWebView+ProtocolConfirmed.h&rdquo;</h1>

<h1>import &ldquo;OAuth2Client.h&rdquo;</h1>

<p>static NSString <em>const clientId = @&ldquo;クライアントID&rdquo;;
static NSString </em>const clientSecret = @&ldquo;クライアントシークレット&rdquo;;
static NSString <em>const authorizationURL = @&ldquo;<a href="https://accounts.google.com/o/oauth2/auth">https://accounts.google.com/o/oauth2/auth</a>&rdquo;;
static NSString </em>const tokenURL = @&ldquo;<a href="https://accounts.google.com/o/oauth2/token">https://accounts.google.com/o/oauth2/token</a>&rdquo;;
static NSString *const scope = @&ldquo;<a href="https://www.googleapis.com/auth/plus.login+https://www.googleapis.com/auth/userinfo.email+https://www.googleapis.com/auth/calendar">https://www.googleapis.com/auth/plus.login+https://www.googleapis.com/auth/userinfo.email+https://www.googleapis.com/auth/calendar</a>&rdquo;;</p>

<p>// UIWebViewおよびWKWebView関連のDelegateを読み込む
@interface ViewController ()&lt;UIWebViewDelegate, WKUIDelegate, WKNavigationDelegate></p>

<p>// UIWebViewとWKWebViewを一纏めにしたWebViewとして下記を定義
@property(nonatomic, assign) id <WKWebViewProtocol> webView;
@property (strong, nonatomic) NSMutableData <em>receivedData;
@property (assign, nonatomic) BOOL </em>isLogin;</p>

<p>@end</p>

<p>@implementation ViewController</p>

<ul>
<li><p>(void)viewDidLoad {
  [super viewDidLoad];</p>

<p>  // WebViewを画面に追加する処理
  [self createWebView];</p>

<p>  NSUserDefaults <em>defaults = [NSUserDefaults standardUserDefaults];
  if([defaults boolForKey:@&ldquo;isLogin&rdquo;]) {
      // 既にOAuth2.0認証実行済みの場合
      [[OAuth2Client sharedInstance] getRefreshAccessToken:^(NSString </em>accessToken) {
          // 成功した場合
          NSLog(@&ldquo;%@&rdquo;, accessToken);
      } failure:^(NSError <em>error) {
          // 失敗した場合
          NSLog(@&ldquo;%@&rdquo;, error);
      }];
  } else {
      // 初めてOAuth2.0認証を実行する場合
      // OAuth2.0認証に必要な各種パラメータの設定
      [[OAuth2Client sharedInstance] setUpOAuth2AccountClientId:clientId clientSecret:clientSecret scope:scope authorizationURL:authorizationURL tokenURL:tokenURL];
      // OAuth2.0認証リクエスト
      [[OAuth2Client sharedInstance] requestAccessToAccount:^(NSURL </em>preparedURL) {
          // リクエスト
          [_webView loadRequest:[NSURLRequest requestWithURL: preparedURL]];
      }
  }</p></li>
</ul>


<p>}</p>

<ul>
<li>(void)didReceiveMemoryWarning {
  [super didReceiveMemoryWarning];
}</li>
</ul>


<p>// WKWebViewまたはUIWebViewをViewに追加する処理
&ndash; (void)createWebView {</p>

<pre><code>if(NSClassFromString(@"WKWebView") != nil) {
    // iOS8の場合
    WKWebView *wkWebView = [[WKWebView alloc] initWithFrame:self.view.bounds];
    wkWebView.navigationDelegate = self;
    wkWebView.UIDelegate = self;
    [self.view addSubview:wkWebView];
    self.webView = wkWebView;
} else {
    // iOS7以下の場合
    UIWebView *uiWebView = [[UIWebView alloc] initWithFrame:self.view.bounds];
    uiWebView.delegate = self;
    [self.view addSubview:uiWebView];
    self.webView = uiWebView;
}
</code></pre>

<p>}</p>

<h1>pragma mark &ndash; UIWebViewDelegate</h1>

<p>// ページの読込みが開始されたときに呼び出される処理
&ndash; (void)webViewDidStartLoad:(UIWebView *)webView {</p>

<pre><code>NSLog(@"webViewDidStartLoad");
</code></pre>

<p>}</p>

<p>// ページを読み終わった後に呼び出される処理
&ndash; (void)webViewDidFinishLoad:(UIWebView *)webView {</p>

<pre><code>NSLog(@"webViewDidFinishLoad");
</code></pre>

<p>}</p>

<p>// エラーが発生したときに呼び出される処理
&ndash; (void)webView:(UIWebView <em>)webView didFailLoadWithError:(NSError </em>)error {</p>

<pre><code>NSLog(@"didFailLoadWithError");
</code></pre>

<p>}</p>

<p>// ページ遷移する前に呼び出される処理
&ndash; (BOOL)webView:(UIWebView <em>)webView shouldStartLoadWithRequest:(NSURLRequest </em>)request navigationType:(UIWebViewNavigationType)navigationType {</p>

<pre><code>NSLog(@"shouldStartLoadWithRequest");

BOOL flag = [[OAuth2Client sharedInstance] checkRedirectURI:request];

if(flag) {
    [[OAuth2Client sharedInstance] getAccessToken:request completionHandler:^(NSString *accessToken){
        // 処理が終了したら呼び出される
        if(accessToken.length &gt; 0) {
            NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];
            [defaults setBool:YES forKey:@"isLogin"];
            [defaults synchronize];
        }
        [webView removeFromSuperview];
    }];

    // ページ遷移しない
    return NO;
}

// ページ遷移する
return YES;
</code></pre>

<p>}</p>

<h1>pragma mark &ndash; WKNavigationDelegate</h1>

<p>// ページの読込みが開始されたときに呼び出される処理
&ndash; (void)webView:(WKWebView <em>)webView didStartProvisionalNavigation:(WKNavigation </em>)navigation
{</p>

<pre><code>NSLog(@"didStartProvisionalNavigation");
</code></pre>

<p>}</p>

<p>// ページを読み終わった後に呼び出される処理
&ndash; (void)webView:(WKWebView <em>)webView didFinishNavigation:(WKNavigation </em>)navigation
{</p>

<pre><code>NSLog(@"didFinishNavigation");
</code></pre>

<p>}</p>

<p>// エラーが発生したときに呼び出される処理
&ndash; (void)webView:(WKWebView <em>)webView didFailProvisionalNavigation:(WKNavigation </em>)navigation withError:(NSError *)error
{</p>

<pre><code>NSLog(@"didFailProvisionalNavigation");
</code></pre>

<p>}</p>

<p>// ページ遷移する前に呼び出される処理
&ndash; (void)webView:(WKWebView <em>)webView decidePolicyForNavigationAction:(WKNavigationAction </em>)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler {</p>

<pre><code>NSLog(@"decidePolicyForNavigationAction");
NSURLRequest *request = navigationAction.request;

BOOL flag = [[OAuth2Client sharedInstance] checkRedirectURI:request];

if(flag) {
    [[OAuth2Client sharedInstance] getAccessToken:request completionHandler:^(NSString *accessToken){
        // 処理が終了したら呼び出される
        if(accessToken.length &gt; 0) {
            NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];
            [defaults setBool:YES forKey:@"isLogin"];
            [defaults synchronize];
        }
        [webView removeFromSuperview];
    }];

    // ページ遷移しない
    decisionHandler(WKNavigationActionPolicyCancel);
}

// ページ遷移する
decisionHandler(WKNavigationActionPolicyAllow);
</code></pre>

<p>}</p>

<p>@end</p>

<p>```</p>

<p>さあ、これでiOS8端末でもiOS7端末でも正しくOAuth認証画面が表示されるかと思います。<br/>
もう今年にはiOS9が発表され、WKWebViewが当然のようになってくるとしたら、UIWebViewは不要になると思いますが、今のところはまだまだ必要でしょう。<br/>
と言ったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OAuth2.0認証の処理を自作しよう！]]></title>
    <link href="http://grandbig.github.io/blog/2015/06/01/custom-oauth/"/>
    <updated>2015-06-01T00:56:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2015/06/01/custom-oauth</id>
    <content type="html"><![CDATA[<h4>OAuth2.0認証処理を自分で作ろう！ Objective-C編</h4>

<p>本日は、<a href="https://code.google.com/p/gtm-oauth2/">gtm-oauth</a>や<a href="https://github.com/nxtbgthng/OAuth2Client">OAuth2Client</a>を使わずにOAuth2.0認証処理を自作してみます。</p>

<p>OAuth2.0認証を通すためのGoogle設定は<a href="http://grandbig.github.io/blog/2014/07/13/ios-google-oauth2/">iOSでGoogle OAuth認証がしたい</a>を参照ください。<br/>
筆者が開発したライブラリは単純な下記処理のみ含んでいます。</p>

<ul>
<li>OAuth2.0認証に必要な各種パラメータをKeychain Servicesに保存</li>
<li>アクセストークンを取得する処理</li>
<li>リフレッシュトークンから新規アクセストークンを取得する処理</li>
</ul>


<p>ここで、Keychain Servicesを使うにあたって、<a href="https://github.com/TheLevelUp/LUKeychainAccess">LUKeychainAccess</a>を利用しています。<br/>
これにより、複雑なKeychain ServicesをNSUserDefaultsの感覚で利用することができます。<br/>
また、Googleへの問い合わせなどのHTTP/HTTPSリクエストに<a href="https://github.com/AFNetworking/AFNetworking">AFNetworking</a>を利用しています。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h4>OAuth2.0認証ライブラリの作成</h4>

<p>下記にソースをそのまま載せておきます。</p>

<p>```objective-c</p>

<p>// OAuth2Client.m</p>

<h1>import &ldquo;OAuth2Client.h&rdquo;</h1>

<h1>import &ldquo;LUKeychainAccess.h&rdquo;</h1>

<h1>import &ldquo;AFNetworking.h&rdquo;</h1>

<p>static NSString <em>callback =  @&ldquo;<a href="http://localhost">http://localhost</a>&rdquo;;
static NSString </em>visibleactions = @&ldquo;<a href="http://schemas.google.com/AddActivity">http://schemas.google.com/AddActivity</a>&rdquo;;</p>

<p>@implementation OAuth2Client</p>

<p>// シングルトンのインスタンス取得
+ (OAuth2Client *)sharedInstance {</p>

<pre><code>static OAuth2Client* sharedInstance = nil;
static dispatch_once_t onceToken;
dispatch_once(&amp;onceToken, ^{
    sharedInstance = [OAuth2Client alloc] init];]
});

return sharedInstance;
</code></pre>

<p>}</p>

<p>// OAuth2.0認証に必要なパラメータを設定する処理
&ndash; (void)setUpOAuth2AccountClientId:(NSString <em>)clientId clientSecret:(NSString </em>)clientSecret scope:(NSString <em>)scope authorizationURL:(NSString </em>)authorizationURL tokenURL:(NSString *)tokenURL {</p>

<pre><code>[[LUKeychainAccess standardKeychainAccess] setObject:clientId forKey:@"clientId"];
[[LUKeychainAccess standardKeychainAccess] setObject:clientSecret forKey:@"clientSecret"];
[[LUKeychainAccess standardKeychainAccess] setObject:scope forKey:@"scope"];
[[LUKeychainAccess standardKeychainAccess] setObject:authorizationURL forKey:@"authorizationURL"];
[[LUKeychainAccess standardKeychainAccess] setObject:tokenURL forKey:@"tokenURL"];
</code></pre>

<p>}</p>

<p>// OAuth2.0認証に必要なリクエストを生成する処理
&ndash; (void)requestAccessToAccount:(void (^)(NSURL *preparedURL))withPreparedAuthorizationURLHandler {</p>

<pre><code>NSString *clientId = [[LUKeychainAccess standardKeychainAccess] objectForKey:@"clientId"];
NSString *scope = [[LUKeychainAccess standardKeychainAccess] objectForKey:@"scope"];
NSString *authorizationURL = [[LUKeychainAccess standardKeychainAccess] objectForKey:@"authorizationURL"];

NSString *url = [[NSString stringWithFormat:@"%@?response_type=code&amp;client_id=%@&amp;redirect_uri=%@&amp;scope=%@&amp;data-requestvisibleactions=%@", authorizationURL, clientId, callback, scope, visibleactions];
withPreparedAuthorizationURLHandler([NSURL URLWithString:url]);
</code></pre>

<p>}</p>

<p>// OAuth2.0認証のリダイレクトURIの一致の有無を確認する処理
&ndash; (BOOL)checkRedirectURI:(NSURLRequest *)request
{</p>

<pre><code>// HOSTの取得
NSString *host = [[request URL] host];
if ([host isEqualToString:@"localhost"]) {
    return YES;
} else {
    return NO;
}
</code></pre>

<p>}</p>

<p>// アクセストークンを取得する処理
&ndash; (void)getAccessToken:(NSURLRequest <em>)request completionHandler:(void (^)(NSString </em>accessToken))completionHandler {</p>

<pre><code>NSString *host = [[request URL] host];
if ([host isEqualToString:@"localhost"]) {
    NSString* verifier = nil;
    NSArray* urlParams = [[request URL] query] componentsSeparatedByString:@"&amp;"];
    for (NSString* param in urlParams) {
        NSArray* keyValue = [param componentsSeparatedByString:@"="];
        NSString* key = [keyValue objectAtIndex:0];
        if ([key isEqualToString:@"code"]) {
            verifier = [keyValue objectAtIndex:1];
            break;
        }
    }

    if (verifier) {
        NSString *clientId = [[LUKeychainAccess standardKeychainAccess] objectForKey:@"clientId"];
        NSString *clientSecret = [[LUKeychainAccess standardKeychainAccess] objectForKey:@"clientSecret"];
        NSString *tokenURL = [[LUKeychainAccess standardKeychainAccess] objectForKey:@"tokenURL"];

        // AFHTTPSessionManagerをインスタンス化
        AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];
        // サーバエラー時のContent-Typeにtext/plainを許可(成功時にapplication/jsonが必要なので共に追加)
        manager.responseSerializer.acceptableContentTypes = [NSSet setWithObjects:@"text/plain", @"application/json", nil];
        // パラメータの設定
        NSDictionary *data = @{@"code": verifier, @"client_id": clientId, @"client_secret": clientSecret, @"redirect_uri": callback, @"grant_type": @"authorization_code"};

        [manager POST:tokenURL parameters:data success:^(NSURLSessionDataTask *task, id responseObject) {
            // 成功した場合
            if(responseObject &amp;&amp; [responseObject count] &gt; 0) {
                NSString *accessToken = responseObject[@"access_token"];
                NSString *refreshToken = responseObject[@"refresh_token"];
                [[LUKeychainAccess standardKeychainAccess] setObject:accessToken forKey:@"accessToken"];
                [[LUKeychainAccess standardKeychainAccess] setObject:refreshToken forKey:@"refreshToken"];

                // 処理が終了したときに実行(アクセストークンを返す)
                completionHandler(accessToken);
            }
        } failure:^(NSURLSessionDataTask *task, NSError *error) {
            // 失敗した場合
            NSError *err;
            NSData *data = [error userInfo] objectForKey:@"com.alamofire.serialization.response.error.data"];
            if(data) {
                // エラーの中身がある場合
                [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingAllowFragments error:&amp;err];
            }
            // 失敗を返す
            failure(err);
        }];
    }
} else {
    // HOST名が一致しない場合
}
</code></pre>

<p>}</p>

<p>// リフレッシュトークンから新しいアクセストークンを取得する処理
&ndash; (void)getRefreshAccessToken:(void (^)(NSString <em>accessToken))success failure:(void (^)(NSError </em>error))failure {</p>

<pre><code>NSString *clientId = [[LUKeychainAccess standardKeychainAccess] objectForKey:@"clientId"];
NSString *tokenURL = [[LUKeychainAccess standardKeychainAccess] objectForKey:@"tokenURL"];
NSString *refreshToken = [[LUKeychainAccess standardKeychainAccess] objectForKey:@"refreshToken"];

if(clientId &amp;&amp; tokenURL &amp;&amp; refreshToken) {
    // 必須パラメータがある場合
    // AFHTTPSessionManagerをインスタンス化
    AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];
    // サーバエラー時のContent-Typeにtext/plainを許可(成功時にapplication/jsonが必要なので共に追加)
    manager.responseSerializer.acceptableContentTypes = [NSSet setWithObjects:@"text/plain", @"application/json", nil];

    // パラメータの設定
    NSDictionary *data = @{@"client_id": clientId, @"refresh_token": refreshToken, @"grant_type": @"refresh_token"};

    [manager POST:tokenURL parameters:data success:^(NSURLSessionDataTask *task, id responseObject) {
        // 成功した場合
        if(responseObject &amp;&amp; [responseObject count] &gt; 0) {
            NSString *accessToken = responseObject[@"access_token"];
            NSString *refreshToken = responseObject[@"refresh_token"];
            [[LUKeychainAccess standardKeychainAccess] setObject:accessToken forKey:@"accessToken"];
            [[LUKeychainAccess standardKeychainAccess] setObject:refreshToken forKey:@"refreshToken"];

            // 処理が終了したときに実行(アクセストークンを返す)
            success(accessToken);
        }
    }, failure(NSURLSessionDataTask *task, NSError *error) {
        // 失敗した場合
        NSError *err;
        NSData *data = [error userInfo] objectForKey:@"com.alamofire.serialization.response.error.data"];
        if(data) {
            // エラーの中身がある場合
            [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingAllowFragments error:&amp;err];
        }
        // 失敗を返す
        failure(err);
    }];
} else {
    // 必須パラメータがない場合
    // TODO: エラーオブジェクトを生成して返す
    failure(nil);
}
</code></pre>

<p>}</p>

<p>@end</p>

<p>```</p>

<p>```objective-c</p>

<p>// OAuth2Client.h</p>

<h1>import &lt;Foundation/Foundation.h></h1>

<p>@interface OAuth2Client : NSObject</p>

<p>/// シングルトンのインスタンス取得
+ (OAuth2Client *)sharedInstance;</p>

<p>/<em><em>
 OAuth2.0認証に必要なパラメータを設定する処理
 @param clientId クライアントID
 @param clientSecret クライアントシークレット
 @param scope アクセス範囲
 @param authorizationURL OAuth2.0 認証先URL
 @param tokenURL OAuth2.0 トークン取得先URL
 </em>/
&ndash; (void)setUpOAuth2AccountClientId:(NSString </em>)clientId clientSecret:(NSString <em>)clientSecret scope:(NSString </em>)scope authorizationURL:(NSString <em>)authorizationURL tokenURL:(NSString </em>)tokenURL;</p>

<p>/<em><em>
 OAuth2.0認証に必要なリクエストを生成する処理
 @param withPreparedAuthorizationURLHandler OAuth2.0認証に必要なリクエストを返すBlock構文
 </em>/
&ndash; (void)requestAccessToAccount:(void (^)(NSURL </em>preparedURL))withPreparedAuthorizationURLHandler;</p>

<p>/<em><em>
 OAuth2.0認証のリダイレクトURIの一致の有無を確認する処理
 @param request リクエスト
 @return リダイレクトURIの一致の有無
 </em>/
&ndash; (BOOL)checkRedirectURI:(NSURLRequest </em>)request;</p>

<p>/<em><em>
 アクセストークンを取得する処理
 @param request アクセストークンの取得に必要なリクエスト
 @param completionHandler アクセストークンの取得処理が完了したら実行される処理
 </em>/
&ndash; (void)getAccessToken:(NSURLRequest </em>)request completionHandler:(void (^)(NSString *accessToken))completionHandler;</p>

<p>/<em><em>
 リフレッシュトークンから新しいアクセストークンを取得する処理
 @param success 処理が成功した場合に実行(返却データはアクセストークン)
 @param failure 処理が失敗した場合に実行(返却データはエラーオブジェクト)
 </em>/
&ndash; (void)getRefreshAccessToken:(void (^)(NSString </em>accessToken))success failure:(void (^)(NSError *error))failure;</p>

<p>```</p>

<h4>呼び出し側のソース</h4>

<p>呼び出し側のソースを記載します。</p>

<p>```objective-c</p>

<p>// ViewController.m</p>

<h1>import &ldquo;ViewController.h&rdquo;</h1>

<h1>import &ldquo;OAuth2Client.h&rdquo;</h1>

<p>static NSString <em>const clientId = @&ldquo;&rdquo;;
static NSString </em>const clientSecret = @&ldquo;&rdquo;;
static NSString <em>const authorizationURL = @&ldquo;<a href="https://accounts.google.com/o/oauth2/auth">https://accounts.google.com/o/oauth2/auth</a>&rdquo;;
static NSString </em>const tokenURL = @&ldquo;<a href="https://accounts.google.com/o/oauth2/token">https://accounts.google.com/o/oauth2/token</a>&rdquo;;
static NSString *const scope = @&ldquo;<a href="https://www.googleapis.com/auth/plus.login+https://www.googleapis.com/auth/userinfo.email+https://www.googleapis.com/auth/calendar">https://www.googleapis.com/auth/plus.login+https://www.googleapis.com/auth/userinfo.email+https://www.googleapis.com/auth/calendar</a>&rdquo;;</p>

<p>@interface ViewController ()<UIWebViewDelegate></p>

<p>@property (weak, nonatomic) IBOutlet UIWebView <em>webView;
@property (strong, nonatomic) NSMutableData </em>receivedData;
@property (assign, nonatomic) BOOL *isLogin;</p>

<p>@end</p>

<p>@implementation ViewController</p>

<ul>
<li><p>(void)viewDidLoad {
  [super viewDidLoad];</p>

<p>  <em>webView.delegate = self;
  NSUserDefaults <em>defaults = [NSUserDefaults standardUserDefaults];
  if([defaults boolForKey:@&ldquo;isLogin&rdquo;]) {
      // 既にOAuth2.0認証実行済みの場合
      [[OAuth2Client sharedInstance] getRefreshAccessToken:^(NSString </em>accessToken) {
          // 成功した場合
          NSLog(@&ldquo;%@&rdquo;, accessToken);
      } failure:^(NSError <em>error) {
          // 失敗した場合
          NSLog(@&ldquo;%@&rdquo;, error);
      }];
  } else {
      // 初めてOAuth2.0認証を実行する場合
      // OAuth2.0認証に必要な各種パラメータの設定
      [[OAuth2Client sharedInstance] setUpOAuth2AccountClientId:clientId clientSecret:clientSecret scope:scope authorizationURL:authorizationURL tokenURL:tokenURL];
      // OAuth2.0認証リクエスト
      [[OAuth2Client sharedInstance] requestAccessToAccount:^(NSURL </em>preparedURL) {
          // リクエスト
          [</em>webView loadRequest:[NSURLRequest requestWithURL: preparedURL]];
      }
  }
}</p></li>
<li><p>(void)didReceiveMemoryWarning {
  [super didReceiveMemoryWarning];
}</p></li>
<li><p>(BOOL)webView:(UIWebView <em>)webView shouldStartLoadWithRequest:(NSURLRequest </em>)request navigationType:(UIWebViewNavigationType)navigationType {</p>

<p>  if([OAuth2Client sharedInstance] checkRedirectURI:request]]) {
      [[OAuth2Client sharedInstance] getAccessToken:request completionHandler:^(NSString <em>accessToken){
          // 処理が終了したら呼び出される
          if(accessToken.length > 0) {
              NSUserDefaults </em>defaults = [NSUserDefaults standardUserDefaults];
              [defaults setBool:YES forKey:@&ldquo;isLogin&rdquo;];
              [defaults synchronize];
          }
          [webView removeFromSuperview];
      }];</p>

<pre><code>  return NO;
</code></pre>

<p>  }</p>

<p>  return YES;
}</p></li>
</ul>


<p>@end</p>

<p>```</p>

<p>これで簡単ですが、OAuth2.0認証の自作ライブラリの開発が完了です。<br/>
必要最低限の機能ですが、十分だと思います。<br/>
(もう少し時間をかけてより良いものを作りたいと思います笑。)</p>

<p>参考:</p>

<ul>
<li><a href="http://technogerms.com/login-with-google-using-oauth-2-0-for-ios-xcode-objective-c/">Login with Google using OAuth 2.0 for iOS Xcode Objective-C</a></li>
<li><a href="http://www.ari-hiro.com/blog/2012/12/30/oauth2-summary">OAuth2.0の備忘録的まとめ</a></li>
<li><a href="http://qiita.com/asakahara/items/06abbc0209262d0051ef">iOSでアプリを削除してもデータを保持する方法</a></li>
</ul>


<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift AFNetworkingライブラリを使ってみよう！]]></title>
    <link href="http://grandbig.github.io/blog/2015/05/24/swift-afnetworking/"/>
    <updated>2015-05-24T10:53:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2015/05/24/swift-afnetworking</id>
    <content type="html"><![CDATA[<h4>通信系ライブラリAFNetworkingの使い方を覚えよう！</h4>

<p>さて、本日はObjective-Cの超有名通信系ライブラリの<a href="https://github.com/AFNetworking/AFNetworking">AFNetworking</a>をSwiftで使ってみようと思います。</p>

<h5>導入の仕方</h5>

<p>まずは導入の仕方を見て行きましょう。<br/>
CocoaPodsを使います。<br/>
Podfileを作成し、下記の内容を記載しましょう。</p>

<p><code>objective-c
platform :ios, '7.0'
pod "AFNetworking", "~&gt; 2.0"
</code></p>

<p>これで<code>pod install</code>すればプロジェクトに <strong>AFNetworking</strong> が追加されるはずです。<br/>
ここで注意したいのが、あくまでもObjective-Cで書かれたライブラリなので、Swiftで使うためにはBridgeファイルを用意する必要があります。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<ol>
<li>プロジェクトにヘッダーファイルを追加します。
ProjectName-Bridging-Header.hという形式が推奨されている模様<br/>
今回はSwiftSample-Bridging-Header.hという名前で追加しました。</li>
<li>TARGETS > SwiftSample > Build Settings > Swift Compiler &ndash; Code Generation > Objective-C Bridging Headerにパスを指定
SwiftSample/SwiftSample-Bridging-Header.hを指定しました。</li>
<li>Bridgeファイルにライブラリを<code>import</code>する</li>
<li>ライブラリを利用するファイルにも<code>import</code>を書きましょう(Swiftの書き方で。)</li>
</ol>


<p>下記の画像を参照ください。
<img src="/images/swift-afnetworking.png" alt="Bridgeファイルの用意" /></p>

<p>また、Bridgeファイルへの具体的な内容を書いておきます。</p>

<p>```objective-c</p>

<h1>ifndef SwiftSample_SwiftSample_Bridging_Header_h</h1>

<h1>define SwiftSample_SwiftSample_Bridging_Header_h</h1>

<h1>endif</h1>

<h1>import &lt;AFNetworking/AFNetworking.h></h1>

<p>```</p>

<h5>GETリクエスト</h5>

<p>では、早速、GETリクエストを書いてみましょう。<br/>
以前の<a href="http://grandbig.github.io/blog/2015/02/12/afnetworking/">AFNetworking2.xでWeb-APIを叩いてみた！</a>でも利用した <strong>OpenWeatherMap API</strong> を例として使います。</p>

<p><code>http://api.openweathermap.org/data/2.5/weather?q=Tokyo,jp</code>でリクエストして、<br/>
下記のデータを返してもらうことを想定しています。</p>

<p>```objective-c</p>

<p>{</p>

<pre><code>base:  "stations",
clouds: {
    all: 32
},
cod: 200,
coord: {
    lat: 35.69,
    lon: 139.65
},
dt: 1432394992,
id: 1850147,
main: {
    grnd_level: 1019.97,
    humidity: 88,
    pressure: 1019.97,
    sea_level: 1024.92,
    temp: 290.99,
    temp_max: 290.99,
    temp_min: 290.99
},
name: Tokyo,
sys: {
    country: "JP",
    message: 0.0386,
    sunrise: 1432323041,
    sunset: 1432374314
},
weather: [
    {
        description: "scattered clouds",
        icon: "03n",
        id: 802,
        main: "Clouds"
    }
],
wind: {
    deg: 198.001,
    speed: 5.11
}
</code></pre>

<p>}</p>

<p>```</p>

<p>では、GETリクエストを投げてみましょう。<br/>
返却されたデータの取得方法についても記載します。</p>

<p>```objective-c
// GETリクエスト
let manager = AFHTTPSessionManager()
manager.GET(&ldquo;<a href="http://api.openweathermap.org/data/2.5/weather?q=Tokyo,jp">http://api.openweathermap.org/data/2.5/weather?q=Tokyo,jp</a>&rdquo;, parameters: nil,</p>

<pre><code>success: { (operation, json) -&gt; Void in
    // 処理が成功した場合
    let dict = json as! [String: AnyObject]
    let weatherArray = dict["weather"] as! [AnyObject]
    let weather = weatherArray[0] as! [String: AnyObject]
    let description = weather["description"] as! String
    println(description)
}, failure: { (operation, error) -&gt; Void in
    // エラーが発生した場合
})
</code></pre>

<p>```</p>

<p>Objective-Cでは下記のように書いていたので、対応づけて見るとわかりやすいかもしれません。</p>

<p>```objective-c
AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];
[manager.GET:@&ldquo;<a href="http://api.openweathermap.org/data/2.5/weather?q=Tokyo,jp">http://api.openweathermap.org/data/2.5/weather?q=Tokyo,jp</a>&rdquo;, parameters: nil,</p>

<pre><code>success:^(NSURLSessionDataTask *task, id responseObject) {
    NSArray *weatherArray = [responseObject objectForKey:@"weather"];
    NSDictionary *weather = [weatherArray objectAtIndex:0];
    NSString *description = [weather objectForKey:@"description"];
    NSLog(description);
}, failure:^(NSURLSessionDataTask *task, NSError *error) {
    // エラーが発生した場合
}];
</code></pre>

<p>```</p>

<p><code>success</code>と<code>failure</code>は戻り値が<code>void</code>なので、Swiftでも<code>-&gt; Void</code>と指定しています。<br/>
<code>[String: AnyObject]</code>は <strong>keyがString型</strong> で <strong>valueがAnyObject(何でもあり)型</strong> のDictionary型への変換で、<br/>
<code>[AnyObject]</code>は <strong>要素がAnyObject(何でもあり)型</strong> のArray型への変換です。</p>

<p>Alamofireとはやはり違った書き方となるので、iOSのターゲットなど要件に従って使い分けていくのが良いでしょう。<br/>
と言ったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift Alamofireライブラリを使ってみよう！]]></title>
    <link href="http://grandbig.github.io/blog/2015/05/24/swift-alamofire1/"/>
    <updated>2015-05-24T00:40:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2015/05/24/swift-alamofire1</id>
    <content type="html"><![CDATA[<h4>通信系ライブラリAlamofireの使い方を覚えよう！</h4>

<p>さて、本日は <strong>Alamofire</strong> ライブラリの使い方を勉強します。<br/>
<a href="https://github.com/Alamofire/Alamofire">Alamofire</a>はObjective-Cの超有名通信系ライブラリである<a href="https://github.com/AFNetworking/AFNetworking">AFNetworking</a>のSwift版と思えばよいでしょう。</p>

<h5>導入の仕方</h5>

<p>まずは導入の仕方から見て行きましょう。<br/>
CocoaPodsを使います。<br/>
Podfileを作成し、下記の内容を記載しましょう。</p>

<p>```objective-c
source &lsquo;<a href="https://github.com/CocoaPods/Specs.git">https://github.com/CocoaPods/Specs.git</a>&rsquo;
platform :ios, &lsquo;8.0&rsquo;
use_frameworks!</p>

<p>pod &lsquo;Alamofire&rsquo;, &lsquo;~> 1.2&rsquo;
```</p>

<p>これで<code>pod install</code>すればプロジェクトにAlamofireが追加されるはずです！<br/>
後は利用したいswiftファイルで<code>import Alamofire</code>しましょう。<br/>
SwiftライブラリをCocoaPodsでインストールすると対象iOSが8.0以上である必要が出てくるので、そこだけ注意しましょう。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h5>GETリクエスト(パターン１)</h5>

<p>続いて、GETリクエストのメソッドを書いてみます。<br/>
以前の<a href="http://grandbig.github.io/blog/2015/02/12/afnetworking/">AFNetworking2.xでWeb-APIを叩いてみた！</a>でも利用した <strong>OpenWeatherMap API</strong> を例として使います。</p>

<p><code>http://api.openweathermap.org/data/2.5/weather?q=Tokyo,jp</code>でリクエストして、<br/>
下記のデータを返してもらうことを想定しています。</p>

<p>```objective-c</p>

<p>{</p>

<pre><code>base:  "stations",
clouds: {
    all: 32
},
cod: 200,
coord: {
    lat: 35.69,
    lon: 139.65
},
dt: 1432394992,
id: 1850147,
main: {
    grnd_level: 1019.97,
    humidity: 88,
    pressure: 1019.97,
    sea_level: 1024.92,
    temp: 290.99,
    temp_max: 290.99,
    temp_min: 290.99
},
name: Tokyo,
sys: {
    country: "JP",
    message: 0.0386,
    sunrise: 1432323041,
    sunset: 1432374314
},
weather: [
    {
        description: "scattered clouds",
        icon: "03n",
        id: 802,
        main: "Clouds"
    }
],
wind: {
    deg: 198.001,
    speed: 5.11
}
</code></pre>

<p>}</p>

<p>```</p>

<p>では、GETリクエストを投げてみましょう。<br/>
返却されたデータの取得方法についても記載します。<br/>
幾つか書き方があるのですが、まずは１つ目の書き方です。</p>

<p>```objective-c
// GETリクエスト
Alamofire.request(.GET, &ldquo;<a href="http://api.openweathermap.org/data/2.5/weather">http://api.openweathermap.org/data/2.5/weather</a>&rdquo;, parameters:[&ldquo;q&rdquo;:&ldquo;Tokyo,jp&rdquo;]).response { (request, response, data, error) in</p>

<pre><code>if let data = data as? NSData {
    // AnyObject型をNSData型に変換できた場合に通過
    // NSData型をJSONの形に変換して、AnyObject?型の変数に格納
    var obj: AnyObject? = NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions.AllowFragments, error: nil)

    if let weatherArray = obj["weather"] as? [AnyObject] {
        // objからweatherフィールドを取得。その際、Array型に変換できた場合に通過
        if let weather = weatherArray[0] as? [String: AnyObject] {
            // NSArray型のweatherArrayから要素0番目を取得。その際、Dictionary型に変換できた場合に通過
            if let description = weather["description"] as? String {
                // NSDictionary型のweatherからdescriptionフィールドを取得。その際、String型に変換できた場合に通過
                println(description)
            }

            // NSDictionary型のweatherからdescriptionを指定して取得
            var description2:String? = weather["description"] as? String
            println(description2)
        }
    }
}
</code></pre>

<p>}
```</p>

<p>注意したいのは、responseで返却される<code>data</code>は <strong>NSData型</strong> ではなく、 <strong>AnyObject?型</strong> だということです。<br/>
そのため、直接<code>NSJSONSerialization.JSONObjectWithData</code>の１つ目の引数に<code>data</code>を指定するとNSData型ではないことを示唆するエラーが出ます。<br/>
なので、 <strong>NSData型</strong> に変換する必要があります。</p>

<p>そして、NSData型のままでは各要素を取り出せないので、 <strong>(JSONの形をした)AnyObject?型</strong> に変換させましょう。<br/>
(Dictionary型に変換しても良いのですが、既にJSONの形に変換されているので十分でしょう。)<br/>
後は各フィールドの型に従って変換して取り出していくイメージで書きましょう。</p>

<p>覚えておきたいのは、</p>

<p>```objective-c
if let 定数名 = 要素 as? 定数の型 {</p>

<pre><code>// 指定した定数の型に変換できた場合に、この中を通過する(変換できなかった場合はnilを入れようとするので、この中を通過しない)
</code></pre>

<p>}
```</p>

<p>という変換の書き方です。<br/>
Swiftの場合、JSONの取り扱いで思った以上にコードが長くなり、ネスト化してしまいます。<br/>
それを防ぐため&amp;JavaScriptのような書き方を意識したライブラリがたくさん出ています。<br/>
近いうち使ってみようと思います。</p>

<p>また、変換時に<code>[AnyObject]</code>や<code>[String: AnyObject]</code>と書いているのは、<br/>
前者が<code>Array型</code>に変換していて、後者は<code>Dictionary型</code>に変換しています。<br/>
Swiftではどんな要素を含むArray型なのかを示し、どんなkeyでどんなvalueなのかをDictionary型として明示的に示す必要があります。</p>

<p>もし、Objective-Cの<code>NSArray型</code>や<code>NSDictionary型</code>に変換する場合は中身の形式を考えずに<code>as</code>の後ろに続けて書けばOKです。</p>

<h5>GETリクエスト(パターン２)</h5>

<p>とは言え、少しネストが深いので、別のresoponse形式のパターンで試してみましょう。</p>

<p>```objective-c
// GETリクエスト
Alamofire.request(.GET, &ldquo;<a href="http://api.openweathermap.org/data/2.5/weather?q=Tokyo,jp">http://api.openweathermap.org/data/2.5/weather?q=Tokyo,jp</a>&rdquo;).responseJSON { (<em>, </em>, JSON, _) in</p>

<pre><code>if let weatherArray = JSON!["weather"] as? [AnyObject] {
    // JSONからweatherフィールドを取得。その際、Array型に変換できた場合に通過
    if let weather = weatherArray[0] as? [String: AnyObject] {
        // NSArray型のweatherArrayから要素0番目を取得。その際、Dictionary型に変換できた場合に通過
        if let description = weather["description"] as? String {
            // NSDictionary型のweatherからdescriptionフィールドを取得。その際、String型に変換できた場合に通過
            println(description)
        }

        // NSDictionary型のweatherからdescriptionを指定して取得
        var description2:String? = weather["description"] as? String
        println(description2)
    }
}
</code></pre>

<p>}
```</p>

<p>これは、レスポンスメソッドに<code>responseJSON</code>を指定することで、<br/>
1つ目に上げた<code>AnyObject?型 ⇒ NSData型</code>への変換と<code>NSData型 ⇒ JSONの形をしたAnyObject?型</code>への変換は不要となります。<br/>
既に<code>responseJSON</code>の中でやってくれています。<br/>
少しネストが浅くなりましたね！</p>

<h5>GETリクエスト(パターン３)</h5>

<p>まだ、ネストが深いって？<br/>
よし！思い切ってネストをなくしましょう！</p>

<p>```objective-c
// GETリクエスト
Alamofire.request(.GET, &ldquo;<a href="http://api.openweathermap.org/data/2.5/weather?q=Tokyo,jp">http://api.openweathermap.org/data/2.5/weather?q=Tokyo,jp</a>&rdquo;).response { (request, response, data, error) in</p>

<pre><code>// AnyObject?型をNSData型に変換。さらにJSONの形をしたNSDictionary型に変換。
let json = NSJSONSerialization.JSONObjectWithData(data as! NSData, options: NSJSONReadingOptions.MutableContainers, error: nil) as! [String: AnyObject]
let weatherArray = json["weather"] as! [AnyObject]
let weather = weatherArray[0] as! [String: AnyObject]
let description = weather["description"] as! String
println(description)
</code></pre>

<p>}
```</p>

<p>う〜ん。ネストは確かになくなったのですが、Unwrapの手法を <strong>Implicitly Unwrapped Optional</strong> にしたため、nilが発生した段階でエラーが発生して落ちます&hellip;。<br/>
値がない場合には空オブジェクトを返すAPIである場合には問題ないと思います。</p>

<p>だんだんとSwiftの基礎含めて理解が進んできた気がします。<br/>
と言ったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swiftの基礎を理解しよう！(2)]]></title>
    <link href="http://grandbig.github.io/blog/2015/05/17/swift-base-2/"/>
    <updated>2015-05-17T17:48:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2015/05/17/swift-base-2</id>
    <content type="html"><![CDATA[<h4>Swiftの型</h4>

<p>続いて、基本的な内容を見ていきます。<br/>
SwiftはObjective-Cと型の表現が変わりました。<br/>
よく使う型を見て行きましょう。</p>

<p>```objective-c</p>

<p>var intValue:Int = 3
var doubleValue:Double = 1.234
var floatValue:Float = 5.678
var boolValue:Bool = true
var stringValue:String = &ldquo;abcdefg&rdquo;
var charValue:Character = &ldquo;a&rdquo;
var intArray = [1, 30, 120, 6]
var stringArray = [&ldquo;abc&rdquo;, &ldquo;123&rdquo;]
var testDictionary = [&ldquo;job&rdquo;: &ldquo;programmer&rdquo;, &ldquo;skillNum&rdquo;: 5]</p>

<p>```</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<p>因みにこれをObjective-Cで書くと</p>

<p>```objective-c</p>

<p>NSInteger intValue = 3;
CGFloat doubleValue = 1.234;
CGFloat floatValue = 5.678;
BOOL boolValue = YES;
NSString <em>stringValue = @&ldquo;abcdefg&rdquo;;
char charValue = &ldquo;a&rdquo;
NSArray </em>intArray = @[1, 30, 120, 6];
NSArray <em>stringArray = @[@&ldquo;abc&rdquo;, @&ldquo;123&rdquo;];
NSDictionary </em>testDictionary = @{@&ldquo;job&rdquo;: @&ldquo;programmer&rdquo;, @&ldquo;skillNum&rdquo;: @5};</p>

<p>```</p>

<p>CGFloatで定義された<code>doubleValue</code>と<code>floatValue</code>は<code>double</code>, <code>float</code>をそれぞれ書くこともできます。<br/>
(ここは32bit, 64bit問題のため、安全側に倒すために<code>CGFloat</code>に統一して書いています。)</p>

<h4>Swiftでクラスを作成</h4>

<p>さて、新たにSwiftファイルを追加して、カスタムクラスを実装してみましょう。<br/>
まずは、Objective-Cと同様で、左メニューのフォルダを右クリックして、『New File』を選択します。</p>

<p><img src="/images/swift_add_new_class.png" alt="New File" /></p>

<p>そして、iOS > Source > Swift Fileを選択します。</p>

<p><img src="/images/choose_swift_file.png" alt="Add Swift File" /></p>

<p>Objective-Cと違って、どのクラスを継承するか否かを決めるフェーズはありません。<br/>
ファイル名と保存場所を決めるのみです。</p>

<p><img src="/images/create_swift_file.png" alt="Save Swift File" /></p>

<p>作成されるファイルの内容は下記になります。</p>

<p>```objective-c</p>

<p>import Foundation</p>

<p>```</p>

<p>ここにカスタムクラスを実装していきましょう。<br/>
例えば下記のようなクラスを作ります。</p>

<p>```objective-c</p>

<p>class Engineer:NSObject {</p>

<pre><code>// プロパティの定義
var level:Int = 1
var businessTitle:String = "新米エンジニア"
var skill:Array&lt;String&gt; = ["Swift"]

// メソッドの定義
// レベルアップ処理
func levelUp() -&gt;Int {
    return level++
}

// 新規スキルをセットする処理
func addNewSkills(newSkill:String) {
    skill.append(newSkill)
}

// 新たな肩書をセットする処理
func updateBusinessTitle(title:String) {
    businessTitle = title
}
</code></pre>

<p>}</p>

<p>```</p>

<p>上記のクラスでは <strong>NSObject</strong> クラスを継承しています。逆に言えばEngineerクラスのスーパークラスは <strong>NSObject</strong> クラスということです。<br/>
Engineerクラスには<code>level</code>, <code>businessTitle</code>, <code>skill</code>という3つのプロパティを定義しています。(全てに初期値を与えています。)<br/>
また、<code>levelUp()</code>, <code>addNewSkills(newSkill:String)</code>, <code>updateBusinessTitle(title:String)</code>の3つのクラス・メソッドを定義しています。</p>

<p>では、実際にカスタムクラスを使ってみましょう。</p>

<p>```objective-c
// 呼び出す側のswiftファイル(ViewController.swift)</p>

<p>import UIKit</p>

<p>class ViewController: UIViewController {</p>

<pre><code>override func viewDidLoad() {
    super.viewDidLoad()

    // カスタムクラスの初期化
    var engineer:Engineer = Engineer()
    // プロパティの初期値をログ出力
    println("Engineer level : \(engineer.level), businessTitle : \(engineer.businessTitle), skill : \(engineer.skill)")

    // 各メソッドを実行
    engineer.levelUp()
    engineer.addNewSkills("Objective-C")
    engineer.updateBusinessTitle("iOSアプリエンジニア")
    // プロパティをログに再出力
    println("Engineer level : \(engineer.level), businessTitle : \(engineer.businessTitle), skill : \(engineer.skill)")
}

&lt;省略&gt;
</code></pre>

<p>}</p>

<p>```</p>

<p>ここで気になるのが、自作したクラスを使うときに<code>import</code>をしていないという点です。<br/>
同プロジェクト内のクラスは<code>import</code>の必要がないということらしいです。<br/>
なので、自作したクラスをCocoaPodでインストールした場合は<code>import</code>の必要があると思われます。</p>

<p>基本的なところで微妙にObjective-Cと異なる部分があるので注意が必要ですね。<br/>
と言ったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
</feed>
