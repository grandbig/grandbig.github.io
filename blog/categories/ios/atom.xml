<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ios | Takahiro Octopress Blog]]></title>
  <link href="http://grandbig.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://grandbig.github.io/"/>
  <updated>2015-04-05T02:27:08+09:00</updated>
  <id>http://grandbig.github.io/</id>
  <author>
    <name><![CDATA[Takahiro]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Objective-Cにおける継承とカテゴリ]]></title>
    <link href="http://grandbig.github.io/blog/2015/04/05/inheritance-and-expansion/"/>
    <updated>2015-04-05T01:10:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2015/04/05/inheritance-and-expansion</id>
    <content type="html"><![CDATA[<h4>Objective-Cの継承とカテゴリについて</h4>

<p>さて、本日は今更ですが、Objective-Cの継承とカテゴリについて書きたいと思います。<br/>
理由は、最近、自分だけではなく、 <strong>『第三者が見てもわかりやすいクラス』</strong> を作ることを意識し始めたからです。<br/>
本当に今更ですね笑。</p>

<p>アジェンダは下記です。</p>

<ul>
<li>Objective-Cの継承</li>
<li>Objective-Cのカテゴリ</li>
<li>シングルトンパターンでの継承</li>
<li>シングルトンパターンのクラスを継承したクラスのカテゴリ</li>
</ul>


<p>では、早速見て行きましょう。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h4>Objective-Cの継承</h4>

<p>まずは、継承です。<br/>
初めに元となるクラスを作成します。</p>

<p>```objective-c
// SampleClass.h</p>

<h1>import &lt;Foundation/Foundation.h></h1>

<p>@interface SampleClass : NSObject</p>

<p>@property(strong, nonatomic) NSString *sampleProperty;</p>

<ul>
<li>(void)sampleMethod;</li>
</ul>


<p>@end
```</p>

<p>```objective-c
// SampleClass.m</p>

<h1>import &ldquo;SampleClass.h&rdquo;</h1>

<p>@implementation SampleClass</p>

<ul>
<li><p>(id)init
{
  self = [super init];</p>

<p>  if(self) {
      self.sampleProperty = @&ldquo;これはsamplePropertyです&rdquo;;
  }</p>

<p>  return self;
}</p></li>
<li><p>(void)sampleMethod
{
  NSLog(@&ldquo;sampleMethodを実行しました&rdquo;);
}</p></li>
</ul>


<p>@end
```</p>

<p>このSampleClassを継承したクラスを作成します。</p>

<p>```objective-c
// SampleClass2.h</p>

<h1>import &ldquo;SampleClass.h&rdquo;</h1>

<p>@interface SampleClass2 : SampleClass</p>

<p>@property(strong, nonatomic) NSString *sample2Property;</p>

<ul>
<li>(void)sample2Method;</li>
</ul>


<p>@end
```</p>

<p>```objective-c
// SampleClass2.m</p>

<h1>import &ldquo;SampleClass2.h&rdquo;</h1>

<p>@implementation SampleClass2</p>

<ul>
<li>(void)sample2Method
{
  [self sampleMethod];
}</li>
</ul>


<p>@end
```</p>

<p>このようにSampleClass2はSampleClassを継承しているので、sampleMethodを利用することができます。<br/>
このクラスをViewControllerで使う場合は下記のようにできます。</p>

<p>```objective-c
// ViewController.m</p>

<h1>import &ldquo;SampleClass2.h&rdquo;</h1>

<p>@interface ViewController ()</p>

<p>@end</p>

<p>@implementation ViewController</p>

<ul>
<li><p>(void)viewDidLoad {
  [super viewDidLoad];
  [self testMethod];
}</p></li>
<li><p>(void)testMethod {
  // SampleClass2の初期化
  SampleClass2 *sample2 = [[SampleClass2 alloc] init];
  // SampleClass2で定義されたsample2Methodを実行
  [sample2 sample2Method];
  // スーパークラスであるSampleClassのsampleMethodを実行
  [sample2 sampleMethod];
}</p></li>
</ul>


<p>@end
```</p>

<p>元々あったクラスに新たなプロパティやメソッドを追加したクラスを作成した場合はこのようにやれば良いわけです。</p>

<h4>Objective-Cのカテゴリ</h4>

<p>続いて、カテゴリです。</p>

<p>SampleClassのカテゴリクラスを作成します。</p>

<p>```objective-c
// SampleClass3.h</p>

<h1>import &ldquo;SampleClass.h&rdquo;</h1>

<p>@interface SampleClass(SampleClass3)</p>

<ul>
<li>(void)sample3Method;</li>
</ul>


<p>@end
```</p>

<p>```objective-c
// SampleClass3.m</p>

<h1>import &ldquo;SampleClass3.h&rdquo;</h1>

<p>@implementation SampleClass(SampleClass3)</p>

<ul>
<li>(void)sample3Method
{
  return [self sampleMethod];
}</li>
</ul>


<p>@end
```</p>

<p>上記を見ると、継承と何が違うの？と思われるかもしれません。<br/>
実はカテゴリでは継承のようにプロパティの定義ができません。<br/>
基本的に元のクラスに新しいメソッドを追加したいときに使うもののようです。<br/>
<a href="http://ja.wikipedia.org/wiki/Objective-C">Wikipedia</a>にも書いてある通り、『ひとつのクラスの実装を関連するメソッド群毎に別々の場所に分割して記述することを可能とする目的で作られた』だそうです。</p>

<p>しかしながら、厳密にはプロパティも追加できます。<br/>
追加したい場合は下記のようにします。</p>

<p>```objective-c
// SampleClass3.h</p>

<h1>import &ldquo;SampleClass.h&rdquo;</h1>

<p>@interface SampleClass(SampleClass3)</p>

<p>// ここを追加
@property(strong, nonatomic) NSString *sample3Property;</p>

<ul>
<li>(void)sample3Method;</li>
</ul>


<p>@end
```</p>

<p>```objective-c
// SampleClass3.m</p>

<h1>import &ldquo;SampleClass3.h&rdquo;</h1>

<p>// ここを追加</p>

<h1>import &lt;objc/runtime.h></h1>

<p>@implementation SampleClass(SampleClass3)</p>

<p>// ここを追加
@dynamic sample3Property;</p>

<p>// ここを追加
&ndash; (void)setValue:(NSString*)sample3Property
{</p>

<pre><code>objc_setAssociatedObject(self, _cmd, sample3Property, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
</code></pre>

<p>}</p>

<ul>
<li>(void)sample3Method
{
  return [self sampleMethod];
}</li>
</ul>


<p>@end
```</p>

<p>では、このカテゴリクラスをViewControllerで使ってみましょう。</p>

<p>```objective-c
// ViewController.m</p>

<h1>import &ldquo;SampleClass.h&rdquo;</h1>

<p>@interface ViewController ()</p>

<p>@end</p>

<p>@implementation ViewController</p>

<ul>
<li><p>(void)viewDidLoad {
  [super viewDidLoad];
  [self testMethod];
}</p></li>
<li><p>(void)testMethod {
  // SampleClassの初期化
  SampleClass *sample = [[SampleClass alloc] init];
  // SampleClassで定義されたsampleMethodを実行
  [sample sampleMethod];
  // SampleClass3のsample3Methodを実行
  [sample sample3Method];
}</p></li>
</ul>


<p>@end
```</p>

<p>カテゴリは <strong>元のクラスに定義を追加した</strong> ものなので、上記ソースのように初期化するオブジェクトはあくまでも <strong>SampleClass</strong> であることに注意しましょう。</p>

<h4>シングルトンパターンでの継承</h4>

<p>シングルトンパターンでは、少し注意が必要です。<br/>
元のクラスをシングルトンパターンにしましょう。</p>

<p>```objective-c
// SampleClass.h</p>

<h1>import &lt;Foundation/Foundation.h></h1>

<p>@interface SampleClass : NSObject</p>

<p>@property(strong, nonatomic) NSString *sampleProperty;</p>

<p>// シングルトンのインスタンス取得
+ (SampleClass *)sharedInstance;</p>

<ul>
<li>(void)sampleMethod;</li>
</ul>


<p>@end
```</p>

<p>```objective-c
// SampleClass.m</p>

<h1>import &ldquo;SampleClass.h&rdquo;</h1>

<p>@implementation SampleClass</p>

<p>// シングルトンのインスタンス取得
+ (SampleClass *)sharedInstance
{</p>

<pre><code>static SampleClass* sharedInstance = nil;
static dispatch_once_t onceToken;
dispatch_once(&amp;onceToken, ^{
    sharedInstance = [[SampleClass alloc] init];
});

return sharedInstance;
</code></pre>

<p>}</p>

<ul>
<li><p>(id)init
{
  self = [super init];</p>

<p>  if(self) {
      self.sampleProperty = @&ldquo;これはsamplePropertyです&rdquo;;
  }</p>

<p>  return self;
}</p></li>
<li><p>(void)sampleMethod
{
  NSLog(@&ldquo;sampleMethodを実行しました&rdquo;);
}</p></li>
</ul>


<p>@end
```</p>

<p>SampleClassをシングルトンパターンにした上で、継承したSample2ClassをViewControllerで使ってみましょう。</p>

<p>```
// ViewController.m</p>

<h1>import &ldquo;SampleClass2.h&rdquo;</h1>

<p>@interface ViewController ()</p>

<p>@end</p>

<p>@implementation ViewController</p>

<ul>
<li><p>(void)viewDidLoad {
  [super viewDidLoad];
  [self testMethod];
}</p></li>
<li><p>(void)testMethod {
  // SampleClassで定義されたsampleMethodを実行
  [[SampleClass2 sharedInstance] sampleMethod];
  // SampleClass2で定義されたsample2Methodを実行
  [[SampleClass2 sharedInstance] sample2Method];
}</p></li>
</ul>


<p>@end
```</p>

<p>実はこれだとうまくいきません。<br/>
どこがうまくいかないかというと、 <strong>SampleClass2で定義されたsample2Methodの実行</strong> の部分です。<br/>
これは <strong>SampleClassにsample2Methodは定義されていません</strong> といったエラーが表示されます。<br/>
そう、初期化されたのはあくまでもSampleClassであって、SampleClass2ではないため、上記のようなエラーが出るのです。</p>

<p>このエラーを防ぐためには、SampleClass2を下記のように定義します。</p>

<p>```objective-c
// SampleClass2.h</p>

<h1>import &ldquo;SampleClass.h&rdquo;</h1>

<p>@interface SampleClass2 : SampleClass</p>

<p>@property(strong, nonatomic) NSString *sample2Property;</p>

<p>+(SampleClass2 *)sharedInstance;</p>

<ul>
<li>(void)sample2Method;</li>
</ul>


<p>@end
```</p>

<p>```objective-c
// SampleClass2.m</p>

<h1>import &ldquo;SampleClass2.h&rdquo;</h1>

<p>@implementation SampleClass2</p>

<p>// シングルトンのインスタンス取得
+ (SampleClass2 *)sharedInstance
{</p>

<pre><code>static SampleClass2* sharedInstance = nil;
static dispatch_once_t onceToken;
dispatch_once(&amp;onceToken, ^{
    sharedInstance = [[SampleClass2 alloc] init];
});

return sharedInstance;
</code></pre>

<p>}</p>

<ul>
<li>(void)sample2Method
{
  [self sampleMethod];
}</li>
</ul>


<p>@end
```</p>

<p>はい。当たり前ですね。<br/>
正しく理解していないと悩むことになるのでご注意を！</p>

<h4>シングルトンパターンのクラスを継承したクラスのカテゴリ</h4>

<p>最後にややこしいことをしてみましょう笑。<br/>
先ほどのシングルトンパターンのクラスであるSampleClassを継承したSampleClass2のカテゴリであるSampleClass4を作成してみます。</p>

<p>```objective-c
// SampleClass4.h</p>

<h1>import &ldquo;SampleClass2.h&rdquo;</h1>

<p>@interface SampleClass2(SampleClass4)</p>

<ul>
<li>(void)sample4Method;</li>
</ul>


<p>@end
```</p>

<p>```</p>

<h1>import &ldquo;SampleClass4.h&rdquo;</h1>

<p>@implementation SampleClass2(SampleClass4)</p>

<ul>
<li>(void)sample4Method
{
  [SampleClass2 sharedInstance].sample2Property = @&ldquo;SampleClass4オブジェクトのsample2Propertyプロパティ&rdquo;;
}
```</li>
</ul>


<p>さて、ViewControllerで使ってみましょう。</p>

<p>```objective-c
// ViewController.m</p>

<h1>import &ldquo;SampleClass4.h&rdquo;</h1>

<p>@interface ViewController ()</p>

<p>@end</p>

<p>@implementation ViewController</p>

<ul>
<li><p>(void)viewDidLoad {
  [super viewDidLoad];
  [self testMethod];
}</p></li>
<li><p>(void)testMethod {
  // SampleClassで定義されたsampleMethodを実行
  [[SampleClass2 sharedInstance] sampleMethod];
  // SampleClass2で定義されたsample2Methodを実行
  [[SampleClass2 sharedInstance] sample2Method];
  // SampleClass4で定義されたsample4Methodを実行
  [[SampleClass2 sharedInstance] sample4Method];
}</p></li>
</ul>


<p>@end
```</p>

<p>なかなかに頭を混乱させられましたが、なんとかできました笑。<br/>
といったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SwiftでGoogle OAuth2認証をしよう！]]></title>
    <link href="http://grandbig.github.io/blog/2015/03/15/gtm-oauth2-in-swift/"/>
    <updated>2015-03-15T22:20:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2015/03/15/gtm-oauth2-in-swift</id>
    <content type="html"><![CDATA[<h4>Swift版 OAuth2認証</h4>

<p>本日は<a href="http://grandbig.github.io/blog/2014/07/13/ios-google-oauth2/">iOSでGoogle OAuth認証がしたい</a>のSwift版を紹介したいと思います。<br/>
Google Play Consoleでの設定やGoogleから配布されているOAuth2認証に必要なソースのダウンロード方法については上記の記事に任せるとして、具体的なソース部分を紹介します。</p>

<p>では早速、Objective-CのソースをSwiftで書きなおしたものを下記に載せます。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<p>```objective-c
// ViewController.swift
import UIKit</p>

<p>class ViewController: UIViewController {</p>

<pre><code>var auth:GTMOAuth2Authentication!
let kKeychainItemName:NSString! = "GOAuthTest"
let scope:NSString! = "https://www.googleapis.com/auth/userinfo.profile https://www.googleapis.com/auth/calendar"
let clientId:NSString! = "Googleから発行されたクライアントID"
let clientSecret:NSString! = "Googleから発行されたクライアントシークレット"
let hasLoggedIn:NSString! = "hasLoggedInKey"

override func viewDidLoad() {
    super.viewDidLoad()
}

override func viewDidAppear(animated: Bool) {
    self.startLogIn()
}

override func didReceiveMemoryWarning() {
    super.didReceiveMemoryWarning()
}

func startLogIn() {
    var defaults:NSUserDefaults? = NSUserDefaults.standardUserDefaults()
    var hasLoggedInFlag:Bool! = defaults?.boolForKey(hasLoggedIn)

    if(hasLoggedInFlag == true) {
        // 認証したことがある場合
        self.auth = GTMOAuth2ViewControllerTouch.authForGoogleFromKeychainForName("Google", clientID: clientId, clientSecret: clientSecret)

        // アクセストークンの取得
        self.authorizeRequest()
    } else {
        // 認証したことがない場合
        var gvc:GTMOAuth2ViewControllerTouch! = GTMOAuth2ViewControllerTouch(scope: scope, clientID: clientId, clientSecret: clientSecret, keychainItemName: "Google", delegate: self, finishedSelector: "viewController:finishedWithAuth:error:")
        self.presentViewController(gvc, animated: true, completion: nil)
    }
}

func viewController(viewController:GTMOAuth2ViewControllerTouch!, finishedWithAuth:GTMOAuth2Authentication!, error:NSError?) {
    if(error != nil) {
        // 認証失敗
    } else {
        // 認証成功
        self.auth = finishedWithAuth
        var defaults = NSUserDefaults.standardUserDefaults()
        defaults.setBool(true, forKey: hasLoggedIn)
        defaults.synchronize()

        // アクセストークンの取得
        self.authorizeRequest()
    }

    // 認証画面を閉じる
    viewController.dismissViewControllerAnimated(true, completion: nil)
}

func authorizeRequest() {
    println(self.auth)
    var req:NSMutableURLRequest! = NSMutableURLRequest(URL: self.auth.tokenURL)
    self.auth.authorizeRequest(req, completionHandler: { (error) -&gt; Void in
        println(self.auth)
    })
}
</code></pre>

<p>}
```</p>

<p>今回のソースは<a href="https://github.com/grandbig/gtm-oauth2-swift">GitHub</a>にアップしています。<br/>
興味があればどしどし使ってみてください。<br/>
ということで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SwiftでWebSocket!]]></title>
    <link href="http://grandbig.github.io/blog/2015/03/11/socketio-in-swift/"/>
    <updated>2015-03-11T14:30:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2015/03/11/socketio-in-swift</id>
    <content type="html"><![CDATA[<h4>socket.io公式クライアントソースを使ったサンプルの作成</h4>

<p>先日、公開された<a href="https://github.com/socketio/socket.io-client-swift">socket.io公式のクライアントソース</a>を使って、サンプルを作成したいと思います。<br/>
公式にも<a href="https://github.com/nuclearace/socket.io-client-swift-example">サンプルコード</a>は公開されているのですが、練習がてら試してみたいと思います。</p>

<p>因みに本件にはサーバ側の説明は特に書いていません。<br/>
下記、内容を試したい場合は<a href="https://github.com/grandbig/socket.io.web">GitHub: socket.io.web</a>からソースをダウンロードしてお使いください。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h5>プログラミング前の準備</h5>

<p>まずは、<a href="https://github.com/square/SocketRocket">SocketRocket</a>をダウンロードしてきましょう。<br/>
READMEに書かれている通り、SocketRocketフォルダごと、自身のフォルダにコピーします。</p>

<p>続いて、下記４つのFrameworkを追加しましょう。</p>

<ul>
<li>libicucore.dylib</li>
<li>CFNetwork.framework</li>
<li>Security.framework</li>
<li>Foundation.framework</li>
</ul>


<p>本プロジェクトはSwiftがベースであるため、このままだと、Objective-Cのクラスを読み込めません。<br/>
そこで、 <strong>Bridge-Header</strong> ファイルを作成する必要があります。</p>

<p>作成手順は下記です。</p>

<ol>
<li>プロジェクトを右クリックでAdd files to &ldquo;プロジェクト名"を選択</li>
<li>TARGETS > Build Settings > Swift Compiler &ndash; Code Generation > Objective-C Bridging Header に作成したBridge-Headerファイルを指定</li>
<li>作成したBridge-Headerファイルに利用したいObjective-Cファイルをimportする</li>
</ol>


<p>そして、socket.io公式のクライアントソースである <strong>SwiftIO</strong> を追加しましょう。</p>

<p>ここまでで準備完了です。<br/>
下記のようなプロジェクト構成になっていることを確認してください。</p>

<p><img src="/images/ws_swift_1.png" alt="プロジェクト構成" /></p>

<h5>プログラミング</h5>

<p>さて、ここからは本格的にプログラミングを書いていきます。<br/>
と言っても、今回作成するサンプルは<a href="http://socket.io/get-started/chat/">socket.io 公式HP > Get Started > Write a chat application</a>を途中まで作成する程度なので、少ししか書きません。</p>

<p>まずは、Storyboardにテキストフィールドとボタンを設置します。</p>

<p><img src="/images/ws_swift_2.png" alt="Storyboardの様子" /></p>

<p>続いて、StoryboardからViewController.swiftにリンク付けします。<br/>
その結果、下記の通りになります。<br/>
(ついでに後々必要となる部分も実装しています。)</p>

<p>```objective-c
// ViewController.swift
import UIKit</p>

<p>class ViewController: UIViewController, UITextFieldDelegate {</p>

<pre><code>// Storyboardからのリンクづけ
@IBOutlet weak var msgField: UITextField!

override func viewDidLoad() {
    super.viewDidLoad()

    // Delegateの設定
    self.msgField.delegate = self
}

override func didReceiveMemoryWarning() {
    super.didReceiveMemoryWarning()
}

func textFieldShouldReturn(textField: UITextField) -&gt; Bool {
    // キーボードのreturnを押下するとキーボードが閉じる処理
    self.msgField.resignFirstResponder()

    return true;
}

@IBAction func sendMessage(sender: AnyObject) {
    // Storyboardからのリンクづけ
    // 後ほど記載
}
</code></pre>

<p>}
```</p>

<p>さて、これでほぼ大詰めです。<br/>
WebSocket処理を書いてみましょう。</p>

<p>```objective-c
// ViewController.swift
import UIKit</p>

<p>class ViewController: UIViewController, UITextFieldDelegate {</p>

<pre><code>// Storyboardからのリンクづけ
@IBOutlet weak var msgField: UITextField!

// クライアント側のSocketコネクションの準備
let socket = SocketIOClient(socketURL: "localhost:3000")

override func viewDidLoad() {
    super.viewDidLoad()

    // Delegateの設定
    self.msgField.delegate = self

    // コネクションの接続
    self.socket.connection()
}

override func didReceiveMemoryWarning() {
    super.didReceiveMemoryWarning()
}

func textFieldShouldReturn(textField: UITextField) -&gt; Bool {
    // キーボードのreturnを押下するとキーボードが閉じる処理
    self.msgField.resignFirstResponder()

    return true;
}

@IBAction func sendMessage(sender: AnyObject) {
    // Storyboardからのリンクづけ
    // テキストフィールド内の文字列をWebSocketで送る処理
    var msg = self.msgField.text
    self.socket.emit("chat message", msg)
}
</code></pre>

<p>}
```</p>

<p>はい。これでクライアント側の実装終了です！<br/>
上記のソースは全て<a href="https://github.com/grandbig/socket.io.ios-swift">GitHub: socket.io.ios-swift</a>にアップしていますので、ご自由にご利用ください。</p>

<p>ということで本日はここまで。</p>

<p>参考:</p>

<ul>
<li><a href="http://socket.io/get-started/chat/">socket.io</a></li>
<li><a href="https://github.com/socketio/socket.io-client-swift">socketio/socket.io-client-swift</a></li>
<li><a href="http://qiita.com/n0bisuke/items/6dc990579b343475a635">SocketRocketでWebSocketを実装してみる</a></li>
<li><a href="http://mk.hatenablog.com/entry/2014/10/16/075841">SwiftからObjective-Cのライブラリ使う</a></li>
</ul>


<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS オールスターズ勉強会に参加しました！]]></title>
    <link href="http://grandbig.github.io/blog/2015/02/14/ios-allstars-study/"/>
    <updated>2015-02-14T13:16:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2015/02/14/ios-allstars-study</id>
    <content type="html"><![CDATA[<h4>iOS オールスターズ勉強会</h4>

<p>本日、<a href="http://eventdots.jp/event/311301">iOSオールスターズ勉強会</a>に参加してきました。<br/>
iOSに特化した勉強会やイベントに参加するのは初めてでしたが、かなりいろいろと勉強になりました。<br/>
そして、まだまだ自分はヒヨッコだと痛感させられました。<br/>
まだまだ-1レベルの情弱プログラマーであることを再認識したところで、いつの日かこのブログを<strong>0から始める情弱プログラミング</strong>に変えてみせたいと思いつつ、勉強会で学んだことを報告したいと思います。</p>

<p>勉強会のテーマは下記の通りです。</p>

<ul>
<li>Adaptive Collection View</li>
<li>Swift製ライブラリの良い書き方を考える</li>
<li>let UIWebView as WKWebView</li>
<li>通信のパフォーマンス改善</li>
<li>効率的なアプリ開発のベストプラクティス</li>
<li>WatchKit を実際にさわってみてわかったこと</li>
<li>長生きするために心臓に悪いリリースはもうやめよう</li>
<li>エンジニア戦記 ~ 小さなチーム 大きな未来 ~</li>
<li>まだiOSでリッチな演出に疲弊してるの？</li>
</ul>


<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h4>Adaptiva Collection View</h4>

<p><a href="https://speakerdeck.com/ishkawa/adaptive-collection-view">本日の資料</a><br/>
<a href="https://github.com/ishkawa">石川さんのGitHub</a>(近々、大きめのライブラリを公開予定とのこと)</p>

<p>下記はメモ</p>

<ul>
<li>iOS8でViewControllerが進化した</li>
<li>セルを並べてアイテムを表示する系のアプリではiPhone, iPadで実装を分けていた。

<ul>
<li>iPhoneはUITableViewを利用</li>
<li>UICollectionViewを利用</li>
</ul>
</li>
<li>UICollectionViewを使えば、iPhone, iPadで実装を分ける必要がなくなる

<ul>
<li>実装はUICollectionViewFlowLayoutを使えば、割りと簡単にできる</li>
<li>UICollectionViewLayoutAttributeをUITableViewに似せる</li>
<li><a href="https://github.com/ishkawa/sandbox">サンプルコード</a></li>
</ul>
</li>
<li>UICollectionViewを使うと、セルの計算がたいへんなのでは？

<ul>
<li>estimatedItemSizeを設定することで、Self Sizing Cellを利用できる(iOS8から)</li>
<li>NSLayoutConstraintを適切に配置するとセルの大きさを自動的に計算してくれる</li>
<li>iOS7はsystemLayoutSizeFittingSize:をitemSizeForIndexPath:で呼べばOK</li>
</ul>
</li>
</ul>


<p>因みに、この手法の優位性に気づいたのは、<br/>
営業: 『急ぎでiPhoneだけで良いので、この機能を実装してください』<br/>
↓<br/>
UICollectionViewを使って開発<br/>
↓<br/>
営業: 『iPad版も実装してくれてありがとうございます！』
↓<br/>
気づいたらiPad版もできていた</p>

<p>まとめ</p>

<ul>
<li>UITableViewはUICollectionViewである</li>
<li>iPhoneはiPadである</li>
<li>同じコードは２度書かない</li>
</ul>


<p>【Q&amp;A】</p>

<p>Q: Cellの並び替え<br/>
A: UITableViewは元々実装されている。UICollectionViewは自分で頑張って実装することになる。<br/>
もしくは諦めてUITableViewを使う</p>

<h4>Swiftで使いやすいAPIを考える</h4>

<p><a href="https://speakerdeck.com/kishikawakatsumi/swiftderaiburariwoshu-kuji-falsepurakuteisu">本日の資料</a><br/>
<a href="https://github.com/kishikawakatsumi">岸川さんGitHub</a></p>

<p>下記はメモ</p>

<ul>
<li><p>Swift製ライブラリの良い書き方を考える</p>

<ul>
<li>人に使われるコードを書くときに、どうすれば良いか</li>
<li>enumが良いという話をすると長くなるので10分でできる話をする</li>
</ul>
</li>
<li><p>Objective-Cとの違い</p>

<ul>
<li>データ型, Optional, オーバーロード, デフォルト引数, メソッドチェーン, エラー処理などの違いがある</li>
</ul>
</li>
<li><p>データ型</p>

<ul>
<li>Class, Struct, Enum, Tuple, Function, Array, Dictionary, Set, Optionalなどがある</li>
<li>Optional型を指定すると、nilを許さない。コンパイル時にわかる(Objective-Cではnilは無視してできていた)</li>
<li>Optionalか否かは明確に設計した方が良い(Swiftは型に厳格な言語なので、明確にして使い方を固めた方が良い)</li>
<li>外に公開しているメソッドは引数にOptionalはつけない(プライベートメソッドはつけても良い)</li>
</ul>
</li>
<li><p>オーバーロード</p>

<ul>
<li>オーバーロードとは引数を変えた同じ名前のメソッドをたくさん用意すること</li>
<li>デフォルト引数は補完がイマイチ</li>
<li>ユーザがメソッドを書いたときに、先に引数の多いメソッドが補完で上がってくると良くない</li>
</ul>
</li>
<li><p>戻り値のオーバーロード</p>

<ul>
<li>戻り値のオーバーロード(NSString, NSData型でそれぞれ返却する場合)はコンパイルエラーが出るので、<code>var let:NSData? = ....</code>と型指定をする</li>
<li>これはリズムが悪いので、メソッド名を分けることにした</li>
</ul>
</li>
<li><p>エラー処理</p>

<ul>
<li>Objective-CならNSErrorのダブルポインタが一般的だけど、Swiftだと実装しにくい</li>
<li>SwiftではEither型を使う(Eitherをユーザが知らないと使えないけど)</li>
<li>自分で定義した型でエラーを返すより、NSErrorを返したほうが良い</li>
</ul>
</li>
<li><p>playground</p>

<ul>
<li>ドキュメントを書くのと一緒にplaygroundをつけてあげると、わかりやすくなって良い</li>
</ul>
</li>
<li><p>Functional style API</p>

<ul>
<li>アドバンストモードで用意すると良い</li>
<li>標準的な書き方と分けて示すと良いと思う</li>
</ul>
</li>
</ul>


<p>【Q&amp;A】</p>

<p>Q: Tupleで返すのは？<br/>
A: EitherでなくてTupleで返すのもあり。<br/>
Tupleで受けると、受けては使いづらい。<br/>
検討した結果、やめた。</p>

<h4>let UIWebView as WKWebView</h4>

<p><a href="http://www.slideshare.net/taketo1024/let-ui-webviewaswkwebview">本日の資料</a></p>

<ul>
<li><p>Swiftについて</p>

<ul>
<li>Swiftは数学と相性が良い</li>
</ul>
</li>
<li><p>UIWebVIewとWKWebViewについて</p>

<ul>
<li>UIWebViewはJavaScriptがSafariよりも遅い</li>
<li>WKWebViewはSafari並に速い</li>
<li>iOS7を切る訳にはいかない&hellip;</li>
<li>毎回、バージョンで条件分岐を書いて、処理を分けるのは美しくない&hellip;</li>
<li>複雑な処理は見えないところに置く方が良い(UIWebViewとWKWebViewのぶん機処理を隠蔽せよ)</li>
<li>iOS7と気持よく別れられるように対応しておくと良い</li>
<li><a href="http://techblog.yahoo.co.jp/ios/let-uiwebview-as-wkwebview/">去年のAdvent Calendar</a>にも載っている</li>
</ul>
</li>
</ul>


<p>個人的には参加前から最も注目していた内容でした。<br/>
WKWebViewは実装で使いたいと思っていたものの、現状、条件分岐が多くなりそうで使っていなかったのですが、これを機会に真似て実装したいと思いました。</p>

<p>【Q&amp;A】</p>

<p>Q: UIWebViewとWKWebViewにおけるDelegateメソッドはどうする？<br/>
A: Delegateはそのまま書いている。<br/>
iOS7をサポートしなくなったときにUIWebViewのDelegateの部分だけ消すことを考えている</p>

<p>Q: UIWebViewと揃えるのであればUIWebViewだけ使えば良いのでは？<br/>
A: WKWebViewの良い所は積極的に使っていきたい(処理が速いところとか)<br/>
iOS8ユーザには体験できる部分は体験してほしいと思っている。</p>

<h4>通信のパフォーマンス改善</h4>

<p><a href="http://www.slideshare.net/susieyy/ios-ios-44665266?ref=http://eventdots.jp/event/311301">本日の資料</a><br/>
<a href="https://github.com/wantedly">wantedlyさんのGItHub</a></p>

<p>下記メモ</p>

<ul>
<li><p>そもそも通信のパフォーマンス改善に取り組んだ理由</p>

<ul>
<li>海外進出する上で通信品質の違いに耐えうるか調べる必要があった</li>
<li>海外の通信品質が悪いので、それに耐えうるパフォーマンス改善に取り組んだ</li>
</ul>
</li>
<li><p>ボトルネックを調べた</p>

<ul>
<li>New Relic Mobileでボトルネックを分析した。(大雑把なボトルネック解析には十分)</li>
<li>Pony Debuggerでもっと細かく分析できるものがあった</li>
</ul>
</li>
<li><p><a href="https://github.com/square/PonyDebugger">Pony Debugger</a>の使い方</p>

<ul>
<li>CocoaPodsでiOSアプリ側にいれる。</li>
<li>サーバ側にもモジュールのインストールが必要。中身はPythonでできている</li>
</ul>
</li>
<li><p>ボトルネック調査の結果</p>

<ul>
<li>画像にボトルネックがあった</li>
<li>画像の処理に関して<a href="https://github.com/rs/SDWebImage">SDWebImage</a>を使っていた</li>
<li>まずは、SDWebImageの仕組みから知る必要がある</li>
<li>SDWebImageのバグを発見して、PullRequestを出したらマージされた</li>
<li><a href="http://agilecatcloud.com/2014/12/02/facebook-%E3%81%8C%E8%AA%9E%E3%82%8B%E3%83%A2%E3%83%90%E3%82%A4%E3%83%AB%EF%BD%A5%E3%83%81%E3%83%A5%E3%83%BC%E3%83%8B%E3%83%B3%E3%82%B0%E3%81%AE%E6%A5%B5%E6%84%8F%EF%BC%9A%E3%81%93%E3%82%8C%E3%81%A7/">Facebookの発展途上国向けの改善施策</a>がネット上に載っていた</li>
</ul>
</li>
<li><p>WebP</p>

<ul>
<li>WebPとはGoogle製のフォーマット(1/3程度のサイズに抑えられる)</li>
<li>SDWebImageはWebPに対応している</li>
<li>wantedlyではサーバはAWSを使っている</li>
<li>WebPに変換する画像サーバを構成するのがたいへんだった</li>
<li><a href="https://github.com/wantedly/nginx-image-server">NginxでWebPに変換するものをGitHubにあげている</a></li>
</ul>
</li>
<li><p>具体的な施策</p>

<ul>
<li>通信帯域により取得する画像サイズを変更する</li>
<li>通信品質は『通信開始・終了の経過時間と受領画像サイズ』から推測</li>
<li>キャッシュ時は計測しない</li>
<li>独自にキャッシュ上に取りに行こうとする画像のサイズよりも大きい物がないか確認するようにしている</li>
<li>実装の可否はデベロッパの通信帯域制限機能で改善結果を確認した</li>
</ul>
</li>
<li><p>他に考えられる対策</p>

<ul>
<li>MessagePackでJSONを圧縮する</li>
<li>SPDYで通信コネクションをまとめる</li>
<li>通信帯域で同時接続数を調整する</li>
</ul>
</li>
</ul>


<h4>効率的なアプリ開発のベストプラクティス</h4>

<p><a href="http://www.slideshare.net/yayugu/ss-44667286">本日の資料</a></p>

<ul>
<li><p>iOSの一大イベントがここ2年連続で実施されている</p>

<ul>
<li>Conference with Developers</li>
</ul>
</li>
<li><p>効率的な開発の必要性</p>

<ul>
<li>メインでない機能を創るときはできる限り効率的に開発したい</li>
</ul>
</li>
<li><p>どうすれば速く開発できるのか</p>

<ul>
<li>やることを減らす</li>
<li>UI, 通信の実装コストを減らす</li>
</ul>
</li>
<li><p>UIの実装コスト</p>

<ul>
<li>端末の性能向上, Auto Layout, Storyboard, Self Sizing Cell</li>
<li>Self Sizing Cellが便利なので、ユーザはiOS8を使って欲しいのが本音</li>
<li>改善の余地としては、React.jsみたいなアプローチ(Viewのdiff &amp; patch)があると良さそう</li>
</ul>
</li>
<li><p>通信の実装コスト</p>

<ul>
<li>仕様に依存。サーバ側が決める。</li>
<li>どちらでも行える処理であれば、サーバ側に処理を任せる。</li>
</ul>
</li>
<li><p>API</p>

<ul>
<li>共通化、RESTにとらわれない</li>
<li>Mantle, JSONModelライブラリの都合に合わせた形で返して欲しい</li>
</ul>
</li>
<li><p>State</p>

<ul>
<li>クライアント側でCacheを持たない</li>
<li>ローカルストアを利用してサーバ側とのdiffがあれば取得しにいく処理はしない</li>
</ul>
</li>
<li><p>サーバ側仕様変更による弊害</p>

<ul>
<li>キレイなRESTful API

<ul>
<li>特化したAPIの作成は断られる。</li>
</ul>
</li>
<li>レガシーサーバ

<ul>
<li>触るのが怖い</li>
<li>リファクタリングするとデグレそう</li>
</ul>
</li>
</ul>
</li>
<li><p>サーバ側担当者の説得の仕方</p>

<ul>
<li>パフォーマンスの向上などメリットを説明</li>
<li>クライアント側の実装の大変さをうったえかける</li>
<li>サーバ側も自分で書く</li>
</ul>
</li>
<li><p>間を取る方法として、中継サーバをたてることも考えられる</p>

<ul>
<li>効率的でないので、やりたくない</li>
<li>中継サーバの処理はClient開発者が書く</li>
<li>ドワンゴはスカラーでProxy Serverを作っていたらしい</li>
</ul>
</li>
</ul>


<p>【Q&amp;A】</p>

<p>Q: サーバ側にどこまで処理を任せているかの線引はあるか<br/>
A: ユーザ体験があがるか、重要な機能かの２つによる<br/>
twitterのツイートはオフラインで見れる ⇒ 意味がある<br/>
設定画面がオンラインでないと見れない ⇒ それで良いのでは？</p>

<h4>WatchKitを実際にさわってみてわかったこと</h4>

<p><a href="http://www.slideshare.net/t26v0748/watch-kit-20150214?ref=http://eventdots.jp/event/311301">本日の資料</a><br/>
<a href="https://github.com/shu223">堤さんのGitHub</a></p>

<ul>
<li><p>自己紹介</p>

<ul>
<li>Over&amp;Out その後: ブログを書いている</li>
<li>iOS7-Sampler, iOS8-Samplerを作っている</li>
<li>iOS9-Samplerのアイコンは作成済み</li>
</ul>
</li>
<li><p>WatchKitについて</p>

<ul>
<li>WatchKitはクラスはたったの15個</li>
<li>Watch ExtensionはiPhone側で実行</li>
<li>Watch Appは基本的に表示だけ</li>
</ul>
</li>
<li><p>動的なイメージの表示</p>

<ul>
<li>タイマーを利用する

<ul>
<li>転送か描画が遅い？ ⇒ 非推奨</li>
</ul>
</li>
<li>キャッシュを使う

<ul>
<li>フレームごとの画像はキャッシュしないようにプログラミングガイドに書いてある</li>
</ul>
</li>
<li>Animated Imageを利用する

<ul>
<li>iOS5から追加されているメソッドが役に立つ</li>
</ul>
</li>
</ul>
</li>
<li><p>テキスト入力</p>

<ul>
<li>presentTextInputControllerWith~を使えば良い

<ul>
<li>テキスト入力のインターフェースを表示するメソッド</li>
</ul>
</li>
</ul>
</li>
<li><p>Smart Replies + 音声入力</p>

<ul>
<li>第一引数にフレーズの履いてる, 第二引数に.Plainを渡す</li>
</ul>
</li>
<li><p>絵文字入力</p>

<ul>
<li>第二引数: .allowEmojiを渡せば良い</li>
<li>シミュレータでは提供されていない</li>
</ul>
</li>
<li><p>カスタムUI</p>

<ul>
<li>WatchKit AppではCore Graphics使えない</li>
<li>Appleの公式を見ると、連番アニメーションだった。</li>
</ul>
</li>
<li><p>カスタムフォント</p>

<ul>
<li>iOSと同様の手順で可能</li>
</ul>
</li>
<li><p>インターフェースのオーバレイ</p>

<ul>
<li>WKInterfaceObjectはUIViewのsubview的にインターフェース同士を重ねられない</li>
<li>WKInterfaceGroupのsetBackgroundImage:を活用すればできる</li>
</ul>
</li>
<li><p>originの調整</p>

<ul>
<li>WKInterfaceGroupを活用(ダミーオブジェクト入れて、グループ化)</li>
</ul>
</li>
<li><p>角丸、Watchの画面サイズ分け対応などなど</p></li>
</ul>


<p>【Q&amp;A】</p>

<p>Q: 手軽にアニメーションするには？<br/>
A: <a href="https://github.com/frosty/Flipbook">Flipbook</a>というOSSがある<br/>
デザイナーが作成したものをアプリに入れるなら、動画としてもらう。<br/>
Flashを使っていた人と仕事をしていたときは連番画像を吐き出してもらっていた</p>

<p>Q: Apple Watchで画像の表示について<br/>
A: AnimatedImageのオブジェクトの生成はiOS側でやるので問題ない<br/>
AnimatedImageをWatch側でレンダリングするのは重い？⇒シミュレータでは問題なかった</p>

<h4>長生きするための心臓に悪いリリースはもうやめよう</h4>

<p><a href="https://speakerdeck.com/tokorom/chang-sheng-kisurutamenixin-zang-nie-iririsuhamouyameyou">本日の資料</a></p>

<ul>
<li><p>アプリの申請について</p>

<ul>
<li>バグが見つかって、月々の課金処理に失敗したとしたら&hellip;.非常に怖い</li>
<li>Internal Testersでの最終チェックすると良い</li>
</ul>
</li>
<li><p>テストの質</p>

<ul>
<li>AppStoreに公開されるものと同じ / 違うアプリのテストなのかどうか</li>
<li>Appleの審査の前後のテストなのかどうか</li>
</ul>
</li>
<li><p>Internal Testers</p>

<ul>
<li>iTunes Connectの新機能</li>
<li>iTunes Connectにサブミットしたアプリをテスト可能</li>
<li>iOS8以降でしか使えない</li>
<li>25人までしか使えない</li>
</ul>
</li>
<li><p>Internal Testers vs CI</p>

<ul>
<li>両方使いましょう(比べるものではない)</li>
</ul>
</li>
<li><p>CIの自動化</p>

<ul>
<li><a href="http://kishikawakatsumi.hatenablog.com/entry/20141022/1413963656">Travis CIでiOSアプリのリリース作業を自動化する</a>という記事が良い</li>
</ul>
</li>
<li><p>万が一の事故に対して&hellip;</p>

<ul>
<li>後から見返せない情報をバックアップしておく

<ul>
<li>Build Details: バージョンが進むと過去のバージョンの情報が見れなくなる。スクショをとっておくと良い。</li>
</ul>
</li>
<li>過去のバージョンのアプリをとっておく

<ul>
<li>iTunesで実際に公開されたアプリをipaで持っておく</li>
<li>それをバージョン毎に保管しておくと良い</li>
<li>コードを見たいのであれば、Gitで良いが、そうでないときもある。</li>
</ul>
</li>
</ul>
</li>
</ul>


<p>【Q&amp;A】</p>

<p>Q: Internal Testers使うと課金できるのか？<br/>
A:実際に購入ができるわけではない。たぶんsandboxに繋がっていると思う。<br/>
厳密に言うと、課金テストはプロモーションコードでテストするしかない。</p>

<p>Q: 自分でリジェクトしてサブミットし直すと速い気がする<br/>
A: 体感的に速く感じることがある。</p>

<h4>エンジニア戦記 ~小さなチーム 大きな未来 ~</h4>

<p><a href="http://www.slideshare.net/yukihirai52/ss-44668339?ref=http://eventdots.jp/event/311301">本日の資料</a></p>

<ul>
<li><p>クラスメソッド</p>

<ul>
<li>Developers.IOを書いている。</li>
<li>月間平均80万PV</li>
<li>ブログを書いている会社だと思われがち</li>
</ul>
</li>
<li><p>iOSエンジニアとWeb-API担当者間で発生した問題</p>

<ul>
<li>APIの返却データにステータスコードが入っている(HTTPステータスコードとは別に)

<ul>
<li>HTTPステータスコードで返すべき</li>
<li>Web APIのレスポンスに独自ステータスコードを持つべきではない</li>
<li>アプリ側でsuccessなのに、エラーハンドリングをしなくてはならない。</li>
</ul>
</li>
<li>1画面で叩くAPIが多い

<ul>
<li>RESTful APIをしたいがために上記のようなことが生じる</li>
<li>複数回APIを実行することで、エラーが発生しやすくなる</li>
</ul>
</li>
</ul>
</li>
<li><p>iOSエンジニアに求められるもの</p>

<ul>
<li>Web APIの知識は必須</li>
<li>改善案を提案できる力が必要</li>
<li><a href="http://www.oreilly.co.jp/books/9784873116860/">Web API The Good Parts</a>を読もう</li>
</ul>
</li>
</ul>


<p>身に染みる話ばかりで考えさせられるテーマでした。<br/>
筆者はクライアント担当としてネイティブとWebの経験があり、サーバ担当としてAPサーバ開発の経験があるので、どっちが良いとは言い難く&hellip;。</p>

<h4>まだiOSでリッチな演出に疲弊しているの？</h4>

<p><a href="https://speakerdeck.com/ryusukefuda/madaiosderitutinayan-chu-nipi-bi-siterufalse">本日の資料</a></p>

<ul>
<li><p>カヤック自社開発アプリ</p>

<ul>
<li>FILTERS</li>
<li>ダンボッコキッチン</li>
</ul>
</li>
<li><p>リッチな演出で何を使う？</p>

<ul>
<li>Core Animation: コードが大量になる。大量オブジェクトを動かすとたいへん</li>
<li>Unity: ネイティブの機能を使うのにプラグインを書くのでたいへん</li>
<li>Cocos2d: Unityと同じ</li>
<li>OSS: いいものが見つからない</li>
</ul>
</li>
<li><p>SpriteKitが良いのでは？</p>

<ul>
<li>iOS7から追加された2Dゲーム用のフレームワーク</li>
<li>パーティクルがXcodeでプレビューしながら編集可能</li>
<li>UIKitと同様に記述できる</li>
<li>SpriteKitがゲーム以外で使えるのか? ⇒ 使える</li>
<li>SKNode, SKScene, SKViewを使う</li>
<li>GUIでパラメータを簡単にいじることで演出を変えられる(コードを書く必要がない)</li>
<li>パーティクル自体にアニメーションをつけることもできる</li>
<li>UIViewのタッチイベントが効くようにするために、SKViewを透明かつタッチイベントを無効化する</li>
<li><a href="https://github.com/ryusukefuda/SpriteKit-Demo">サンプルコード</a></li>
</ul>
</li>
<li><p>SpriteKitを使うメリット</p>

<ul>
<li>Appleが提供している安心感</li>
<li>既存のコードを邪魔することなく導入可能</li>
<li>デザイナーも利用可能</li>
</ul>
</li>
</ul>


<p>SpriteKitとUIKitを組合せた演出はありであるという結論に至っていました。</p>

<p>【Q&amp;A】</p>

<p>Q: SpriteKitを使った理由<br/>
A: マップとかカメラとの組合せを考えると、SpriteKitを選択した。<br/>
3Dの演出をする場合はUnity一択になる。</p>

<p>Q: パーティクルは重くないか？<br/>
A: 重い。シミュレータだとカクついたりする。<br/>
表示する場所を絞る。(SKViewの大きさを小さくするなど)</p>

<p>といったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AFNetworking2.xでWeb-APIを叩いてみた！]]></title>
    <link href="http://grandbig.github.io/blog/2015/02/12/afnetworking/"/>
    <updated>2015-02-12T00:01:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2015/02/12/afnetworking</id>
    <content type="html"><![CDATA[<h3>AFNetworking2.x</h3>

<p>さて、本日は今更ながら超有名ライブラリである <strong>AFNetworking</strong> を使ってみたいと思います。<br/>
ただ、単に使い方を説明するのであれば、他のサイトにお任せすれば良いので、Web-APIを使ってみる形で書きたいと思います。</p>

<p>今回は、<br/>
GETリクエスト: <strong>OpenWeatherMap API</strong><br/>
POSTリクエスト: <strong>VoiceText Web API</strong><br/>
を試してみました。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<p>　</p>

<p><strong>AFNetworking</strong> を使うためにはCocoaPodsでライブラリをインストールして、<br/>
ViewController.mで<code>#import "AFNetworking.h"</code>を書きましょう。</p>

<p>まずは、OpenWeatherMap APIを使って、GETリクエストを投げてみました。</p>

<p>```objective-c
// ViewController.m</p>

<h1>import &ldquo;ViewController.h&rdquo;</h1>

<h1>import &ldquo;AFNetworking.h&rdquo;</h1>

<p>@interface ViewController ()</p>

<p>@end</p>

<p>@implementation ViewController</p>

<ul>
<li><p>(void)viewDidLoad {
  [super viewDidLoad];</p>

<p>  // AFHTTPSessionManagerをインスタンス化
  AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];</p>

<p>  // OpenWeatherMap APIを利用
  [manager GET:@&ldquo;<a href="http://api.openweathermap.org/data/2.5/weather?q=Tokyo,jp">http://api.openweathermap.org/data/2.5/weather?q=Tokyo,jp</a>&rdquo;
    parameters:nil
       success:^(NSURLSessionDataTask <em>task, id responseObject) {
           NSLog(@&ldquo;response: %@&rdquo;, responseObject);
       } failure:^(NSURLSessionDataTask </em>task, NSError *error) {
           NSLog(@&ldquo;error: %@&rdquo;, error);
       }
}
```</p></li>
</ul>


<p>きちんと値が返ってきました。</p>

<p>続いて、<a href="https://cloud.voicetext.jp/webapi">VoiceText Web API</a>を使って、POSTリクエストを投げてみました。<br/>
VoiceText Web APIは無料利用に登録が必要なので、さくっと登録しましょう。<br/>
すぐに登録したメールにAPIキーが来ます。<br/>
これを使って、POSTリクエストを投げてみました。</p>

<p>```objective-c
// ViewController.m</p>

<h1>import &ldquo;ViewController.h&rdquo;</h1>

<h1>import &ldquo;AFNetworking.h&rdquo;</h1>

<p>@interface ViewController ()</p>

<p>@end</p>

<p>@implementation ViewController</p>

<ul>
<li><p>(void)viewDidLoad {
  [super viewDidLoad];</p>

<p>  // AFHTTPSessionManagerをインスタンス化
  AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];</p>

<p>  // APIキーをセット
  NSString *apiKey = @&ldquo;&lt;メールで届いたAPIキー>&rdquo;;
  [manager.requestSerializer setAuthorizationHeaderFieldWithUsername:apiKey password:nil];</p>

<p>  // リクエストパラメータをセット
  NSMutableDictionary <em>params = [NSMutableDictionary alloc] init];
  NSString </em>text = @&ldquo;おはようございます。&rdquo;;
  [params setObject:text forKey:@&ldquo;text&rdquo;];
  [params setObject:@&ldquo;show&rdquo; forKey:@&ldquo;speaker&rdquo;];
  [params setObject:@&ldquo;ogg&rdquo; forKey:@&ldquo;format&rdquo;];]</p>

<p>  // Content-Typeをセット
  [manager setResponseSerializer:[AFHTTPResponseSerializer serializer]];
  manager.responseSerializer.acceptableContentTypes = [NSSet setWithObject:@&ldquo;audio/ogg&rdquo;];</p>

<p>  // OpenWeatherMap APIを利用
  [manager POST:@&ldquo;<a href="https://api.voicetext.jp/v1/tts">https://api.voicetext.jp/v1/tts</a>&rdquo;
     parameters:params
        success:^(NSURLSessionDataTask <em>task, id responseObject) {
            NSLog(@&ldquo;response: %@&rdquo;, responseObject);
        } failure:^(NSURLSessionDataTask </em>task, NSError *error) {
            NSLog(@&ldquo;error: %@&rdquo;, error);
        }
}
```</p></li>
</ul>


<p>注意点は下記です。</p>

<ul>
<li>APIキーの設定
VoiceText Web APIではAPIキーを利用する必要があるので、<code>requestSerializer</code>の<code>authorization</code>にユーザネームとしてAPIキーを設定しましょう。</li>
<li><code>Content-Type</code>の設定
<code>audio/ogg</code>でレスポンスを受け取る必要があるので、<code>responseSerializer</code>を設定しましょう。</li>
</ul>


<p>あとは通常の<code>NSURLSession</code>や<code>NSURLConnection</code>のPOSTリクエストと同様にリクエストパラメータをセットすれば良いのです。
正しく値が返ってきますね。</p>

<p>AFNetworkingの良いところはエラーでも値が返ってくるところでしょうか。<br/>
<code>Content-Type</code>が対応していないので<code>success</code>を通らないということが一目瞭然でした。</p>

<p>今後は、この便利なライブラリを積極的に使っていこうかと思います。<br/>
といったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
</feed>
