<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: swift | Takahiro Octopress Blog]]></title>
  <link href="http://grandbig.github.io/blog/categories/swift/atom.xml" rel="self"/>
  <link href="http://grandbig.github.io/"/>
  <updated>2017-05-06T02:52:33+09:00</updated>
  <id>http://grandbig.github.io/</id>
  <author>
    <name><![CDATA[Takahiro]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Swift3でRealmSwiftを使ってみよう！]]></title>
    <link href="http://grandbig.github.io/blog/2017/05/06/swift3-realm/"/>
    <updated>2017-05-06T02:06:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2017/05/06/swift3-realm</id>
    <content type="html"><![CDATA[<h3>はじめに</h3>

<p>約2年前に画期的なモバイルデータベースとして<a href="https://realm.io/jp/">Realm</a>について紹介させて頂きました。<br/>
当時はSwift専用のものがなかったため、Objective-C用のものをブリッジヘッダーファイルを作成することで利用していました。<br/>
現在はかなり多くのアプリでも利用され、広く浸透していると共に、<code>SwiftRealm</code>が作られ、Swift専用化しています。</p>

<p>今回は、以前、筆者が書いた<a href="http://grandbig.github.io/blog/2015/06/07/swift-realm/">SwiftでRealmを使ってみよう！</a>を<code>SwiftRealm</code>で書き直す形でSwift3での<code>Realm</code>の使い方を見ていきたいと思います。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h3>RealmSwiftの導入方法</h3>

<p><code>CocoaPods</code>を利用して導入してみます。<br/>
(<code>Carthage</code>での利用方法も公式サイトにて紹介されています。)</p>

<p>```objective-c</p>

<h1>Podfile</h1>

<p>use_frameworks!</p>

<p>target &ldquo;RealmSwiftSample&rdquo; do
  # Normal libraries
  pod &lsquo;RealmSwift&rsquo;</p>

<p>  abstract_target &lsquo;Tests&rsquo; do</p>

<pre><code>inherit! :search_paths
target "RealmSwiftSampleTests"
target "RealmSwiftSampleUITests"
</code></pre>

<p>  end
end</p>

<p>post_install do |installer|
  installer.pods_project.targets.each do |target|</p>

<pre><code>target.build_configurations.each do |config|
  config.build_settings['SWIFT_VERSION'] = '3.0'
end
</code></pre>

<p>  end
end
```</p>

<p>因みに、<code>abstract_target</code>は複数targetにまたがって利用したいライブラリがある場合に利用します。<br/>
(上記の例はテストでのみ利用するライブラリがある場合に利用する書式です。)<br/>
また、<code>post_install do |installer|</code>〜<code>end</code>までの書式はSwiftのバージョンを指定するために追加します。</p>

<p><code>Podfile</code>ができたら<code>pod install</code>を実行して<code>xcworkspace</code>ファイルを開きましょう。</p>

<h3>保存オブジェクトの生成</h3>

<p>Objective-C用のときは<code>RLMObject</code>型のクラスを作成していましたが、<code>RealmSwift</code>では単に<code>Object</code>型のクラスを作成します。</p>

<p>```objective-c
// Engineer.swift</p>

<p>import Foundation
import RealmSwift</p>

<p>// Skillクラス
class Skill: Object {</p>

<pre><code>dynamic var name: String = ""
</code></pre>

<p>}</p>

<p>// Engineerクラス
class Engineer: Object {</p>

<pre><code>dynamic var id: Int = 0
dynamic var name: String = ""
dynamic var level: Int = 0
let skills = List&lt;Skill&gt;()
dynamic var created: Double = Date().timeIntervalSince1970
dynamic var updated: Double = Date().timeIntervalSince1970

// プライマリーキーの設定
override static func primaryKey() -&gt; String? {
    return "id"
}

// インデックスの設定
override static func indexedProperties() -&gt; [String] {
    return ["level"]
}
</code></pre>

<p>}
```</p>

<p>Objective-C用の<code>Realm</code>では<code>RLMArray</code>型として<code>skills</code>を作成していましたが、<code>RealmSwift</code>では<code>List&lt;Skill&gt;</code>型として作成できます。<br/>
こちらの方が直感的でわかりやすいですね。<br/>
因みに、<code>dynamic var skills = List&lt;Skill&gt;()</code>と書くとエラーが発生するので<code>List</code>を利用する場合は<code>let</code>にしましょう。</p>

<h3>オブジェクトのインサート/アップデート</h3>

<p>先程作成したオブジェクトを保存する方法について紹介しましょう。</p>

<p>```objective-c
// ViewController.swift
import UIKit
import RealmSwift</p>

<p>class ViewController: UIViewController {</p>

<pre><code>override func viewDidLoad() {
    super.viewDidLoad()
    // 新規オブジェクトをインサート
    createEngineer(name: "test1", level: 1, skills: ["swift", "objective-c"])
}

&lt;省略&gt;

func createEngineer(name: String, level: Int, skills: [String]) {
    // Skill型オブジェクトに変換してList&lt;Skill&gt;に格納
    let skillList = List&lt;Skill&gt;()
    for skill in skills {
        let newSkill = Skill()
        newSkill.name = skill
        skillList.append(newSkill)
    }

    // Engineer型オブジェクトの作成
    let engineer = Engineer()
    engineer.name = name
    engineer.level = level
    engineer.skills.append(objectsIn: skillList)
    let realm = try! Realm()

    // Realmへのオブジェクトの書き込み
    try! realm.write {
        realm.add(engineer)
    }
}
</code></pre>

<p>}
```</p>

<p>Objective-Cの際は<code>realm.beginWriteTransaction()</code>や<code>realm.commitWriteTransaction()</code>などわざわざ書いていたものの、<code>RealmSwift</code>では非常にコンパクトに書けますね。<br/>
因みに、アップデートであれば、</p>

<p><code>objective-c
try! realm write {
  engineer.name = "takahiro"
}
</code></p>

<p>のようにすれば良さそうです。</p>

<h3>データの確認</h3>

<p>今は、Mac App Storeから<code>Realm Browser</code>アプリをインストールすることで簡単にデータ確認が可能になっています。</p>

<p>手順は以下の通りです。<br/>
１．<code>Realm Browser</code>を起動する<br/>
２．<code>Realm</code>ファイルを選択して開く</p>

<p>そうすることで、下記のようにデータを確認することができます。</p>

<p><img src="/images/swift3-realm1.png" alt="Realm BrowserでEngineerオブジェクトを確認" /><br/>
<img src="/images/swift3-realm2.png" alt="Realm BrowserでSkillオブジェクトを確認" /></p>

<p>注意すべきこととしては、シミュレータだと<code>realm</code>ファイルを探すのに骨が折れるかもくらいでしょうか&hellip;<br/>
<code>/Users/&lt;username&gt;/Library/Developer/CoreSimulator/Devices/&lt;simulator-uuid&gt;/data/Containers/Data/Application/&lt;application-uuid&gt;/Documents/default.realm</code>にありますので該当するファイルを検索するなどして探しましょう。</p>

<h3>まとめ</h3>

<p>さて、如何でしたでしょうか。<br/>
筆者は久しぶりに<code>Realm</code>を触ったため、以前利用していたときよりも『だいぶ変わったな』と正直思いました。<br/>
ですが、<code>RealmSwift</code>になったことで、より<code>Swift</code>らしい書き方ができると思いますし、単純に記述量も少なく書けるような気がしています。<br/>
今後も多くのアプリで利用されることでしょうし、知っておいて損は絶対になさそうですね。<br/>
ということで本日はここまで。</p>

<p>参考:</p>

<ul>
<li><a href="http://qiita.com/shu223/items/e9d0145a2087da0d6d46">CocoaPods でビルド設定を追加する</a></li>
<li><a href="https://guides.cocoapods.org/using/the-podfile.html">CocoaPods公式サイトでの説明</a></li>
<li><a href="http://stackoverflow.com/questions/28465706/how-to-find-my-realm-file/28465803#28465803">stackoverflow &ndash; How to find my realm file?</a></li>
</ul>


<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swiftで使いたいんだけど思うように使えないsubscript]]></title>
    <link href="http://grandbig.github.io/blog/2017/04/23/swift-base-3/"/>
    <updated>2017-04-23T23:03:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2017/04/23/swift-base-3</id>
    <content type="html"><![CDATA[<h3>はじめに</h3>

<p>さて、今日はSwiftの <code>String</code> 型に関するメモです。<br/>
何かできそうなのに実は面倒だという話があったのでちょろっと忘れないように書いておきます。</p>

<h3>文字列から文字を取り出したい！</h3>

<p>プログラミングを書いているときに、たまに『文字列から文字を取り出したい！』ということがあるかと思います。<br/>
JavaScriptなら <code>charAt</code> を利用するだけで任意の場所の文字を取得することができますが、Swiftだと意外に面倒でした&hellip;</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<p><code>objective-c
func sample1() {
  let chrSample1 = "こんにちは"
  // 先頭文字の取得
  print(chrSample1.characters[chrSample1.startIndex]) // こ
  // 先頭から1つ先の文字を取得
  let secondIndex = chrSample1.index(after: chrSample1.startIndex)  // ん
  print(chrSample1.characters[secondIndex])
  // 末尾の文字を取得
  let lastBeforeIndex = chrSample1.index(before: chrSample1.endIndex) // は
  print(chrSample1.characters[lastBeforeIndex])
}
</code></p>

<p>上記のように場所を指定する必要があります。<br/>
下記のように数字で指定しようとすると全て静的解析でエラー判断されます。</p>

<p><code>objective-c
func sample1() {
  let chrSample1 = "こんにちは"
  print(chrSample1.characters[0]) // エラー
  print(chrSample1[0])            // エラー
  print(chrSample1.subscript(0))  // エラー
}
</code></p>

<h3>まとめ</h3>

<p>案外ハマる場面がある気がするので、試しておくと良かったりしますね。<br/>
今回は単なるメモ書きでした。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dockerコンテナ内のUbuntuにSwiftサーバを立てよう！]]></title>
    <link href="http://grandbig.github.io/blog/2017/04/11/docker-for-mac-7/"/>
    <updated>2017-04-11T19:13:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2017/04/11/docker-for-mac-7</id>
    <content type="html"><![CDATA[<h3>はじめに</h3>

<p>さて本日はDockerつながりで『UbuntuにSwiftサーバを立ててみたい』と思います。<br/>
今後、ますます加熱する <strong>Server Side Swift</strong> を誰でも簡単に使えるように、きっとDockerを使う場面も増えてくることでしょう。<br/>
ということで早速見ていきたいと思います。</p>

<h3>Swiftのインストール方法</h3>

<p>次の手順に従って<code>swift</code>コマンドが叩けるところまで進めてみましょう。</p>

<p>１．KitematicでUbuntuを検索してDLする</p>

<p>まずはDockerコンテナを作ります。</p>

<p><img src="/images/docker_swift_1.png" alt="KitematicでUbuntuをダウンロード" /></p>

<p>※Ubuntuのバージョンは<code>Ubuntu 16.04.2 LTS</code>です。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<p>２．<code>Privileged mode</code>をONにする</p>

<p>Dockerコンテナのあるある話ですが、<code>Privileged mode</code>をONにしないとコマンド利用制限かかったりするので、忘れずにしておきましょう。</p>

<p><img src="/images/docker_swift_2.png" alt="Privileged modeをONにする" /></p>

<p>３．<code>PortFoward</code>を設定する</p>

<p>後々、Swiftサーバを立てた時にアクセスしたいので、Dockerにポートフォワード設定をしておきましょう。<br/>
後ほどSwiftサーバを起動したときに<code>8080</code>にアクセスすることになるので、</p>

<p><code>javascript
0.0.0.0:15700-&gt;8080/tcp
</code></p>

<p>という形でポートフォワードを設定します。<br/>
もちろんKitematicから設定可能です。</p>

<p>４．<code>apt-get</code>を最新化する</p>

<p>毎度のことですが、最新化しておきます。<br/>
まずは、Dockerコンテナにアクセスする。</p>

<p><code>javascript
$ docker exec -it ubuntu /bin/bash
</code></p>

<p>```javascript</p>

<h1>apt-get update</h1>

<h1>apt-get upgrade</h1>

<p>```</p>

<p>５．<code>wget</code>と<code>vim</code>をインストールする</p>

<p>後ほど利用するので<code>wget</code>と<code>vim</code>をインストールしておきます。</p>

<p>```javascript</p>

<h1>apt-get install wget</h1>

<h1>apt-get install vim</h1>

<p>```</p>

<p>６．Swiftサーバの依存モジュールをインストールする</p>

<p><a href="https://swift.org/download/#using-downloads">Swiftの公式サイト</a>にも書かれていますが、依存モジュールがあるのでインストールしましょう。</p>

<p>```javascript</p>

<h1>apt-get install clang libicu-dev</h1>

<p>```</p>

<p>７．Swiftパッケージをインストールする</p>

<p>Swiftサーバを立てるのに必要なものは2つあります。<br/>
それぞれ<code>wget</code>でインストールしましょう。<br/>
今回インストールするSwiftのバージョンは <strong>3.1</strong> です。</p>

<p>```javascript
// バイナリアーカイブの取得</p>

<h1>wget <a href="https://swift.org/builds/swift-3.1-release/ubuntu1604/swift-3.1-RELEASE/swift-3.1-RELEASE-ubuntu16.04.tar.gz">https://swift.org/builds/swift-3.1-release/ubuntu1604/swift-3.1-RELEASE/swift-3.1-RELEASE-ubuntu16.04.tar.gz</a></h1>

<p>// 署名ファイルの取得</p>

<h1>wget <a href="https://swift.org/builds/swift-3.1-release/ubuntu1604/swift-3.1-RELEASE/swift-3.1-RELEASE-ubuntu16.04.tar.gz.sig">https://swift.org/builds/swift-3.1-release/ubuntu1604/swift-3.1-RELEASE/swift-3.1-RELEASE-ubuntu16.04.tar.gz.sig</a></h1>

<p>```</p>

<p>８．PGP鍵をインポートする</p>

<p>次の手順で実施しますが、PGP(Pretty Good Privacy)の公開鍵を利用してSwiftパッケージが安全なものであると署名されたかどうかを検証します。<br/>
その前準備としてPGP鍵をインポートします。</p>

<p>```javascript</p>

<h1>gpg &mdash;keyserver hkp://pool.sks-keyservers.net \</h1>

<pre><code>  --recv-keys \
  '7463 A81A 4B2E EA1B 551F  FBCF D441 C977 412B 37AD' \
  '1BE1 E29A 084C B305 F397  D62A 9F59 7F4D 21A5 6D5F' \
  'A3BA FD35 56A5 9079 C068  94BD 63BC 1CFE 91D3 06C6'
</code></pre>

<p>gpg: requesting key 412B37AD from hkp server pool.sks-keyservers.net
gpg: requesting key 21A56D5F from hkp server pool.sks-keyservers.net
gpg: requesting key 91D306C6 from hkp server pool.sks-keyservers.net
gpg: /root/.gnupg/trustdb.gpg: trustdb created
gpg: key 412B37AD: public key &ldquo;Swift Automatic Signing Key #1 <a href="&#x6d;&#97;&#x69;&#108;&#116;&#111;&#58;&#x73;&#119;&#x69;&#102;&#116;&#x2d;&#x69;&#110;&#x66;&#x72;&#97;&#x73;&#116;&#x72;&#x75;&#99;&#116;&#x75;&#114;&#x65;&#x40;&#x73;&#119;&#x69;&#102;&#116;&#x2e;&#111;&#x72;&#x67;">&#x73;&#119;&#105;&#102;&#116;&#45;&#x69;&#x6e;&#x66;&#x72;&#x61;&#x73;&#116;&#x72;&#117;&#99;&#x74;&#117;&#x72;&#x65;&#x40;&#115;&#x77;&#105;&#102;&#x74;&#46;&#x6f;&#114;&#x67;</a>&rdquo; imported
gpg: key 21A56D5F: public key &ldquo;Swift 2.2 Release Signing Key <a href="&#109;&#x61;&#105;&#108;&#x74;&#111;&#x3a;&#x73;&#119;&#105;&#102;&#x74;&#x2d;&#105;&#110;&#x66;&#114;&#x61;&#115;&#116;&#x72;&#x75;&#99;&#116;&#x75;&#114;&#x65;&#64;&#x73;&#x77;&#x69;&#102;&#116;&#x2e;&#111;&#114;&#103;">&#x73;&#x77;&#105;&#x66;&#x74;&#x2d;&#105;&#x6e;&#x66;&#114;&#97;&#115;&#116;&#114;&#x75;&#x63;&#116;&#x75;&#x72;&#x65;&#x40;&#x73;&#119;&#105;&#102;&#116;&#x2e;&#111;&#x72;&#x67;</a>&rdquo; imported
gpg: key 91D306C6: public key &ldquo;Swift 3.x Release Signing Key <a href="&#109;&#97;&#105;&#108;&#116;&#x6f;&#x3a;&#115;&#119;&#105;&#102;&#116;&#45;&#105;&#110;&#102;&#114;&#x61;&#x73;&#x74;&#114;&#117;&#99;&#116;&#x75;&#114;&#x65;&#64;&#115;&#119;&#x69;&#102;&#116;&#x2e;&#111;&#114;&#103;">&#x73;&#x77;&#105;&#x66;&#x74;&#x2d;&#105;&#110;&#x66;&#114;&#97;&#115;&#x74;&#x72;&#117;&#99;&#x74;&#x75;&#x72;&#x65;&#64;&#x73;&#119;&#105;&#102;&#116;&#46;&#x6f;&#x72;&#x67;</a>&rdquo; imported
gpg: no ultimately trusted keys found
gpg: Total number processed: 3
gpg:               imported: 3  (RSA: 3)
```</p>

<p>９．PGP鍵で署名を検証する</p>

<p>公式で説明されている通り、<code>key</code>のリフレッシュをします。</p>

<p>```javascript</p>

<h1>gpg &mdash;keyserver hkp://pool.sks-keyservers.net &mdash;refresh-keys Swift</h1>

<p>```</p>

<p>続いて、署名を検証します。</p>

<p>```javascript</p>

<h1>gpg &mdash;verify swift-3.1-RELEASE-ubuntu16.04.tar.gz.sig</h1>

<p>gpg: assuming signed data in `swift-3.1-RELEASE-ubuntu16.04.tar.gz'
gpg: Signature made Tue Mar 28 07:36:36 2017 UTC using RSA key ID 91D306C6
gpg: Good signature from &ldquo;Swift 3.x Release Signing Key <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#x6f;&#58;&#115;&#x77;&#105;&#102;&#x74;&#45;&#x69;&#110;&#x66;&#x72;&#x61;&#115;&#116;&#x72;&#117;&#x63;&#x74;&#117;&#x72;&#x65;&#64;&#115;&#119;&#x69;&#x66;&#x74;&#x2e;&#x6f;&#x72;&#x67;">&#x73;&#x77;&#105;&#x66;&#x74;&#45;&#105;&#110;&#102;&#x72;&#97;&#115;&#x74;&#114;&#x75;&#x63;&#116;&#117;&#x72;&#x65;&#x40;&#x73;&#119;&#105;&#x66;&#x74;&#x2e;&#111;&#114;&#103;</a>&rdquo;
gpg: WARNING: This key is not certified with a trusted signature!
gpg:          There is no indication that the signature belongs to the owner.
Primary key fingerprint: A3BA FD35 56A5 9079 C068  94BD 63BC 1CFE 91D3 06C6
```</p>

<p>正しいSwiftパッケージであることがわかります。</p>

<p>１０．パッケージを展開する</p>

<p>パッケージは圧縮されているので展開しましょう。</p>

<p>```javascript</p>

<h1>tar xzf swift-3.1-RELEASE-ubuntu16.04.tar.gz</h1>

<p>```</p>

<p>１１．パスを通す</p>

<p>さて、DLしたパッケージに対して検索パスを設定する必要があります。<br/>
Dockerコンテナには環境設定ファイルとして<code>.dockerenv</code>があるのでこちらにパスを記載します。</p>

<p>```javascript
// 解凍フォルダの名前が長いので名称を変更する</p>

<h1>mv swift-3.1-RELEASE-ubuntu16.04 swift</h1>

<p>// ファイルを開く</p>

<h1>vi .dockerenv</h1>

<p>// 下記のようにパスを書く
export PATH=/swift/usr/bin:&ldquo;${PATH}&rdquo;</p>

<p>// 環境設定を更新する</p>

<h1>source .dockerenv</h1>

<p>// 検索パスが通ったことを確認する</p>

<h1>which swift</h1>

<p>/swift/usr/bin/swift</p>

<h1>swift &mdash;version</h1>

<p>Swift version 3.1 (swift-3.1-RELEASE)
Target: x86_64-unknown-linux-gnu
```</p>

<p>１２．必要なモジュールをインストールする</p>

<p>このままで<code>swift</code>コマンドを叩いても下記のようにエラーが表示されます。</p>

<p><code>javascript
/swift/usr/bin/lldb: error while loading shared libraries: libedit.so.2: cannot open shared object file: No such file or directory
</code></p>

<p>どうやら必要なモジュールが足りないようですね&hellip;<br/>
ということで下記をインストールしましょう。</p>

<p>```javascript</p>

<h1>apt-get install libedit-dev</h1>

<h1>apt-get install libpython-dev</h1>

<h1>apt-get install libxml2-dev</h1>

<p>```</p>

<p>これで<code>swift</code>コマンドを実行できるようになります。<br/>
ついでに<code>Hello World</code>まで出力してみます。</p>

<p>```javascript</p>

<h1>swift</h1>

<p>Welcome to Swift version 3.1 (swift-3.1-RELEASE). Type :help for assistance.
  1> print(&ldquo;Hello, world!&rdquo;)
Hello, world!
```</p>

<h3>PerfectでSwiftサーバを立てよう！</h3>

<p>今回もSwiftサーバを立てるために<a href="https://github.com/PerfectlySoft/Perfect">Perfect</a>を利用します。<br/>
下記手順に従って進めましょう。</p>

<p>１．<code>git</code>をインストールする<br/>
まずは<code>Perfect</code>を<code>git</code>経由でダウンロードする必要があるので<code>git</code>をインストールしましょう。</p>

<p>```javascript</p>

<h1>apt-get install git</h1>

<p>```</p>

<p>２．<code>PerfectTemplate</code>をダウンロードする<br/>
簡潔にSwiftサーバを立てたいので<code>PerfectTemplate</code>をダウンロードします。</p>

<p>```javascript</p>

<h1>git clone <a href="https://github.com/PerfectlySoft/PerfectTemplate.git">https://github.com/PerfectlySoft/PerfectTemplate.git</a></h1>

<p>```</p>

<p>３．必要モジュールをインストールする<br/>
PerfectのGet Startedに書かれている通り、次の必要なモジュールをインストールします。</p>

<p>```javascript</p>

<h1>apt-get install openssl libssl-dev uuid-dev</h1>

<p>```</p>

<p>４．不足モジュールをインストールする<br/>
このままだと<code>swift build</code>実行しても下記エラーが出てしまいました。</p>

<p><code>javascript
error while loading shared libraries: libcurl.so.4: cannot open shared object file: No such file or directory
</code></p>

<p>上記解決のためにモジュールをインストールしましょう。</p>

<p>```javascript</p>

<h1>apt-get install libcurl4-openssl-dev</h1>

<p>```</p>

<p>５．<code>swift build</code>を実行する<br/>
さて、ビルドしましょう。</p>

<p>```javascript</p>

<h1>cd PerfectTemplate</h1>

<h1>swift build</h1>

<p>```</p>

<p>６．Swiftサーバを起動する<br/>
後は下記コマンドでSwiftサーバを起動しましょう。</p>

<p>```javascript</p>

<h1>.build/debug/PerfectTemplate</h1>

<p>[INFO] Starting HTTP server localhost on 0.0.0.0:8080
[INFO] Starting HTTP server localhost on 0.0.0.0:8181
```</p>

<p><img src="/images/docker_swift_3.png" alt="Swiftサーバにアクセス" /></p>

<h3>まとめ</h3>

<p>さていかがでしたでしょうか？<br/>
筆者個人としては、途中で何回かハマったものの、DockerコンテナのUbuntuにSwiftサーバを立てられたことに満足できました。<br/>
今回はサーバを立てるという基本的なものでしたが、今度はWeb APIを作成して、iOSアプリからアクセスしてみたりなど遊んでみたいと思います。</p>

<p>と言ったところで本日はここまで。</p>

<p>参考:</p>

<ul>
<li><a href="https://www.twilio.com/blog/2015/12/getting-started-with-swift-on-linux.html">Getting Started with Swift on Linux</a></li>
<li><a href="http://qiita.com/yonell/items/79bf4ee3cd65f69903ec">Ubuntu上でSwiftサーバーサイドフレームワークのPerfectを動かしてみた</a></li>
</ul>


<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SwinjectでDIを意識してみよう！]]></title>
    <link href="http://grandbig.github.io/blog/2017/04/09/swift-di/"/>
    <updated>2017-04-09T22:51:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2017/04/09/swift-di</id>
    <content type="html"><![CDATA[<h3>はじめに</h3>

<p>筆者はここ１年間、主にバックエンド構築にSpring Bootを利用してきました。<br/>
Spring Framework自体は2002年頃にリリースされたそうなのですが、Spring BootはSpringベースでのアプリ開発を楽にしてくれる新たな形で様々なSpringのFramework群を統合したものとのことです。<br/>
(Spring Bootでググると2〜3年前辺りからの記事が多い印象です。)</p>

<p>Springの特徴は何と言っても <strong>DI</strong> でしょう。<br/>
今回はそのSpringの代名詞とも言える <strong>DI</strong> をSwiftで扱ってみたいと思います。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h3>DIとは</h3>

<p>DIとは『Dependency Injection』の略語で、日本語だと依存性の注入と翻訳されたりします。<br/>
具体的に何者なのかと言うと、</p>

<ul>
<li>コンポーネント間の依存関係を排除するソフトウェアパターン (<a href="https://ja.wikipedia.org/wiki/%E4%BE%9D%E5%AD%98%E6%80%A7%E3%81%AE%E6%B3%A8%E5%85%A5">Wikipedia &ndash; 依存性の注入</a>)</li>
<li>これにより疎結合性が高まるので単体テストが書きやすい</li>
</ul>


<p>というものです。</p>

<p>Springベースのアプリでは基本パターンとして利用しています。<br/>
詳しい説明は省きますが、<br/>
Spring起動時に<code>Bean</code>化したオブジェクトを<code>@Autowired</code>アノテーションを利用することで、DIコンテナ経由で簡単に <strong>DI</strong> を利用することができます。</p>

<p>注意しておきたいこととして、<br/>
<code>Bean</code>定義したクラスは<code>@Autowired</code>アノテーションで呼び出される際、デフォルトでシングルトンパターンとして生成されたオブジェクトを呼び出しています。</p>

<h3>SwiftでDIするには？</h3>

<p>さて、そんなSpringの特徴的なDIですが、Swiftアプリで利用することはできるのでしょうか？<br/>
筆者が調べたところ、最も人気のあるSwift版DIライブラリとして<a href="https://github.com/Swinject/Swinject">Swinject</a>というものがあるようです。<br/>
本日時点でGitHub上のスター数が<code>1,432</code>となっており、なかなかの注目度かと思います。</p>

<p>しかも、下記のようにSwift3にも対応しているのが嬉しいですね！</p>

<p><code>objective-c
iOS 8.0+ / Mac OS X 10.10+ / watchOS 2.0+ / tvOS 9.0+
Swift 2.2 or 2.3
Xcode 7.0+
Swift 3
Xcode 8.0+
Carthage 0.18+ (if you use)
CocoaPods 1.1.1+ (if you use)
</code></p>

<p>実際に<code>Swinject</code>を利用してSwiftでのDIを試してみたいと思います。</p>

<h3>Swinjectの使い方</h3>

<p>では早速使ってみましょう。</p>

<h4>Swinjectのインストール</h4>

<p>CocoaPodsでインストールするために下記のように<code>Podfile</code>を作成しましょう。</p>

<p>```
// Podfile
source &lsquo;<a href="https://github.com/CocoaPods/Specs.git">https://github.com/CocoaPods/Specs.git</a>&rsquo;
platform :ios, &lsquo;8.0&rsquo; # or platform :osx, &lsquo;10.10&rsquo; if your target is OS X.</p>

<p>target &lsquo;SwinjectSample&rsquo; do
  use_frameworks!</p>

<p>  pod &lsquo;Swinject&rsquo;, &lsquo;~> 2.0.0&rsquo;
  pod &lsquo;SwinjectStoryboard&rsquo;, &lsquo;1.0.0&rsquo;
end
```</p>

<p>その後に<code>pod install</code>を実行しましょう。<br/>
これで<code>Swinject</code>の用意は完了です。</p>

<h4>DIしたいクラスの定義</h4>

<p>サンプルとしてDIしたいクラスを定義します。<br/>
具体的なクラスだけでなく <strong>プロトコル</strong> を定義しているのは、<br/>
後々、同じような<code>JavaProgrammer</code>クラスを作成したくなった際に便利だからです。<br/>
(ベースが同じで、拡張機能が必要になった際に、0から書き直す必要がなくなります。)</p>

<p>```objective-c
// Engineer.swift
import Foundation</p>

<p>protocol Engineer {</p>

<pre><code>var name: String? { get set }
func develop() -&gt; String
</code></pre>

<p>}</p>

<p>class SwiftProgrammer: Engineer {</p>

<pre><code>var name: String?

init(name: String?) {
    self.name = name
}

func develop() -&gt; String {
    return "Let's start developing a swift application!"
}
</code></pre>

<p>}
```</p>

<p>続いて、先程作成した<code>Engineer</code>を参照する<code>CompanyOwner</code>クラスを作成します。</p>

<p>```objective-c
// Company.swift
import Foundation</p>

<p>protocol Person {</p>

<pre><code>func hire() -&gt; String
</code></pre>

<p>}</p>

<p>class CompanyOwner: Person {</p>

<pre><code>let humanResource: Engineer

init(humanResource: Engineer) {
    self.humanResource = humanResource
}

func hire() -&gt; String {
    let name = humanResource.name ?? "someone"
    return "I'm hiring \(name). \(humanResource.develop())"
}
</code></pre>

<p>}
```</p>

<p>ここで<code>SwiftProgrammer</code>クラスでなく<code>Engineer</code>プロトコルを参照することで、<code>CompanyOwner</code>クラス自体が<code>SwiftProgrammer</code>クラスに依存することがなくなりました。<br/>
つまり<code>JavaProgrammer</code>を雇いたい<code>CompanyOwner</code>クラスが必要になった場合、作成するのは<code>JavaProgrammer</code>クラスのみで良くなります。<br/>
これはこれで<code>CompanyOwner</code>クラスに対して単体テストコードを書く時に<code>SwiftProgrammer</code>クラスに依存せずに書くことができます。</p>

<h4>DIコンテナへのクラスの登録</h4>

<p>さて、DIしたいクラスが定義できたので、そのクラスをDIコンテナに登録します。<br/>
公式ページによると<code>SwinjectStoryboard</code>を利用する場合と利用しない場合の2種類の方法があるそうですが、今回は簡単に対応可能な<code>SwinjectStoryboard</code>利用する方法で書いてみます。</p>

<p>サンプルとして、<code>ViewController.swift</code>でDIコンテナ経由で呼び出したクラスを利用したいとします。<br/>
その場合、下記のように、<code>ViewController.swift</code>にコンテナ定義を書きます。</p>

<p>```objective-c
// ViewController.swift
import UIKit
import SwinjectStoryboard</p>

<p>extension SwinjectStoryboard {</p>

<pre><code>class func setup() {
    // (1)
    defaultContainer.register(Engineer.self) { _ in SwiftProgrammer(name: "Takahiro") }
    // (2)
    defaultContainer.register(Person.self) { r in
        CompanyOwner(humanResource: r.resolve(Engineer.self)!)
    }
    // (3)
    defaultContainer.storyboardInitCompleted(ViewController.self) { r, c in
        c.person = r.resolve(Person.self)
    }
}
</code></pre>

<p>}
&hellip;
```</p>

<p>順々に説明すると、</p>

<ol>
<li><code>defaultContainer</code>に<code>Engineer</code>指定で<code>SwiftProgrammer(name: "Takahiro")</code>が呼び出されるように登録</li>
<li><code>defaultContainer</code>に<code>Person</code>指定で<code>CompanyOwner(humanResource: r.resolve(Engineer.self)!)</code>が呼び出されるように登録<br/>
※ 1で<code>Engineer</code>指定で<code>SwiftProgrammer(name: "Takahiro")</code>呼び出しをセットしているので、それが2の<code>CompanyOwner</code>の引数にセットされます。</li>
<li><code>defaultContainer</code>にDIコンテナ経由での呼び出し先と先ほどまで定義していた<code>Person</code>指定での呼び出し元を紐付け</li>
</ol>


<p>となっています。<br/>
これにより、下記のように<code>ViewController.swift</code>内でDIコンテナ経由で<code>Person</code>指定で想定した処理を呼び出すことができます。</p>

<p>```objective-c
// ViewController.swift</p>

<p>class ViewController: UIViewController {</p>

<pre><code>var person: Person?

override func viewDidLoad() {
    super.viewDidLoad()
    // Do any additional setup after loading the view, typically from a nib.
    print(person?.hire() ?? "I can't hire engineers.")
}

override func didReceiveMemoryWarning() {
    super.didReceiveMemoryWarning()
    // Dispose of any resources that can be recreated.
}
</code></pre>

<p>}
```</p>

<p>上記を見ると、<code>ViewController</code>クラスの中で<code>Person</code>をインスタンス化している箇所はないことがわかると思います。<br/>
つまり、DIコンテナ経由で<code>Person</code>を呼び出せているわけですね。</p>

<h3>まとめ</h3>

<p>さて、<code>Swinject</code>を利用してサンプルを書いてみた感想ですが&hellip;<br/>
正直、Spring Bootと比較すると、Swiftでは手動で書くべきところが多いと感じました。<br/>
また、様々な<code>UIViewController</code>にまたがって利用する場合は記載箇所に一工夫必要なのかなとも思いました。<br/>
(毎回、全<code>UIViewController</code>系のファイルに<code>setUp()</code>を書くわけにもいかないと思いますし&hellip;)</p>

<p>まだまだ未知数なところがあるので、継続して試してみたいところではあります。<br/>
と言ったところで本日はここまで。</p>

<p>参考：</p>

<ul>
<li><a href="http://permanent-til.me/archives/613">Spring BeanはSingletonだから、状態持たせるとバグるよ。</a></li>
<li><a href="http://qiita.com/chkkchy/items/5f59817beb3dff9c0c1e">SpringのDIとnewってなにがちがうんだっけ？</a></li>
<li><a href="https://github.com/Swinject/Swinject">Swinject</a></li>
<li><a href="http://dev.classmethod.jp/smartphone/swinject-dependency-injection/">Swinjectを使ったDependency Injection</a></li>
</ul>


<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Notificationとメインスレッド/サブスレッド]]></title>
    <link href="http://grandbig.github.io/blog/2017/02/12/notification-and-thread/"/>
    <updated>2017-02-12T17:15:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2017/02/12/notification-and-thread</id>
    <content type="html"><![CDATA[<h3>はじめに</h3>

<p>今日は久々にiOS関連の話を書きたいと思います。<br/>
正直なところSwiftを触って思ったのですが、今やXcodeではSwift3が標準装備されているため書き方が変わっており、業務で触らないまでも遅れを取らないように勉強しなきゃな&hellip;なんて感じてしまいました。</p>

<p>本日のお題は<br/>
『<code>Notification</code>はメインスレッド/サブスレッドのどちらで実行されるのか』<br/>
という話です。</p>

<p>筆者の理解では、普通に使う限りメインスレッドだと思っていたのですが、「使い方に寄るのでは？」なんて話題が上がったこともあって、調べてみたくなりました。<br/>
その調べ方と調査結果を書いていきます。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h3>Notificationとは</h3>

<p>まずは、<code>Notification</code>とは何かという話から始めましょう。<br/>
その名の通り、アプリ内で通知を行う仕組みを実装するために利用します。<br/>
少し前までは<code>NSNotification</code>という名前でしたので、こちらの名前の方がしっくりくるiOSエンジニアの方々は多いのではないでしょうか。</p>

<p>使い方は非常に簡単です。</p>

<p>１．監視対象のメソッドを登録する</p>

<p><img src="/images/notification_1.png" alt="監視対象のメソッドを登録" /></p>

<p><code>objective-c
// 登録時にはaddObserverメソッドを利用する
NotificationCenter.default.addObserver(self, selector: #selector(self.doSomething), name: NSNotification.Name("SomeNotification"), object: nil)
</code></p>

<p>２．監視対象メソッドの呼び出しを要求する</p>

<p><img src="/images/notification_2.png" alt="監視対象メソッドの呼び出し要求" /></p>

<p><code>objective-c
// 呼び出し要求時にはpostメソッドを利用する
NotificationCenter.default.post(name: NSNotification.Name("SomeNotification"), object: nil)
</code></p>

<p>３．監視対象メソッドを実行する</p>

<p><img src="/images/notification_3.png" alt="監視対象メソッドを実行" /></p>

<h3>Notificationとメインスレッド/サブスレッドの調査</h3>

<p>さて、本題に入ります。<br/>
<code>Notification</code>はメインスレッド/サブスレッドどちらで実行されるのでしょうか。</p>

<h4>普通に呼び出す場合</h4>

<p>まずは特異なことをせず、普通に実行してみます。<br/>
要件としては下記になります。</p>

<ul>
<li>アプリ起動時に<code>doSomething</code>メソッドを<code>NotificationCenter</code>に登録する</li>
<li>ボタンタップ時に<code>doSomething</code>メソッドの呼び出しを要求する</li>
<li><code>doSomething</code>メソッド内でメインスレッド/サブスレッドの判定処理を実行する</li>
</ul>


<p>ソースコードは下記となります。</p>

<p>```objective-c
// ViewController.swift
import UIKit</p>

<p>class ViewController: UIViewController {</p>

<pre><code>override func viewDidLoad() {
    super.viewDidLoad()
    NotificationCenter.default.addObserver(self, selector: #selector(doSomething), name: NSNotification.Name("SomeNotification"), object: nil)
}

override func didReceiveMemoryWarning() {
    super.didReceiveMemoryWarning()
}

func doSomething() {
    print("このメソッドは\(Thread.isMainThread)で動いています。(false: サブスレッド, true: メインスレッド)")
}
@IBAction func checkThread(_ sender: Any) {
    NotificationCenter.default.post(name: NSNotification.Name("SomeNotification"), object: nil)
}
</code></pre>

<p>}
```</p>

<p>結果は「呼び出し先の処理実行は <strong>メインスレッド</strong> 」となりました。</p>

<h4>GCDを利用して、サブスレッド内でメソッドを呼び出す</h4>

<p>次はサブスレッドで監視対象メソッドの呼び出し要求を実施します。<br/>
ソースコードは下記の通りです。</p>

<p>```objective-c
import UIKit</p>

<p>class ViewController: UIViewController {</p>

<pre><code>override func viewDidLoad() {
    super.viewDidLoad()
    NotificationCenter.default.addObserver(self, selector: #selector(doSomething), name: NSNotification.Name("SomeNotification"), object: nil)
}

override func didReceiveMemoryWarning() {
    super.didReceiveMemoryWarning()
}

func doSomething() {
    print("このメソッドは\(Thread.isMainThread)で動いています。(0: サブスレッド, 1: メインスレッド)")
}
@IBAction func checkThread(_ sender: Any) {
    DispatchQueue.global().async {
        NotificationCenter.default.post(name: NSNotification.Name("SomeNotification"), object: nil)
    }
}
</code></pre>

<p>}
```</p>

<p>結果は「呼び出し先の処理実行は <strong>サブスレッド</strong> 」となりました。</p>

<h4>GCDを利用して、メインスレッド内でメソッドを呼び出す</h4>

<p>今度はGCDを利用したメインスレッド内で監視対象メソッドの呼び出し要求を実施してみます。<br/>
ソースコードは下記の通りです。</p>

<p>```objective-c
import UIKit</p>

<p>class ViewController: UIViewController {</p>

<pre><code>override func viewDidLoad() {
    super.viewDidLoad()NotificationCenter.default.addObserver(self, selector: #selector(doSomething), name: NSNotification.Name("SomeNotification"), object: nil)
}

override func didReceiveMemoryWarning() {
    super.didReceiveMemoryWarning()
}

func doSomething() {
    print("このメソッドは\(Thread.isMainThread)で動いています。(0: サブスレッド, 1: メインスレッド)")
}
@IBAction func checkThread(_ sender: Any) {
    DispatchQueue.global().async {
        DispatchQueue.main.async {
            NotificationCenter.default.post(name: NSNotification.Name("SomeNotification"), object: nil)
        }
    }
}
</code></pre>

<p>}
```</p>

<p>結果は「呼び出し先の処理実行は <strong>メインスレッド</strong> 」となりました。</p>

<h3>まとめ</h3>

<p>調査結果をまとめると次の通りです。</p>

<p>「要求 <strong>元</strong> と <strong>同じスレッド</strong> で監視対象メソッドは実行されます。」<br/>
※登録時(<code>addObserver</code>)のスレッドは無関係です。</p>

<p>さて如何でしたでしょうか？<br/>
普段考えずに利用している様々な処理が実際にはどのスレッドで実行されるのか、どういった書き方をするとどのスレッドで実行されうるのか調べてみることも面白いですね。<br/>
ふとしたときにまた調べてみようと思います。<br/>
と言ったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
</feed>
