<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: swift | Takahiro Octopress Blog]]></title>
  <link href="http://grandbig.github.io/blog/categories/swift/atom.xml" rel="self"/>
  <link href="http://grandbig.github.io/"/>
  <updated>2017-07-23T16:19:35+09:00</updated>
  <id>http://grandbig.github.io/</id>
  <author>
    <name><![CDATA[Takahiro]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[AlamofireImageを使ってみよう！]]></title>
    <link href="http://grandbig.github.io/blog/2017/07/23/alamofireimage/"/>
    <updated>2017-07-23T15:35:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2017/07/23/alamofireimage</id>
    <content type="html"><![CDATA[<h3>はじめに</h3>

<p>本日は何気に今まで使ってこなかった<a href="https://github.com/Alamofire/AlamofireImage">AlamofireImage</a>についてメモ書きです。<br/>
キャッシュコントロールやら同期/非同期での画像取得など考えなくても良いというのはパワー的にかなり楽になりますね。<br/>
ということで早速見ていきましょう。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h3>API経由で取得した画像URLを使ってUIImageViewに画像を表示する</h3>

<h4>テストとして利用するAPI</h4>

<p>今回はテスト用APIとして<a href="https://webservice.recruit.co.jp/hotpepper/reference.html">ホットペッパーのグルメサーチAPI</a>を利用しました。</p>

<p>ホットペッパーAPIを利用するには新規登録して<code>API Key</code>をゲットする必要があります。<br/>
また、前提として取得した<code>API Key</code>は<code>key.plist</code>に書いているとします。</p>

<p><img src="/images/alamofireimage_1.png" alt="API Keyをkey.plistに書き出し" /></p>

<p>上記準備をした上で下記クラスを作成しました。</p>

<p>```objective-c
// HotpepperAPI.swift
import Foundation
import CoreLocation
import Alamofire
import SwiftyJSON</p>

<p>/<em>*
 ホットペッパーAPI
 </em>/
class HotpepperAPI {
  /// API Key
  private var apiKey: String = String()
  /// ホットペッパーAPIのベースURL
  private let baseURL: String = &ldquo;<a href="https://webservice.recruit.co.jp/hotpepper/gourmet/v1/">https://webservice.recruit.co.jp/hotpepper/gourmet/v1/</a>&rdquo;</p>

<p>  /// 初期化処理
  init() {</p>

<pre><code>if let path = Bundle.main.path(forResource: "key", ofType: "plist") {
  if let dic = NSDictionary(contentsOfFile: path) as? [String: Any] {
    if let apiKey = dic["hotpepperApiKey"] as? String {
      self.apiKey = apiKey
    }
  }
}
</code></pre>

<p>  }</p>

<p>  /**
   ホットペッパーグルメサーチAPI</p>

<ul>
<li> parameter coordinate: 位置</li>
<li><p> parameter completion: レストラン情報を返却するcallback
*/
func searchRestaurant(coordinate: CLLocationCoordinate2D, completion: @escaping ((JSON) &ndash;> Void)) {
let parameters = [&ldquo;key&rdquo;: self.apiKey, &ldquo;format&rdquo;: &ldquo;json&rdquo;, &ldquo;lat&rdquo;: coordinate.latitude, &ldquo;lng&rdquo;: coordinate.longitude, &ldquo;range&rdquo;: 2] as [String : Any]
Alamofire.request(baseURL, method: .get, parameters: parameters, encoding: URLEncoding.default, headers: nil).responseJSON { response in
  let json = JSON(response.result.value as Any)
  let result = json[&ldquo;results&rdquo;][&ldquo;shop&rdquo;]</p>

<p>  completion(result)
}
}
}
```</p></li>
</ul>


<h4>テストとして用意するUIImageView</h4>

<p>今回はテストとして <strong>マップにプロットしたマーカをタップしたときに表示するInfoWindow内にUIImageViewを用意する</strong> ようにしました。</p>

<p>【準備事項】<br/>
&ndash; Google Maps SDK for iOSをマップとして利用<br/>
&ndash; マーカタップ時に表示されるInfoWindowをカスタム化</p>

<p>表示するViewとしては下図のようになります。<br/>
<img src="/images/alamofireimage_2.png" alt="MarkerInfoContentsView.xib" /></p>

<h4>AlamofireImageの用意</h4>

<p>では肝心な<code>AlamofireImage</code>の導入を見てみましょう。<br/>
<code>CocoaPods</code>で簡単に導入が可能です。</p>

<p>```objective-c</p>

<h1>Podfile</h1>

<p>use_frameworks!
platform :ios, &lsquo;10.0&rsquo;</p>

<p>target &ldquo;SampleApp&rdquo; do
  # Normal libraries
  &hellip;
  pod &lsquo;AlamofireImage&rsquo;, &lsquo;~> 3.1&rsquo;
end</p>

<p>post_install do |installer|
  installer.pods_project.targets.each do |target|</p>

<pre><code>target.build_configurations.each do |config|
  config.build_settings['SWIFT_VERSION'] = '3.0'
end
</code></pre>

<p>  end
end
```</p>

<h4>マーカタップ時に表示するInfoWindowに画像を表示する</h4>

<p>まずは<code>InfoWindow</code>をカスタム化したクラスである<code>MarkerInfoContentsView.swift</code>のソースコードを書きます。</p>

<p>```objective-c
// MarkerInfoContentsView.swift
import Foundation
import UIKit
import AlamofireImage</p>

<p>class MarkerInfoContentsView: UIView {</p>

<p>  @IBOutlet weak var shopName: UILabel!
  @IBOutlet weak var categoryName: UILabel!
  @IBOutlet weak var shopImage: UIImageView!</p>

<p>  override init(frame: CGRect) {</p>

<pre><code>super.init(frame: frame)
self.xibViewSet()
</code></pre>

<p>  }</p>

<p>  required init?(coder aDecoder: NSCoder) {</p>

<pre><code>super.init(coder: aDecoder)!
self.xibViewSet()
</code></pre>

<p>  }</p>

<p>  internal func xibViewSet() {</p>

<pre><code>if let view = Bundle.main.loadNibNamed("MarkerInfoContentsView", owner: self, options: nil)?.first as? UIView {
  view.frame = self.bounds
  self.addSubview(view)
}
</code></pre>

<p>  }</p>

<p>  /**</p>

<pre><code>データの設定処理

- parameter shopName: 店舗名
- parameter categoryName: カテゴリ名
- parameter shopImageURLString: 画像URL
</code></pre>

<p>   */
  func setData(shopName: String?, categoryName: String?, shopImageURLString: String?) {</p>

<pre><code>// 店舗名の設定
if let shopNameTextCount = shopName?.characters.count, shopNameTextCount &gt; 0 {
  self.shopName.text = shopName
} else {
  self.shopName.text = "店舗名不明"
  self.shopName.textColor = UIColor.gray
}
// 詳細説明の設定
if let categoryNameTextCount = categoryName?.characters.count, categoryNameTextCount &gt; 0 {
  self.categoryName.text = categoryName
} else {
  self.categoryName.text = "カテゴリ不明"
  self.categoryName.textColor = UIColor.gray
}
// 画像の設定
if let shopImageURLStringTextCount = shopImageURLString?.characters.count, shopImageURLStringTextCount &gt; 0 {
  if let shopImageURL = URL(string: shopImageURLString!) {
    self.shopImage.af_setImage(withURL: shopImageURL, placeholderImage: UIImage(named: "NoImageIcon"))
  } else {
    self.shopImage.image = UIImage(named: "NoImageIcon")
  }
} else {
  self.shopImage.image = UIImage(named: "NoImageIcon")
}    
</code></pre>

<p>  }
}
```</p>

<p>実際に<code>AlamofireImage</code>を利用して画像URLから取得した画像データを格納している箇所は、</p>

<p><code>objective-c
self.shopImage.af_setImage(withURL: shopImageURL, placeholderImage: UIImage(named: "NoImageIcon"))
</code></p>

<p>になります。<br/>
続いて、<code>ViewController.swift</code>での<code>GMSMapViewDelegate</code>部分の処理を抜粋して書きます。</p>

<p>```objective-c
// ViewController.swift
extension ViewController: GMSMapViewDelegate {
  func mapView(_ mapView: GMSMapView, markerInfoWindow marker: GMSMarker) &ndash;> UIView? {</p>

<pre><code>guard let cMarker = marker as? CustomGMSMarker else {
  return nil
}
cMarker.tracksInfoWindowChanges = true
let view = MarkerInfoContentsView(frame: CGRect(x: 0, y: 0, width: 250, height: 265))
view.setData(shopName: cMarker.shopName, categoryName: cMarker.categoryName, shopImageURLString: cMarker.imageURL)
return view
}
</code></pre>

<p>}
```</p>

<p>重要なのは、 <strong><code>cMarker.tracksInfoWindowChanges = true</code></strong> です。<br/>
これを書かないと <strong>画像URLから画像データを取得したタイミングで<code>InfoWindow</code>の画像を更新する</strong>ということができなくなります。<br/>
(<code>placeholderImage</code>として用意した画像がずっと表示されてしまいます。)</p>

<p>筆者はここでドハマリして試行錯誤してしまいました。<br/>
非同期で画像データを取得しに行っているので、データ取得前に<code>InfoWindow</code>の描画処理に進んでしまうということはわかるのですが、どうすれば想定した挙動が実現できるのか悩みました。<br/>
ですが、蓋を開けてみれば何ということもなかったんですよね。</p>

<h3>まとめ</h3>

<p>さて、如何でしたでしょうか？<br/>
画像取得/キャッシュ関連のOSSライブラリは多種多様なものが出ており、好き嫌いもあるかもしれませんが、筆者は通信ライブラリに<code>Alamofire</code>を使うことが多いため、<code>AlamofireImage</code>も嫌いではないんですよね。<br/>
と言ったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Geocoding APIとDirections APIを使ってみよう！]]></title>
    <link href="http://grandbig.github.io/blog/2017/07/17/google-maps-api/"/>
    <updated>2017-07-17T22:32:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2017/07/17/google-maps-api</id>
    <content type="html"><![CDATA[<h3>はじめに</h3>

<p>本日はGoogleが提供している<a href="https://developers.google.com/maps/documentation/geocoding/intro?hl=ja">Geocoding API</a>と<a href="https://developers.google.com/maps/documentation/directions/?hl=ja">Directions API</a>をiOSで使ってみた話を書きます。</p>

<p>まずは、Google Cloud Platform > API Managerから <strong>Geocoding API</strong> と <strong>Directions API</strong> を有効にしましょう。</p>

<p><img src="/images/google_api_1.png" alt="API Manager" /></p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h3>Geocoding APIの利用</h3>

<p>Googleから提供されたAPIを利用し、それがJSON形式が返却されるため、<code>Alamofire</code>と<code>SwiftyJSON</code>をあわせて利用します。</p>

<p>因みに、APIキーは<a href="http://grandbig.github.io/blog/2017/06/18/google-maps-sdk/">Google Maps SDK for iOSを導入してみよう！</a>で説明した通り<code>key.plist</code>に記載することでGitHubにアップすることを避けています。</p>

<p>今回実装する処理は <strong>住所を緯度/経度に変換する処理</strong> になります。</p>

<p>```objective-c
import CoreLocation
import Alamofire
import SwiftyJSON</p>

<p>class Geocoding {</p>

<p>  /// API Key
  private var apiKey: String = String()
  /// Geocoding APIのベースURL
  private let baseURL: String = &ldquo;<a href="https://maps.googleapis.com/maps/api/geocode/json?language=ja">https://maps.googleapis.com/maps/api/geocode/json?language=ja</a>&rdquo;</p>

<p>  /// 初期化処理
  init() {</p>

<pre><code>if let path = Bundle.main.path(forResource: "key", ofType: "plist") {
  if let dic = NSDictionary(contentsOfFile: path) as? [String: Any] {
    if let apiKey = dic["googleWebApiKey"] as? String {
      self.apiKey = apiKey
    }
  }
}
</code></pre>

<p>  }</p>

<p>  /**
   ジオコーディング</p>

<ul>
<li> parameter address: 住所</li>
<li><p> parameter completion: 緯度/経度を返すcallback
*/
func geocoding(address: String, completion: @escaping ((CLLocationCoordinate2D) &ndash;> Void)) {
let requestURL = &ldquo;(baseURL)&amp;key=(String(describing: self.apiKey))&rdquo;
Alamofire.request(requestURL, method: .get, parameters: [&ldquo;address&rdquo;: address], encoding: URLEncoding.default, headers: nil).responseJSON { response in
  let json = JSON(response.result.value as Any)</p>

<p>  guard let latitude = json[&ldquo;results&rdquo;][0][&ldquo;geometry&rdquo;][&ldquo;location&rdquo;][&ldquo;lat&rdquo;].double else {
    return
  }</p>

<p>  guard let longitude = json[&ldquo;results&rdquo;][0][&ldquo;geometry&rdquo;][&ldquo;location&rdquo;][&ldquo;lng&rdquo;].double else {
    return
  }</p>

<p>  completion(CLLocationCoordinate2D.init(latitude: latitude, longitude: longitude))
}
}<br/>
}
```</p></li>
</ul>


<h3>Directions APIの利用</h3>

<p>ここで実装する処理は <strong>開始地点から終了地点までの道順を取得する処理</strong> になります。</p>

<p>```objective-c
import CoreLocation
import Alamofire
import SwiftyJSON</p>

<p>class Direction {</p>

<p>  /// API Key
  private var apiKey: String = String()
  /// Geocoding APIのベースURL
  private let baseURL: String = &ldquo;<a href="https://maps.googleapis.com/maps/api/directions/json?language=ja&amp;mode=walking">https://maps.googleapis.com/maps/api/directions/json?language=ja&amp;mode=walking</a>&rdquo;</p>

<p>  /// 初期化処理
  init() {</p>

<pre><code>if let path = Bundle.main.path(forResource: "key", ofType: "plist") {
  if let dic = NSDictionary(contentsOfFile: path) as? [String: Any] {
    if let apiKey = dic["googleWebApiKey"] as? String {
      self.apiKey = apiKey
    }
  }
}
</code></pre>

<p>  }</p>

<p>  /**
   目的地までの道順を取得</p>

<ul>
<li> parameter from: 開始地点</li>
<li> parameter to: 終了地点</li>
<li><p> parameter completion: 道順を返すcallback
*/
func getRoutes(from: CLLocationCoordinate2D, to: CLLocationCoordinate2D, completion: @escaping ((JSON) &ndash;> Void)) {
let requestURL = &ldquo;(baseURL)&amp;key=(String(describing: self.apiKey))&rdquo;
let parameters = [&ldquo;origin&rdquo;: &ldquo;(from.latitude),(from.longitude)&rdquo;, &ldquo;destination&rdquo;: &ldquo;(to.latitude),(to.longitude)&rdquo;]
Alamofire.request(requestURL, method: .get, parameters: parameters, encoding: URLEncoding.default, headers: nil).responseJSON { response in
  let json = JSON(response.result.value as Any)
  let steps = json[&ldquo;routes&rdquo;][0][&ldquo;legs&rdquo;][0][&ldquo;steps&rdquo;]</p>

<p>  completion(steps)
}
}
}
```</p></li>
</ul>


<h3>まとめ</h3>

<p>今回はGoogleが提供している <strong>Geocoding API</strong> と <strong>Directions API</strong> について見てみました。<br/>
Google Mapを利用するサービスを考えると案外必要となる場面が多いんですよね。<br/>
知っておいて損はないかと思います。<br/>
本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Geccoを使ったiOSアプリのチュートリアルを実装しよう！]]></title>
    <link href="http://grandbig.github.io/blog/2017/07/17/gecco/"/>
    <updated>2017-07-17T21:29:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2017/07/17/gecco</id>
    <content type="html"><![CDATA[<h3>はじめに</h3>

<p>本日はアプリでのチュートリアル実装について見ていきたいと思います。<br/>
あまたあるOSSライブラリの中で筆者が注目したのは、<a href="https://github.com/yukiasai/Gecco">Gecco</a>です。<br/>
理由は</p>

<ul>
<li>Swiftで作られていること</li>
<li>GitHubでのStar数が多いこと</li>
<li>タップ箇所を誘導するUIであること</li>
</ul>


<p>です。<br/>
では早速見ていきましょう。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h3>Geccoのインストール</h3>

<p>CocoaPodsでインストールします。<br/>
以下のように <code>Podfile</code> を作成して、 <code>pod install</code> を実行してください。</p>

<p>```objective-c</p>

<h1>Podfile</h1>

<p>use_frameworks!
platform :ios, &lsquo;10.0&rsquo;</p>

<p>target &ldquo;SampleApplication&rdquo; do
  pod &lsquo;Gecco&rsquo;
end
```</p>

<h3>Geccoの使い方</h3>

<p>これまた実にシンプルです。</p>

<h4>スポットライトの表示</h4>

<p>タップを促すときなどに焦点を当てるためのスポットライトを表示させたいことがあると思います。<br/>
これを実現してみましょう。</p>

<p>```objective-c
import UIKit
import Gecco</p>

<p>class ViewController: UIViewController {</p>

<p>  private var spotlightViewController: SpotlightViewController!
  &hellip;
  override func viewDidLoad() {</p>

<pre><code>super.viewDidLoad()

// 初期化
self.spotlightViewController = SpotlightViewController()
</code></pre>

<p>  }</p>

<p>  override func viewWillAppear() {</p>

<pre><code>super.viewWillAppear()

present(self.spotlightViewController, animated: true) {
  // スポットライトの表示
  self.spotlightViewController.spotlightView.appear(Spotlight.Oval(center: CGPoint(x: 100, y: 100), diameter: 50))
}
</code></pre>

<p>  }
}
```</p>

<p>上記のように初期化をして、<code>present</code>で画面遷移させる要領で表示させることができます。<br/>
また、上記例では円形のスポットライトが表示されますが、<br/>
スポットライトの形式には <code>Oval</code>(円) / <code>Rect</code>(長方形) / <code>RoundRect</code>(角丸長方形)の3つがあるため用途にあった形式を選択することができます。</p>

<h4>スポットライトに対するアクションを拾う</h4>

<p>続いて、下図のようにボタンタップを促す形で表示したスポットライトをタップしたことを検知して、次のチュートリアルに進みたいことがあると思います。</p>

<p><img src="/images/gecco_1.png" alt="ボタンの上にスポットライトの表示" /></p>

<p>これは <code>SpotlightViewControllerDelegate</code> を利用することになります。</p>

<p>```objective-c
import UIKit
import Gecco</p>

<p>class ViewController: UIViewController, SpotlightViewControllerDelegate {</p>

<p>  @IBOutlet weak var button: UIButton!
  private var spotlightViewController: SpotlightViewController!
  &hellip;
  override func viewDidLoad() {</p>

<pre><code>super.viewDidLoad()

// 初期化
self.spotlightViewController = SpotlightViewController()
self.spotlightViewController?.delegate = self
</code></pre>

<p>  }</p>

<p>  override func viewWillAppear() {</p>

<pre><code>super.viewWillAppear()

present(self.spotlightViewController, animated: true) {
  self.spotlightViewController.spotlightView.appear(Spotlight.Oval(center: CGPoint(x: 100, y: 100), diameter: 50))
}
</code></pre>

<p>  }</p>

<p>  // SpotlightViewControllerをタップした場合
  func spotlightViewControllerTapped(_ viewController: SpotlightViewController, isInsideSpotlight: Bool) {</p>

<pre><code>if isInsideSpotlight {
  // スポットライトの内側をタップした場合
  // SpotlightViewControllerを非表示にする
  self.spotlightViewController.dismiss(animated: true, completion: {
    self.button.sendActions(for: .touchUpInside)
  })
}
</code></pre>

<p>  }
}
```</p>

<p>上記のようにタップの検知は <code>spotlightViewControllerTapped</code> で可能です。<br/>
また、 <code>isInsideSpotlight</code> を利用することでスポットライトの内側をタップしたかどうかも検知できます。<br/>
余談ですが、<br/>
スポットライトをタップしても、そのままではボタンをタップしたことにはなりません。<br/>
そのため、ボタンへのタップアクションを伝えるために <code>sendActions(for: .touchUpInside)</code> を利用します。</p>

<p><code>spotlightViewControllerTapped</code>以外にも<code>spotlightViewControllerWillPresent</code>や<code>spotlightViewControllerWillDismiss</code>もありますので、状況次第で利用すると良いかと思います。</p>

<p><code>objective-c
@objc public protocol SpotlightViewControllerDelegate: class {
  optional func spotlightViewControllerWillPresent(viewController: SpotlightViewController, animated: Bool)
  optional func spotlightViewControllerWillDismiss(viewController: SpotlightViewController, animated: Bool)
  optional func spotlightViewControllerTapped(viewController: SpotlightViewController, isInsideSpotlight: Bool)
}
</code></p>

<h3>Geccoに機能を追加しよう</h3>

<p>デフォルトで用意されている機能以外に何らかの機能を合わせて使いたいこともあるでしょう。<br/>
そんなときは自ら実装するのが良いかと思います。</p>

<h4>チュートリアル用の説明を追加</h4>

<p>今回、筆者がGeccoを使った際に必要とした機能の中に <strong>説明表記</strong> がありました。<br/>
<code>GeccoExample</code> の中に <code>AnnotationViewController</code> が用意されていますので参考にさせて頂きました。</p>

<p>```objective-c
// AnnotationViewController
import Foundation
import UIKit
import Gecco</p>

<p>class AnnotationViewController: SpotlightViewController {</p>

<p>  @IBOutlet weak var label: UILabel!</p>

<p>  override func viewDidLoad() {</p>

<pre><code>super.viewDidLoad()
</code></pre>

<p>  }</p>

<p>  override func viewWillAppear(_ animated: Bool) {</p>

<pre><code>super.viewWillAppear(animated)
</code></pre>

<p>  }</p>

<p>  func updateLabel(_ text: String, blackColor: Bool = false) {</p>

<pre><code>self.label.text = text
if blackColor {
  self.label.textColor = UIColor.black
} else {
  self.label.textColor = UIColor.white
}
</code></pre>

<p>  }
}
```</p>

<p>筆者の場合、<code>UILabel</code>の位置は常に同じ場所で十分だったため上記のみの追加になっています。</p>

<h4>長押しジェスチャの追加</h4>

<p>今回、筆者がGeccoを使った際に必要とした機能の中に <strong>長押し検知</strong> がありました。<br/>
デフォルトで実装されていないため、GitHubからRepositoryをForkして機能追加することにしました。<br/>
コメントを記載した4箇所の追加のみで実装できます。</p>

<p>```objective-c
// SpotlightViewController
import UIKit</p>

<p>@objc public protocol SpotlightViewControllerDelegate: class {
  @objc optional func spotlightViewControllerWillPresent(<em> viewController: SpotlightViewController, animated: Bool)
  @objc optional func spotlightViewControllerWillDismiss(</em> viewController: SpotlightViewController, animated: Bool)
  @objc optional func spotlightViewControllerTapped(<em> viewController: SpotlightViewController, isInsideSpotlight: Bool)
  // (1)長押し検知
  @objc optional func spotlightViewControllerLongPressed(</em> viewController: SpotlightViewController, isInsideSpotlight: Bool)
}</p>

<p>open class SpotlightViewController: UIViewController {
  open weak var delegate: SpotlightViewControllerDelegate?
  &hellip;
  open override func viewDidLoad() {</p>

<pre><code>super.viewDidLoad()

setupSpotlightView(alpha)
setupContentView()
setupTapGesture()
// (2)長押し処理の追加
setupLongPressGesture()

view.backgroundColor = UIColor.clear
</code></pre>

<p>  }
  &hellip;
  // (3)長押し処理ジェスチャの初期化
  fileprivate func setupLongPressGesture() {</p>

<pre><code>let gesture = UILongPressGestureRecognizer(target: self, action: #selector(SpotlightViewController.viewLongPressed(_:)));
view.addGestureRecognizer(gesture)
</code></pre>

<p>  }
}</p>

<p>extension SpotlightViewController {
  &hellip;
  // (4)長押し時に実行される処理を追加
  func viewLongPressed(_ gesture: UILongPressGestureRecognizer) {</p>

<pre><code>let pressPoint = gesture.location(in: spotlightView)
let isInside = spotlightView.spotlight?.frame.contains(pressPoint) ?? false
delegate?.spotlightViewControllerLongPressed?(self, pressPoint: pressPoint, isInsideSpotlight: isInside)
</code></pre>

<p>  }
}
```</p>

<h3>まとめ</h3>

<p>さて如何でしたでしょうか？<br/>
今回はチュートリアル用に利用する <code>Gecco</code> ライブラリについて紹介させて頂きました。<br/>
チュートリアルにはGoogleがよく使うような初めに説明スライドを数枚用意する方式もあるかと思います。<br/>
ケースによって使い分けると良いんでしょうね。<br/>
と言ったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Google Maps SDK for iOSを使ってみよう！]]></title>
    <link href="http://grandbig.github.io/blog/2017/07/16/google-maps-sdk-2/"/>
    <updated>2017-07-16T23:43:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2017/07/16/google-maps-sdk-2</id>
    <content type="html"><![CDATA[<h3>はじめに</h3>

<p>前回、<a href="http://grandbig.github.io/blog/2017/06/18/google-maps-sdk/">Google Maps SDK for iOSを導入してみよう！</a>について説明しましたが、今回はもう一歩踏み込んで使い方を見ていこうと思います。</p>

<p>これまた本家の<a href="https://developers.google.com/maps/documentation/ios-sdk/start?hl=ja">Google スタートガイド</a>を見ればできることも多いのですが、見ていきましょう。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h3>Google Mapにマーカを配置する</h3>

<p>Google Mapを使う上で必ずと言っていいほど利用する機能である「マーカの配置」を見ていきましょう。<br/>
これは実に簡単で「マーカを配置するメソッド」はたった下記だけで実装できます。</p>

<p>```objective-c
/**
  マップにマーカを設置する処理</p>

<ul>
<li>parameter title: マーカのタイトル</li>
<li>parameter coordinate: 位置</li>
<li>parameter iconName: アイコン名</li>
<li>parameter completion: Callback
*/
private func putMarker(title: String?, coordinate: CLLocationCoordinate2D, iconName: String?, completion: @escaping ((GMSMarker) &ndash;> Void)) {
// マーカの生成
let marker = GMSMarker()
marker.title = title
marker.position = coordinate
if iconName != nil {
// アイコン名が指定されている場合は画像を設定
marker.icon = UIImage.init(named: iconName!)
}
marker.map = self.mapView
completion(marker)
}
```</li>
</ul>


<h3>Google Mapからマーカを削除する</h3>

<p>逆にGoogle Mapからマーカを削除する場合はどうするかを見ていきます。<br/>
これも簡単なので、下記のように実装できます。</p>

<p>```objective-c
/**
  マップからマーカを削除する処理</p>

<ul>
<li>parameter marker: マーカ
*/
private func deleteMarker(marker: GMSMarker) {
marker.map = nil
}
```</li>
</ul>


<h3>2つのマーカが入る縮尺にGoogle Mapを変更する</h3>

<p>こちらはGoogle Mapを捉えるカメラの位置を移動することで実現可能です。</p>

<p>```objective-c
@IBOutlet weak var mapView: GMSMapView!</p>

<p>&lt;省略></p>

<p>/**
  現在地と指定した場所の両方が入るようにマップの縮尺を変更する処理</p>

<ul>
<li>parameter coordinate: 場所
*/
private func changeCameraPosition(fromCoordinate: CLLocationCoordinate2D, toCoordinate: CLLocationCoordinate2D) {
let bounds = GMSCoordinateBounds(coordinate: fromCoordinate, coordinate: toCoordinate)
let margin: CGFloat = 50.0  // 上下左右に設定するマージン
guard let camera = self.mapView.camera(for: bounds, insets: UIEdgeInsets(top: margin, left: margin, bottom: margin, right: margin)) else {
return
}
self.mapView.camera = camera
}
```</li>
</ul>


<h3>Google Mapに線を描画する</h3>

<p>これもそんなに難しくありません。</p>

<p>```objective-c
@IBOutlet weak var mapView: GMSMapView!
private var routePath: GMSPolyline = GMSPolyline()</p>

<p>&lt;省略></p>

<p>/**
  マップへの線描画</p>

<ul>
<li>parameter fromCoordinate: 起点位置</li>
<li>parameter toCoordinate: 終点位置
*/
private func drawPolyline(fromCoordinate: CLLocationCoordinate2D, toCoordinate: CLLocationCoordinate2D) {</li>
</ul>


<p>  let path = GMSMutablePath()
  path.add(fromCoordinate)
  path.add(toCoordinate)</p>

<p>  self.routePath = GMSPolyline(path: path)
  self.routePath.strokeWidth = 3.0
  self.routePath.map = self.mapView
}
```</p>

<h3>Google Mapから線を削除する</h3>

<p>先程描画した線を削除するには下記で実行できます。</p>

<p>```objective-c
private var routePath: GMSPolyline = GMSPolyline()</p>

<p>&lt;省略></p>

<p>/<em>*
  マップへの描画線を削除する処理
</em>/
private func clearRoutePath() {
  self.routePath.map = nil
}
```</p>

<h3>緯度/経度とピクセル座標の相互変換</h3>

<p>これは利用ケースが限られるかもしれませんが、覚えておくと役に立つ処理です。<br/>
Google Mapは複数のマップ座標を扱うことができます。</p>

<ul>
<li>緯度/経度を用いて地球上にプロット</li>
<li>世界座標: メルカトル図法を用いて緯度/経度を地図に変換した座標</li>
<li>ピクセル座標: 世界座標を指定したズームレベルで変換した座標</li>
<li>タイル座標: 地図を複数の画像に分けたときの座標</li>
</ul>


<p>ほとんどの場合は緯度/経度をマップにプロットすると思いますが、<br/>
筆者は先日ピクセル座標を利用する場面がありました。</p>

<p>それは、「Google Mapの上に透過Viewが載せられた状態でGoogle Mapにマーカを配置する」というものでした。
今回はこれを例に変換方法を見ていきましょう。</p>

<h4>ピクセル座標を緯度/経度に変換</h4>

<p>これはGoogle Maps SDKに用意されています。</p>

<p><code>objective-c
let pressPoint = CGPoint(x: 100, y: 200)
let coordinate = self.mapView.projection.coordinate(for: pressPoint)
</code></p>

<p>たったのこれだけでピクセル座標を緯度/経度に変換できるんです。</p>

<h4>緯度/経度をピクセル座標に変換</h4>

<p>これもGoogle Maps SDKに用意されています。</p>

<p><code>objective-c
let coordinate = CLLocationCoordinate2D(latitude: 35, longitude: 139)
let point = self.mapView.projection.point(for: coordinate)
</code></p>

<h3>まとめ</h3>

<p>さて如何でしたでしょうか？<br/>
JavaScriptでGoogle Maps APIを利用していた方々も臆することなく使えるような簡単さだと思います。<br/>
次回はGeocoding APIやDirection APIを見ていきたいと思います。</p>

<p>と言ったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Google Maps SDK for iOSを導入してみよう！]]></title>
    <link href="http://grandbig.github.io/blog/2017/06/18/google-maps-sdk/"/>
    <updated>2017-06-18T19:47:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2017/06/18/google-maps-sdk</id>
    <content type="html"><![CDATA[<h3>はじめに</h3>

<p>本日は<a href="https://developers.google.com/maps/documentation/ios-sdk/?hl=ja">Google Maps SDK for iOS</a>の導入の仕方を書きたいと思います。<br/>
(<a href="https://grandbig.github.io/blog/2014/01/27/googlemapssdk2/">3年以上前</a>に遊んでいたようですが、全く記憶にない&hellip;)</p>

<p>基本的には、<a href="https://developers.google.com/maps/documentation/ios-sdk/start?hl=ja">本家のスタートガイド</a>に従って進めるだけで特に問題なく<code>Google Map</code>を実装できるでしょう。<br/>
筆者の場合は<code>Storyboard</code>を使いたかったので少し気をつける必要がありました。<br/>
では早速見ていきましょう。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h3>Google Maps SDK for iOSの導入</h3>

<p>実際に手順を書いていきます。</p>

<p><strong>１．Xcodeでプロジェクトを作成します。</strong><br/>
<strong>２．<code>Podfile</code>を作成します。</strong></p>

<p>```objective-c</p>

<h1>Podfile</h1>

<p>use_frameworks!</p>

<p>target &ldquo;GoogleMapsSample&rdquo; do
  # Normal libraries
  pod &lsquo;GoogleMaps&rsquo;
  pod &lsquo;GooglePlaces&rsquo;</p>

<p>  abstract_target &lsquo;Tests&rsquo; do</p>

<pre><code>inherit! :search_paths
target "GoogleMapsSampleTests"
target "GoogleMapsSampleUITests"

pod 'Quick'
pod 'Nimble'
</code></pre>

<p>  end
end</p>

<p>post_install do |installer|
  installer.pods_project.targets.each do |target|</p>

<pre><code>target.build_configurations.each do |config|
  config.build_settings['SWIFT_VERSION'] = '3.0'
end
</code></pre>

<p>  end
end
```</p>

<p><strong>３．<code>pod install</code>で必要な<code>Framework</code>をインストールします。</strong><br/>
<strong>４．APIキーを取得します。</strong><br/>
スタートガイドに従って下記ボタンをクリックすればAPIキーを取得することができます。</p>

<p><img src="/images/google-maps-sdk-1.png" alt="APIキーの取得" /></p>

<p><strong>５．アプリのAPIキーを読み取らせる処理を導入します。</strong><br/>
筆者の場合、基本的なソースコードは<code>GitHub</code>に公開したかったため、そのままAPIキーをべた書きするわけにいきませんでした。<br/>
なので、<code>key.plist</code>ファイルを作成し、このファイルを<code>GitHub</code>にアップしないという手法を取ることにしました。</p>

<p>下図のように<code>key.plist</code>ファイルを作成</p>

<p><img src="/images/google-maps-sdk-2.png" alt="key.plistの作成" /></p>

<p>また下図のようなフォルダ構成で<code>Info.plist</code>と同じ階層に<code>key.plist</code>を配置しています。<br/>
<img src="/images/google-maps-sdk-6.png" alt="フォルダ構成" /></p>

<p><code>AppDelegate.swift</code>で<code>key.plist</code>からAPIキーを読み込みます。</p>

<p>```objective-c
// AppDelegate.swift
import UIKit
import GoogleMaps
import GooglePlaces</p>

<p>@UIApplicationMain
class AppDelegate: UIResponder, UIApplicationDelegate {</p>

<p>  var window: UIWindow?</p>

<p>  func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) &ndash;> Bool {</p>

<pre><code>// Override point for customization after application launch.

if let path = Bundle.main.path(forResource: "key", ofType: "plist") {
  if let dic = NSDictionary(contentsOfFile: path) as? [String: Any] {
    if let apiKey = dic["googleMapsApiKey"] as? String {
      GMSServices.provideAPIKey(apiKey)
      GMSPlacesClient.provideAPIKey(apiKey)
    }
  }
}

return true
</code></pre>

<p>  }</p>

<pre><code>...
</code></pre>

<p>}
```</p>

<p><strong>６．<code>Storyboard</code>に<code>Google Map</code>を追加します。</strong><br/>
本家スタートガイドだと<code>Storyboard</code>を利用しない方式での説明が書かれていましたが、筆者は<code>Storyboard</code>を利用しました。</p>

<p><img src="/images/google-maps-sdk-3.png" alt="StoryboardにGoogle Mapを配置" /></p>

<p>これで導入が完了です。</p>

<h3>Google Cloud PlatformのAPI Managerで詳細設定</h3>

<p>先程、本家のスタートガイドからAPIキーを取得していましたが、<a href="https://console.cloud.google.com/home">Google Cloud Platform</a>内の<code>API Manager</code>からAPIキーに対して詳細設定をすることができます。<br/>
例えば、スタートガイドから取得しただけでは、APIキーの用途が無制限になっています。<br/>
この状態では意図しない大量利用に繋がる可能性もあるため、iOSアプリでのみ利用するなど詳細を設定した方が良いでしょう。</p>

<p><code>API Manager</code>ページには下記のように遷移できます。<br/>
<img src="/images/google-maps-sdk-4.png" alt="Google Cloud Platform" /></p>

<p>APIキーの詳細設定は下記の通りです。<br/>
<img src="/images/google-maps-sdk-5.png" alt="APIキーの詳細設定" /></p>

<h3>Google Mapで初期描画時の中心位置を現在地にしてみる</h3>

<p>Apple標準で用意されている<code>MapKit</code>であれば、</p>

<p><code>objective-c
self.mapView.setUserTrackingMode(MKUserTrackingMode.follow, animated: true)
</code></p>

<p>とすれば良いだけでした。<br/>
しかし、<code>Google Map</code>では同様の手立てがなさそうなので、下記のように対応しました。</p>

<p>```objective-c
// ViewController.swift
import UIKit
import GoogleMaps
import GooglePlaces</p>

<p>class ViewController: UIViewController, GMSMapViewDelegate, CLLocationManagerDelegate {</p>

<p>  @IBOutlet weak var mapView: GMSMapView!
  private var locationManager: CLLocationManager?
  private var currentLocation: CLLocation?
  private var placesClient: GMSPlacesClient!
  private var zoomLevel: Float = 15.0
  /// 初期描画の判断に利用
  private var initView: Bool = false</p>

<p>  override func viewDidLoad() {</p>

<pre><code>super.viewDidLoad()
// Do any additional setup after loading the view, typically from a nib.

// GoogleMapの初期化
self.mapView.isMyLocationEnabled = true
self.mapView.mapType = GMSMapViewType.normal
self.mapView.settings.compassButton = true
self.mapView.settings.myLocationButton = true
self.mapView.delegate = self

// 位置情報関連の初期化
self.locationManager = CLLocationManager()
self.locationManager?.desiredAccuracy = kCLLocationAccuracyBest
self.locationManager?.requestAlwaysAuthorization()
self.locationManager?.distanceFilter = 50
self.locationManager?.startUpdatingLocation()
self.locationManager?.delegate = self

self.placesClient = GMSPlacesClient.shared()
</code></pre>

<p>  }</p>

<p>  override func didReceiveMemoryWarning() {</p>

<pre><code>super.didReceiveMemoryWarning()
// Dispose of any resources that can be recreated.
</code></pre>

<p>  }</p>

<p>  // MARK: CLLocationManagerDelegate
  func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {</p>

<pre><code>if !self.initView {
  // 初期描画時のマップ中心位置の移動
  let camera = GMSCameraPosition.camera(withTarget: (locations.last?.coordinate)!, zoom: self.zoomLevel)
  self.mapView.camera = camera
  self.locationManager?.stopUpdatingLocation()
  self.initView = true
}
</code></pre>

<p>  }
}
```</p>

<p>これは<code>viewDidLoad</code>時に<code>startUpdatingLocation()</code>で位置情報の取得を開始し、取得したタイミングである<code>didUpdateLocations</code>内で位置情報を<code>camera</code>に設定しています。<br/>
(もっと良い方法がありそうな気もしますが、一旦これで様子見&hellip;)</p>

<h3>まとめ</h3>

<p>さて如何でしたでしょうか？<br/>
これから<code>Google Maps SDK for iOS</code>をバシバシ使っていきたいと思っているので理解が進み次第、続きを書いていきたいと思います。<br/>
と言ったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
</feed>
