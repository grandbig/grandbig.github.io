<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: swift | Takahiro Octopress Blog]]></title>
  <link href="http://grandbig.github.io/blog/categories/swift/atom.xml" rel="self"/>
  <link href="http://grandbig.github.io/"/>
  <updated>2016-01-12T00:08:38+09:00</updated>
  <id>http://grandbig.github.io/</id>
  <author>
    <name><![CDATA[Takahiro]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SwiftでXCTestを使って単体テストとUIテストをしてみよう！]]></title>
    <link href="http://grandbig.github.io/blog/2016/01/11/xctest/"/>
    <updated>2016-01-11T19:17:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2016/01/11/xctest</id>
    <content type="html"><![CDATA[<h4>iOSアプリケーション開発でのテストとは</h4>

<p>さて、本日はiOSアプリケーションを開発する際のテストについて書きたいと思います。<br/>
元々、Objective-Cでは下記のテスト用のライブラリが使われてきました。</p>

<ul>
<li><a href="https://github.com/kiwi-bdd/Kiwi">Kiwi</a></li>
<li><a href="https://github.com/gh-unit/gh-unit">GHUnit</a></li>
<li><a href="https://github.com/specta/specta">Specta</a></li>
</ul>


<p>しかし、これらはあくまでもObjective-C時代にApple公式のテストフレームワークが充実する以前から活躍していたものです。今後、Swiftが普及するにつれて、これらのテストフレームワークもSwiftに最適化したものになっていくかもしれません。<br/>
とは言え、AppleもいつまでもOSSのテストフレームワークがなければならない状況は避け、Xcode内で完結することを目指していくかもしれません。<br/>
後ほど詳しく説明しますが、Xcode7からUIテストが新たに追加されたのも、その流れだと思っています。</p>

<p>本日は特に <strong>XCTest</strong> に焦点をあてた、iOSにおけるテストについて見ていきたいと思います。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h4>XCTestでUnit Test</h4>

<p>早速、XCTestの使い方について見ていきましょう。<br/>
Xcode7ではプロジェクトを新規作成する際にXCTest用のTargetを作成するか否かを選ぶことができます。<br/>
初めにチェックを入れていない場合は、途中で追加することが可能ですが、単体テストをすることは大切なので、チェックはつけておきましょう。</p>

<p><img src="/images/xctest_1.png" alt="プロジェクト作成時にXCTest用のTargetを作成" /></p>

<p>今回テストするソースコードは下記のようなシンプルなものにします。</p>

<p>```objective-c
import UIKit
import Alamofire</p>

<p>class ViewController: UIViewController {</p>

<pre><code>override func viewDidLoad() {
    super.viewDidLoad()
}

override func didReceiveMemoryWarning() {
    super.didReceiveMemoryWarning()
}

func showWeather() {
    self.getWeather{(description) -&gt; Void in
        print(description)
    }
}

func getWeather(closure:(String) -&gt; Void) {
    Alamofire.request(.GET, "http://api.openweathermap.org/data/2.5/weather?APPID=&lt;自身のAPPIDを指定&gt;", parameters:
        ["q":"Tokyo"]).response { (request, response, data, error) -&gt; Void in
        if(error == nil) {
            do {
                let dataDict = try NSJSONSerialization.JSONObjectWithData(data!, options: NSJSONReadingOptions.AllowFragments)
                let weatherArray:[AnyObject] = dataDict["weather"] as! [AnyObject]
                let weather:AnyObject = weatherArray[0]
                let description:String = weather["description"] as! String

                // アラートを表示
                self.showAlert(description)
            } catch {
                print("例外が発生しました！")
            }
        }
    }
}
</code></pre>

<p>}
```</p>

<p>今回は <strong>showWeather</strong> メソッドのUnit Testを書いていきます。<br/>
上記コードを見て頂くと、 <strong>showWeather</strong> メソッドは <strong>Open Weather Map API</strong> を使って東京の天気を取得し、それをログとして出力していることがわかると思います。<br/>
前半の <strong>Alamofire</strong> を使った通信処理はOSSライブラリを使っているわけで、この通信処理のテストがしたいわけではありません。<br/>
筆者が実施したいテストは後半の <strong>Open Weather Map API</strong> を使って <strong>取得した天気情報をログに出力する</strong> 部分です。<br/>
(本来はテストするまでもないのですが、テストの手法や考え方をメインに説明したいので、ソースは超簡単にしています。)</p>

<p>それを踏まえた上で、実際にテストコードを書いてみましょう。<br/>
&lt;Project名>Tests.swiftファイルを選択します。</p>

<p>```objective-c
import XCTest
@testable import SimpleApplication</p>

<p>class SimpleApplicationTests: XCTestCase {</p>

<pre><code>override func setUp() {
    super.setUp()
}

override func tearDown() {
    super.tearDown()
}

func testShowWeather() {
    class VCMock:ViewController {
        override func getWeather(closure:(String) -&gt; Void) {
            closure("test weather")
        }
    }

    let vcm:VCMock = VCMock()
    vcm.showWeather()
}
</code></pre>

<p>}
```</p>

<p>ポイントは</p>

<ol>
<li>テストメソッドの定義<br/>
テストメソッドは、 <strong>test + &lt;任意の文字列></strong> で命名しましょう。</li>
<li>スタブの定義<br/>
Swiftは <strong>manual mocking</strong> という手法を取ります。<br/>
これはテスト対象クラスを継承したクラスを定義し、テストしたいメソッドをオーバーライドします。<br/>
返却値等を固定文字列とすることで、スタブの作成となります。</li>
</ol>


<p>の2点です。</p>

<p>では、このテストを実行してみます。</p>

<p>まず、実行Targetに <strong>&lt;Project名>Tests</strong> を選択できるようにSchemeを編集します。</p>

<p><img src="/images/xctest_2.png" alt="Manage Schemes..." /></p>

<p><img src="/images/xctest_3.png" alt="Add Scheme" /></p>

<p><img src="/images/xctest_4.png" alt="Choose Testsファイル" /></p>

<p><img src="/images/xctest_5.png" alt="Set Scheme" /><br/>
実行するSchemeを <strong>&lt;Project名>Tests</strong> に設定し、実行デバイスをシミュレータにします。<br/>
(実機ではテスト実行できないからです。)</p>

<p><img src="/images/xctest_6.png" alt="Testを実行" /><br/>
Xcodeメニュー > Product > Test を選択してテストを実行します。</p>

<p><img src="/images/xctest_7.png" alt="テスト結果の確認" /><br/>
左メニューおよびコード上からテスト結果を確認できます。</p>

<p>メソッドが増えるごとにテストメソッドを増やしていきましょう。<br/>
テストファイルはクラス別に作成しておくと、第三者から見ても見やすいと思います。</p>

<h4>XCTestでUI Test</h4>

<p>続いて、Xcode7から追加されたUI Testの方法を見ていきたいと思います。<br/>
冒頭で説明した通り、プロジェクト作成時に <strong>include UI Tests</strong> を選択しておくことで、 <strong>&lt;Project名>UITests.swift</strong> ファイルが作成されます。</p>

<p>では、UI Test用に少しコードを修正してみます。</p>

<p>```objective-c
import UIKit
import Alamofire</p>

<p>class ViewController: UIViewController {</p>

<pre><code>override func viewDidLoad() {
    super.viewDidLoad()
}

override func didReceiveMemoryWarning() {
    super.didReceiveMemoryWarning()
}

@IBAction func getWeatherAction(sender: AnyObject) {
    self.getWeather { (description) -&gt; Void in
        self.showAlert(description)
    }
}

func getWeather(closure:(String) -&gt; Void) {
    Alamofire.request(.GET, "http://api.openweathermap.org/data/2.5/weather?APPID=&lt;自身のAPPIDを指定&gt;", parameters:
        ["q":"Tokyo"]).response { (request, response, data, error) -&gt; Void in
        if(error == nil) {
            do {
                let dataDict = try NSJSONSerialization.JSONObjectWithData(data!, options: NSJSONReadingOptions.AllowFragments)
                let weatherArray:[AnyObject] = dataDict["weather"] as! [AnyObject]
                let weather:AnyObject = weatherArray[0]
                let description:String = weather["description"] as! String

                // アラートを表示
                self.showAlert(description)
            } catch {
                print("例外が発生しました！")
            }
        }
    }
}

func showAlert(message:String) {
    let alertController:UIAlertController = UIAlertController(title: "確認", message: message, preferredStyle: .Alert)
    let okAction:UIAlertAction = UIAlertAction(title: "OK", style: .Default) { (alert) -&gt; Void in
        // OKを選択したときに実行される処理
    }
    alertController.addAction(okAction)

    presentViewController(alertController, animated: true, completion: nil)
}
</code></pre>

<p>}
```</p>

<p>これに伴い、画面にボタンを配置しました。<br/>
このボタンをタップすると、天気情報をアラートで表示してくれます。</p>

<p><img src="/images/xctest_8.png" alt="ボタンを配置" /></p>

<p><img src="/images/xctest_9.png" alt="アラートを表示" /></p>

<p>では、UI Testのテストコードを作成します。<br/>
UI Testの場合は、Xcodeの <strong>UI recording</strong> 機能を使って、手作業でコードを修正していきます。</p>

<p><img src="/images/xctest_10.png" alt="UI recording 開始ボタンをタップ" /></p>

<p><img src="/images/xctest_11.png" alt="UI recording 終了ボタンをタップ" /></p>

<p>すると、下記のようなコードが生成されました。</p>

<p>```objective-c
func testShowWeatherAlert() {</p>

<pre><code>let app = XCUIApplication()
app.buttons["GET Weather"].tap()
app.alerts["\U78ba\U8a8d"].collectionViews.buttons["OK"].tap()
</code></pre>

<p>}
```</p>

<p>しかし、このままではエラーが表示されるはずです。<br/>
理由はアラートのタイトルを日本語にしていたため、ASCIIコードで表示されてしまっているからです。<br/>
もし、指し示しているASCIIコードが理解できないようであれば、<a href="http://web-apps.nbookmark.com/ascii-converter/">ASCIIコード変換機</a>を使ってください。</p>

<p>ASCIIコード部分を修正した結果が下記となります。</p>

<p>```objective-c
func testShowWeatherAlert() {</p>

<pre><code>let app = XCUIApplication()
app.buttons["GET Weather"].tap()
app.alerts["確認"].collectionViews.buttons["OK"].tap()
</code></pre>

<p>}
```</p>

<p>テストコードが作成できましたので、実行Targetに &lt;Project名>UITests を選択できるようにSchemeを編集します。</p>

<p><img src="/images/xctest_12.png" alt="Manage Schemes..." /></p>

<p><img src="/images/xctest_13.png" alt="Add Scheme" /></p>

<p><img src="/images/xctest_14.png" alt="Choose Testsファイル" /></p>

<p><img src="/images/xctest_15.png" alt="Set Scheme" /><br/>
実行するSchemeを &lt;Project名>UITests に設定し、実行デバイスをシミュレータにします。<br/>
(実機ではテスト実行できないからです。)</p>

<p><img src="/images/xctest_6.png" alt="Testを実行" /><br/>
Xcodeメニュー > Product > Test を選択してテストを実行します。</p>

<p><img src="/images/xctest_16.png" alt="テスト結果の確認" /><br/>
左メニューおよびコード上からテスト結果を確認できます。</p>

<p>Unit Testと同様にメソッドが増えるごとにテストメソッドを増やしていきましょう。<br/>
テストファイルはクラス別に作成しておくと、第三者から見ても見やすいと思います。</p>

<p>いかがだったでしょうか？<br/>
今回は超簡単なサンプルコードで基本的なことについて説明しましたが、今後深く使っていくことで躓くこともあるかもしれません。<br/>
その際にはまたブログにて説明したいと思います。<br/>
ぜひ、単体テストとUIテストを駆使して、バグの少ないアプリを作っていきたいものです。</p>

<p>と言ったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOSアプリ開発で役立つオープンソースライブラリのまとめサイト]]></title>
    <link href="http://grandbig.github.io/blog/2015/10/25/ios-opensource/"/>
    <updated>2015-10-25T22:45:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2015/10/25/ios-opensource</id>
    <content type="html"><![CDATA[<h4>オープンソースライブラリは積極的に使おう！</h4>

<p>さて、本日は珍しくプログラミングそのものではなく、オープンソースライブラリのまとめサイトを紹介したいと思います。<br/>
と言っても、ほとんど皆さん当たり前のように使っていると思いますが笑。</p>

<p>Webアプリケーションと同じようにiOSアプリケーションでも当然の事ながらオープンソースのライブラリが存在します。<br/>
使いやすく役立つものから、ちょっとした心をくすぐるものまで様々なものがネット上にあふれています。<br/>
何の手がかりもなしに目的のものを探すのは困難だと思うので、筆者がよく使っているサイトを紹介します。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h5>Objective-Cならcocoa-CONTROLS</h5>

<p>こちらは最早、老舗と言えるかもしれません。<a href="https://www.cocoacontrols.com/platforms/ios/controls">cocoa-CONTROLS</a>はiOSおよびOSXアプリケーションの開発に利用可能なオープンソースライブラリをまとめてくれているサイトです。</p>

<p>下記が主な特徴となります。</p>

<ul>
<li>iOS, OSXで利用可能なライブラリが記載されています</li>
<li>Objective-Cだけでなく、Swiftで書かれたライブラリが記載されています(React Nativeもあります)</li>
<li>ライセンスによる検索が可能です。</li>
</ul>


<h5>SwiftならiOS cookies</h5>

<p>Swiftのライブラリを分野別にまとめたサイトが<a href="http://www.ioscookies.com/">iOS cookies</a>です。<br/>
こちらはcocoa-CONTROLSに比べて圧倒的にライブラリの数は少なくなりますが、各分野の有名ドコロのライブラリを抑えているので、目安にはなると思われます。</p>

<p>Swiftライブラリはまだまだしばらくはネット上で検索する必要が絶えないと思いますが、ふとした時に覗いてみると良いのではないでしょうか。</p>

<h4>その他の役立つサイトの紹介</h4>

<p>さて、アプリ開発をする上では、他にも必要なサイトがあります。<br/>
折角なので、それも紹介させてください。</p>

<h5>アプリのリリースに必要な画像を一式揃えよう</h5>

<p>アプリをリリースするためには様々なサイズの画像を用意する必要があります。<br/>
全てをいちいちメモして用意するのもたいへんなので、ここは<a href="http://makeappicon.com/">MakeAppicon</a>を使いましょう。<br/>
iOSだけでなくApple Watch用そしてAndroid用も一式そろえてくれます。</p>

<h5>アプリ関係の資料を作るなら実機つき画像が良いよね！</h5>

<p>アプリを紹介するための資料やアプリの使い方マニュアルなどを作る場合、アプリの実際の画面だけでも事足りるかもしれないのですが、どうせなら、iPhoneやAndroid端末の <strong>端末自体</strong> の画像もあった方がきれいな資料になりますよね？<br/>
そんなときには<a href="http://mockuphone.com/">MockUPhone</a>を使いましょう。</p>

<h5>アプリの画面内の色を設定するために&hellip;</h5>

<p>アプリの画面を作成するためには色を事細かに設定する必要が出てくるでしょう。<br/>
iOSではUIColorによる色設定を行うのですが、これがかなり特殊でありまして、Webアプリ出身者の筆者としてはなかなか苦労するところであります。<br/>
そんなときには<a href="http://www.peko-step.com/tool/tfcolor.html">RGB↔16進数変換サイト</a>と<a href="http://tobioka.net/wp-content/uploads/2012/05/hexrgb2uicolor.html">16進数↔UIColor変換サイト</a>を使うようにしています。</p>

<p>さて如何だったでしょうか。<br/>
もし、初めて知ったというサイトがあれば、ぜひ使ってみてください。<br/>
必ず役に立つこと請け合いです！<br/>
と言ったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swiftで継承とカテゴリってどうやってやるの！？]]></title>
    <link href="http://grandbig.github.io/blog/2015/06/07/swift-inheritance-extension/"/>
    <updated>2015-06-07T23:30:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2015/06/07/swift-inheritance-extension</id>
    <content type="html"><![CDATA[<h4>Swiftで継承</h4>

<p>まずはObjective-CとSwiftの継承の書き方の違いを見て行きましょう。</p>

<p>早速、Objective-Cの継承ですが、</p>

<p>```objective-c
// ヘッダーファイル
@interface SampleA:NSObject
// プロパティの定義
@property(strong, nonatomic) NSString *sampleString;
// メソッドの定義
&ndash; (void)sampleMethod;</p>

<p>@end</p>

<p>```</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<p>```objective-c
// モデルファイル
@interface SampleA()</p>

<p>@end</p>

<p>@implementation</p>

<ul>
<li>(void)sampleMethod {
  &hellip;.
}</li>
</ul>


<p>@end</p>

<p>```</p>

<p>といった形で書けます。</p>

<p>これがSwiftだと、</p>

<p>```objective-c
// swiftファイル
class SampleA:NSObject {</p>

<pre><code>// プロパティの定義
var sampleString:String = "サンプル"
// メソッドの定義
func sampleMethod {
    ....
}
</code></pre>

<p>}</p>

<p>```</p>

<p>とかなりシンプルに書けますね！</p>

<h4>Swiftでカテゴリ</h4>

<p>次にSwiftでObjective-Cで言うカテゴリを実装してみます。</p>

<p>Objective-Cでは、</p>

<p>```objective-c
// ヘッダーファイル
@interface NSError(ContextBase)</p>

<ul>
<li>(NSError <em>)createError:(NSString </em>)message code:(NSInteger)code;</li>
</ul>


<p>@end
```</p>

<p>```objective-c
// モデルファイル
@implementation NSError(ContextBase)</p>

<ul>
<li><p>(NSError <em>)createError:(NSString </em>)message code:(NSInteger)code {
 NSDictionary <em>errorUserInfo = @{ NSLocalizedDescriptionKey:message };
 NSError </em>error = [[NSError alloc] initWithDomain:domain code:code userInfo:errorUserInfo];</p>

<p> return error;
}</p></li>
</ul>


<p>@end
```</p>

<p>と書いてきました。<br/>
これがSwiftでは、</p>

<p>```objective-c
// Swiftファイル
extension NSError {</p>

<pre><code>func createError(message:String!, code:Int!) -&gt; NSError {
    let errorUserInfo = [NSLocalizedDescriptionKey: message]
    let error:NSError = NSError(domain: "jp.co.swiftSample", code: code, userInfo: errorUserInfo)

    return error
}
</code></pre>

<p>}
```</p>

<p>と書けます。<br/>
う〜んこれもシンプル！！<br/>
Objective-Cで利用してきた継承はもちろんのこと、カテゴリも残っていて助かりますね！</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SwiftでRealmを使ってみよう！]]></title>
    <link href="http://grandbig.github.io/blog/2015/06/07/swift-realm/"/>
    <updated>2015-06-07T16:35:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2015/06/07/swift-realm</id>
    <content type="html"><![CDATA[<h4>Realmをプロジェクトに追加しよう</h4>

<p>本日は最近、流行っているRealmについて遊んでみたいと思います。<br/>
まずは導入の仕方から見て行きましょう！</p>

<h5>Realmの導入方法</h5>

<p>下記のPodfileを作成しましょう。<br/>
本記事のSwiftプロジェクトとして、<code>SwiftRealm.xcodeproj</code>を作成します。</p>

<p>```objective-c
// Podfile
platform :ios, &lsquo;8.0&rsquo;
source &lsquo;<a href="https://github.com/CocoaPods/Specs.git">https://github.com/CocoaPods/Specs.git</a>&rsquo;</p>

<p>target &lsquo;SwiftRealm&rsquo;, exclusive: true do</p>

<pre><code>pod 'Realm'
</code></pre>

<p>end</p>

<p>target &lsquo;SwiftRealmTests&rsquo;, exclusive: true do</p>

<pre><code>pod 'Realm/Headers'
</code></pre>

<p>end
```</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<p>あとは<code>pod install</code>しましょう。<br/>
すると、<code>SwiftRealm.xcworkspace</code>が作成されるので、Xcodeで起動しましょう。</p>

<p><img src="/images/swift-realm.png" alt="Realmを追加した結果" /></p>

<p>なんと、Objective-C++で書かれていますね！
Swiftで利用するためにはBridging-Headerファイルの設定を行う必要があります。</p>

<p>SwiftRealm-Bridging-Header.hを作成します。<br/>
<img src="/images/swift-realm2.png" alt="ヘッダーファイルの作成" /></p>

<p>TARGETS > SwiftRealm > Build Settings > Swift Compiler &ndash; Code Generation > Objective-C Bridging Header にパスを設定します。<br/>
<img src="/images/swift-realm3.png" alt="パスの設定" /></p>

<p>SwiftRealm-Bridging-Header.hの中身を書きます。</p>

<p>```objective-c</p>

<h1>ifndef SwiftRealm_SwiftRealm_Bridging_Header_h</h1>

<h1>define SwiftRealm_SwiftRealm_Bridging_Header_h</h1>

<h1>import &lt;Realm/Realm.h></h1>

<h1>endif</h1>

<p>```</p>

<p>これでRealmを利用する準備が整いました。<br/>
実際にコードを書いていきましょう。</p>

<h5>保存オブジェクトの生成</h5>

<p>Realmでは保存する対象を<code>RLMObject</code>として作成します。<br/>
SQLiteでいうところのテーブルを生成しているイメージでしょうか。</p>

<p>今回は練習として<code>Engineer.swift</code>内で<code>Engineer</code>クラスを作ってみました。</p>

<p>```objective-c
// Engineer.swift</p>

<p>// Engineerクラス
class Engineer:RLMObject {</p>

<pre><code>// プロパティと初期値の設定
dynamic var id:Int = 0
dynamic var level:Int = 0
dynamic var businessTitle:String = ""
dynamic var skills = RLMArray(objectClassName: "Skills")
dynamic var created:Double = 0
dynamic var updated:Double = 0

// プライマリーキーの設定
override class func primaryKey() -&gt; String? {
    return "id"
}

// インデックスの設定
override class func indexedProperties() -&gt; [AnyObject]? {
    return ["level"]
}
</code></pre>

<p>}</p>

<p>// Skillsクラス
class Skills: RLMObject {</p>

<pre><code>    dynamic var skill:String = ""
</code></pre>

<p>}
```</p>

<p>ポイントとしては、<code>skills</code>のように配列の形で1つの要素に複数の値を割り当てたい場合は、それ単体で別に<code>RLMObject</code>の拡張クラスを作成する必要があります。<br/>
<code>RLMArray</code>を初期化することは許可されていないためです。</p>

<h5>オブジェクトのインサート/アップデート</h5>

<p>続いて、先ほど生成したオブジェクトをインサート/アップデートしてみましょう。</p>

<p>```objective-c
// ViewController.swift
import UIKit</p>

<p>class ViewController: UIViewController {</p>

<pre><code>override func viewDidLoad() {
    super.viewDidLoad()

    // id=0のオブジェクトを検索
    if let engineer = Engineer(forPrimaryKey: 0) {
        // 検索結果がある場合
        println("既にエンジニアが１人います。\(engineer)")

        // アップデート
        let realm = RLMRealm.defaultRealm()
        // 書込みの開始
        realm.beginWriteTransaction()
        // Skillsクラスをインスタンス化
        let skills = Skills()
        // 要素を設定
        skills.skill = "Objective-C"
        // 既存のデータに要素を追加
        engineer.skills.addObject(skills)
        engineer.updated = NSDate().timeIntervalSince1970
        // データのアップデート処理
        realm.addOrUpdateObject(engineer)
        // 書込みの終了
        realm.commitWriteTransaction()
    } else {
        // 検索結果がない場合
        // Engineerクラスをインスタンス化
        let newEngineer = Engineer()
        newEngineer.id = 0
        newEngineer.level = 0
        newEngineer.businessTitle = "新米エンジニア"
        // Skillsクラスをインスタンス化
        let skills = Skills()
        skills.skill = "Swift"
        newEngineer.skills.addObject(skills)
        newEngineer.created = NSDate().timeIntervalSince1970

        // データの新規作成
        let realm = RLMRealm.defaultRealm()
        // 書込みの開始
        realm.beginWriteTransaction()
        // データのインサート処理
        realm.addObject(newEngineer)
        // 書込みの終了
        realm.commitWriteTransaction()
    }
}

override func didReceiveMemoryWarning() {
    super.didReceiveMemoryWarning()
}
</code></pre>

<p>}
```</p>

<p>ここでは、<code>id=0</code>のデータを検索して、見つからない場合は新規データをインサートし、見つかった場合はデータのアップデートをしています。<br/>
書込みにはトランザクションブロックを使った方法もあるようですが、今回は<code>beginWriteTransaction</code>と<code>commitWriteTransaction</code>を利用しました。</p>

<h5>データの確認</h5>

<p>では、データを作成した後に、そのデータを確認したい場合はどうすれば良いのでしょうか？<br/>
実はMac専用のアプリが提供されています。</p>

<p><a href="https://realm.io/jp/docs/java/latest/">こちらのサイト</a>の <strong>Realm Browser</strong> の項目からインストールしましょう。</p>

<p>Realm Browserを使えば、下記のようにデータを見ることができます。</p>

<p><img src="/images/swift-realm4.png" alt="Realm Browserで確認１" /><br/>
<img src="/images/swift-realm5.png" alt="Realm Browserで確認２" /></p>

<p>これからSQLiteよりもRealmの方がスタンダートな保存方法となることでしょう。<br/>
どんどん使い方を勉強していかなくては！！<br/>
と言ったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift AFNetworkingライブラリを使ってみよう！]]></title>
    <link href="http://grandbig.github.io/blog/2015/05/24/swift-afnetworking/"/>
    <updated>2015-05-24T10:53:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2015/05/24/swift-afnetworking</id>
    <content type="html"><![CDATA[<h4>通信系ライブラリAFNetworkingの使い方を覚えよう！</h4>

<p>さて、本日はObjective-Cの超有名通信系ライブラリの<a href="https://github.com/AFNetworking/AFNetworking">AFNetworking</a>をSwiftで使ってみようと思います。</p>

<h5>導入の仕方</h5>

<p>まずは導入の仕方を見て行きましょう。<br/>
CocoaPodsを使います。<br/>
Podfileを作成し、下記の内容を記載しましょう。</p>

<p><code>objective-c
platform :ios, '7.0'
pod "AFNetworking", "~&gt; 2.0"
</code></p>

<p>これで<code>pod install</code>すればプロジェクトに <strong>AFNetworking</strong> が追加されるはずです。<br/>
ここで注意したいのが、あくまでもObjective-Cで書かれたライブラリなので、Swiftで使うためにはBridgeファイルを用意する必要があります。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<ol>
<li>プロジェクトにヘッダーファイルを追加します。
ProjectName-Bridging-Header.hという形式が推奨されている模様<br/>
今回はSwiftSample-Bridging-Header.hという名前で追加しました。</li>
<li>TARGETS > SwiftSample > Build Settings > Swift Compiler &ndash; Code Generation > Objective-C Bridging Headerにパスを指定
SwiftSample/SwiftSample-Bridging-Header.hを指定しました。</li>
<li>Bridgeファイルにライブラリを<code>import</code>する</li>
<li>ライブラリを利用するファイルにも<code>import</code>を書きましょう(Swiftの書き方で。)</li>
</ol>


<p>下記の画像を参照ください。
<img src="/images/swift-afnetworking.png" alt="Bridgeファイルの用意" /></p>

<p>また、Bridgeファイルへの具体的な内容を書いておきます。</p>

<p>```objective-c</p>

<h1>ifndef SwiftSample_SwiftSample_Bridging_Header_h</h1>

<h1>define SwiftSample_SwiftSample_Bridging_Header_h</h1>

<h1>endif</h1>

<h1>import &lt;AFNetworking/AFNetworking.h></h1>

<p>```</p>

<h5>GETリクエスト</h5>

<p>では、早速、GETリクエストを書いてみましょう。<br/>
以前の<a href="http://grandbig.github.io/blog/2015/02/12/afnetworking/">AFNetworking2.xでWeb-APIを叩いてみた！</a>でも利用した <strong>OpenWeatherMap API</strong> を例として使います。</p>

<p><code>http://api.openweathermap.org/data/2.5/weather?q=Tokyo,jp</code>でリクエストして、<br/>
下記のデータを返してもらうことを想定しています。</p>

<p>```objective-c</p>

<p>{</p>

<pre><code>base:  "stations",
clouds: {
    all: 32
},
cod: 200,
coord: {
    lat: 35.69,
    lon: 139.65
},
dt: 1432394992,
id: 1850147,
main: {
    grnd_level: 1019.97,
    humidity: 88,
    pressure: 1019.97,
    sea_level: 1024.92,
    temp: 290.99,
    temp_max: 290.99,
    temp_min: 290.99
},
name: Tokyo,
sys: {
    country: "JP",
    message: 0.0386,
    sunrise: 1432323041,
    sunset: 1432374314
},
weather: [
    {
        description: "scattered clouds",
        icon: "03n",
        id: 802,
        main: "Clouds"
    }
],
wind: {
    deg: 198.001,
    speed: 5.11
}
</code></pre>

<p>}</p>

<p>```</p>

<p>では、GETリクエストを投げてみましょう。<br/>
返却されたデータの取得方法についても記載します。</p>

<p>```objective-c
// GETリクエスト
let manager = AFHTTPSessionManager()
manager.GET(&ldquo;<a href="http://api.openweathermap.org/data/2.5/weather?q=Tokyo,jp">http://api.openweathermap.org/data/2.5/weather?q=Tokyo,jp</a>&rdquo;, parameters: nil,</p>

<pre><code>success: { (operation, json) -&gt; Void in
    // 処理が成功した場合
    let dict = json as! [String: AnyObject]
    let weatherArray = dict["weather"] as! [AnyObject]
    let weather = weatherArray[0] as! [String: AnyObject]
    let description = weather["description"] as! String
    println(description)
}, failure: { (operation, error) -&gt; Void in
    // エラーが発生した場合
})
</code></pre>

<p>```</p>

<p>Objective-Cでは下記のように書いていたので、対応づけて見るとわかりやすいかもしれません。</p>

<p>```objective-c
AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];
[manager.GET:@&ldquo;<a href="http://api.openweathermap.org/data/2.5/weather?q=Tokyo,jp">http://api.openweathermap.org/data/2.5/weather?q=Tokyo,jp</a>&rdquo;, parameters: nil,</p>

<pre><code>success:^(NSURLSessionDataTask *task, id responseObject) {
    NSArray *weatherArray = [responseObject objectForKey:@"weather"];
    NSDictionary *weather = [weatherArray objectAtIndex:0];
    NSString *description = [weather objectForKey:@"description"];
    NSLog(description);
}, failure:^(NSURLSessionDataTask *task, NSError *error) {
    // エラーが発生した場合
}];
</code></pre>

<p>```</p>

<p><code>success</code>と<code>failure</code>は戻り値が<code>void</code>なので、Swiftでも<code>-&gt; Void</code>と指定しています。<br/>
<code>[String: AnyObject]</code>は <strong>keyがString型</strong> で <strong>valueがAnyObject(何でもあり)型</strong> のDictionary型への変換で、<br/>
<code>[AnyObject]</code>は <strong>要素がAnyObject(何でもあり)型</strong> のArray型への変換です。</p>

<p>Alamofireとはやはり違った書き方となるので、iOSのターゲットなど要件に従って使い分けていくのが良いでしょう。<br/>
と言ったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
</feed>
