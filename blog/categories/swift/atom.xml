<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: swift | Takahiro Octopress Blog]]></title>
  <link href="http://grandbig.github.io/blog/categories/swift/atom.xml" rel="self"/>
  <link href="http://grandbig.github.io/"/>
  <updated>2017-10-01T00:41:08+09:00</updated>
  <id>http://grandbig.github.io/</id>
  <author>
    <name><![CDATA[Takahiro]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Clean Swiftを勉強してみよう！(1)]]></title>
    <link href="http://grandbig.github.io/blog/2017/09/25/clean-swift/"/>
    <updated>2017-09-25T23:42:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2017/09/25/clean-swift</id>
    <content type="html"><![CDATA[<h3>はじめに</h3>

<p>本日は<a href="https://clean-swift.com/">Clean Swift</a>について書いていきたいと思います。</p>

<h3>Clean Swiftとは</h3>

<p>Clean Swiftは簡単に言うと『<a href="https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html">Clean Architecture</a>のSwift版』です。  <br/>
参考までにClean Architectureの有名な図を掲載します。<br/>
※ <a href="https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html">Clean Architecture</a>より抜粋させて頂きました。<br/>
<img src="/images/clean-swift_1.jpg" alt="Clean Architecture" /></p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<p>Clean Swiftアーキテクチャを採用することで受けられる恩恵として下記が考えられます。</p>

<ul>
<li>各種コンポーネントの責務を細分化することで、Massive ViewControllerの解消に繋がる</li>
<li>データの方向性が一方向になるため、各種コンポーネントの相互依存性が減り、TDD開発が進めやすくなる</li>
<li>各種コンポーネントの責務がはっきりしているため、チーム開発する際に、実装が平準化される</li>
</ul>


<h3>コンポーネントの関係性</h3>

<p>各種コンポーネントの関係性を表した全体像が下図になります。<br/>
<img src="/images/clean-swift_2.png" alt="Clean Swift Architectureの図" /></p>

<p>この関係性を説明するにあたって、各種コンポーネントの責務を理解しておく必要があるのでそれぞれ見ていきましょう。</p>

<h3>各コンポーネントの説明</h3>

<h4>View</h4>

<p>特に他のアーキテクチャと大きく違わない認識です。</p>

<p><strong>責務：</strong><br/>
① iOSアプリの見た目を表現する</p>

<h4>ViewController</h4>

<p><code>Massive ViewController</code> になりがちな部分ですが、Clean Swiftでの責務は以下になります。</p>

<p><strong>責務：</strong><br/>
① <code>Interactor</code> に具体的な処理内容(表示ロジック)を問い合わせる<br/>
② <code>Presenter</code> からの指示を受けて、最適な <code>View</code> を描画する<br/>
③ <code>Router</code> に画面遷移を依頼する</p>

<p>具体例は下記になります。</p>

<p>```objective-c
import UIKit</p>

<p>protocol SampleViewDisplayLogic: class {
  func displaySomething(viewModel: SampleView.Something.ViewModel)
  func displayError(viewModel: SampleView.Something.ViewModel)
  func transitionToSomeWhere(viewModel: SampleView.Sometime.ViewModel)
}</p>

<p>class SampleViewController: UIViewController, SampleViewDisplayLogic {
  var interactor: SampleViewBusinessLogic?
  var router: (NSObjectProtocol &amp; SampleViewRoutingLogic &amp; SampleViewDataPassing)?</p>

<p>  // MARK: Object lifecycle
  override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {</p>

<pre><code>super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
setup()
</code></pre>

<p>  }</p>

<p>  required init?(coder aDecoder: NSCoder) {</p>

<pre><code>super.init(coder: aDecoder)
setup()
</code></pre>

<p>  }</p>

<p>  // MARK: Setup
  private func setup() {</p>

<pre><code>let viewController = self
let interactor = SampleViewInteractor()
let presenter = SampleViewPresenter()
let router = SampleViewRouter()
viewController.interactor = interactor
viewController.router = router
interactor.presenter = presenter
presenter.viewController = viewController
router.viewController = viewController
router.dataStore = interactor
</code></pre>

<p>  }</p>

<p>  // MARK: Routing
  override func prepare(for segue: UIStoryboardSegue, sender: Any?) {</p>

<pre><code>if let scene = segue.identifier {
  let selector = NSSelectorFromString("routeTo\(scene)WithSegue:")
  if let router = router, router.responds(to: selector) {
    router.perform(selector, with: segue)
  }
}
</code></pre>

<p>  }</p>

<p>  // MARK: View lifecycle
  override func viewDidLoad() {</p>

<pre><code>super.viewDidLoad()

fetchSomethingOnLoad()
</code></pre>

<p>  }</p>

<p>  // ① Interactorに具体的な処理内容を問い合わせる
  func fetchSomethingOnLoad() {</p>

<pre><code>let request = SampleView.Something.Request()
interactor?.fetchSomething(request: request)
</code></pre>

<p>  }</p>

<p>  // ② Presenterからの指示を受けてViewを描画する
  func displaySomething(viewModel: SampleView.Something.ViewModel) {</p>

<pre><code>// do something
</code></pre>

<p>  }</p>

<p>  func displayError(viewModel: SampleView.Something.ViewModel) {</p>

<pre><code>// do error something
</code></pre>

<p>  }</p>

<p>  // ③ Routerに画面遷移を依頼する
  func transitionToSomeWhere(viewModel: SampleView.Sometime.ViewModel) {</p>

<pre><code>// 画面遷移
router?.routeToSomeWhere(segue: nil)
</code></pre>

<p>  }
}
```</p>

<p>また、ユーザによるアクション起因の場合は下記のようにするだけです。</p>

<p><code>objective-c
@IBAction func tapSomeAction(_ sender: Any) {
  // ① Interactorに具体的な処理内容を問い合わせる
  let request = SampleView.Sometime.Request()
  interactor?.fetchSometime(request: request)
}
</code></p>

<p><code>Presenter</code> からの指示を受けて、 <code>ViewController</code> は描画処理を実行するため、見た目の整形などの <strong>描画処理自体</strong> は <code>ViewController</code> 内に書きます。</p>

<p>例えば、</p>

<p>・正方形の <code>UIView</code> を角丸にする/背景色を変更する/非表示にする etc<br/>
・マップにマーカを配置する/図形を描画する etc</p>

<h4>Interactor</h4>

<p><code>ViewController</code> から依頼を受け、 <code>Interactor</code> は下記を実施する責務を持っています。</p>

<p><strong>責務：</strong><br/>
① <code>Worker</code> と <code>Presenter</code> を仲介する<br/>
② どんな条件で、 <code>Worker</code> に何の処理を依頼するのかハンドリングする<br/>
③ <code>Worker</code> 経由で取得したレスポンスを <code>Presenter</code> に渡す</p>

<p>```objective-c
import UIKit</p>

<p>protocol SampleViewBusinessLogic {</p>

<pre><code>func fetchSomething(request: SampleView.Something.Request)
func fetchSometime(request: SampleView.Sometime.Request)
</code></pre>

<p>}</p>

<p>protocol SampleViewDataStore {
  // 画面遷移時にパラメータを受け取れるように定義
  var something: String { get set }
}</p>

<p>class SampleViewInteractor: SampleViewBusinessLogic, SampleViewDataStore {</p>

<pre><code>var presenter: SampleViewPresentationLogic?
var worker = SampleViewWorker?
var something: String!

func fetchSomething(request: SampleView.Something.Request) {
  // ① WorkerとPresenterを仲介する
  worker.fetch(success: { (object) in
    // 処理が成功した場合
    // ③ Worker経由で取得したレスポンスをPresenterに渡す  
    let response = SampleView.Something.Response(object: object, isError: false)
    self.presenter?.presentSomething(response: response)
  }, failure: { _ in
    // 処理が失敗した場合
    // ③ Worker経由で取得したレスポンスをPresenterに渡す  
    let response = SampleView.Something.Response(object: object, isError: true)
    self.presenter?.presentSomething(response: response)
  })

func fetchSometime(request: SampleView.Sometime.Request) {
  // ② どんな条件で、Workerに何の処理を依頼するのかハンドリングする
  if request.time &gt; Date() {
    let response = SampleView.Sometime.Response(future: true)
    presenter?.presentSometime(response: response)

    return
  }
  let response = SampleView.Sometime.Response(future: false)
  presenter?.presentSometime(response: response)
}

func fetchSomeWhat(request: SampleView.SomeWhat.Request) {
  // 画面遷移時に渡されたパラメータを利用した描画を実施したい場合
  let response = SampleView.Something.Response(object: something)
  self.presenter?.presentSomething(response: response)
}
</code></pre>

<p>}
```</p>

<h4>Worker</h4>

<p><code>Interactor</code> から受けた依頼を実行します。</p>

<p><strong>責務：</strong><br/>
① <code>API</code> 処理や <code>Core Data</code> / <code>Realm</code> などのアプリ内ローカルデータの処理をハンドリングする<br/>
② 成功/失敗レスポンスをハンドリングする</p>

<p>```objective-c
import UIKit</p>

<p>class SampleViewWorker {</p>

<pre><code>func fetch(success: @escaping ((SomeObject) -&gt; Void), failure: @escaping ((Error) -&gt; Void)) {
  // APIリクエストまたはローカルDBへのアクセスを実行してデータを取得
  // 具体的な処理は省略
  let obj: SomeObject = ...
  success(obj)
}) { (error) in
  failure(error)
}
</code></pre>

<p>}
```</p>

<h4>Presenter</h4>

<p><code>Interactor</code> から <code>Worker</code> 経由で取得したレスポンスを受け取った後に、 <code>Presenter</code> は下記を実行することを責務とします。</p>

<p><strong>責務：</strong><br/>
① 受け取ったレスポンスを元に最適な表示(成功/失敗などの表示)になるようハンドリングする<br/>
② 受け取ったレスポンスを <code>Model.ViewModel</code> 形式に変換する<br/>
③ <code>ViewController</code> に <code>Model.ViewModel</code> を渡して描画を依頼する</p>

<p>```objective-c
import UIKit</p>

<p>protocol SampleViewPresentationLogic {
  func presentSomething(response: SampleView.Something.Response)
}</p>

<p>class SampleViewPresenter: SampleViewPresentationLogic {
  weak var viewController: SampleViewDisplayLogic?</p>

<p>  // MARK: Present something</p>

<p>  func presentSomething(response: SampleView.Something.Response) {</p>

<pre><code>// ② 受け取ったレスポンスをModel.ViewModel形式に変換する
let viewModel = SampleView.Something.ViewModel(object: response.object)

// ① 受け取ったレスポンスを元に最適な表示(成功/失敗などの表示)になるようハンドリングする
if response.isError {
  // エラーがある場合
  // ③ ViewControllerにModel.ViewModelを渡して描画を依頼する  
  viewController?.displayError(viewModel: viewModel)
  return
}

// ③ ViewControllerにModel.ViewModelを渡して描画を依頼する
viewController?.displaySomething(viewModel: viewModel)
</code></pre>

<p>  }
}
```</p>

<h4>Model</h4>

<p>Clean Swiftアーキテクチャの肝といっても過言ではないのが <code>Model</code> です。</p>

<p><strong>責務：</strong><br/>
① 各種コンポーネントを切り離し、各種コンポーネント間のやり取りに利用される<br/>
② <code>Request</code> / <code>Response</code> / <code>ViewModel</code> の3つの構造体を持つ</p>

<p><strong>3つの構造体の説明：</strong><br/>
・ <code>Request</code><br/>
　　・ ユーザの操作をInputパラメータとして内包したデータ形式<br/>
　　・ <code>ViewController</code> から <code>Interactor</code> に渡される<br/>
・ <code>Response</code><br/>
　　・ <code>Worker</code> 処理結果を内包しているデータ形式<br/>
　　・ <code>Interactor</code> から <code>Presenter</code> に渡される<br/>
・ <code>ViewModel</code><br/>
　　・ <code>ViewController</code> での描画に即したデータ形式<br/>
　　・ <code>Presenter</code> から <code>ViewController</code> に渡される</p>

<p>```objective-c
import UIKit</p>

<p>enum SampleView {</p>

<p>  // MARK: Fetch something
  enum Something {</p>

<pre><code>struct Request {
}
struct Response {
  var object: SomeObject
  var isError: Bool
}
struct ViewModel {
  var object: SomeObject
}
</code></pre>

<p>  }</p>

<p>  // MARK: Fetch sometime
  enum Sometime {</p>

<pre><code>struct Request {
  ...
}
struct Response {
  ...
}
struct ViewModel {
  ...
}
</code></pre>

<p>  }
}
```</p>

<h3>データフローの例</h3>

<p>各コンポーネントの責務を理解した上で、コンポーネント間のフローの流れを見ていきましょう。</p>

<h4>ユーザがボタンをタップして通信処理後に取得データを描画するフロー</h4>

<p>ユーザが <code>View</code> 上のボタンをタップした後に、外部APIを叩いて取得したデータで <code>View</code> 描画するデータフローは下記になります。</p>

<p>① <code>ViewController</code> が <code>View</code> に対するユーザアクションを検知<br/>
② <code>ViewController</code> が <code>Interactor</code> に <code>Model.Request</code> を送って具体的な処理を依頼<br/>
③ <code>Interactor</code> が <code>Worker</code> に処理を依頼<br/>
④ <code>Worker</code> が通信処理した結果を <code>Interactor</code> に返却<br/>
⑤ <code>Interactor</code> が返却データを <code>Model.Response</code> に変換して、 <code>Presenter</code> に処理を依頼 <br/>
⑥ <code>Presenter</code> が受け渡されたデータを <code>Model.ViewModel</code> に変換して、 <code>ViewController</code> に描画を指示<br/>
⑦ <code>ViewController</code> が <code>View</code> に描画を反映</p>

<p><img src="/images/clean-swift_3.png" alt="データのフロー例１" /></p>

<p>※このフローでは画面遷移がないため、Routerへの繋がりはありません。</p>

<h4>ユーザがボタンをタップしてローカルDBからデータ取得して画面遷移するフロー</h4>

<p>ユーザが <code>View</code> 上のボタンをタップした後に、ローカルDB内データを取得して、画面遷移するデータフローは下記になります。</p>

<p>① <code>ViewController</code> が <code>View</code> に対するユーザアクションを検知<br/>
② <code>ViewController</code> が <code>Interactor</code> に <code>Model.Request</code> を送って具体的な処理を依頼<br/>
③ <code>Interactor</code> が <code>Worker</code> に処理を依頼<br/>
④ <code>Worker</code> がローカルDBから処理した結果を <code>Interactor</code> に返却<br/>
⑤ <code>Interactor</code> が返却データを <code>Model.Response</code> に変換して、 <code>Presenter</code> に処理を依頼 <br/>
⑥ <code>Presenter</code> が受け渡されたデータを <code>Model.ViewModel</code> に変換して、 <code>ViewController</code> に描画を指示<br/>
⑦ <code>ViewController</code> が <code>Router</code> に画面遷移を依頼<br/>
⑧ <code>Router</code> が依頼された画面先にデータを受け渡し、画面遷移を実行</p>

<p><img src="/images/clean-swift_4.png" alt="データのフロー例２" /></p>

<h3>まとめ</h3>

<p>まず、各種コンポーネントの責務と、そのコンポーネント間の関係性および抽象的なデータフローについて説明しました。<br/>
次回は具体的なサンプルを元にClean Swiftについて説明したいと思います。</p>

<p>参考URL:</p>

<ul>
<li><a href="https://clean-swift.com/clean-swift-ios-architecture/">Clean Swift公式ページ</a></li>
<li><a href="https://hackernoon.com/introducing-clean-swift-architecture-vip-770a639ad7bf">Introducing Clean Swift Architecture (VIP)</a></li>
<li><a href="https://swifting.io/blog/2016/09/07/architecture-wars-a-new-hope/">swifting.io: #24 Architecture Wars – A New Hope</a></li>
</ul>


<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Firebase NotificationをiOSで使ってみよう！]]></title>
    <link href="http://grandbig.github.io/blog/2017/09/18/firebase-notification/"/>
    <updated>2017-09-18T00:45:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2017/09/18/firebase-notification</id>
    <content type="html"><![CDATA[<h3>はじめに</h3>

<p>今回はFirebase Notificationについて見ていきたいと思います。<br/>
一昔前であれば、プロダクトごとにNotificationの仕組みを作り込んだり、共通基盤としてNotificationプロジェクトを推進していたりといった会社が多かった気がします。<br/>
また、未だにリッチなNotificationのプロダクトを生業として利益を上げている会社もあるので、それだけNotificationの仕組みは自作ではなくあるものを使いたいという需要が大きいのでしょう。<br/>
しかしながら、Firebaseの登場により、Notificationプロダクト市場もより加熱化しているのではないでしょうか。</p>

<p>筆者的にはGoogleが出す、それも無料のプロダクトであるわけなので、使わない手はないと思うわけです。<br/>
なんて偉そうなことを言いつつ、FireabseによるNotificationの仕組みを利用したことがなかったので、今回試しに使ってみることにしました。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h3>Firebaseの導入</h3>

<p>こちらの内容は<a href="https://grandbig.github.io/blog/2017/05/14/firebase-ios/">以前書いた記事</a>に任せたいと思います。</p>

<h3>APNs証明書の作成</h3>

<p>こちらに関しては、様々なサイトにて説明がされているので、そちらを見るなどした方が早いので省きます。<br/>
例えば <a href="http://qiita.com/natsumo/items/d5cc1d0be427ca3af1cb#6-apns%E7%94%A8%E8%A8%BC%E6%98%8E%E6%9B%B8cer%E3%81%AE%E4%BD%9C%E6%88%90">プッシュ通知に必要な証明書の作り方2017</a>など参考にすると良いでしょう。</p>

<h3>Firebase Notificationの利用</h3>

<p>さて、本題です。<br/>
Firebase Notificationを利用するための手順について説明します。</p>

<p>① 作成したAPNs証明書をダウンロードする<br/>
先程作成したAPNs証明書はキーチェーンに登録していると思います。<br/>
(Apple Developer Programで作成したAPNs証明書は必ずDLしてキーチェーンに登録しましょう。)<br/>
キーチェーンを開いて、該当の証明書をダウンロードします。</p>

<p>該当のAPNs証明書は <code>Apple Development IOS Push Services: xxxxx</code> のようになっているものです。<br/>
<img src="/images/firebase_notificcation_ios_1.png" alt="キーチェーンを開く" /></p>

<p>右クリックして書き出すを選択します。<br/>
<img src="/images/firebase_notificcation_ios_2.png" alt="証明書を書き出す" /></p>

<p>ファイル名とパスワードをつけて保存します。<br/>
<img src="/images/firebase_notificcation_ios_3.png" alt="ファイル名とパスワードの付け方" /></p>

<p>② ダウンロードしたAPNs証明書をFirebaseに登録する</p>

<p>FirebaseのConsoleを開き、設定画面に遷移します。<br/>
<img src="/images/firebase_notificcation_ios_4.png" alt="Firebase Consoleの設定画面" /></p>

<p>クラウドメッセージングタブを開き、APNs証明書をアップロードします。<br/>
<img src="/images/firebase_notificcation_ios_5.png" alt="Firebase Console クラウドメッセージングタブ" /></p>

<p>③ Firebaseの必要ライブラリを導入する<br/>
Firebaseの導入で<code>Core</code>ライブラリはインストールできているかもしれませんが、Notificationでは<code>Messaging</code>が必要になります。<br/>
よって、<code>Podfile</code>を下記のように修正して、<code>pod update</code>をする必要があります。</p>

<p>```objective-c</p>

<h1>Podfile</h1>

<p>use_frameworks!</p>

<p>target &ldquo;NotificationSample&rdquo; do
  # Normal libraries
  pod &lsquo;Firebase/Core&rsquo;
  pod &lsquo;Firebase/Messaging&rsquo;</p>

<p>  abstract_target &lsquo;Tests&rsquo; do</p>

<pre><code>inherit! :search_paths
target "NotificationSampleTests"
target "NotificationSampleUITests"
</code></pre>

<p>  end
end
```</p>

<p>④ ソースコードにFirebase Notificationが利用できるように実装する<br/>
続いて、ソースコードの設定です。</p>

<p>```objective-c
// AppDelegate.swift
import UIKit
import Firebase
import UserNotifications</p>

<p>@UIApplicationMain
class AppDelegate: UIResponder, UIApplicationDelegate, UNUserNotificationCenterDelegate, MessagingDelegate {
  var window: UIWindow?
  func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) &ndash;> Bool {</p>

<pre><code>// リモート通知 (iOS10に対応)
let authOptions: UNAuthorizationOptions = [.alert, .badge, .sound]
UNUserNotificationCenter.current().requestAuthorization(
  options: authOptions,
  completionHandler: {_, _ in })

// UNUserNotificationCenterDelegateの設定
UNUserNotificationCenter.current().delegate = self
// FCMのMessagingDelegateの設定
Messaging.messaging().delegate = self

// リモートプッシュの設定
application.registerForRemoteNotifications()
// Firebase初期設定
FirebaseApp.configure()

// アプリ起動時にFCMのトークンを取得し、表示する
let token = Messaging.messaging().fcmToken
print("FCM token: \(token ?? "")")

return true
</code></pre>

<p>  }</p>

<p>  // 省略</p>

<p>  func userNotificationCenter(_ center: UNUserNotificationCenter,</p>

<pre><code>                            willPresent notification: UNNotification,
                            withCompletionHandler completionHandler: @escaping (UNNotificationPresentationOptions) -&gt; Void) {
print("フロントでプッシュ通知受け取ったよ")
</code></pre>

<p>  }</p>

<p>  func messaging(_ messaging: Messaging, didRefreshRegistrationToken fcmToken: String) {</p>

<pre><code>print("Firebase registration token: \(fcmToken)")
</code></pre>

<p>  }
}
```</p>

<p>たったのこれだけでプッシュ通知の受信ができるようになります。</p>

<h3>Firebase Notificationを利用する</h3>

<p>設定が完了したため、Firebaseからプッシュ通知を送ってみましょう。</p>

<p>方法は簡単です。</p>

<p>① 左メニューから <code>Notification</code> を選択する<br/>
② 「新しいメッセージ」を選択する<br/>
③ 必要項目を入力して「メッセージを送る」を選択する</p>

<p><img src="/images/firebase_notificcation_ios_6.png" alt="Firebase Consoleからプッシュ通知を送る" /></p>

<p>これにより、下図のようにプッシュが届くことを確認できます。<br/>
<img src="/images/firebase_notificcation_ios_7.png" alt="端末にプッシュ通知が届く" /></p>

<h3>FirebaseにAPNs Keyを登録する方法</h3>

<p>さて、上記まででは、APNs証明書を作成して、Firebaseに登録する方法を説明しましたが、実はAPNs証明書よりも <code>APNs Key</code> というものの利用を推奨されています。<br/>
なので、こちらの方法も説明しておきます。</p>

<p>作成方法はいたって簡単です。</p>

<p>① Apple Developer Programの左メニューから<code>Keys &gt; All</code>を選択する<br/>
② 「＋」ボタンで新規作成する<br/>
③ Keyの名称を設定する<br/>
④ Service種別として<code>APNs</code>を選択する<br/>
⑤ Continueボタンを選択して作成する</p>

<p><img src="/images/firebase_notificcation_ios_8.png" alt="APNs Keyの作成方法" /></p>

<p>上記で作成した<code>APNs Key</code>をFirebase Console上で設定します。</p>

<p>Firebase Console > 設定 > クラウドメッセージング > iOSアプリの設定から<code>APNs認証キー</code>に設定します。</p>

<p><img src="/images/firebase_notificcation_ios_9.png" alt="APNs認証キーを設定" /></p>

<p>因みに、設定時に利用するIDはそれぞれ下記から取得します。</p>

<p><img src="/images/firebase_notificcation_ios_10.png" alt="キーID" /><br/>
<img src="/images/firebase_notificcation_ios_11.png" alt="App ID Prefix" /></p>

<h3>まとめ</h3>

<p>さて如何でしたでしょうか？<br/>
まだまだFirebase Console上からプッシュできるNotificationにも制限があるようですが、複雑なことをしない例えば「一斉お知らせ機能」のような形で利用するのであれば非常に良いのではないでしょうか？<br/>
今後もバージョンアップして使いやすくなることを期待しつつ、本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UICollectionViewCellをカスタム化しよう！]]></title>
    <link href="http://grandbig.github.io/blog/2017/08/06/custome-collectionview/"/>
    <updated>2017-08-06T03:41:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2017/08/06/custome-collectionview</id>
    <content type="html"><![CDATA[<h3>はじめに</h3>

<p>今回は基礎中の基礎ではあるものの、結構忘れがちなカスタム化についてメモ書きしておきたいと思います。<br/>
その題材として <code>UICollectionViewCell</code> を使ってみます。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h3>カスタムファイルの作成</h3>

<p>まずは <code>xib</code> ファイルを作成します。<br/>
今回は下記のように <code>UIImageView</code> を持たせるようにカスタム化させます。<br/>
(<code>CustomCollectionViewCell.xib</code>とします。)</p>

<p><img src="/images/custom-collection-view-1.png" alt="xibファイル" /></p>

<p>これと対となる<code>swift</code>ファイルを作成します。<br/>
(<code>CustomCollectionViewCell.swift</code>とします。)</p>

<p>```objective-c
// CustomCollectionViewCell.swift
import UIKit</p>

<p>class CustomCollectionViewCell: UICollectionViewCell {</p>

<p>  @IBOutlet weak var imageView: UIImageView!</p>

<p>  override init(frame: CGRect) {</p>

<pre><code>super.init(frame: frame)
self.xibViewSet()
</code></pre>

<p>  }</p>

<p>  required init?(coder aDecoder: NSCoder) {</p>

<pre><code>super.init(coder: aDecoder)!
self.xibViewSet()
</code></pre>

<p>  }</p>

<p>  internal func xibViewSet() {</p>

<pre><code>if let view = Bundle.main.loadNibNamed("CustomCollectionViewCell", owner: self, options: nil)?.first as? UIView {
  view.frame = self.bounds
  self.addSubview(view)
}
</code></pre>

<p>  }
}
```</p>

<p>この<code>xib</code>と<code>swift</code>ファイルを繋ぐために <code>xib</code>ファイルの<code>File's Owner</code>の<code>Custom Class</code>の<code>Class</code>にクラス名を入力します。</p>

<p><img src="/images/custom-collection-view-2.png" alt="xibとswiftの接続" /></p>

<h3>Storyboardにカスタム部品を配置</h3>

<p>続いて、先程作成したカスタム部品を<code>Storyboard</code>に配置します。<br/>
今回は <code>UICollectionViewCell</code> をカスタム化しているので、右メニューから <code>UICollectionView</code> をドラッグ&amp;ドロップして持ってきます。</p>

<p><img src="/images/custom-collection-view-3.png" alt="UICollectionViewをドラッグ&amp;ドロップ" /></p>

<p>持ってきた部品とカスタム化クラスを結びつけます。<br/>
<code>右メニュー &gt; Show the Identity inspector &gt; Custom Class &gt; Class</code> にクラス名を入力します。</p>

<p><img src="/images/custom-collection-view-4.png" alt="カスタムクラスへの接続" /></p>

<h3>CustomCollectionViewCellの表示</h3>

<p>ここまでくれば後はいつも通り<code>UICollectionView</code>を使えば良いだけです。</p>

<p>・ <code>Storyboard</code> 上で <code>Collection Reusable View</code> の <code>Identifier</code> に値を設定<br/>
・ 下記の通りソースコードを実装</p>

<p>```objective-c
import Foundation
import UIKit</p>

<p>class CreateShopMemoViewController: UIViewController, UICollectionViewDataSource {</p>

<p>  /// UICollectionView
  @IBOutlet weak var collectionView: UICollectionView!</p>

<p>  override func viewDidLoad() {</p>

<pre><code>super.viewDidLoad()
self.collectionView.dataSource = self
</code></pre>

<p>  }</p>

<p>  override func didReceiveMemoryWarning() {</p>

<pre><code>super.didReceiveMemoryWarning()
// Dispose of any resources that can be recreated.
</code></pre>

<p>  }</p>

<p>  // MARK: &ndash; UICollectionViewDataSource
  func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) &ndash;> UICollectionViewCell {</p>

<pre><code>let cell = collectionView.dequeueReusableCell(withReuseIdentifier: "CustomCell", for: indexPath) as? CustomCollectionViewCell   
// 画像を設定 (今回はサンプルのためNoImageIconというものがあることを想定しています)
cell?.imageView.image = UIImage(named: "NoImageIcon")

return cell!
</code></pre>

<p>  }</p>

<p>  func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) &ndash;> Int {</p>

<pre><code>return 1
</code></pre>

<p>  }
}
```</p>

<p>その結果は下記の通りです。</p>

<p><img src="/images/custom-collection-view-6.png" alt="CustomCollectionViewCellの表示" /></p>

<p>因みに、今回のように、Viewを1枚ペタッと貼るだけであれば、</p>

<p>```objective-c
// MARK: &ndash; UICollectionViewDataSource
func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) &ndash;> UICollectionViewCell {
  let cell = collectionView.dequeueReusableCell(withReuseIdentifier: &ldquo;CustomCell&rdquo;, for: indexPath) <br/>
  // 画像を設定 (今回はサンプルのためNoImageIconというものがあることを想定しています)
  cell.backgroundView = UIImageView(image: UIImage(named: &ldquo;NoImageIcon&rdquo;))</p>

<p>  return cell
}
```</p>

<p>とすれば良いだけです。</p>

<h3>まとめ</h3>

<p>今回は完全なるメモ書きでしたが、カスタム化の基礎なので、十二分に慣れておかないとですね。<br/>
と言ったところで本日はここまで。</p>

<p>参考</p>

<ul>
<li><a href="http://himaratsu.hatenablog.com/entry/ios/customview">カスタムViewをNibから初期化し、IBDesignableとIBInspectableで便利に使う</a></li>
<li><a href="http://qiita.com/taketomato/items/7bf3f1dc2690c76079fb">xib 化した UITableViewCell を使うときの Tips</a></li>
</ul>


<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bond, SwiftBondを使ってみよう！]]></title>
    <link href="http://grandbig.github.io/blog/2017/07/31/swiftbond-1/"/>
    <updated>2017-07-31T20:17:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2017/07/31/swiftbond-1</id>
    <content type="html"><![CDATA[<h3>はじめに</h3>

<p>さて、今回はiOSで <code>MVVM</code> アーキテクチャで重宝されている<a href="https://github.com/ReactiveKit/Bond">ReactiveKit/Bond</a>(SwiftBond)について勉強したいと思います。<br/>
趣味で個人iOSアプリを作成する分にはそこまで大規模アプリになることも少ないとは思うものの、仕事で大人数で1つのアプリを開発することは当然あることでしょう。<br/>
そんなときに備えて知識を向上させたいと思います。<br/>
(今まで <code>MVC</code> で済んできたこともあり、良い機会なので <code>MVVM</code> を勉強したいと思っています。)</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h3>MVVMとは</h3>

<p>まず、 <code>MVVM</code> とはそもそも何なのでしょうか？<br/>
<code>MVVM</code> とは <code>Model View ViewModel</code> の略です。</p>

<p><a href="https://ja.wikipedia.org/wiki/Model_View_ViewModel">Wikipedia</a>を見ると、それぞれ</p>

<ul>
<li><code>Model</code>

<ul>
<li>そのアプリケーションが扱う領域のデータと手続き (ビジネスロジック)を表現する要素</li>
<li>データの格納に永続的な記憶の仕組み(データベース)やサーバ側との通信ロジックなど</li>
</ul>
</li>
<li><code>View</code>

<ul>
<li>ユーザに見せるためのアウトプット描画およびユーザ入力を受け取る(UIへの入力とUIからの出力を担当する)要素</li>
<li>データバインディング機構を通して自動的に描画</li>
<li><code>View</code> そのものに複雑なロジックや状態を持たない</li>
</ul>
</li>
<li><code>ViewModel</code>

<ul>
<li>Viewを描画するための状態の保持と、Viewから受け取った入力を適切な形に変換してModelに伝達する役目を持つ</li>
</ul>
</li>
</ul>


<p>と書かれています。<br/>
他の方のブログ記事を見ても、上記からそう遠くはない印象です。</p>

<h3>Bond, SwiftBondとは</h3>

<p><code>Bond</code> は昔は <code>SwiftBond</code> と呼ばれていたようですが、今はGitHub上でも <code>ReactiveKit</code> の一部として提供されているようです。<br/>
元々、 <code>SwiftBond</code> も <code>ReactiveKit</code> も開発者は同じなので、どこかのタイミングで取り込まれたんですかね&hellip;。<br/>
この <code>Bond</code> を <code>MVVM</code> で言うところのデータバインディング機構を実現するために利用します。</p>

<h3>サンプルを作ってみよう</h3>

<p>今回のサンプルで扱う機能は下記です。</p>

<ul>
<li>Google　Mapに現在地周辺のレストランをマッピングする</li>
<li>レストラン情報はホットペッパーAPIの周辺レストラン検索APIから取得する</li>
</ul>


<p>続いてXcode上のフォルダ構成は下記にします。</p>

<p><code>objective-c
SampleApp
├── Model
│    └── HotpepperAPI.swift
├── ViewModel
│    └── HotpepperAPIViewModel.swift
├── View
│    └── ViewController.swift
├── AppDelegate.swift
└── Main.storyboard
</code></p>

<p>また、今回は <code>Google Maps SDK for iOS</code> と ホットペッパーのAPIを利用します。<br/>
これらのAPIキーを公式案内を元に取得して、 <code>Info.plist</code> と同じ階層に作成した <code>key.plist</code> に追加します。</p>

<p><img src="/images/swiftbond_1.png" alt="ホットペッパーAPIキー" /></p>

<p>さて下準備は済んだので、各ファイルの実装を見ていきましょう。</p>

<h4>AppDelegate.swift</h4>

<p><code>Google Maps SDK for iOS</code> を利用するために <code>AppDelegate.swift</code> に下記処理を実装します。</p>

<p>```objective-c
import UIKit
import GoogleMaps</p>

<p>@UIApplicationMain
class AppDelegate: UIResponder, UIApplicationDelegate {</p>

<p>  var window: UIWindow?</p>

<p>  func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) &ndash;> Bool {</p>

<pre><code>// Override point for customization after application launch.

if let path = Bundle.main.path(forResource: "key", ofType: "plist") {
  if let dic = NSDictionary(contentsOfFile: path) as? [String: Any] {
    if let apiKey = dic["googleMapsApiKey"] as? String {
      GMSServices.provideAPIKey(apiKey)
    }
  }
}

return true
</code></pre>

<p>  }
  &hellip;
}
```</p>

<h4>HotpepperAPI.swift</h4>

<p>ホットペッパーのグルメサーチAPIを利用する <code>Model</code> ファイルです。<br/>
今回はサンプルということもあって、ほとんど複雑な処理はありません。</p>

<p>```objective-c
// HotpepperAPI.swift
import Foundation
import CoreLocation
import Alamofire
import SwiftyJSON</p>

<p>/<em>*
 ホットペッパーAPI
 </em>/
class HotpepperAPI {
  /// API Key
  private var apiKey: String = String()
  /// ホットペッパーAPIのベースURL
  private let baseURL: String = &ldquo;<a href="https://webservice.recruit.co.jp/hotpepper/gourmet/v1/">https://webservice.recruit.co.jp/hotpepper/gourmet/v1/</a>&rdquo;</p>

<p>  /// 初期化処理
  init() {</p>

<pre><code>if let path = Bundle.main.path(forResource: "key", ofType: "plist") {
  if let dic = NSDictionary(contentsOfFile: path) as? [String: Any] {
    if let apiKey = dic["hotpepperApiKey"] as? String {
      self.apiKey = apiKey
    }
  }
}
</code></pre>

<p>  }</p>

<p>  /**
   ホットペッパーグルメサーチAPI</p>

<ul>
<li> parameter coordinate: 位置</li>
<li><p> parameter completion: レストラン情報を返却するcallback
*/
func searchRestaurant(coordinate: CLLocationCoordinate2D, completion: @escaping ((JSON) &ndash;> Void)) {
let parameters = [&ldquo;key&rdquo;: self.apiKey, &ldquo;format&rdquo;: &ldquo;json&rdquo;, &ldquo;lat&rdquo;: coordinate.latitude, &ldquo;lng&rdquo;: coordinate.longitude, &ldquo;range&rdquo;: 2] as [String : Any]
Alamofire.request(baseURL, method: .get, parameters: parameters, encoding: URLEncoding.default, headers: nil).responseJSON { response in
  let json = JSON(response.result.value as Any)
  let result = json[&ldquo;results&rdquo;][&ldquo;shop&rdquo;]</p>

<p>  completion(result)
}
}
}
```</p></li>
</ul>


<h4>HotpepperAPIViewModel.swift</h4>

<p><code>Model</code>である<code>HotpepperAPI.swift</code>と<code>View</code>である<code>ViewController.swift</code>を繋ぐ<code>ViewModel</code>ファイルです。<br/>
<code>View</code>からの入力受付を想定して<code>searchRestaurant</code>メソッドを用意しています。</p>

<p>```objective-c
// HotpepperAPIViewModel.swift
import Foundation
import ReactiveKit
import Bond
import SwiftyJSON
import CoreLocation</p>

<p>/// 通信の各状態をEnumで表現
enum RequestState {
  case none
  case requesting
  case finish
  case error
}</p>

<p>/// HotpepperAPIのViewModelクラス
final class HotpepperAPIViewModel {</p>

<p>  var items: ObservableArray<JSON> = ObservableArray([])
  let requestState = Observable<RequestState>(.none)
  let hotpepperAPI = HotpepperAPI.init()</p>

<p>  var finishSearchRestaurant: Signal&lt;[JSON]?, NoError> {</p>

<pre><code>return self.requestState.map({ (requestState) -&gt; [JSON]? in
  if requestState == .finish {
    return self.items.array
  }
  return nil
})
</code></pre>

<p>  }</p>

<p>  func searchRestaurant(coordinate: CLLocationCoordinate2D) {</p>

<pre><code>self.requestState.next(RequestState.requesting)
hotpepperAPI.searchRestaurant(coordinate: coordinate, completion: { (result) in
  guard let resultArray = result.array else {
    return
  }
  self.items = ObservableArray(resultArray)
  self.requestState.next(RequestState.finish)
})
</code></pre>

<p>  }
}
```</p>

<p>上記では、<code>searchRestaurant</code>の中で先程紹介した<code>Model</code>の<code>HotpepperAPI</code>クラスにアクセスしてサーバ通信を委託しています。<br/>
また、返却された値を受け取って<code>requestState</code>の状態を変えることが、<code>finishSearchRestaurant</code>の処理のトリガーになっています。<br/>
<code>finishSearchRestaurant</code>では、<code>RequestState</code>の状態が<code>finish</code>になったときのみ正しい値を返却し、それ以外は<code>nil</code>を返却しています。</p>

<h4>ViewController.swift</h4>

<p>最後に <code>View</code> に当たる <code>ViewController.swift</code> について見ていきます。<br/>
iOSでファットになりがちな <code>ViewController</code> を <code>View</code> の定義に則って実装していくというのがキーになります。</p>

<p>```objective-c
// ViewController.swift
import UIKit
import GoogleMaps
import SwiftyJSON
import RealmSwift</p>

<p>class ViewController: UIViewController {
  /// マップビュー
  @IBOutlet weak var mapView: GMSMapView!
  /// 検索ボタン
  @IBOutlet weak var searchButton: UIButton!
  /// 現在地
  internal var currentLocation: CLLocationCoordinate2D?
  /// ViewModel
  internal var hotpepperAPIVM = HotpepperAPIViewModel()</p>

<p>  override func viewDidLoad() {</p>

<pre><code>super.viewDidLoad()

// データバインディング機構の設定処理
self.setUpBind()
</code></pre>

<p>  }</p>

<p>  &hellip;</p>

<p>  private func setUpBond() {</p>

<pre><code>// 検索ボタンをタップ(.touchUpInside)したときに呼び出される処理
_ = self.searchButton.reactive.tap.observeNext { _ in
  self.hotpepperAPIVM.searchRestaurant(coordinate: self.currentLocation!)
}
// finishSearchRestaurantから値が返却されるときに呼び出される処理
_ = self.hotpepperAPIVM.finishSearchRestaurant.ignoreNil().observeNext(with: { (searchShops) in
  for searchShop in searchShops {
    // Google Mapへのマッピング処理
    // 省略
  }
})
</code></pre>

<p>  }
}
```</p>

<p>上記のように実装することで、データバインディング機構を <code>View</code> に実装することができます。<br/>
ポイントは上記ソース内コメントに書いた通りですが、筆者が苦戦したのは、</p>

<ul>
<li><code>_ =</code> から始めなかったためSwift3の静的解析で怒られた</li>
<li><code>observeNext</code> 内で <code>nil</code> 判定してしまっていたが、 <code>ignoreNil</code> という便利なものがある</li>
</ul>


<p>の2点です。</p>

<h3>まとめ</h3>

<p>さて如何でしたでしょうか？<br/>
筆者的にもまだまだ理解しきれていないところがあり、引き続き勉強する必要があると感じています。<br/>
特にエラーハンドリング周りでは <code>ReactiveKit</code> を利用することで、<br/>
うまく書けるようになるのではという期待感があるのでもう少し見ていきたいと思っています。<br/>
と言ったところで本日はここまで。</p>

<p>参考</p>

<ul>
<li><a href="http://qiita.com/hachinobu/items/27a92d480db24511559a">SwiftBondの魅力 ~実用サンプル編~</a></li>
<li><a href="http://qiita.com/susieyy/items/2af5321b287b8d2f49f6">MVVMをベースに複雑な振る舞いをしっかり把握できるアプリ開発</a></li>
<li><a href="http://qiita.com/ko2ic/items/44c18b07c7f337dfb06b">SwiftBondをSwift3対応するためにv5にマイグレーションする</a></li>
<li><a href="https://www.raywenderlich.com/149753/bond-tutorial-bindings-swift">Bond Tutorial: Bindings in Swift</a></li>
<li><a href="https://github.com/ReactiveKit/ReactiveKit">ReactiveKit/ReactiveKit</a></li>
</ul>


<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AlamofireImageを使ってみよう！]]></title>
    <link href="http://grandbig.github.io/blog/2017/07/23/alamofireimage/"/>
    <updated>2017-07-23T15:35:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2017/07/23/alamofireimage</id>
    <content type="html"><![CDATA[<h3>はじめに</h3>

<p>本日は何気に今まで使ってこなかった<a href="https://github.com/Alamofire/AlamofireImage">AlamofireImage</a>についてメモ書きです。<br/>
キャッシュコントロールやら同期/非同期での画像取得など考えなくても良いというのはパワー的にかなり楽になりますね。<br/>
ということで早速見ていきましょう。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h3>API経由で取得した画像URLを使ってUIImageViewに画像を表示する</h3>

<h4>テストとして利用するAPI</h4>

<p>今回はテスト用APIとして<a href="https://webservice.recruit.co.jp/hotpepper/reference.html">ホットペッパーのグルメサーチAPI</a>を利用しました。</p>

<p>ホットペッパーAPIを利用するには新規登録して<code>API Key</code>をゲットする必要があります。<br/>
また、前提として取得した<code>API Key</code>は<code>key.plist</code>に書いているとします。</p>

<p><img src="/images/alamofireimage_1.png" alt="API Keyをkey.plistに書き出し" /></p>

<p>上記準備をした上で下記クラスを作成しました。</p>

<p>```objective-c
// HotpepperAPI.swift
import Foundation
import CoreLocation
import Alamofire
import SwiftyJSON</p>

<p>/<em>*
 ホットペッパーAPI
 </em>/
class HotpepperAPI {
  /// API Key
  private var apiKey: String = String()
  /// ホットペッパーAPIのベースURL
  private let baseURL: String = &ldquo;<a href="https://webservice.recruit.co.jp/hotpepper/gourmet/v1/">https://webservice.recruit.co.jp/hotpepper/gourmet/v1/</a>&rdquo;</p>

<p>  /// 初期化処理
  init() {</p>

<pre><code>if let path = Bundle.main.path(forResource: "key", ofType: "plist") {
  if let dic = NSDictionary(contentsOfFile: path) as? [String: Any] {
    if let apiKey = dic["hotpepperApiKey"] as? String {
      self.apiKey = apiKey
    }
  }
}
</code></pre>

<p>  }</p>

<p>  /**
   ホットペッパーグルメサーチAPI</p>

<ul>
<li> parameter coordinate: 位置</li>
<li><p> parameter completion: レストラン情報を返却するcallback
*/
func searchRestaurant(coordinate: CLLocationCoordinate2D, completion: @escaping ((JSON) &ndash;> Void)) {
let parameters = [&ldquo;key&rdquo;: self.apiKey, &ldquo;format&rdquo;: &ldquo;json&rdquo;, &ldquo;lat&rdquo;: coordinate.latitude, &ldquo;lng&rdquo;: coordinate.longitude, &ldquo;range&rdquo;: 2] as [String : Any]
Alamofire.request(baseURL, method: .get, parameters: parameters, encoding: URLEncoding.default, headers: nil).responseJSON { response in
  let json = JSON(response.result.value as Any)
  let result = json[&ldquo;results&rdquo;][&ldquo;shop&rdquo;]</p>

<p>  completion(result)
}
}
}
```</p></li>
</ul>


<h4>テストとして用意するUIImageView</h4>

<p>今回はテストとして <strong>マップにプロットしたマーカをタップしたときに表示するInfoWindow内にUIImageViewを用意する</strong> ようにしました。</p>

<p>【準備事項】<br/>
&ndash; Google Maps SDK for iOSをマップとして利用<br/>
&ndash; マーカタップ時に表示されるInfoWindowをカスタム化</p>

<p>表示するViewとしては下図のようになります。<br/>
<img src="/images/alamofireimage_2.png" alt="MarkerInfoContentsView.xib" /></p>

<h4>AlamofireImageの用意</h4>

<p>では肝心な<code>AlamofireImage</code>の導入を見てみましょう。<br/>
<code>CocoaPods</code>で簡単に導入が可能です。</p>

<p>```objective-c</p>

<h1>Podfile</h1>

<p>use_frameworks!
platform :ios, &lsquo;10.0&rsquo;</p>

<p>target &ldquo;SampleApp&rdquo; do
  # Normal libraries
  &hellip;
  pod &lsquo;AlamofireImage&rsquo;, &lsquo;~> 3.1&rsquo;
end</p>

<p>post_install do |installer|
  installer.pods_project.targets.each do |target|</p>

<pre><code>target.build_configurations.each do |config|
  config.build_settings['SWIFT_VERSION'] = '3.0'
end
</code></pre>

<p>  end
end
```</p>

<h4>マーカタップ時に表示するInfoWindowに画像を表示する</h4>

<p>まずは<code>InfoWindow</code>をカスタム化したクラスである<code>MarkerInfoContentsView.swift</code>のソースコードを書きます。</p>

<p>```objective-c
// MarkerInfoContentsView.swift
import Foundation
import UIKit
import AlamofireImage</p>

<p>class MarkerInfoContentsView: UIView {</p>

<p>  @IBOutlet weak var shopName: UILabel!
  @IBOutlet weak var categoryName: UILabel!
  @IBOutlet weak var shopImage: UIImageView!</p>

<p>  override init(frame: CGRect) {</p>

<pre><code>super.init(frame: frame)
self.xibViewSet()
</code></pre>

<p>  }</p>

<p>  required init?(coder aDecoder: NSCoder) {</p>

<pre><code>super.init(coder: aDecoder)!
self.xibViewSet()
</code></pre>

<p>  }</p>

<p>  internal func xibViewSet() {</p>

<pre><code>if let view = Bundle.main.loadNibNamed("MarkerInfoContentsView", owner: self, options: nil)?.first as? UIView {
  view.frame = self.bounds
  self.addSubview(view)
}
</code></pre>

<p>  }</p>

<p>  /**</p>

<pre><code>データの設定処理

- parameter shopName: 店舗名
- parameter categoryName: カテゴリ名
- parameter shopImageURLString: 画像URL
</code></pre>

<p>   */
  func setData(shopName: String?, categoryName: String?, shopImageURLString: String?) {</p>

<pre><code>// 店舗名の設定
if let shopNameTextCount = shopName?.characters.count, shopNameTextCount &gt; 0 {
  self.shopName.text = shopName
} else {
  self.shopName.text = "店舗名不明"
  self.shopName.textColor = UIColor.gray
}
// 詳細説明の設定
if let categoryNameTextCount = categoryName?.characters.count, categoryNameTextCount &gt; 0 {
  self.categoryName.text = categoryName
} else {
  self.categoryName.text = "カテゴリ不明"
  self.categoryName.textColor = UIColor.gray
}
// 画像の設定
if let shopImageURLStringTextCount = shopImageURLString?.characters.count, shopImageURLStringTextCount &gt; 0 {
  if let shopImageURL = URL(string: shopImageURLString!) {
    self.shopImage.af_setImage(withURL: shopImageURL, placeholderImage: UIImage(named: "NoImageIcon"))
  } else {
    self.shopImage.image = UIImage(named: "NoImageIcon")
  }
} else {
  self.shopImage.image = UIImage(named: "NoImageIcon")
}    
</code></pre>

<p>  }
}
```</p>

<p>実際に<code>AlamofireImage</code>を利用して画像URLから取得した画像データを格納している箇所は、</p>

<p><code>objective-c
self.shopImage.af_setImage(withURL: shopImageURL, placeholderImage: UIImage(named: "NoImageIcon"))
</code></p>

<p>になります。<br/>
続いて、<code>ViewController.swift</code>での<code>GMSMapViewDelegate</code>部分の処理を抜粋して書きます。</p>

<p>```objective-c
// ViewController.swift
extension ViewController: GMSMapViewDelegate {
  func mapView(_ mapView: GMSMapView, markerInfoWindow marker: GMSMarker) &ndash;> UIView? {</p>

<pre><code>guard let cMarker = marker as? CustomGMSMarker else {
  return nil
}
cMarker.tracksInfoWindowChanges = true
let view = MarkerInfoContentsView(frame: CGRect(x: 0, y: 0, width: 250, height: 265))
view.setData(shopName: cMarker.shopName, categoryName: cMarker.categoryName, shopImageURLString: cMarker.imageURL)
return view
}
</code></pre>

<p>}
```</p>

<p>重要なのは、 <strong><code>cMarker.tracksInfoWindowChanges = true</code></strong> です。<br/>
これを書かないと <strong>画像URLから画像データを取得したタイミングで<code>InfoWindow</code>の画像を更新する</strong>ということができなくなります。<br/>
(<code>placeholderImage</code>として用意した画像がずっと表示されてしまいます。)</p>

<p>筆者はここでドハマリして試行錯誤してしまいました。<br/>
非同期で画像データを取得しに行っているので、データ取得前に<code>InfoWindow</code>の描画処理に進んでしまうということはわかるのですが、どうすれば想定した挙動が実現できるのか悩みました。<br/>
ですが、蓋を開けてみれば何ということもなかったんですよね。</p>

<h3>まとめ</h3>

<p>さて、如何でしたでしょうか？<br/>
画像取得/キャッシュ関連のOSSライブラリは多種多様なものが出ており、好き嫌いもあるかもしれませんが、筆者は通信ライブラリに<code>Alamofire</code>を使うことが多いため、<code>AlamofireImage</code>も嫌いではないんですよね。<br/>
と言ったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
</feed>
