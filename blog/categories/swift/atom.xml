<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: swift | Takahiro Octopress Blog]]></title>
  <link href="http://grandbig.github.io/blog/categories/swift/atom.xml" rel="self"/>
  <link href="http://grandbig.github.io/"/>
  <updated>2016-08-30T00:14:54+09:00</updated>
  <id>http://grandbig.github.io/</id>
  <author>
    <name><![CDATA[Takahiro]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[RxSwiftを勉強してみよう！(2)]]></title>
    <link href="http://grandbig.github.io/blog/2016/08/29/rxswift-2/"/>
    <updated>2016-08-29T22:40:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2016/08/29/rxswift-2</id>
    <content type="html"><![CDATA[<h3>RxSwiftの公式Exampleを覗いてみる(2)</h3>

<p>前回に引き続きRxSwiftの公式Exampleを見ていきたいと思います。<br/>
公式ソースは<a href="https://github.com/ReactiveX/RxSwift">GitHub: ReactiveX/RxSwift</a>からダウンロードできます。</p>

<h4>GeolocationExample</h4>

<p>位置情報を用いたときのRxの有効性が表現されているのでしょうか？<br/>
早速見ていきましょう。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<p>まずは、<code>CoreLocation</code>のコア部分をラップしている<code>GeolocationService</code>です。</p>

<p>```objective-c
import Foundation
import CoreLocation
import RxSwift
import RxCocoa</p>

<p>class GeolocationService {</p>

<pre><code>static let instance = GeolocationService()
// (1)
private (set) var authorized: Driver&lt;Bool&gt;
private (set) var location: Driver&lt;CLLocationCoordinate2D&gt;

private let locationManager = CLLocationManager()

private init() {
    locationManager.distanceFilter = kCLDistanceFilterNone
    locationManager.desiredAccuracy = kCLLocationAccuracyBestForNavigation

    // (2)
    authorized = Observable.deferred { [weak locationManager] in
        let status = CLLocationManager.authorizationStatus()
        guard let locationManager = locationManager else {
            // (3)
            return Observable.just(status)
        }
        return locationManager
            .rx_didChangeAuthorizationStatus
            .startWith(status) // (4)
        }
        .asDriver(onErrorJustReturn: CLAuthorizationStatus.NotDetermined) // (5)
        .map {
            switch $0 {
                case .AuthorizedAlways:
                    return true
                default:
                    return false
            }
        }
}
</code></pre>

<p>}
```</p>

<p>上記ソースでポイントとなる部分を見ていきます。</p>

<p>(1): <code>Driver</code><br/>
末尾に参考URLとして上げさせて頂いた記事に書かれているのですが、<br/>
<code>Driver</code>型で定義することで、エラー発生時の処理<code>asDriver</code>オペレータで続けて書くことができます。</p>

<p>(2): <code>deferred</code><br/>
ObserverがSubscribe(購読)されたタイミングで動的にObservableを生成します。<br/>
※ 因みに新規ObservableをSubscribeタイミングで毎回生成します。</p>

<p>(3): <code>just</code><br/>
引数に取った特定の型を返却するObservableを生成します。<br/>
この場合は<code>CLAuthorizationStatus</code>型のObservableです。</p>

<p>(4): <code>startWith</code><br/>
想定したemit対象値の前に何らかの値をemitしたい場合に利用します。<br/>
この場合、<code>rx_didChangeAuthoricationStatus</code>をemitする前にということでしょうか。<br/>
(これが恐らく、一番わかりやすい例です → <a href="http://www.introtorx.com/Content/v1.0.10621.0/12_CombiningSequences.html#StartWith">Introduction to Rx: startWith</a>)</p>

<p>(5): <code>asDriver</code><br/>
(1)で説明した<code>Driver</code>に関係するオペレータです。<br/>
エラーが発生した場合に<code>onErrorJustReturn</code>で指定した値を返却して処理を続けます。</p>

<p>続いて、<code>GeolocationService</code>を利用している<code>GeolocationViewController</code>です。</p>

<p>```objective-c
import Foundation
import UIKit
import RxSwift
import RxCocoa</p>

<p>// (6)
private extension UILabel {</p>

<pre><code>var rx_driveCoordinates: AnyObserver&lt;CLLocationCoordinate2D&gt; {
    return UIBindingObserver(UIElement: self) { label, location in
        label.text = "Lat: \(location.latitude)\nLon: \(location.longitude)"
    }.asObserver()
}
</code></pre>

<p>}</p>

<p>// (7)
private extension UIView {</p>

<pre><code>var rx_driveAuthorization: AnyObserver&lt;Bool&gt; {
    return UIBindingObserver(UIElement: self) { view, authorized in
        if authorized {
            view.hidden = true
            view.superview?.sendSubviewToBack(view)
        }
        else {
            view.hidden = false
            view.superview?.bringSubviewToFront(view)
        }
    }.asObserver()
}
</code></pre>

<p>}</p>

<p>class GeolocationViewController: ViewController {</p>

<pre><code>@IBOutlet weak private var noGeolocationView: UIView!
@IBOutlet weak private var button: UIButton!
@IBOutlet weak private var button2: UIButton!
@IBOutlet weak var label: UILabel!

override func viewDidLoad() {
    super.viewDidLoad()

    let geolocationService = GeolocationService.instance

    geolocationService.authorized
        .drive(noGeolocationView.rx_driveAuthorization) // (8)
        .addDisposableTo(disposeBag)

    geolocationService.location
        .drive(label.rx_driveCoordinates) // (8)
        .addDisposableTo(disposeBag)

    button.rx_tap
        .bindNext { [weak self] in
            self?.openAppPreferences()
        }
        .addDisposableTo(disposeBag)

    button2.rx_tap
        .bindNext { [weak self] in
            self?.openAppPreferences()
        }
        .addDisposableTo(disposeBag)
}

private func openAppPreferences() {
    UIApplication.sharedApplication().openURL(NSURL(string: UIApplicationOpenSettingsURLString)!)
}
</code></pre>

<p>}
```</p>

<p>(6): <code>rx_driveCoordinates</code><br/>
見ての通りここで<code>UILabel</code>の<code>extension</code>をしています。<br/>
<code>UILabel</code>の<code>text</code>内容を任意の値で返却するために作成しています。<br/>
(<code>asObserver</code>をつけることで<code>rx_driveCoordinates</code>という<code>AnyObserver</code>型の変数定義を実現しています。)</p>

<p>(7): <code>rx_driveAuthorization</code><br/>
同じく<code>UIView</code>の<code>extension</code>をしています。<br/>
<code>authorized</code>の値でViewの表示/非表示を切り替えています。</p>

<p>(8): <code>drive</code><br/>
ここで新たにSubscribtionを生成して、引数に取ったObserverに処理の実行を要請しています。</p>

<p>今回のExampleを見てみると下記のようなメリットが感じられます。</p>

<ul>
<li>Rxを利用することで非同期処理を直列的に書ける</li>
<li>エラーハンドリングを直列的に書けることで後処理も直列的に統一して見れる(<code>jQuery</code>の<code>ajax</code>メソッドの<code>always</code>的なイメージ)</li>
<li>処理の拡張がRxで用意されたメソッドで比較的に容易に書ける</li>
</ul>


<h3>Rxで把握しておきたいAPI一覧</h3>

<p>RxSwiftをインストールすると中にドキュメントが含まれています。<br/>
<a href="https://github.com/ReactiveX/RxSwift/blob/master/Documentation/API.md">API.md</a>を読むだけでもかなり理解が進むと思われます。</p>

<p>特に言語がSwiftであるが故に他のRxフレームワークとはメソッド名が異なる場合があります。<br/>
(<code>defer</code>でなく<code>deferred</code>、<code>repeat</code>でなく<code>repeatElement</code>など)</p>

<p>一度は目を通しておくと良いかもしれません。<br/>
と言いつつ、筆者も全然見れていませんが&hellip;</p>

<h3>まとめ</h3>

<p>さて、今回は公式Exampleの1つを見るだけに留まりましたが如何でしたでしょうか？<br/>
筆者としてはRxの使い方の理解がだいぶ進んだ気がしております。<br/>
引き続きRxに関する勉強は続けていきたいと思います。<br/>
と言ったところで本日はここまで。</p>

<p>参考:</p>

<ul>
<li><a href="http://qiita.com/yuzushioh/items/0a4483502c5c8569790a">RxSwift/RxCocoa Driver Unitについてまとめてみた。</a></li>
</ul>


<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RxSwiftを勉強してみよう！]]></title>
    <link href="http://grandbig.github.io/blog/2016/08/21/rxswift-1/"/>
    <updated>2016-08-21T18:09:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2016/08/21/rxswift-1</id>
    <content type="html"><![CDATA[<h3>RxSwiftとは</h3>

<p>Reactive Extensions(以下、Rx)のSwift版です。<br/>
と一言で言っても、「Rxとはなんぞや？？」となってしまうかと思います。<br/>
(多分に漏れず、筆者もそうです&hellip;)<br/>
そこで、いろいろと調べてみると、</p>

<ul>
<li>「非同期/イベント/時間に関する処理をLINQの形式で簡潔かつ宣言的に記述すること」ができるのが特徴</li>
<li>観測可能 (observable) なシーケンスと LINQ スタイルのクエリ演算子を使って、非同期なイベントベースのプログラムを合成するライブラリ</li>
</ul>


<p>なんて話が出てきます。<br/>
確かに非同期処理はソースコードが複雑になりやすいので、何となくRxは良さそうな気がしてきました。<br/>
今回はまず触って慣れてみようということで見ていきましょう。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h3>RxSwiftでUI</h3>

<p>まずはRxSwiftの書き方を覚えるためにUI関連から見てきましょう。</p>

<h4>サンプル画面</h4>

<p>下記のように画面を作成します。<br/>
<img src="/images/rxswift_1.png" alt="サンプル画面" /></p>

<h4>RxSwiftのインストール</h4>

<p>下記のように<code>Podfile</code>を作成します。</p>

<p>```objective-c
use_frameworks!</p>

<p>target &lsquo;RxSwiftSample&rsquo; do</p>

<pre><code>pod 'RxSwift',    '~&gt; 2.0'
pod 'RxCocoa',    '~&gt; 2.0'
</code></pre>

<p>end</p>

<p>target &lsquo;RxSwiftSampleTests&rsquo; do</p>

<pre><code>pod 'RxBlocking', '~&gt; 2.0'
pod 'RxTests',    '~&gt; 2.0'
</code></pre>

<p>end</p>

<p>target &lsquo;RxSwiftSampleUITests&rsquo; do</p>

<pre><code>pod 'RxBlocking', '~&gt; 2.0'
pod 'RxTests',    '~&gt; 2.0'
</code></pre>

<p>end
```</p>

<p>そして、<code>pod install</code>を実行します。</p>

<h4>RxSwiftを用いたUIアクションを実装</h4>

<p>下記のようにアクションを実装します。</p>

<p>```objective-c
// ViewController.swift
import UIKit
import RxSwift
import RxCocoa</p>

<p>class ViewController: UIViewController {</p>

<pre><code>// UI部品
@IBOutlet weak var sampleBtn: UIButton!
@IBOutlet weak var sampleTextField: UITextField!
@IBOutlet weak var sampleLabel: UILabel!

// 自動unsubscribeのために必要
let disposeBag = DisposeBag()

override func viewDidLoad() {
    super.viewDidLoad()

    // ボタンタップアクション
    self.sampleBtn.rx_tap.subscribeNext { [unowned self] _ in
        self.showAlert()
    }.addDisposableTo(disposeBag)

    // テキストフィールドの入力アクション
    self.sampleTextField.rx_text
        .map { "Your Text is \($0)" }
        .bindTo(self.sampleTextField.rx_text)
        .addDisposableTo(disposeBag)
}

&lt;省略&gt;

func showAlert() {
    let alert = UIAlertController(title: "Sample Alert", message: "Can you see a sample alert?", preferredStyle: .Alert)
    let ok = UIAlertAction(title: "OK", style: .Default) { (action) in
        // 特に何もしない
    }
    alert.addAction(ok)
    presentViewController(alert, animated: true, completion: nil)
}
</code></pre>

<p>}
```</p>

<p>上記のUIアクションはあまりにも単純な例であるため、恩恵を受けられている気はしないですね&hellip;<br/>
いつものようにXcodeでアクションを繋げているのと同じ気がする&hellip;</p>

<h3>RxSwiftの公式Exampleを覗いてみる</h3>

<p>先ほどの例ではイマイチ良さがわからなかったので、公式のExampleを覗いてみます。<br/>
公式のExampleは<a href="https://github.com/ReactiveX/RxSwift">GitHub: ReactiveX/RxSwift</a>からダウンロードできます。</p>

<h4>NumbersViewController</h4>

<p>最も簡単なExampleはこれになるかと思います。</p>

<p>```objective-c
import Foundation
import UIKit
import RxSwift
import RxCocoa</p>

<p>class NumbersViewController: ViewController {</p>

<pre><code>@IBOutlet weak var number1: UITextField!
@IBOutlet weak var number2: UITextField!
@IBOutlet weak var number3: UITextField!

@IBOutlet weak var result: UILabel!

override func viewDidLoad() {
    super.viewDidLoad()
    // 注目！！
    Observable.combineLatest(number1.rx_text, number2.rx_text, number3.rx_text) { textValue1, textValue2, textValue3 -&gt; Int in
        return (Int(textValue1) ?? 0) + (Int(textValue2) ?? 0) + (Int(textValue3) ?? 0)
    }
    .map { $0.description }
    .bindTo(result.rx_text)
    .addDisposableTo(disposeBag)
}
</code></pre>

<p>}
```</p>

<p>ここで注目したいのは<code>Observable.combineLatest</code>です。<br/>
Exampleではこれを利用して一気に3つの<code>UITextField</code>から値を取得して、合計値を計算しています。<br/>
<code>Obsertvable.combineLatest</code>は名前から察することができると思いますが、3つの<code>UITextField</code>のいずれかの値が変わったタイミングで合計値が再計算されます。</p>

<p>これだけでも少し便利な感じが伝わってきました。</p>

<h4>SimpleValidationViewController</h4>

<p>続いて着手しやすいExampleはこちらになりそうです。</p>

<p>```objective-c
import Foundation
import UIKit
import RxSwift
import RxCocoa</p>

<p>let minimalUsernameLength = 5
let minimalPasswordLength = 5</p>

<p>class SimpleValidationViewController : ViewController {</p>

<pre><code>@IBOutlet weak var usernameOutlet: UITextField!
@IBOutlet weak var usernameValidOutlet: UILabel!
@IBOutlet weak var passwordOutlet: UITextField!
@IBOutlet weak var passwordValidOutlet: UILabel!
@IBOutlet weak var doSomethingOutlet: UIButton!

override func viewDidLoad() {
    super.viewDidLoad()

    usernameValidOutlet.text = "Username has to be at least \(minimalUsernameLength) characters"
    passwordValidOutlet.text = "Password has to be at least \(minimalPasswordLength) characters"

    // 注目！！
    let usernameValid = usernameOutlet.rx_text
        .map { $0.characters.count &gt;= minimalUsernameLength }
        .shareReplay(1)

    let passwordValid = passwordOutlet.rx_text
        .map { $0.characters.count &gt;= minimalPasswordLength }
        .shareReplay(1)

    let everythingValid = Observable.combineLatest(usernameValid, passwordValid) { $0 &amp;&amp; $1 }
        .shareReplay(1)

    usernameValid
        .bindTo(passwordOutlet.rx_enabled)
        .addDisposableTo(disposeBag)

    usernameValid
        .bindTo(usernameValidOutlet.rx_hidden)
        .addDisposableTo(disposeBag)

    passwordValid
        .bindTo(passwordValidOutlet.rx_hidden)
        .addDisposableTo(disposeBag)

    everythingValid
        .bindTo(doSomethingOutlet.rx_enabled)
        .addDisposableTo(disposeBag)

    doSomethingOutlet.rx_tap
        .subscribeNext { [weak self] in self?.showAlert() }
        .addDisposableTo(disposeBag)
}

func showAlert() {
    let alertView = UIAlertView(
        title: "RxExample",
        message: "This is wonderful",
        delegate: nil,
        cancelButtonTitle: "OK"
    )

    alertView.show()
}
</code></pre>

<p>}
```</p>

<p>ここで注目したいのは<code>shareReplay(1)</code>という記述です。<br/>
このExampleでは、<br/>
<code>username</code>のバリデーションをクリアしていれば、<code>passwordOutlet.rx_enabled</code>と<code>usernameValidOutlet.rx_hidden</code>の2つを実行するように実装されています。</p>

<p>通常だと、<code>usernameValid</code>が2回実行されてしまうところを<code>shareReplay(1)</code>をつけることで、最適な回数だけ実行してくれます。<br/>
詳しくは、<a href="http://qiita.com/kazu0620/items/bde4a65e82a10bd33f88">hareReplayをちゃんと書いてお行儀良くストリームを購読しよう</a>を読むと良いでしょう。</p>

<p>ここまで来ると<code>RxSwift</code>の有効性を許容せざるを得ませんね。</p>

<h3>まとめ</h3>

<p>今回簡単に触っただけでも、Rxはかなり有効なものであると感じました。<br/>
非同期処理や互いに関連性を持つ複雑な処理を実装する際にはぜひRxを使ってみたいと思いました。</p>

<p>本当はもっとExampleを追っていきたいのですが、一旦ここまでとさせて頂きます。<br/>
(単なる時間切れなので、続きは必ず書きたいを思っています。)</p>

<p>ということで本日はここまで。</p>

<p>参考:</p>

<ul>
<li><a href="https://github.com/ReactiveX/RxSwift">GitHub: ReactiveX/RxSwift</a></li>
<li><a href="http://qiita.com/nakailand/items/8b54dc9b4b39b0809c57">RxSwiftの道標</a></li>
<li><a href="http://qiita.com/usamik26/items/2bbd0b8d304ab42b2279">RxSwift で UIKit を扱う基本</a></li>
<li><a href="http://okapies.hateblo.jp/entry/2015/03/04/031148">関数型プログラマのための Rx 入門（前編）</a></li>
</ul>


<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift ExpressでAjax通信してみよう！]]></title>
    <link href="http://grandbig.github.io/blog/2016/07/31/swift-express-2/"/>
    <updated>2016-07-31T23:40:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2016/07/31/swift-express-2</id>
    <content type="html"><![CDATA[<h3>Swift ExpressでPOSTリクエスト投げてみよう！</h3>

<p>さて、本日は<a href="https://github.com/crossroadlabs/Express">Swift Express</a>の続きを試してみます。<br/>
<a href="http://grandbig.github.io/blog/2016/07/10/swift-express/">前回</a>はインストール方法とデフォルト画面の表示までを紹介しましたが、<br/>
今回はAjax通信によるPOSTリクエストを投げてみたいと思います。</p>

<h4>サーバサイドの対応</h4>

<p>まずは、サーバサイドの準備です。<br/>
<code>main.swift</code>を修正しましょう。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<p>```objective-c
import Express</p>

<p>let app = express()</p>

<p>app.views.register(StencilViewEngine())</p>

<!-- ここを追加 -->


<p>app.views.register(JsonView())</p>

<p>app.get(&ldquo;/assets/:file+&rdquo;, action: StaticAction(path: &ldquo;public&rdquo;, param:&ldquo;file&rdquo;))</p>

<p>app.get(&ldquo;/&rdquo;) { (request:Request<AnyContent>)&ndash;>Action<AnyContent> in</p>

<pre><code>return Action&lt;AnyContent&gt;.render("index", context: ["hello": "Hello,", "swift": "Swift", "express": "Express!"])
</code></pre>

<p>}</p>

<!-- ここを追加 -->


<p>app.post(&ldquo;/:param&rdquo;) { (request:Request<AnyContent>)&ndash;>Action<AnyContent> in</p>

<pre><code>let response = ["status": "ok", "description": "Post Request Succesfully"]
    return Action.render(JsonView.name, context: response)
</code></pre>

<p>}</p>

<p>app.listen(9999).onSuccess { server in</p>

<pre><code>print("Express was successfully launched on port", server.port)
</code></pre>

<p>}</p>

<p>app.run()
```</p>

<p><code>app.views.register(JsonView())</code>を追加することで、JSON形式のデータを返却できるようになります。<br/>
また、返却レスポンスは<code>dictionary</code>型で書けばOKなようです。</p>

<h4>クライアントサイドの対応</h4>

<p>続いて、クライアントサイドの準備です。<br/>
手っ取り早くjQuery使いましょう。<br/>
<a href="https://jquery.com/">こちらのページ</a>から最新のjQueryをダウンロードしてきます。</p>

<p>そして、<code>index.js</code>をさくっと作っちゃいましょう。</p>

<p>```javascript
$(function() {</p>

<pre><code>$("#touch").on("click", function() {
    // Ajax通信
    ajax();
});

function ajax() {
    $.ajax({
        type: "POST",
        url: "http://localhost:9999/1",
        dataType: "json"
    }).done(function(data) {
        alert(data.status + "\n" + data.description);
    }).fail(function(data) {
        alert("error!!");
    });
}
</code></pre>

<p>});
```</p>

<p>これらjsファイルを読み込みます。</p>

<p>```html
// index.stencil
<html></p>

<pre><code>&lt;head&gt;
    &lt;title&gt;  &lt;/title&gt;
    &lt;link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:700italic,700' rel='stylesheet' type='text/css'&gt;
    &lt;link href='http://grandbig.github.io/assets/css/main.css' rel='stylesheet' type='text/css'&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;img class="logo" src="http://grandbig.github.io/assets/logo.png"/&gt;
    &lt;h1&gt; &lt;i&gt;&lt;span class="swift"&gt;&lt;/span&gt; &lt;/i&gt;&lt;/h1&gt;
    &lt;div id="touch"&gt;ここをタッチ！！&lt;/div&gt;

    &lt;script src="http://grandbig.github.io/assets/js/jquery-3.1.0.min.js"&gt;&lt;/script&gt;
    &lt;script src="http://grandbig.github.io/assets/js/index.js"&gt;&lt;/script&gt;
&lt;/body&gt;
</code></pre>

<p></html>
```</p>

<p>これだけで下図のようにPOSTリクエストが通りました。</p>

<p><img src="/images/swift-express-3.png" alt="POSTリクエスト" /></p>

<p>というところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift Expressを使ってみよう！]]></title>
    <link href="http://grandbig.github.io/blog/2016/07/10/swift-express/"/>
    <updated>2016-07-10T22:56:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2016/07/10/swift-express</id>
    <content type="html"><![CDATA[<h3>今注目のサーバーサイドSwift</h3>

<p>本日はサーバーサイドSwiftのWebフレームワークの1つである<a href="https://github.com/crossroadlabs/Express">Swift Express</a>を紹介したいと思います。<br/>
近年、AppleからSwiftのOSS化が発表されたことで一気に動き出したのがGitHub上でのWebフレームワーク作成合戦です。<br/>
筆者が知っているだけでも、</p>

<ul>
<li><a href="https://github.com/PerfectlySoft/Perfect">Perfect</a></li>
<li><a href="https://github.com/qutheory/vapor">Vapor</a></li>
<li><a href="https://github.com/IBM-Swift/Kitura-Starter-Bluemix">Kitura</a></li>
<li><a href="https://github.com/slimane-swift">Sliman</a></li>
</ul>


<p>などが上げられます。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<p>そんな中、筆者の目に止まったのが、 <strong>Swift Express</strong> でした。<br/>
本ブログでも度々 <strong>Node.js</strong> を触ったことがあると述べてきたように、筆者は <strong>Node.js</strong> でサーバサイド実装の経験があります。<br/>
その際に利用していたWebフレームワークに<a href="http://expressjs.com/">Express</a>というものがありました。<br/>
Expressは <strong>Node.js</strong> でいとも簡単にベースとなるサーバサイド実装を提供してくれます。</p>

<p>Swiftの経験はあるものの、サーバサイドSwiftの実装経験がない筆者にとっては『願ってもないWebフレームワークじゃないか！』ということで <strong>Swift Express</strong> に惹かれたのです。<br/>
さて、本日はそんな <strong>Swift Express</strong> を見ていきたいと思います。</p>

<h3>Swift Expressをインストールしよう</h3>

<p>まずは、Swift Expressをインストールしてみます。<br/>
<code>homebrew</code>でインストールします。</p>

<p>```javascript
// 手順(1)
brew tap crossroadlabs/tap</p>

<p>// 手順(2)
brew install swift-express
```</p>

<p>手順(1)を実行すると、下記のように結果が表示されます。</p>

<p><code>javascript
==&gt; Tapping crossroadlabs/tap
Cloning into '/usr/local/Library/Taps/crossroadlabs/homebrew-tap'...
remote: Counting objects: 8, done.
remote: Compressing objects: 100% (7/7), done.
remote: Total 8 (delta 0), reused 6 (delta 0), pack-reused 0
Unpacking objects: 100% (8/8), done.
Checking connectivity... done.
Tapped 2 formulae (34 files, 72.7K)
</code></p>

<p>続いて、手順(2)を実行すると、下記のように結果が表示されます。</p>

<p>```javascript
==> Installing swift-express from crossroadlabs/tap
==> Installing dependencies for crossroadlabs/tap/swift-express: openssl, cmake, libevent, libevhtp, carthage
==> Installing crossroadlabs/tap/swift-express dependency: openssl
==> Downloading <a href="https://homebrew.bintray.com/bottles/openssl-1.0.2h_1.el_capitan.bottle.tar.gz">https://homebrew.bintray.com/bottles/openssl-1.0.2h_1.el_capitan.bottle.tar.gz</a></p>

<h6>################################################################## 100.0%</h6>

<p>==> Pouring openssl-1.0.2h_1.el_capitan.bottle.tar.gz
==> Caveats
A CA file has been bootstrapped using certificates from the system
keychain. To add additional certificates, place .pem files in
  /usr/local/etc/openssl/certs</p>

<p>  and run</p>

<pre><code>/usr/local/opt/openssl/bin/c_rehash

This formula is keg-only, which means it was not symlinked into /usr/local.

Apple has deprecated use of OpenSSL in favor of its own TLS and crypto libraries

Generally there are no consequences of this for you. If you build your
own software and it requires this formula, you'll need to add to your
build variables:

    LDFLAGS:  -L/usr/local/opt/openssl/lib
    CPPFLAGS: -I/usr/local/opt/openssl/include
</code></pre>

<p>==> Summary
🍺  /usr/local/Cellar/openssl/1.0.2h_1: 1,691 files, 12M
==> Installing crossroadlabs/tap/swift-express dependency: cmake
==> Downloading <a href="https://homebrew.bintray.com/bottles/cmake-3.6.0.el_capitan.bottle.tar.gz">https://homebrew.bintray.com/bottles/cmake-3.6.0.el_capitan.bottle.tar.gz</a></p>

<h6>################################################################## 100.0%</h6>

<p>==> Pouring cmake-3.6.0.el_capitan.bottle.tar.gz
==> Caveats
Emacs Lisp files have been installed to:
  /usr/local/share/emacs/site-lisp/cmake
  ==> Summary
  🍺  /usr/local/Cellar/cmake/3.6.0: 2,028 files, 27.8M
  ==> Installing crossroadlabs/tap/swift-express dependency: libevent
  ==> Downloading <a href="https://homebrew.bintray.com/bottles/libevent-2.0.22.el_capitan.bottle.tar.gz">https://homebrew.bintray.com/bottles/libevent-2.0.22.el_capitan.bottle.tar.gz</a></p>

<h6>################################################################## 100.0%</h6>

<p>==> Pouring libevent-2.0.22.el_capitan.bottle.tar.gz
🍺  /usr/local/Cellar/libevent/2.0.22: 53 files, 1.6M
==> Installing crossroadlabs/tap/swift-express dependency: libevhtp
==> Downloading <a href="https://github.com/ellzey/libevhtp/archive/1.2.10.tar.gz">https://github.com/ellzey/libevhtp/archive/1.2.10.tar.gz</a>
==> Downloading from <a href="https://codeload.github.com/ellzey/libevhtp/tar.gz/1.2.10">https://codeload.github.com/ellzey/libevhtp/tar.gz/1.2.10</a></p>

<h6>################################################################## 100.0%</h6>

<p>Warning: SHA1 support is deprecated and will be removed in a future version.
Please switch this formula to SHA256.
==> cmake . -DEVHTP_DISABLE_REGEX:STRING=ON -DEVHTP_BUILD_SHARED:STRING=ON -DCMAKE_C_FLAGS_RELEASE=-DNDEBUG -DCMAKE_CXX_FLAGS_RELEASE=-DNDEBUG -DCMAKE_INSTALL_PREFIX=/usr/local/Cell
==> make install
🍺  /usr/local/Cellar/libevhtp/1.2.10: 9 files, 151.5K, built in 48 seconds
==> Installing crossroadlabs/tap/swift-express dependency: carthage
==> Downloading <a href="https://homebrew.bintray.com/bottles/carthage-0.17.2.el_capitan.bottle.tar.gz">https://homebrew.bintray.com/bottles/carthage-0.17.2.el_capitan.bottle.tar.gz</a></p>

<h6>################################################################## 100.0%</h6>

<p>==> Pouring carthage-0.17.2.el_capitan.bottle.tar.gz
🍺  /usr/local/Cellar/carthage/0.17.2: 45 files, 11.9M
==> Installing crossroadlabs/tap/swift-express
==> Cloning <a href="https://github.com/crossroadlabs/ExpressCommandLine.git">https://github.com/crossroadlabs/ExpressCommandLine.git</a>
Cloning into &lsquo;/Users/kato_takahiro/Library/Caches/Homebrew/swift-express&mdash;git&rsquo;&hellip;
remote: Counting objects: 67, done.
remote: Compressing objects: 100% (63/63), done.
remote: Total 67 (delta 21), reused 25 (delta 1), pack-reused 0
Unpacking objects: 100% (67/67), done.
Checking connectivity&hellip; done.
Note: checking out &lsquo;fae821f4d52c9dfb4e4c34ab0a4297ea700c9db1&rsquo;.</p>

<p>You are in &lsquo;detached HEAD&rsquo; state. You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by performing another checkout.</p>

<p>If you want to create a new branch to retain commits you create, you may
do so (now or later) by using -b with the checkout command again. Example:</p>

<pre><code>  git checkout -b &lt;new-branch-name&gt;

==&gt; Checking out tag 0.2.2
==&gt; carthage update --platform Mac --no-use-binaries --no-build
==&gt; rm -rf Carthage/Checkouts/Commandant/Carthage/Checkouts/Nimble Carthage/Checkouts/Commandant/Carthage/Checkouts/Quick
==&gt; carthage build --platform Mac
==&gt; xcodebuild SYMROOT=build
==&gt; Caveats
.app bundles were installed.
Run `brew linkapps swift-express` to symlink these to /Applications.
==&gt; Summary
🍺  /usr/local/Cellar/swift-express/0.2.2: 30 files, 7.3M, built in 3 minutes 5 seconds
</code></pre>

<p>```</p>

<p>さて、見過ごしがちですが、<br/>
最後の方に『<code>brew linkapps swift-express</code> to symlink these to /Applications.』と書かれているので、</p>

<p><code>brew linkapps swift-express</code>を実行しておきましょう。</p>

<p>ここまで来たら、<code>swift-express</code>を実行してください。</p>

<p>```javascript
Available commands:</p>

<p>bootstrap   download and build Express project dependencies
build       build Express project
help        Display general or command-specific help
init        Creates new Express application project
run         run Express project
update      update and build Express project dependencies
version     Display the current version of Swift Express Command Line
```</p>

<p>のようにコマンド種別が表示されたら、正しく <strong>Swift Express</strong> がインストールされた証拠です。</p>

<h3>Swift Expressのプロジェクトを作ろう！</h3>

<p>Swift Expressのインストールが完了したので、早速プロジェクト作成しましょう。</p>

<p>```javascript
// 手順(1)
swift-express init &lt;プロジェクト名></p>

<p>// 手順(2)
cd &lt;プロジェクト名></p>

<p>// 手順(3)
swift-express bootstrap
```</p>

<p>手順(1)を実行すると、下記の結果が表示されます。</p>

<p><code>javascript
Cloning into '/var/folders/hj/p9y9d00s3sb5nn_x04961z2m0000gn/T/swift-express-827699'...
remote: Counting objects: 124, done.
remote: Total 124 (delta 0), reused 0 (delta 0), pack-reused 124
Receiving objects: 100% (124/124), 79.66 KiB | 0 bytes/s, done.
Resolving deltas: 100% (33/33), done.
Checking connectivity... done.
Task: "init" done.
</code></p>

<p>続いて、手順(2)で作成したプロジェクトフォルダ配下に移動すると、</p>

<p><code>javascript
HelloExpress
  ┣━━ Cartfile
  ┣━━ HelloExpress.xcodeproj
  ┣━━ Info.plist
  ┣━━ Package.swift
  ┣━━ app
  ┃    ┗━━ main.swift
  ┣━━ dist
  ┣━━ public
  ┃    ┣━━ css
  ┃    ┃    ┗━━ main.css
  ┃    ┗━━ logo.png
  ┗━━ views
</code></p>

<p>といった形で構成されていることを確認できます。</p>

<p>最後に手順(3)を実行すると、下記の結果が表示されます。<br/>
(ここが最も時間のかかる工程になります。)</p>

<p>```javascript
<strong><em> No Cartfile.resolved found, updating dependencies
</em></strong> Cloning Express
<strong><em> Cloning Stencil
</em></strong> Cloning GRMustache.swift
<strong><em> Cloning CEVHTP
</em></strong> Cloning PathToRegex
<strong><em> Cloning Regex
</em></strong> Cloning TidyJSON
<strong><em> Cloning BrightFutures
</em></strong> Cloning PathKit
<strong><em> Cloning ExecutionContext
</em></strong> Cloning Result
<strong><em> Checking out CEVHTP at &ldquo;0.1.0&rdquo;
</em></strong> Checking out ExecutionContext at &ldquo;0.3.1&rdquo;
<strong><em> Checking out Result at &ldquo;1.0.3&rdquo;
</em></strong> Checking out GRMustache.swift at &ldquo;bf7d6031d7e0dd862519eaba2b36b2e11a0d25a9&rdquo;
<strong><em> Checking out Regex at &ldquo;0.5.2&rdquo;
</em></strong> Checking out PathToRegex at &ldquo;0.2.2&rdquo;
<strong><em> Checking out PathKit at &ldquo;0.6.1&rdquo;
</em></strong> Checking out BrightFutures at &ldquo;0.4.0&rdquo;
<strong><em> Checking out Stencil at &ldquo;0.5.3&rdquo;
</em></strong> Checking out Express at &ldquo;0.3.6&rdquo;
*** Checking out TidyJSON at &ldquo;1.1.0&rdquo;</p>

<p>&lt;省略></p>

<p>/Users/<strong><strong>**/</strong></strong>/HelloExpress/Carthage/Checkouts/Express/Express/Content.swift:39:5: warning: use of &lsquo;typealias&rsquo; to declare associated types is deprecated; use &lsquo;associatedtype&rsquo; instead
Task: &ldquo;bootstrap&rdquo; done.
```</p>

<p>これでプロジェクトの作成は完了です。</p>

<h3>プロジェクトを実行してみよう！</h3>

<p>先ほど作成したプロジェクトを実行してみたいと思います。</p>

<p>```javascript
// 手順(1)
swift-express build</p>

<p>// 手順(2)
swift-express run
```</p>

<p>早速、ビルドを実行するために手順(1)のコマンドを叩いてください。<br/>
すると、</p>

<p>```javascript
Building HelloExpress in Debug mode&hellip;</p>

<p>&lt;省略></p>

<p>=== BUILD TARGET HelloExpress OF PROJECT HelloExpress WITH CONFIGURATION Debug ===</p>

<p>&lt;省略></p>

<p><strong> BUILD SUCCEEDED </strong></p>

<p>Task: &ldquo;build&rdquo; done.
```</p>

<p>という結果が表示されます。<br/>
問題がなければ<code>BUILD SUCCEEDED</code>が表示されるはずです。</p>

<p>ビルドが成功したら、手順(2)を実行しましょう。<br/>
すると、</p>

<p><code>javascript
Running HelloExpress...
Express was successfully launched on port 9999
</code></p>

<p>のように表示されます。デフォルトでポート番号が <strong>9999</strong> になっていることがわかると思います。<br/>
<code>http://localhost:9999</code>にアクセスしてみると、</p>

<p><img src="/images/swift-express-1.png" alt="Swift Express TOPページ" /></p>

<p>という画面が得られます。</p>

<p>因みにですが、Xcodeからも<code>Build</code>＆<code>Run</code>はできます。</p>

<p><img src="/images/swift-express-2.png" alt="XcodeからBuild &amp; Run" /></p>

<h3>Swift Expressの中身を見てみよう！</h3>

<p>最後にざっくり中身のソースを見てみようと思います。<br/>
Swift Expressのメインソースである<code>main.swift</code>を見てみます。</p>

<p>```javascript
// app/main.swift</p>

<p>import Express</p>

<p>let app = express()</p>

<p>// (1)
app.views.register(StencilViewEngine())</p>

<p>// (2)
app.get(&ldquo;/assets/:file+&rdquo;, action: StaticAction(path: &ldquo;public&rdquo;, param:&ldquo;file&rdquo;))</p>

<p>// (3)
app.get(&ldquo;/&rdquo;) { (request:Request<AnyContent>)&ndash;>Action<AnyContent> in</p>

<pre><code>return Action&lt;AnyContent&gt;.render("index", context: ["hello": "Hello,", "swift": "Swift", "express": "Express!"])
</code></pre>

<p>}</p>

<p>// (4)
app.listen(9999).onSuccess { server in</p>

<pre><code>print("Express was successfully launched on port", server.port)
</code></pre>

<p>}</p>

<p>app.run()
```</p>

<p>これは <strong>Node.js</strong> 経験者としてはかなりExpressに酷似してるなと感じます。<br/>
順に追ってみていきます。</p>

<p>(1): 描画エンジンを設定しています。</p>

<p>Node.jsのExpressで言うところの、</p>

<p><code>javascript
app.set('views', path.join(__dirname, 'views'));
app.set('view engine', 'jade');
</code></p>

<p>に該当します。</p>

<p>(2): 静的ファイルの格納場所を設定しています。</p>

<p>Node.jsのExpressで言うところの、</p>

<p><code>javascript
app.use(express.static(path.join(__dirname, 'public')));
</code></p>

<p>に該当します。</p>

<p>(3): リクエストのアクションパスと処理を設定しています。</p>

<p>Node.jsのExpressで言うところの、</p>

<p>```javascript
// app.js
app.use(&lsquo;/&rsquo;, routes);</p>

<p>// route/index.js
router.get(&lsquo;/&rsquo;, function(req, res, next) {</p>

<pre><code>res.render('index', { title: 'Express' }); 
</code></pre>

<p>}
```</p>

<p>に該当します。</p>

<p>(4): ポート番号を設定しています。</p>

<p>Node.jsのExpressで言うところの、</p>

<p>```javascript
// bin/www
var port = normalizePort(process.env.PORT || &lsquo;3000&rsquo;);
app.set(&lsquo;port&rsquo;, port);</p>

<p>var server = http.createServer(app);</p>

<p>server.listen(port);</p>

<p>server.on(&lsquo;listening&rsquo;, onListening);</p>

<p>function onListening() {</p>

<pre><code>var addr = server.address();
var bind = typeof addr === 'string'
    ? 'pipe ' + addr
    : 'port ' + addr.port;
debug('Listening on ' + bind);
</code></pre>

<p>}
```</p>

<p>に該当します。</p>

<h3>まとめ</h3>

<p>さて如何でしたでしょうか？<br/>
これだけNode.jsのExpressに似ているのですから、<br/>
<strong>Swift Express</strong> はこれからサーバサイドSwiftを学んでいく上で強力なWebフレームワークとなるかもしれません。<br/>
新しくNode.jsを学ぶ人も将来的にサーバサイドSwiftを触る機会が出てくるかもしれませんので知っておいて損はないでしょう。<br/>
筆者もこれまら益々注目されるであろうサーバサイドSwiftの情報は追っていきたいと思います。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SwiftとJava8でOptional型を比較してみよう！]]></title>
    <link href="http://grandbig.github.io/blog/2016/06/19/swift-java-optional/"/>
    <updated>2016-06-19T21:12:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2016/06/19/swift-java-optional</id>
    <content type="html"><![CDATA[<h4>SwiftとJava8のOptional型を比較してみよう！</h4>

<p>本日はSwiftとJava8のOptional型について比較してみたいと思います。<br/>
最近チラチラとJava8を見かける機会が多いのですが、Swiftと同じくOptional型という概念があるんだ〜と何となく思っていました。<br/>
が、実際に全く同じというわけではないと思うので比較したいと思ったわけです。<br/>
ということで早速見ていきましょう！</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h5>SwiftのOptional型とは</h5>

<p>まずはSwiftのOptional型から見ていきましょう。<br/>
SwiftはObjective-Cでよく発生していた『思いがけず<code>nil</code>が入ったプロパティにアクセスしてExceptionが発生する』という事象を回避できる <strong>Optional型</strong> という概念があります。<br/>
Swiftでは <strong>Optional型</strong> と <strong>非Optional型</strong> を変数定義時に明示的に利用することでこういったExceptionを回避することが可能なのです。</p>

<ul>
<li>Optional型: 変数に<code>nil</code>を代入することを <strong>許容します</strong>

<ul>
<li>Optional型はデータ型の末尾に <strong>『?』</strong> か <strong>『!』</strong> をつけます

<ul>
<li>『?』: 一般的なOptional型です</li>
<li>『!』: 暗黙的Optional型です</li>
</ul>
</li>
</ul>
</li>
<li>非Optional型: 変数に<code>nil</code>を代入することを <strong>許容しません</strong></li>
</ul>


<p>```objective-c
// Optional型
var hoge: Int?
var fuga: Int!</p>

<p>// 非Optional型
var piyo
```</p>

<h5>Optional型から値を取得する方法は</h5>

<p>さて、Optional型の宣言方法は先程話した通りです。<br/>
実際に値を取得する際はOptional型で定義された変数を <strong>アンラップ</strong> する必要があります。</p>

<p>ここで注意したいのが、先に紹介した『!』を使った暗黙的Optional型の場合は <strong>自動的にアンラップする</strong> ので開発者側はアンラップさせる必要がないということです。</p>

<p>アンラップ方法は下記の3通りです。</p>

<ul>
<li>Forced Unwrapping: 変数に『!』をつけます</li>
<li>Optional Binding: <code>if</code>文を利用します</li>
<li>Optional Chaining: 変数に『?』をつけます</li>
</ul>


<p>Forced UnwrappingとOptional Bindeingの例は下記です。</p>

<p>```objective-c
var hoge: Int? = 1</p>

<p>// Forced Unwrapping
print(hoge!)</p>

<p>// Optional Binding
if let fuga = hoge {</p>

<pre><code>print(fuga)
</code></pre>

<p>}
```</p>

<p>続いてOptional Chainingの例を書きます。<br/>
まずは下記のようなクラスを定義します。</p>

<p>```objective-c
class Hoge: NSObject {</p>

<pre><code>func hogehoge() {
    print("hogehogeメソッドを実行しました")
}
</code></pre>

<p>}
```</p>

<p>上記で定義したクラスの<code>hogehoge</code>メソッドをOptional Chaningを利用して実行します。</p>

<p>```objective-c
var hoge: Hoge? = Hoge()</p>

<p>// Optional Chaining
hoge?.hogehoge()
```</p>

<p>このようにSwiftではコーディングしていく段階でかなり<code>nil</code>に注意する必要があることがわかります。</p>

<h5>Java8のOptional型とは</h5>

<p>次にJava8のOptional型について見ていきましょう！<br/>
Java8ではOptionalを利用することで</p>

<ul>
<li><code>null</code>の可能性がある変数をラップしておくことで、値を安全に取り出せる</li>
<li>実行したメソッドが<code>null</code>を返却する可能性がある場合に、場合分けを短く書ける</li>
</ul>


<p>というメリットがあります。<br/>
では実際に使い方を見ていきましょう！</p>

<p>```java
String hoge = &ldquo;hoge&rdquo;;</p>

<p>// Optional型にラップする
Optional<String> hogeOpt = Optional.of(hoge);</p>

<p>// Optional型から値を取り出す
// getメソッドを使う
System.out.println(hogeOpt.get());</p>

<p>// orElseメソッドを使う
System.out.println(hogeOpt.orElse(&ldquo;default data&rdquo;));</p>

<p>// orElseGetメソッドを使う
System.out.println(hogeOpt.orElseGet(() &ndash;> &ldquo;default data&rdquo;));</p>

<p>// ifPresentメソッドを使う
hogeOpt.ifPresent( hoge &ndash;> {</p>

<pre><code>// 値があったときにログ出力
System.out.println(hoge);
</code></pre>

<p>});
```</p>

<p>上記を見ると幾つか値の取得方法があることがわかると思います。<br/>
それぞれSwiftの表記に近しいところがあると感じました。</p>

<p>例えば、<code>get</code>メソッドは値が<code>null</code>だった場合に<code>NoSuchElementException</code>を投げます。<br/>
逆に言えば、確実に<code>null</code>が来ない場合の<code>get</code>メソッドが利用できると言えます。<br/>
これはSwiftで言うところの『Forced Unwrapping』です。</p>

<p><code>orElse</code>や<code>orElseGet</code>はSwiftで言うところのnil合体演算子である『??』を利用しているのとほぼ同等です。<br/>
(Swiftであれば<code>let val = hoge ?? "default data"</code>みたいな感じですね。)</p>

<p><code>ifPresent</code>メソッドもSwiftで言うところの『Optional Binding』と言えるでしょう。</p>

<h4>まとめ</h4>

<p>さて如何でしたでしょうか？<br/>
Android Studio 2.2からJava8のラムダ式サポートなんて話も聞こえてきますし、<br/>
スマートフォンのアプリ開発者は今後、SwiftにもJava8にも関わっていく可能性が十分ありえます。<br/>
そうなったときに学習コストが高いな〜と避けるのではなく、案外触ってみると「あれ！？似てる&hellip;」なんてことがあるかもしれません。<br/>
そんな近未来！？を夢見つつブログを書いてみたのでした。<br/>
ということで今日はここまで。</p>

<p>参考:</p>

<ul>
<li><a href="http://qiita.com/maiki055/items/b24378a3707bd35a31a8">どこよりも分かりやすいSwiftの"?&ldquo;と&rdquo;!"</a></li>
<li><a href="http://www.task-notes.com/entry/20150708/1436324400">Java8のOptionalの使い方について</a></li>
</ul>


<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
</feed>
