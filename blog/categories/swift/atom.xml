<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: swift | Takahiro Octopress Blog]]></title>
  <link href="http://grandbig.github.io/blog/categories/swift/atom.xml" rel="self"/>
  <link href="http://grandbig.github.io/"/>
  <updated>2016-05-15T01:36:45+09:00</updated>
  <id>http://grandbig.github.io/</id>
  <author>
    <name><![CDATA[Takahiro]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SwiftでFacebookログインを始めよう！]]></title>
    <link href="http://grandbig.github.io/blog/2016/05/14/facebook-login-for-swift/"/>
    <updated>2016-05-14T15:30:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2016/05/14/facebook-login-for-swift</id>
    <content type="html"><![CDATA[<h4>Facebookログインの実装方法</h4>

<p>公式ページの<a href="https://developers.facebook.com/">facebook for developers</a>を見るのが、一番良いと思いますが、<br/>
あちこちページを飛ばされるので、順を追って説明することにします。<br/>
※ 本記事で利用しているFacebook SDKは <strong>v4.11.0</strong> です。</p>

<p><strong>1．Facebookログインを選択する</strong></p>

<p><img src="/images/facebook_login_1.png" alt="Facebookログインを選択" /></p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<p><strong>2．Get Startedを選択する</strong></p>

<p><img src="/images/facebook_login_2.png" alt="Get Startedを選択" /></p>

<p><strong>3．iOSを選択する</strong></p>

<p><img src="/images/facebook_login_3.png" alt="iOSを選択" /></p>

<p><strong>4．利用手順の概要を読む</strong></p>

<p><img src="/images/facebook_login_4.png" alt="利用手順の概要を読む" /></p>

<p><strong>5．Facebookアプリを作成する</strong></p>

<p><img src="/images/facebook_login_5.png" alt="Facebookアプリを作成" /></p>

<p>※ CocoaPodsでFacebook SDKを取り込むので、ダウンロードはしません。</p>

<p>「新しいアプリを作成」を選択すると、アプリ作成画面が表示されるため、任意の値を入力してください。</p>

<p><img src="/images/facebook_login_6.png" alt="任意の値を入力" /></p>

<p><strong>6．作成したFacebookアプリにiOSアプリ用の設定を追加する</strong></p>

<p><img src="/images/facebook_login_7.png" alt="一連のiOSアプリ用設定手順" /></p>

<p><img src="/images/facebook_login_8.png" alt="追加ボタンを選択" /></p>

<p><img src="/images/facebook_login_9.png" alt="iOSを選択" /></p>

<p>追加された設定項目に値を入力して、「変更を保存」ボタンを選択します。</p>

<ul>
<li>バンドルIDを入力</li>
<li>シングルサインオンボタンをONに変更</li>
</ul>


<p><img src="/images/facebook_login_10.png" alt="設定項目に値を入力" /></p>

<p>続いて、詳細設定でネイティブアプリでの利用を許可します。</p>

<p><img src="/images/facebook_login_18.png" alt="詳細設定" /></p>

<p><strong>7．Xcodeプロジェクトを用意する</strong></p>

<p>当然のことながら、Xcodeプロジェクトを作成します。</p>

<p><strong>8．<code>Podfile</code>を作成する</strong></p>

<p>```objective-c
source &lsquo;<a href="https://github.com/CocoaPods/Specs.git">https://github.com/CocoaPods/Specs.git</a>&rsquo;
platform :ios, &lsquo;8.0&rsquo;</p>

<h1>Facebook</h1>

<p>pod &lsquo;FBSDKCoreKit&rsquo;
pod &lsquo;FBSDKLoginKit&rsquo;
pod &lsquo;FBSDKShareKit&rsquo;
```</p>

<p><strong>9．<code>pod install</code>を実行する</strong></p>

<p><strong>10．Xcodeプロジェクトに必要な設定を追加</strong></p>

<p>必要な設定値を見るために、<br/>
下図のようにFacebookアプリページのiOS設定項目上の <strong>クイックスタート</strong> を選択します。</p>

<p><img src="/images/facebook_login_11.png" alt="クイックスタートを選択" /></p>

<p>すると、下図のページに遷移します。</p>

<p><img src="/images/facebook_login_12.png" alt="クイックスタートページ" /></p>

<p>この中で重要なのが <strong>Configure your info.plist</strong> です。<br/>
ここに書かれた設定値をXcodeに追加します。</p>

<p><img src="/images/facebook_login_13.png" alt="Configure your info.plist" /></p>

<p><img src="/images/facebook_login_14.png" alt="Xcodeに設定値を追加" /></p>

<p><strong>11．XcodeプロジェクトにiOS9 SDK対応の設定を追加</strong></p>

<p>iOS9 SDKよりHTTP通信が非推奨となったため、ATS設定を追加する必要があります。</p>

<p><img src="/images/facebook_login_15.png" alt="XcodeにATS設定を追加" /></p>

<p><strong>12．Facebookアプリをホワイトリストに追加する</strong></p>

<p><img src="/images/facebook_login_16.png" alt="ホワイトリストへの追加" /></p>

<p><strong>13．Bridge-Headerファイルを追加</strong></p>

<p>Swift実装なので、Bridge-Headerファイルを追加します。</p>

<p>```objective-c
// FacebookLoginSample-Bridging-Header.h</p>

<h1>ifndef FacebookLoginSample_Bridging_Header_h</h1>

<h1>define FacebookLoginSample_Bridging_Header_h</h1>

<h1>import &lt;FBSDKCoreKit/FBSDKCoreKit.h></h1>

<h1>import &lt;FBSDKLoginKit/FBSDKLoginKit.h></h1>

<h1>endif /<em> FacebookLoginSample_Bridging_Header_h </em>/</h1>

<p>```</p>

<p><strong>14．<code>AppDelegate.swift</code>に<code>FBSDKApplicationDelegate</code>への接続処理を追加</strong></p>

<p>```objective-c
// AppDelegate.swift</p>

<p>func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) &ndash;> Bool {</p>

<pre><code>FBSDKApplicationDelegate.sharedInstance().application(application, didFinishLaunchingWithOptions: launchOptions)
return true;
</code></pre>

<p>}</p>

<p>func application(application: UIApplication, openURL url: NSURL, sourceApplication: String?, annotation: AnyObject) &ndash;> Bool {</p>

<pre><code>return FBSDKApplicationDelegate.sharedInstance().application(application,
                                                             openURL: url,
                                                             sourceApplication: sourceApplication,
                                                             annotation: annotation)
</code></pre>

<p>}
```</p>

<p><strong>15．Facebook SDKが機能しているか確認</strong></p>

<p>Facebook SDKを搭載したつもりでも、一切機能していないと困りますよね？<br/>
ということでログ収集機能を使ってTestできたりします。<br/>
様々なログ収集が可能なようですが、公式ページにあるように最も簡単なアプリ起動ログ収集を実装します。</p>

<p>```objective-c
// AppDelegate.swift
func applicationDidBecomeActive(application: UIApplication) {</p>

<pre><code>FBSDKAppEvents.activateApp()
</code></pre>

<p>}
```</p>

<p><a href="https://www.facebook.com/analytics?__aref_src=devsite&amp;__aref_id=docs_ios_getting_started">アプリ用Analyticsダッシュボード</a>に遷移します。<br/>
ログを確認したいアプリ > アクティビティー > イベントを選択します。<br/>
すると「App Launches」の件数を確認することができます。</p>

<p><strong>16．ログインボタンを追加</strong></p>

<p>公式ではソースコードから追加しているので、その想定で書いていますが、もちろんStoryboardも利用できます。</p>

<p>```objective-c
// ViewController.swift
import UIKit</p>

<p>class ViewController: UIViewController, FBSDKLoginButtonDelegate {</p>

<pre><code>override func viewDidLoad() {
    super.viewDidLoad()

    let loginBtn : FBSDKLoginButton = FBSDKLoginButton()
    self.view.addSubview(loginBtn)
    loginBtn.center = self.view.center
    loginBtn.readPermissions = ["public_profile", "email", "user_friends"]
    loginBtn.delegate = self
}
</code></pre>

<p>}</p>

<p>func loginButton(loginButton: FBSDKLoginButton!, didCompleteWithResult result: FBSDKLoginManagerLoginResult!, error: NSError!) {</p>

<pre><code>print("ログイン処理を実行")

if (error != nil) {
    // エラーが発生した場合
    print("Process Error !")
} else if result.isCancelled {
    // ログインをキャンセルした場合
    print("User Cancelled")
} else {
    // その他
    print("Login Succeeded")
}
</code></pre>

<p>}</p>

<p>func loginButtonDidLogOut(loginButton: FBSDKLoginButton!) {</p>

<pre><code>print("ログアウト処理を実行")
</code></pre>

<p>}
```</p>

<p>結果、下図のような遷移が可能となります。</p>

<p><img src="/images/facebook_login_17.png" alt="Facebookログイン" /></p>

<h4>Facebookログインボタンのカスタム化</h4>

<p>因みに、Facebookログインボタンをカスタム化する方法を説明します。<br/>
折角なので、Storyboardでの方法として載せておきましょう。</p>

<p><strong>1．Storyboardにボタンを配置する</strong></p>

<p><img src="/images/facebook_login_19.png" alt="Storyboardにボタンを配置" /></p>

<p><strong>2．StoryboardからViewControllerにボタンアクションを接続する</strong></p>

<p><img src="/images/facebook_login_20.png" alt="ボタンアクションの接続" /><br/>
※ 上記キャプチャでは既に下記3の処理を書いてあるけど悪しからず&hellip;</p>

<p><strong>3．ログインアクションを追加</strong></p>

<p>```objective-c
// ViewController.swift
@IBAction func loginByFacebookID(sender: AnyObject) {</p>

<pre><code>let loginManager: FBSDKLoginManager = FBSDKLoginManager()
loginManager.logInWithReadPermissions(["public_profile", "email", "user_friends"], fromViewController: self) { (result, error) in
    if (error != nil) {
        // エラーが発生した場合
        print("Process error")
    } else if result.isCancelled {
        // ログインをキャンセルした場合
        print("Cancelled")
    } else {
        // その他
        print("Login Succeeded")
    }
}
</code></pre>

<p>}
```</p>

<p>さて、いかがでしたでしょうか？<br/>
Facebook SDKも徐々にバージョンアップしていますので、なかなか最新のライブラリに対応した記事がないこともあるでしょう。<br/>
そんなときに本記事を少しでも参考にしてもらえればと思います。<br/>
ということで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Freddyを使ってみよう！]]></title>
    <link href="http://grandbig.github.io/blog/2016/05/08/freddy/"/>
    <updated>2016-05-08T22:47:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2016/05/08/freddy</id>
    <content type="html"><![CDATA[<h4>SwiftでJSONパーサーライブラリを使ってみよう</h4>

<p>GW最終日にブログを更新します。<br/>
以前、<a href="http://grandbig.github.io/blog/2016/03/06/swiftyjson/">今更だけど使ってみようSwiftyJson</a>で紹介しましたが、今回は別のSwift製のJSONパーサーライブラリを紹介したいと思います。<br/>
本日は、<a href="https://github.com/bignerdranch/Freddy">Freddy</a>というJSONパーサーライブラリを紹介します。<br/>
SwiftyJsonのGitHub上でのStar数が約1万なのに比べるとFreddyは約850と段違いに支持数は低いですが、割りと有名なライブラリかと思います。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h4>CocoaPodsでインストール</h4>

<p>まずはインストールです。<br/>
今回も<code>Open Weather Map API</code>をサンプルに利用したいので<a href="https://github.com/Alamofire/Alamofire">Alamofire</a>も合わせてインストールします。</p>

<p>```objective-c
source &lsquo;<a href="https://github.com/CocoaPods/Specs.git">https://github.com/CocoaPods/Specs.git</a>&rsquo;
platform :ios, &lsquo;8.0&rsquo;
use_frameworks!</p>

<p>pod &lsquo;Freddy&rsquo;
pod &lsquo;Alamofire&rsquo;, &lsquo;~> 3.0&rsquo;
```</p>

<h4>Freddyを使ってみる</h4>

<p>続いて、早速<code>Freddy</code>を使ってみましょう。</p>

<p>```objective-c
Alamofire.request(.GET, &ldquo;<a href="http://api.openweathermap.org/data/2.5/weather?APPID=">http://api.openweathermap.org/data/2.5/weather?APPID=</a>&lt;あなた自身のAPPID>&rdquo;,</p>

<pre><code>parameters:["q":location]).responseJSON { (response) -&gt; Void in
    if response.result.isSuccess {
        do {
            let json = try JSON(data: response.data!)
            let description = try json.array("weather")[0]["description"]
            print(description)
        } catch {
            print("例外が発生しました！")
        }
    }
</code></pre>

<p>}
```</p>

<p><code>SwiftyJson</code>では下記のように書いていました。</p>

<p>```objective-c
Alamofire.request(.GET, &ldquo;<a href="http://api.openweathermap.org/data/2.5/weather?APPID=">http://api.openweathermap.org/data/2.5/weather?APPID=</a>&lt;あなた自身のAPPID>&rdquo;,</p>

<pre><code>parameters:["q":location]).responseJSON { (response) -&gt; Void in
    if response.result.isSuccess {
        guard let data = response.result.value else {
            return
        }
        let json = JSON(data)
        guard let description = json["weather"][0]["description"] else {
            return
        }
        print(description)
    }
</code></pre>

<p>}
```</p>

<p><code>Freddy</code>と<code>SwiftyJson</code>を比較すると、そこまで大きな違いはないと思います。<br/>
<code>Freddy</code>の場合は、</p>

<ul>
<li>JSON型への変換に失敗した場合、throwで例外を投げる</li>
<li>JSON型データ内のデータ形式次第で実行するメソッドが変わる<br/>
<code>array</code>, <code>string</code>, <code>bool</code>等のメソッドを使うことでアンラップを気にする必要がなくなります。</li>
</ul>


<p>といった特徴があります。<br/>
どのライブラリを使った方が良いか否かは個々人の判断ですね。</p>

<p>簡単ですが、本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tokyo Server-Side Swift Meetup #2 に行ってきました！]]></title>
    <link href="http://grandbig.github.io/blog/2016/04/21/server-side-swift-meetup-2/"/>
    <updated>2016-04-21T19:24:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2016/04/21/server-side-swift-meetup-2</id>
    <content type="html"><![CDATA[<h3>Tokyo Server-Side Swift Meetup #2</h3>

<p>今日は久しぶりに勉強会に行ってきた話です。<br/>
今日行ってきた勉強会は<a href="http://tokyo-ss-swift.connpass.com/event/29240/">Tokyo Server-Side Swift Meetup #2</a>です。<br/>
筆者はSwiftでサーバサイドを書けるようになるとAppleが発表してからというもの、Swift3.0の公開を心待ちにしていました。<br/>
いざ、GitHubで公開された瞬間は何とも言えない感動を覚えました。</p>

<p>時は流れ&hellip;筆者は未だにSwift3.0を全く触っていません！<br/>
日々、世の中で公開されるサーバサイドSwift関連の情報も全然追いきれていません&hellip;<br/>
これはマズイということでまずは形だけでも参加してみることにしました。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<p>ということで勉強会のメモ書きです。</p>

<h3>Swiftプロトコル指向なCのラッパーを作る</h3>

<p><a href="https://speakerdeck.com/yusukeito/swift-purotokoruzhi-xiang-nacfalseratupawozuo-ru">資料のリンク</a></p>

<ul>
<li>CoreAudio→Swiftからたたくと問題があった

<ul>
<li>APIはC言語</li>
<li>AVFoundation系を叩くことが多いので、直接使う機会はあまりないかも</li>
<li>C言語でのサンプルを紹介</li>
<li>C言語は辛い, 1箇所でも間違えると落ちる・辛い</li>
<li>AudioObjectGetPropertyData, AudioObjectSetPropertyData</li>
</ul>
</li>
<li>Swiftでは入力の方に対応する出力の型として表現できる(Protocolのassociated-type)</li>
<li><a href="http://github.com/novi/HALAudio">HALAudio</a>

<ul>
<li>Core AudioはPrefixが特殊なのでわかりにくい</li>
<li>C言語よりSwiftの方がエラーハンドリングが楽(try-catchを使えるから)</li>
</ul>
</li>
<li>プロトコルの場合の制約

<ul>
<li>コンストラクタのある型(class, struct, enum)を一連の制約の中に入れることができない</li>
<li>プロトコル自体に値は持たせられない</li>
</ul>
</li>
</ul>


<h3>The Ecosystem of Web Development with Swift</h3>

<p><a href="https://speakerdeck.com/takebayashi/the-ecosystem-of-web-development-with-swift">資料のリンク</a></p>

<ul>
<li>Web Applicationを開発する上で使うツール

<ul>
<li>Web Application Framework</li>
<li>Web Application Servers etc</li>
</ul>
</li>
<li>FrameworkとServerの選び方

<ul>
<li>Framework

<ul>
<li><a href="https://github.com/PerfectlySoft/Perfect">PerfectLib</a>

<ul>
<li>2015/11に発表</li>
<li>オーソドックスな形で使える</li>
<li>PerfectServerModuleInitという名前は固定(癖がある)</li>
<li>デプロイがしんどい</li>
</ul>
</li>
<li><a href="https://github.com/IBM-Swift/Kitura">Kitura</a>

<ul>
<li>IBM製</li>
<li>2016/02に発表</li>
<li>至って普通の書き方</li>
<li>PerfectLibよりもシンプル！</li>
<li>Kitura-netでKitura Appはデプロイできる</li>
<li>サーバとFrameworkが密になり過ぎている</li>
<li>PerfectLibをKitura-netで使うことはできない</li>
<li>サーバとFrameworkは疎結合であるべき</li>
<li>Python: WSGI, Perl: PSGI, Ruby: Rack

<ul>
<li>サーバとFrameworkが疎結合で好きに組み合わせることができる</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://github.com/nestproject/Nest">Nest</a>

<ul>
<li>WSGIとかのSwift版</li>
<li>Swift Protocolの</li>
<li>非常にシンプル</li>
<li>Nest.swift1個だけ</li>
<li><a href="https://github.com/necolt/Swifton">Swifton</a>, <a href="https://github.com/nestproject/Frank">Frank</a>はNestをサポートしている</li>
<li><a href="https://github.com/kylef/Curassow/blob/master/docs/index.rst">Curassow</a>, <a href="https://github.com/takebayashi/http4swift">http4swift</a>はNestをサポートしている

<ul>
<li>http4swiftはオススメしない</li>
</ul>
</li>
<li><a href="https://github.com/nestproject/Inquiline">Inquiline</a>でちょっと楽に</li>
<li>Applicationの部分を変更せずにサーバを変えられる</li>
<li>Nest Tools: <a href="https://github.com/nestproject/NestTest">NestTest</a>, <a href="https://github.com/nestproject/NestTestSuite">NestTestSuite</a></li>
</ul>
</li>
<li><a href="https://github.com/open-swift">Open-Swft</a>

<ul>
<li>Cross project standards for Swift</li>
<li>先週まではSwiftXという名前だった</li>
<li><a href="https://github.com/open-swift/C7">C7(Component)</a>, <a href="https://github.com/open-swift/S4">S4(Server-Side)</a>, <a href="https://github.com/open-swift/D5">D5</a>

<ul>
<li>C7: Data, Stream, URIなどの基本的なデータ構造を提供</li>
<li>S4: Server-Side Swift StandardsなのでS4

<ul>
<li>More Swifty</li>
<li>Nestの競合(PSGIとかのSwift版)</li>
<li>NestよりもSwiftっぽい</li>
<li>非同期/同期をIFレベルで対応</li>
<li>S4はサーバ側も仕様が決まっている

<ul>
<li><a href="https://github.com/qutheory/vapor">Vapor</a>, <a href="https://github.com/Zewo/Zewo">Zewo</a>, <a href="https://github.com/noppoMan/Slimane">Slimane: Frameworks Supporting S4</a></li>
<li><a href="https://github.com/VeniceX/Venice">VeniceX</a>, <a href="https://github.com/noppoMan/Skelton">Skelton: Servers Supporting S4</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Slackチャンネルがある</li>
</ul>
</li>
<li>Nest vs S4

<ul>
<li>Community: S4の方が活発, NestはCommunityが死んでる</li>
<li>API: Nestは安定している, S4はAPIがころころ変わる</li>
<li>Spec: Nestはシンプル(画面1個に収まる), S4は複雑(C7をベースにしているから)</li>
<li>開発時は好きな方を選んでOK</li>
<li>Nestで実装されたものが多いが、S4はこれから良くなる</li>
<li>好きなFrameworkを選んで、それに対応した好きなサーバを選ぶ</li>
<li>NestでApp, S4でサーバしたい場合はアダプタを自作しましょう</li>
</ul>
</li>
<li>PerfectLibは使わないで!</li>
</ul>
</li>
</ul>
</li>
</ul>


<h3>Up to Simane 0.2 and the Server Side Swift Standards</h3>

<p><a href="https://speakerdeck.com/noppoman/up-to-slimane-0-dot-2-and-the-server-side-swift-standards">資料のリンク</a></p>

<ul>
<li>Slimane

<ul>
<li>Slimane開発者</li>
<li>Express inspireしたFramework</li>
<li>超軽量</li>
<li>完全に非同期</li>
<li>超高速</li>
<li>モジュール化されています</li>
<li>マルチプロセスで動く</li>
<li>Swift3.0サポートしている(Swift2.2は動かない)</li>
<li>Open-Swiftを採用している</li>
<li>常に最新を追いかける思想で開発します</li>
<li>SUV: Swift Wrapper for libuv</li>
<li>Skelton: Stream based tiny Asynchronous HTTP Server</li>
</ul>
</li>
<li>0.1から結構変更した

<ul>
<li>極力頑張ってExpressっぽく書けるようにしている</li>
</ul>
</li>
<li>Open-Swift

<ul>
<li>開発がめちゃ速い(次の日はCompileが通らない&hellip;)</li>
<li>forkして、そのバージョンを使うようにしている</li>
<li>SwiftonがNestからOpen-Swiftに移行するかも？</li>
</ul>
</li>
<li>Slimaneでの書き方

<ul>
<li>めっちゃExpressっぽい</li>
<li>RESTful APIの書き方とか&hellip;</li>
<li>RouterもMiddlewareもExpressっぽい&hellip;</li>
<li>Session

<ul>
<li>Redisを使ったSession Storeの例を紹介</li>
</ul>
</li>
<li>Slimane.Static

<ul>
<li>今はバグっているので、すぐに直します！</li>
</ul>
</li>
<li>BodyParser

<ul>
<li>application/json, application/x-www-form-urlencoding</li>
</ul>
</li>
<li>Response with Template Engine

<ul>
<li>MustacheViewEngine</li>
</ul>
</li>
<li>Renderable Protocol

<ul>
<li>ReactのView EngineをSwiftで作る夢</li>
<li>夢であって、現実には存在しない</li>
</ul>
</li>
<li>Cluster

<ul>
<li>シングルスレッドをコア数分、展開する</li>
<li>書き方はNode.jsライク</li>
<li>Node.jsのClusterモジュールを真似て作った</li>
</ul>
</li>
<li>IPC between the Master and the Workers</li>
<li>Let it crash

<ul>
<li>メモリが80%こえたらRestartするといったAppの作り方ができる</li>
<li>プロセス管理ができる</li>
</ul>
</li>
<li>DataBase

<ul>
<li>Slimaneには今はない</li>
<li>MySql-Swiftがすごく良い

<ul>
<li>SlimaneはNo Blocking I/Oだからダメ&hellip;</li>
</ul>
</li>
</ul>
</li>
<li>Process.qwork

<ul>
<li>Blocking I/OをNo Blocking I/Oに見せかける</li>
<li>Synchronous I/O</li>
</ul>
</li>
<li>パフォーマンス

<ul>
<li>ABテストをやってみた</li>
<li>Slimaneが動くバージョンで試してみた</li>
<li>Swiftのバージョンによって動かないFrameworkは多い</li>
<li>Nginxは早過ぎる&hellip;</li>
<li>Expressより相当Slimaneは速い(Swiftが速いことが証明された)</li>
<li>REVELよりもVAPORの方が速い(Swiftが速いことを証明)</li>
</ul>
</li>
<li>Slimaneの今後

<ul>
<li>Promise対応必須</li>
<li>Stream Response</li>
<li>MySqlをネイティブ非同期で通信</li>
<li>Command line IF</li>
<li>Test Codes</li>
<li>Webフロントとの親和性を高めたい</li>
</ul>
</li>
</ul>
</li>
</ul>


<p>今日は以上です。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PromiseKitを使ってみよう！]]></title>
    <link href="http://grandbig.github.io/blog/2016/04/09/swift-promisekit/"/>
    <updated>2016-04-09T23:07:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2016/04/09/swift-promisekit</id>
    <content type="html"><![CDATA[<h4>SwiftでPromiseライブラリを使ってみよう</h4>

<p>さて、前回から引き続きSwiftでのPromiseライブラリについて見ていきたいと思います。<br/>
今回はPromiseライブラリのSwift界隈で有名な <strong>PromiseKit</strong> について見ていきます。</p>

<h4>PromiseKitのインストール</h4>

<p>早速、 <strong>PromiseKit</strong> の導入について紹介します。<br/>
筆者の場合、Xcode7.3を利用しているため、Swift2.2を扱うことになります。<br/>
<a href="https://github.com/mxcl/PromiseKit">GitHub</a>で紹介されている下記の導入方法では <strong>2.2.1</strong> がインストールされます。<br/>
しかし、このバージョンはSwift2.2に対応していないため、エラーが発生します。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<p>```objective-c
use_frameworks!</p>

<p>pod &ldquo;PromiseKit&rdquo;, &ldquo;~>2.0&rdquo;
```</p>

<p><a href="http://promisekit.org/">PromiseKitの公式ドキュメントページ</a>を見ると、Newsの項目でバージョン <strong>3.1.0</strong> でSwift2.2に対応したと書かれています。<br/>
そこで、今回は、</p>

<p>```objective-c
use_frameworks!</p>

<p>pod &ldquo;PromiseKit&rdquo;, &ldquo;3.1.0&rdquo;
```</p>

<p>とすることで、Xcode7.3でも問題なく、PromiseKitを扱えるようにしました。</p>

<h4>PromiseKitで非同期処理を直列に書いてみよう</h4>

<p>前回のBrightFutureで紹介した処理をPromiseKitで書いてみようと思います。<br/>
まずは、非同期処理をPromiseKitを使って定義します。</p>

<p>```objective-c
func p(msg: String) &ndash;> Promise<String>{</p>

<pre><code>let promise = Promise&lt;String&gt; { (fulfill, reject) in
    let queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)
    dispatch_async(queue, { 
        sleep(1)
        dispatch_sync(dispatch_get_main_queue(), {
            print(msg)
            fulfill(msg)
        })
    })
}

return promise
</code></pre>

<p>}
```</p>

<p>では、これを呼び出してみましょう。</p>

<p>```objective-c
p(&ldquo;Hello&rdquo;).then { (msg1) &ndash;> Promise<String> in</p>

<pre><code>return p("Good Evening")
</code></pre>

<p>}.then { (msg2) &ndash;> Promise<String> in</p>

<pre><code>return p("Good Bye")
</code></pre>

<p>}
```</p>

<p>ネストが浅い状態で複数の非同期処理を書くことができました。<br/>
また、BrightFutureと大きな違いはなく書くことできました。</p>

<h4>PromiseKitで非同期処理を並列に書いてみよう</h4>

<p>続いて、複数の非同期処理を並列に実行する場合を考えてみます。<br/>
順番に処理をする必要がなく、処理が完了したものから反映していきたい場合などに使いますね。</p>

<p>非同期処理自体は先程と同じものを使います。<br/>
では、並列に処理を呼び出してみましょう。</p>

<p>```objective-c
// 実行したい非同期処理を定義
let p1 = ps.p_promiseKit(&ldquo;Method1&rdquo;)
let p2 = ps.p_promiseKit(&ldquo;Method2&rdquo;)
let p3 = ps.p_promiseKit(&ldquo;Method3&rdquo;)</p>

<p>// まとめて非同期処理を実行
when([p1, p2, p3]).then { (result: [String]) &ndash;> AnyPromise in</p>

<pre><code>return AnyPromise(bound: Promise())
</code></pre>

<p>}
```</p>

<p>先に書いた直列処理では、1秒間隔でログが出力されたかと思います。<br/>
ここでは同時に実行したため、ほぼ同時に3つのログが出力されたはずです。</p>

<p>さて如何だったでしょうか？<br/>
SwiftでもPromiseライブラリはたくさん出てきました。<br/>
<a href="https://github.com/Thomvis/BrightFutures">BrightFuture</a>, <a href="https://github.com/mxcl/PromiseKit">PromiseKit</a>, <a href="https://github.com/ReactKit/SwiftTask">SwiftTask</a>のいずれを利用するかは開発者の判断になるかと思います。<br/>
個人的にはPromiseKitはGitHub上に似た名称のブランチがたくさんあるのをどうにかして欲しいなと思ってたりします笑</p>

<p>また、時間があるときにPromiseを使って何かやりたいと思います。<br/>
と言ったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[BrightFutureを使ってみよう！]]></title>
    <link href="http://grandbig.github.io/blog/2016/04/03/bright-future/"/>
    <updated>2016-04-03T17:11:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2016/04/03/bright-future</id>
    <content type="html"><![CDATA[<h4>SwiftでPromiseライブラリを使ってみよう</h4>

<p>最近は更新頻度が落ちてしまっていますが、久々に更新します。<br/>
(iPhoneSEが発表されたことですし笑)</p>

<p>さて、本日はSwift版Promiseライブラリとしては割と有名な <strong>BrightFuture</strong> ライブラリを使ってみたいと思います。<br/>
筆者は、新しいことに取り組む際は、JSで例を見た方がわかりやすかったりするので、Node.jsのPromiseと交えながら紹介していきたいと思います。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h4>Promiseとは</h4>

<p>まずは、Promiseの存在について軽く触れておきます。<br/>
<a href="http://azu.github.io/promises-book/">JS Promiseの本</a>によると、Promiseとは『非同期処理を抽象化したオブジェクトとそれを操作する仕組み』のことだそうです。<br/>
これだけ読むと理解しがたいと思うので、筆者が感じるPromiseの良さをざっくり書くと&hellip;</p>

<ul>
<li>非同期処理を繰り返す場合でも、深いネストにならない</li>
<li>非同期処理を繰り返す場合でも、見かけ上、直列的に処理を書ける</li>
</ul>


<p>ということにつきると思います。</p>

<p>具体的な例については、Node.jsで説明します。</p>

<h4>Node.jsでのPromiseの例</h4>

<p>早速、見ていきます。<br/>
Node.jsで非同期処理を定義する場合、</p>

<p>```javascript
// 非同期処理を持ったメソッド
function p(msg, callback) {</p>

<pre><code>setTimeout(function() {
    callback(msg);
}, 1000);
</code></pre>

<p>}
```</p>

<p>となります。<br/>
このメソッドを繰り返し実行する場合、</p>

<p>```javascript
p(&ldquo;Hello&rdquo;, function(msg1) {</p>

<pre><code>console.log(msg1 + ", date: " + new Date());
p("Good Evening", function(msg2) {
    console.log(msg2 + ", date: " + new Date());
    p("Good Bye", function(msg3) {
        console.log(msg3 + ", date: " + new Date());
    });
});
</code></pre>

<p>});
```</p>

<p>のようになります。<br/>
ネスト深いですね&hellip;。</p>

<p>これをPromiseを用いて書き直してみましょう。<br/>
まずはメソッドの定義にPromiseを適用します。</p>

<p>```javascript
function p(msg) {</p>

<pre><code>return new Promise(function(resolve) {
    setTimeout(function() {
        resolve(msg);
    }, 1000);
});
</code></pre>

<p>}
```</p>

<p>こうすることで、呼び出し側で下記のように浅いネストで書くことができます。</p>

<p>```javascript
p(&ldquo;Hello&rdquo;).then(function(msg1) {</p>

<pre><code>console.log(msg1 + ", date: " + new Date());
return p("Good Evening");
</code></pre>

<p>})
.then(function(msg2) {</p>

<pre><code>console.log(msg2 + ", date: " + new Date());
return p("Good Bye")
</code></pre>

<p>})
.then(function(msg3) {</p>

<pre><code>console.log(msg3 + ", date: " + new Date());
</code></pre>

<p>});
```</p>

<p>うむ。かなり浅くなりましたね。<br/>
これをSwiftで書くとどうなるのでしょうか？</p>

<h4>SwiftでのPromiseの例</h4>

<p>Swiftでも非同期処理を定義する場合、</p>

<p>```objective-c
func p(msg: String, closure: (String &ndash;> ())) {</p>

<pre><code>let queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)
dispatch_async(queue, {
    sleep(1)
    dispatch_sync(dispatch_get_main_queue(), {
        closure(msg)
    })
})
</code></pre>

<p>}
```</p>

<p>のように書けたりします。<br/>
これを複数回呼び出す場合、</p>

<p>```objective-c
p(&ldquo;Hello&rdquo;) { (msg1) in</p>

<pre><code>print(msg1 + ", date: \(NSDate())")
p("Good Evening") { (msg2) in
    print(msg2 + ", date: \(NSDate())")
    p("Good Bye") { (msg3) in
        print(msg3 + ", date: \(NSDate())")
    }
}
</code></pre>

<p>}
```</p>

<p>のようになります。<br/>
同様にネストが深くなりますね&hellip;。</p>

<p>では、Promiseでネストを改善しましょう。<br/>
Swiftでは、OSSの<a href="https://github.com/Thomvis/BrightFutures">BrightFuture</a>を利用します。<br/>
導入はいつも通りCocoaPodsを使いました。</p>

<p>1． Podfileに下記を記載</p>

<p>```objective-c
source &lsquo;<a href="https://github.com/CocoaPods/Specs.git">https://github.com/CocoaPods/Specs.git</a>&rsquo;
platform :ios, &lsquo;8.0&rsquo;
use_frameworks!</p>

<p>pod &lsquo;BrightFutures&rsquo;
```</p>

<p>2．<code>pod install</code>を実行</p>

<p>導入が完了したら、処理を書き換えていきます。<br/>
メソッドにPromiseを適用しましょう。</p>

<p>```objective-c
func p_future(msg: String) &ndash;> Future&lt;String, NoError> {</p>

<pre><code>let promise = Promise&lt;String, NoError&gt;()
let queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)

dispatch_async(queue, {
    sleep(1)
    dispatch_sync(dispatch_get_main_queue(), {
        promise.success(msg)
    })
})

return promise.future
</code></pre>

<p>}
```</p>

<p>これを呼び出すときは下記のように書けます。</p>

<p>```objective-c
p_future(&ldquo;Hello&rdquo;).flatMap { msg1 in</p>

<pre><code>print(msg1 + ", date: \(NSDate())")
p_future("Good Evening")
</code></pre>

<p>}.flatMap { msg2 in</p>

<pre><code>print(msg2 + ", date: \(NSDate())")
p_future("Good Bye")
</code></pre>

<p>}.onSuccess { (msg3) in</p>

<pre><code>print(msg3)
</code></pre>

<p>}
```</p>

<p>ネストが浅くなりましたね。<br/>
こうして比較してみると、Node.jsとSwiftで呼び出し側の書き方はかなり似ていますね。<br/>
Swiftだけを眺めてみてもよくわからないという方はNode.jsの方も見てみると良いと思います。</p>

<p>今回はかなり基本的な例を書かせて頂きましたが、参考になれば幸いです。<br/>
といったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>



]]></content>
  </entry>
  
</feed>
