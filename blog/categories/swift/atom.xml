<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: swift | Takahiro Octopress Blog]]></title>
  <link href="http://grandbig.github.io/blog/categories/swift/atom.xml" rel="self"/>
  <link href="http://grandbig.github.io/"/>
  <updated>2016-07-17T00:08:58+09:00</updated>
  <id>http://grandbig.github.io/</id>
  <author>
    <name><![CDATA[Takahiro]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Swift Expressを使ってみよう！]]></title>
    <link href="http://grandbig.github.io/blog/2016/07/10/swift-express/"/>
    <updated>2016-07-10T22:56:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2016/07/10/swift-express</id>
    <content type="html"><![CDATA[<h3>今注目のサーバーサイドSwift</h3>

<p>本日はサーバーサイドSwiftのWebフレームワークの1つである<a href="https://github.com/crossroadlabs/Express">Swift Express</a>を紹介したいと思います。<br/>
近年、AppleからSwiftのOSS化が発表されたことで一気に動き出したのがGitHub上でのWebフレームワーク作成合戦です。<br/>
筆者が知っているだけでも、</p>

<ul>
<li><a href="https://github.com/PerfectlySoft/Perfect">Perfect</a></li>
<li><a href="https://github.com/qutheory/vapor">Vapor</a></li>
<li><a href="https://github.com/IBM-Swift/Kitura-Starter-Bluemix">Kitura</a></li>
<li><a href="https://github.com/slimane-swift">Sliman</a></li>
</ul>


<p>などが上げられます。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<p>そんな中、筆者の目に止まったのが、 <strong>Swift Express</strong> でした。<br/>
本ブログでも度々 <strong>Node.js</strong> を触ったことがあると述べてきたように、筆者は <strong>Node.js</strong> でサーバサイド実装の経験があります。<br/>
その際に利用していたWebフレームワークに<a href="http://expressjs.com/">Express</a>というものがありました。<br/>
Expressは <strong>Node.js</strong> でいとも簡単にベースとなるサーバサイド実装を提供してくれます。</p>

<p>Swiftの経験はあるものの、サーバサイドSwiftの実装経験がない筆者にとっては『願ってもないWebフレームワークじゃないか！』ということで <strong>Swift Express</strong> に惹かれたのです。<br/>
さて、本日はそんな <strong>Swift Express</strong> を見ていきたいと思います。</p>

<h3>Swift Expressをインストールしよう</h3>

<p>まずは、Swift Expressをインストールしてみます。<br/>
<code>homebrew</code>でインストールします。</p>

<p>```javascript
// 手順(1)
brew tap crossroadlabs/tap</p>

<p>// 手順(2)
brew install swift-express
```</p>

<p>手順(1)を実行すると、下記のように結果が表示されます。</p>

<p><code>javascript
==&gt; Tapping crossroadlabs/tap
Cloning into '/usr/local/Library/Taps/crossroadlabs/homebrew-tap'...
remote: Counting objects: 8, done.
remote: Compressing objects: 100% (7/7), done.
remote: Total 8 (delta 0), reused 6 (delta 0), pack-reused 0
Unpacking objects: 100% (8/8), done.
Checking connectivity... done.
Tapped 2 formulae (34 files, 72.7K)
</code></p>

<p>続いて、手順(2)を実行すると、下記のように結果が表示されます。</p>

<p>```javascript
==> Installing swift-express from crossroadlabs/tap
==> Installing dependencies for crossroadlabs/tap/swift-express: openssl, cmake, libevent, libevhtp, carthage
==> Installing crossroadlabs/tap/swift-express dependency: openssl
==> Downloading <a href="https://homebrew.bintray.com/bottles/openssl-1.0.2h_1.el_capitan.bottle.tar.gz">https://homebrew.bintray.com/bottles/openssl-1.0.2h_1.el_capitan.bottle.tar.gz</a></p>

<h6>################################################################## 100.0%</h6>

<p>==> Pouring openssl-1.0.2h_1.el_capitan.bottle.tar.gz
==> Caveats
A CA file has been bootstrapped using certificates from the system
keychain. To add additional certificates, place .pem files in
  /usr/local/etc/openssl/certs</p>

<p>  and run</p>

<pre><code>/usr/local/opt/openssl/bin/c_rehash

This formula is keg-only, which means it was not symlinked into /usr/local.

Apple has deprecated use of OpenSSL in favor of its own TLS and crypto libraries

Generally there are no consequences of this for you. If you build your
own software and it requires this formula, you'll need to add to your
build variables:

    LDFLAGS:  -L/usr/local/opt/openssl/lib
    CPPFLAGS: -I/usr/local/opt/openssl/include
</code></pre>

<p>==> Summary
🍺  /usr/local/Cellar/openssl/1.0.2h_1: 1,691 files, 12M
==> Installing crossroadlabs/tap/swift-express dependency: cmake
==> Downloading <a href="https://homebrew.bintray.com/bottles/cmake-3.6.0.el_capitan.bottle.tar.gz">https://homebrew.bintray.com/bottles/cmake-3.6.0.el_capitan.bottle.tar.gz</a></p>

<h6>################################################################## 100.0%</h6>

<p>==> Pouring cmake-3.6.0.el_capitan.bottle.tar.gz
==> Caveats
Emacs Lisp files have been installed to:
  /usr/local/share/emacs/site-lisp/cmake
  ==> Summary
  🍺  /usr/local/Cellar/cmake/3.6.0: 2,028 files, 27.8M
  ==> Installing crossroadlabs/tap/swift-express dependency: libevent
  ==> Downloading <a href="https://homebrew.bintray.com/bottles/libevent-2.0.22.el_capitan.bottle.tar.gz">https://homebrew.bintray.com/bottles/libevent-2.0.22.el_capitan.bottle.tar.gz</a></p>

<h6>################################################################## 100.0%</h6>

<p>==> Pouring libevent-2.0.22.el_capitan.bottle.tar.gz
🍺  /usr/local/Cellar/libevent/2.0.22: 53 files, 1.6M
==> Installing crossroadlabs/tap/swift-express dependency: libevhtp
==> Downloading <a href="https://github.com/ellzey/libevhtp/archive/1.2.10.tar.gz">https://github.com/ellzey/libevhtp/archive/1.2.10.tar.gz</a>
==> Downloading from <a href="https://codeload.github.com/ellzey/libevhtp/tar.gz/1.2.10">https://codeload.github.com/ellzey/libevhtp/tar.gz/1.2.10</a></p>

<h6>################################################################## 100.0%</h6>

<p>Warning: SHA1 support is deprecated and will be removed in a future version.
Please switch this formula to SHA256.
==> cmake . -DEVHTP_DISABLE_REGEX:STRING=ON -DEVHTP_BUILD_SHARED:STRING=ON -DCMAKE_C_FLAGS_RELEASE=-DNDEBUG -DCMAKE_CXX_FLAGS_RELEASE=-DNDEBUG -DCMAKE_INSTALL_PREFIX=/usr/local/Cell
==> make install
🍺  /usr/local/Cellar/libevhtp/1.2.10: 9 files, 151.5K, built in 48 seconds
==> Installing crossroadlabs/tap/swift-express dependency: carthage
==> Downloading <a href="https://homebrew.bintray.com/bottles/carthage-0.17.2.el_capitan.bottle.tar.gz">https://homebrew.bintray.com/bottles/carthage-0.17.2.el_capitan.bottle.tar.gz</a></p>

<h6>################################################################## 100.0%</h6>

<p>==> Pouring carthage-0.17.2.el_capitan.bottle.tar.gz
🍺  /usr/local/Cellar/carthage/0.17.2: 45 files, 11.9M
==> Installing crossroadlabs/tap/swift-express
==> Cloning <a href="https://github.com/crossroadlabs/ExpressCommandLine.git">https://github.com/crossroadlabs/ExpressCommandLine.git</a>
Cloning into &lsquo;/Users/kato_takahiro/Library/Caches/Homebrew/swift-express&mdash;git&rsquo;&hellip;
remote: Counting objects: 67, done.
remote: Compressing objects: 100% (63/63), done.
remote: Total 67 (delta 21), reused 25 (delta 1), pack-reused 0
Unpacking objects: 100% (67/67), done.
Checking connectivity&hellip; done.
Note: checking out &lsquo;fae821f4d52c9dfb4e4c34ab0a4297ea700c9db1&rsquo;.</p>

<p>You are in &lsquo;detached HEAD&rsquo; state. You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by performing another checkout.</p>

<p>If you want to create a new branch to retain commits you create, you may
do so (now or later) by using -b with the checkout command again. Example:</p>

<pre><code>  git checkout -b &lt;new-branch-name&gt;

==&gt; Checking out tag 0.2.2
==&gt; carthage update --platform Mac --no-use-binaries --no-build
==&gt; rm -rf Carthage/Checkouts/Commandant/Carthage/Checkouts/Nimble Carthage/Checkouts/Commandant/Carthage/Checkouts/Quick
==&gt; carthage build --platform Mac
==&gt; xcodebuild SYMROOT=build
==&gt; Caveats
.app bundles were installed.
Run `brew linkapps swift-express` to symlink these to /Applications.
==&gt; Summary
🍺  /usr/local/Cellar/swift-express/0.2.2: 30 files, 7.3M, built in 3 minutes 5 seconds
</code></pre>

<p>```</p>

<p>さて、見過ごしがちですが、<br/>
最後の方に『<code>brew linkapps swift-express</code> to symlink these to /Applications.』と書かれているので、</p>

<p><code>brew linkapps swift-express</code>を実行しておきましょう。</p>

<p>ここまで来たら、<code>swift-express</code>を実行してください。</p>

<p>```javascript
Available commands:</p>

<p>bootstrap   download and build Express project dependencies
build       build Express project
help        Display general or command-specific help
init        Creates new Express application project
run         run Express project
update      update and build Express project dependencies
version     Display the current version of Swift Express Command Line
```</p>

<p>のようにコマンド種別が表示されたら、正しく <strong>Swift Express</strong> がインストールされた証拠です。</p>

<h3>Swift Expressのプロジェクトを作ろう！</h3>

<p>Swift Expressのインストールが完了したので、早速プロジェクト作成しましょう。</p>

<p>```javascript
// 手順(1)
swift-express init &lt;プロジェクト名></p>

<p>// 手順(2)
cd &lt;プロジェクト名></p>

<p>// 手順(3)
swift-express bootstrap
```</p>

<p>手順(1)を実行すると、下記の結果が表示されます。</p>

<p><code>javascript
Cloning into '/var/folders/hj/p9y9d00s3sb5nn_x04961z2m0000gn/T/swift-express-827699'...
remote: Counting objects: 124, done.
remote: Total 124 (delta 0), reused 0 (delta 0), pack-reused 124
Receiving objects: 100% (124/124), 79.66 KiB | 0 bytes/s, done.
Resolving deltas: 100% (33/33), done.
Checking connectivity... done.
Task: "init" done.
</code></p>

<p>続いて、手順(2)で作成したプロジェクトフォルダ配下に移動すると、</p>

<p><code>javascript
HelloExpress
  ┣━━ Cartfile
  ┣━━ HelloExpress.xcodeproj
  ┣━━ Info.plist
  ┣━━ Package.swift
  ┣━━ app
  ┃    ┗━━ main.swift
  ┣━━ dist
  ┣━━ public
  ┃    ┣━━ css
  ┃    ┃    ┗━━ main.css
  ┃    ┗━━ logo.png
  ┗━━ views
</code></p>

<p>といった形で構成されていることを確認できます。</p>

<p>最後に手順(3)を実行すると、下記の結果が表示されます。<br/>
(ここが最も時間のかかる工程になります。)</p>

<p>```javascript
<strong><em> No Cartfile.resolved found, updating dependencies
</em></strong> Cloning Express
<strong><em> Cloning Stencil
</em></strong> Cloning GRMustache.swift
<strong><em> Cloning CEVHTP
</em></strong> Cloning PathToRegex
<strong><em> Cloning Regex
</em></strong> Cloning TidyJSON
<strong><em> Cloning BrightFutures
</em></strong> Cloning PathKit
<strong><em> Cloning ExecutionContext
</em></strong> Cloning Result
<strong><em> Checking out CEVHTP at &ldquo;0.1.0&rdquo;
</em></strong> Checking out ExecutionContext at &ldquo;0.3.1&rdquo;
<strong><em> Checking out Result at &ldquo;1.0.3&rdquo;
</em></strong> Checking out GRMustache.swift at &ldquo;bf7d6031d7e0dd862519eaba2b36b2e11a0d25a9&rdquo;
<strong><em> Checking out Regex at &ldquo;0.5.2&rdquo;
</em></strong> Checking out PathToRegex at &ldquo;0.2.2&rdquo;
<strong><em> Checking out PathKit at &ldquo;0.6.1&rdquo;
</em></strong> Checking out BrightFutures at &ldquo;0.4.0&rdquo;
<strong><em> Checking out Stencil at &ldquo;0.5.3&rdquo;
</em></strong> Checking out Express at &ldquo;0.3.6&rdquo;
*** Checking out TidyJSON at &ldquo;1.1.0&rdquo;</p>

<p>&lt;省略></p>

<p>/Users/<strong><strong>**/</strong></strong>/HelloExpress/Carthage/Checkouts/Express/Express/Content.swift:39:5: warning: use of &lsquo;typealias&rsquo; to declare associated types is deprecated; use &lsquo;associatedtype&rsquo; instead
Task: &ldquo;bootstrap&rdquo; done.
```</p>

<p>これでプロジェクトの作成は完了です。</p>

<h3>プロジェクトを実行してみよう！</h3>

<p>先ほど作成したプロジェクトを実行してみたいと思います。</p>

<p>```javascript
// 手順(1)
swift-express build</p>

<p>// 手順(2)
swift-express run
```</p>

<p>早速、ビルドを実行するために手順(1)のコマンドを叩いてください。<br/>
すると、</p>

<p>```javascript
Building HelloExpress in Debug mode&hellip;</p>

<p>&lt;省略></p>

<p>=== BUILD TARGET HelloExpress OF PROJECT HelloExpress WITH CONFIGURATION Debug ===</p>

<p>&lt;省略></p>

<p><strong> BUILD SUCCEEDED </strong></p>

<p>Task: &ldquo;build&rdquo; done.
```</p>

<p>という結果が表示されます。<br/>
問題がなければ<code>BUILD SUCCEEDED</code>が表示されるはずです。</p>

<p>ビルドが成功したら、手順(2)を実行しましょう。<br/>
すると、</p>

<p><code>javascript
Running HelloExpress...
Express was successfully launched on port 9999
</code></p>

<p>のように表示されます。デフォルトでポート番号が <strong>9999</strong> になっていることがわかると思います。<br/>
<code>http://localhost:9999</code>にアクセスしてみると、</p>

<p><img src="/images/swift-express-1.png" alt="Swift Express TOPページ" /></p>

<p>という画面が得られます。</p>

<p>因みにですが、Xcodeからも<code>Build</code>＆<code>Run</code>はできます。</p>

<p><img src="/images/swift-express-2.png" alt="XcodeからBuild &amp; Run" /></p>

<h3>Swift Expressの中身を見てみよう！</h3>

<p>最後にざっくり中身のソースを見てみようと思います。<br/>
Swift Expressのメインソースである<code>main.swift</code>を見てみます。</p>

<p>```javascript
// app/main.swift</p>

<p>import Express</p>

<p>let app = express()</p>

<p>// (1)
app.views.register(StencilViewEngine())</p>

<p>// (2)
app.get(&ldquo;/assets/:file+&rdquo;, action: StaticAction(path: &ldquo;public&rdquo;, param:&ldquo;file&rdquo;))</p>

<p>// (3)
app.get(&ldquo;/&rdquo;) { (request:Request<AnyContent>)&ndash;>Action<AnyContent> in</p>

<pre><code>return Action&lt;AnyContent&gt;.render("index", context: ["hello": "Hello,", "swift": "Swift", "express": "Express!"])
</code></pre>

<p>}</p>

<p>// (4)
app.listen(9999).onSuccess { server in</p>

<pre><code>print("Express was successfully launched on port", server.port)
</code></pre>

<p>}</p>

<p>app.run()
```</p>

<p>これは <strong>Node.js</strong> 経験者としてはかなりExpressに酷似してるなと感じます。<br/>
順に追ってみていきます。</p>

<p>(1): 描画エンジンを設定しています。</p>

<p>Node.jsのExpressで言うところの、</p>

<p><code>javascript
app.set('views', path.join(__dirname, 'views'));
app.set('view engine', 'jade');
</code></p>

<p>に該当します。</p>

<p>(2): 静的ファイルの格納場所を設定しています。</p>

<p>Node.jsのExpressで言うところの、</p>

<p><code>javascript
app.use(express.static(path.join(__dirname, 'public')));
</code></p>

<p>に該当します。</p>

<p>(3): リクエストのアクションパスと処理を設定しています。</p>

<p>Node.jsのExpressで言うところの、</p>

<p>```javascript
// app.js
app.use(&lsquo;/&rsquo;, routes);</p>

<p>// route/index.js
router.get(&lsquo;/&rsquo;, function(req, res, next) {</p>

<pre><code>res.render('index', { title: 'Express' }); 
</code></pre>

<p>}
```</p>

<p>に該当します。</p>

<p>(4): ポート番号を設定しています。</p>

<p>Node.jsのExpressで言うところの、</p>

<p>```javascript
// bin/www
var port = normalizePort(process.env.PORT || &lsquo;3000&rsquo;);
app.set(&lsquo;port&rsquo;, port);</p>

<p>var server = http.createServer(app);</p>

<p>server.listen(port);</p>

<p>server.on(&lsquo;listening&rsquo;, onListening);</p>

<p>function onListening() {</p>

<pre><code>var addr = server.address();
var bind = typeof addr === 'string'
    ? 'pipe ' + addr
    : 'port ' + addr.port;
debug('Listening on ' + bind);
</code></pre>

<p>}
```</p>

<p>に該当します。</p>

<h3>まとめ</h3>

<p>さて如何でしたでしょうか？<br/>
これだけNode.jsのExpressに似ているのですから、<br/>
<strong>Swift Express</strong> はこれからサーバサイドSwiftを学んでいく上で強力なWebフレームワークとなるかもしれません。<br/>
新しくNode.jsを学ぶ人も将来的にサーバサイドSwiftを触る機会が出てくるかもしれませんので知っておいて損はないでしょう。<br/>
筆者もこれまら益々注目されるであろうサーバサイドSwiftの情報は追っていきたいと思います。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SwiftとJava8でOptional型を比較してみよう！]]></title>
    <link href="http://grandbig.github.io/blog/2016/06/19/swift-java-optional/"/>
    <updated>2016-06-19T21:12:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2016/06/19/swift-java-optional</id>
    <content type="html"><![CDATA[<h4>SwiftとJava8のOptional型を比較してみよう！</h4>

<p>本日はSwiftとJava8のOptional型について比較してみたいと思います。<br/>
最近チラチラとJava8を見かける機会が多いのですが、Swiftと同じくOptional型という概念があるんだ〜と何となく思っていました。<br/>
が、実際に全く同じというわけではないと思うので比較したいと思ったわけです。<br/>
ということで早速見ていきましょう！</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h5>SwiftのOptional型とは</h5>

<p>まずはSwiftのOptional型から見ていきましょう。<br/>
SwiftはObjective-Cでよく発生していた『思いがけず<code>nil</code>が入ったプロパティにアクセスしてExceptionが発生する』という事象を回避できる <strong>Optional型</strong> という概念があります。<br/>
Swiftでは <strong>Optional型</strong> と <strong>非Optional型</strong> を変数定義時に明示的に利用することでこういったExceptionを回避することが可能なのです。</p>

<ul>
<li>Optional型: 変数に<code>nil</code>を代入することを <strong>許容します</strong>

<ul>
<li>Optional型はデータ型の末尾に <strong>『?』</strong> か <strong>『!』</strong> をつけます

<ul>
<li>『?』: 一般的なOptional型です</li>
<li>『!』: 暗黙的Optional型です</li>
</ul>
</li>
</ul>
</li>
<li>非Optional型: 変数に<code>nil</code>を代入することを <strong>許容しません</strong></li>
</ul>


<p>```objective-c
// Optional型
var hoge: Int?
var fuga: Int!</p>

<p>// 非Optional型
var piyo
```</p>

<h5>Optional型から値を取得する方法は</h5>

<p>さて、Optional型の宣言方法は先程話した通りです。<br/>
実際に値を取得する際はOptional型で定義された変数を <strong>アンラップ</strong> する必要があります。</p>

<p>ここで注意したいのが、先に紹介した『!』を使った暗黙的Optional型の場合は <strong>自動的にアンラップする</strong> ので開発者側はアンラップさせる必要がないということです。</p>

<p>アンラップ方法は下記の3通りです。</p>

<ul>
<li>Forced Unwrapping: 変数に『!』をつけます</li>
<li>Optional Binding: <code>if</code>文を利用します</li>
<li>Optional Chaining: 変数に『?』をつけます</li>
</ul>


<p>Forced UnwrappingとOptional Bindeingの例は下記です。</p>

<p>```objective-c
var hoge: Int? = 1</p>

<p>// Forced Unwrapping
print(hoge!)</p>

<p>// Optional Binding
if let fuga = hoge {</p>

<pre><code>print(fuga)
</code></pre>

<p>}
```</p>

<p>続いてOptional Chainingの例を書きます。<br/>
まずは下記のようなクラスを定義します。</p>

<p>```objective-c
class Hoge: NSObject {</p>

<pre><code>func hogehoge() {
    print("hogehogeメソッドを実行しました")
}
</code></pre>

<p>}
```</p>

<p>上記で定義したクラスの<code>hogehoge</code>メソッドをOptional Chaningを利用して実行します。</p>

<p>```objective-c
var hoge: Hoge? = Hoge()</p>

<p>// Optional Chaining
hoge?.hogehoge()
```</p>

<p>このようにSwiftではコーディングしていく段階でかなり<code>nil</code>に注意する必要があることがわかります。</p>

<h5>Java8のOptional型とは</h5>

<p>次にJava8のOptional型について見ていきましょう！<br/>
Java8ではOptionalを利用することで</p>

<ul>
<li><code>null</code>の可能性がある変数をラップしておくことで、値を安全に取り出せる</li>
<li>実行したメソッドが<code>null</code>を返却する可能性がある場合に、場合分けを短く書ける</li>
</ul>


<p>というメリットがあります。<br/>
では実際に使い方を見ていきましょう！</p>

<p>```java
String hoge = &ldquo;hoge&rdquo;;</p>

<p>// Optional型にラップする
Optional<String> hogeOpt = Optional.of(hoge);</p>

<p>// Optional型から値を取り出す
// getメソッドを使う
System.out.println(hogeOpt.get());</p>

<p>// orElseメソッドを使う
System.out.println(hogeOpt.orElse(&ldquo;default data&rdquo;));</p>

<p>// orElseGetメソッドを使う
System.out.println(hogeOpt.orElseGet(() &ndash;> &ldquo;default data&rdquo;));</p>

<p>// ifPresentメソッドを使う
hogeOpt.ifPresent( hoge &ndash;> {</p>

<pre><code>// 値があったときにログ出力
System.out.println(hoge);
</code></pre>

<p>});
```</p>

<p>上記を見ると幾つか値の取得方法があることがわかると思います。<br/>
それぞれSwiftの表記に近しいところがあると感じました。</p>

<p>例えば、<code>get</code>メソッドは値が<code>null</code>だった場合に<code>NoSuchElementException</code>を投げます。<br/>
逆に言えば、確実に<code>null</code>が来ない場合の<code>get</code>メソッドが利用できると言えます。<br/>
これはSwiftで言うところの『Forced Unwrapping』です。</p>

<p><code>orElse</code>や<code>orElseGet</code>はSwiftで言うところのnil合体演算子である『??』を利用しているのとほぼ同等です。<br/>
(Swiftであれば<code>let val = hoge ?? "default data"</code>みたいな感じですね。)</p>

<p><code>ifPresent</code>メソッドもSwiftで言うところの『Optional Binding』と言えるでしょう。</p>

<h4>まとめ</h4>

<p>さて如何でしたでしょうか？<br/>
Android Studio 2.2からJava8のラムダ式サポートなんて話も聞こえてきますし、<br/>
スマートフォンのアプリ開発者は今後、SwiftにもJava8にも関わっていく可能性が十分ありえます。<br/>
そうなったときに学習コストが高いな〜と避けるのではなく、案外触ってみると「あれ！？似てる&hellip;」なんてことがあるかもしれません。<br/>
そんな近未来！？を夢見つつブログを書いてみたのでした。<br/>
ということで今日はここまで。</p>

<p>参考:</p>

<ul>
<li><a href="http://qiita.com/maiki055/items/b24378a3707bd35a31a8">どこよりも分かりやすいSwiftの"?&ldquo;と&rdquo;!"</a></li>
<li><a href="http://www.task-notes.com/entry/20150708/1436324400">Java8のOptionalの使い方について</a></li>
</ul>


<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SwiftとJava8とJavaScriptでreduce / filter / map / flatMap]]></title>
    <link href="http://grandbig.github.io/blog/2016/06/12/filter-map/"/>
    <updated>2016-06-12T21:01:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2016/06/12/filter-map</id>
    <content type="html"><![CDATA[<h4>SwiftとJava8とJavaScriptを比較してみよう！</h4>

<p>本日は前々から気になっていた『SwiftとJava8とJavaScript』の比較をしてみたいと思います。<br/>
と言っても難しいことをやるわけではなく、今回はreduce, filter, map, flatMapメソッドの書き方を比較してみます。</p>

<p>筆者個人としては、どうしてもSwiftやJava8から書き方やメソッドの意味の理解を始めようとすると時間がかかってしまいます。<br/>
なので、JavaScriptから入って比較することで理解が促進することがあるのです。</p>

<p>では早速見ていきましょう。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h4>reduceメソッド</h4>

<p>まずは<code>reduce</code>メソッドです。</p>

<h5>JavaScript</h5>

<p>```javascript
var array = [1, 2, 3, 4, 5];
var reduced = array.reduce(function(previus, current) {</p>

<pre><code>return previous + current;
</code></pre>

<p>}, 0);</p>

<p>// 結果 &ndash;> 15
```</p>

<h5>Swift</h5>

<p>```objective-c
let array = [1, 2, 3, 4, 5]
let reduced = array.reduce(0) { (previous, current) &ndash;> Int in</p>

<pre><code>previous + current
</code></pre>

<p>}</p>

<p>// 結果 &ndash;> 15
```</p>

<h5>Java8</h5>

<p>```java
List<Integer> integerList = Arrays.asList(1, 2, 3, 4, 5);
Optional<Integer> sum = list.stream().reduce((previous, current) &ndash;> previous + current);</p>

<p>// 結果 &ndash;> 15
```</p>

<h4>filterメソッド</h4>

<p>次に<code>filter</code>メソッドです。</p>

<h5>JavaScript</h5>

<p>```javascript
var array = [1, 50, 800, 3, 44];
var filtered = array.filter(function(elem) {</p>

<pre><code>return elem &gt;= 10;
</code></pre>

<p>});</p>

<p>// 結果 &ndash;> [50, 800, 44]
```</p>

<h5>Swift</h5>

<p>```objective-c
let array = [1, 50, 800, 3, 44]
var filtered = array.filter { (elem) &ndash;> Bool in</p>

<pre><code>elem &gt;= 10
</code></pre>

<p>}</p>

<p>// 結果 &ndash;> [50, 800, 44]
```</p>

<h5>Java8</h5>

<p>```java
List<Integer> list = Arrays.asList(1, 50, 800, 3, 44);
List<Integer> filteredList = new ArrayList<Integer>();
list.stream().filter(elem &ndash;> elem >= 10).forEach(elem &ndash;> filteredList.add(elem));</p>

<p>// 結果 &ndash;> [50, 800, 44]
```</p>

<h4>mapメソッド</h4>

<p>続いて<code>map</code>メソッドです。</p>

<h5>JavaScript</h5>

<p>```javascript
var array = [1, 2, 3, 4, 5];
var mapped = array.map(function(elem) {</p>

<pre><code>return elem * elem;
</code></pre>

<p>});</p>

<p>// 結果 &ndash;> [1, 4, 9, 16, 25]
```</p>

<h5>Swift</h5>

<p>```objective-c
let array = [1, 2, 3, 4, 5]
var mapped = array.map { (elem) &ndash;> Int in</p>

<pre><code>elem * elem
</code></pre>

<p>}</p>

<p>// 結果 &ndash;> [1, 4, 9, 16, 25]
```</p>

<h5>Java8</h5>

<p>```java
List<Integer> list = Arrays.asList(1, 2, 3, 4, 5);
List<Integer> mappedList = new ArrayList<Integer>();
list.stream().map(elem &ndash;> elem * elem).forEach(elem &ndash;> mappedList.add(elem));</p>

<p>// 結果 &ndash;> [1, 4, 9, 16, 25]
```</p>

<h4>flatMapメソッド</h4>

<p>最後に<code>flatMap</code>メソッドです。<br/>
(と言いつつ、処理の意味的には<code>flatten</code>しか入っていませんね&hellip;)</p>

<h5>JavaScript</h5>

<p>JavaScriptでは標準で<code>flatMap</code>メソッドは実装されていません。<br/>
自作するしかないわけですが、<code>flatMap = flatten + map</code>なので下記のように書けます。</p>

<p>```javascript
var listArrayList = [[1, 2], [3], [4, 5]]
var flatMappedList = Array.prototype.concat.apply([], listArrayList).map(function(elem) {</p>

<pre><code>return elem;
</code></pre>

<p>});</p>

<p>// 結果 &ndash;> [1, 2, 3, 4, 5]
```</p>

<h5>Swift</h5>

<p>```objective-c
var listArrayList:[Int]] = []
let list1: [Int] = [1, 2]
let list2: [Int] = [3]
let list3: [Int] = [4, 5]
listArrayList.append(list1)
listArrayList.append(list2)
listArrayList.append(list3)</p>

<p>let flatMappedList = listArrayList.flatMap { (elem) &ndash;> [Int] in</p>

<pre><code>return elem
</code></pre>

<p>}</p>

<p>// 結果 &ndash;> [1, 2, 3, 4, 5]
```</p>

<h5>Java8</h5>

<p>```java
List&lt;List<Integer>> listArrayList = new ArrayList&lt;List<Integer>>();
List<Integer> list1 = Arrays.asList(1, 2);
List<Integer> list2 = Arrays.asList(3);
List<Integer> list3 = Arrays.asList(4, 5);
listArrayList.add(list1);
listArrayList.add(list2);
listArrayList.add(list3);
List<Integer> flatMappedList = new ArrayList<Integer>();
listArrayList.stream().flatMap(elem &ndash;> elem.stream()).forEach(elem &ndash;> flatMappedList.add(elem));</p>

<p>// 結果 &ndash;> [1, 2, 3, 4, 5]
```</p>

<p>さていかがでしたでしょうか？<br/>
1つの言語を極めれば、何となく他の言語でも書き方がわかるという話を聞いたりすると思うのですが、こういったことの延長戦にある話なんだろうなと思ったりました。<br/>
と言ったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bolts-Swiftを使ってみよう！]]></title>
    <link href="http://grandbig.github.io/blog/2016/05/15/bolts-swift/"/>
    <updated>2016-05-15T22:34:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2016/05/15/bolts-swift</id>
    <content type="html"><![CDATA[<h4>SwiftでBolts-Swiftライブラリを使ってみよう</h4>

<p>これまで、<code>BrightFuture</code>, <code>PromiseKit</code>とPromiseライブラリについて見てきましたが、本日はFacebook製のPromiseライブラリである<a href="https://github.com/BoltsFramework/Bolts-Swift">Bolts-Swift</a>を試してみたいと思います。</p>

<p><code>Bolts</code>はこれまでもObjective-Cコードで利用されてきた有名ライブラリですが、<br/>
2016-03-18にSwift版 v1.0.0(<code>Bolts-Swift</code>) が公開されました。<br/>
※ Objective-C版は<a href="https://github.com/BoltsFramework/Bolts-ObjC">Bolts-ObjC</a>です。<br/>
※ 本記事執筆時点ではv1.1.0が最新となっています。</p>

<p>Facebookのエンジニアが開発しているため、Facebook SDKを利用する場合でも内部で<code>Bolts-ObjC</code>が利用されています。<br/>
現在、Facebook SDKがObjective-Cで書かれているため、今後Swift化される際に、<code>Bolts-Swift</code>が使われることになる可能性が高いと思います。<br/>
知っておいて損はないでしょう。</p>

<p>ということで早速、使い方を見ていきましょう。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h4>Bolts-Swiftのインストール</h4>

<p>CocoaPodsでインストールします。</p>

<p><strong>1．Podfileに下記を記載</strong></p>

<p>```objective-c
source &lsquo;<a href="https://github.com/CocoaPods/Specs.git">https://github.com/CocoaPods/Specs.git</a>&rsquo;
platform :ios, &lsquo;8.0&rsquo;
use_frameworks!     // (1)</p>

<p>target &ldquo;BoltsSwiftSample&rdquo; do    // (2)</p>

<pre><code>pod 'Bolts-Swift'
</code></pre>

<p>end
```</p>

<p><code>Bolts-Swift</code>の場合は(1)と(2)が必須書式となります。<br/>
(書かない場合、インストール時にErrorが発生します。)</p>

<p><strong>2．<code>pod install</code>を実行</strong></p>

<p><strong>3．処理の実装</strong></p>

<p>ライブラリのインストールが完了したら、処理を書いていきましょう。</p>

<p><code>Bolts-Swift</code>を適用したメソッドを用意します。<br/>
※ 非同期処理を含むサンプルメソッドです。</p>

<p>```objective-c
func p_task(msg: String) &ndash;> Task<String> {</p>

<pre><code>let taskCompletionSource = TaskCompletionSource&lt;String&gt;()
let queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)
dispatch_async(queue, {
    sleep(1)
    dispatch_sync(dispatch_get_main_queue(), {
        print(msg)
        taskCompletionSource.setResult(msg)
    })
})

return taskCompletionSource.task
</code></pre>

<p>}
```
このように定義することで、下記のように呼び出すことが可能となります。</p>

<p>```objective-c
let bt = BoltsTask()
bt.p_task(&ldquo;Hello&rdquo;).continueOnSuccessWith { (msg1) &ndash;> Task<String> in</p>

<pre><code>return bt.p_task("Good Evening")
</code></pre>

<p>}.continueOnSuccessWith { (msg2) &ndash;> Task<String> in</p>

<pre><code>return bt.p_task("Good Bye")
</code></pre>

<p>}
```</p>

<p>これを実行すれば、</p>

<p><code>objective-c
Hello
Good Evening
Good Bye
</code></p>

<p>と結果が得られます。<br/>
以上のように『ネストを浅く』、『非同期処理を直列的に書く』ことができます。</p>

<p><code>BrightFuture</code>や<code>PromiseKit</code>を試しに使ってきたことで思ったのが、同様の書式で書けることが多いということです。<br/>
一見、GitHub上のReadmeを読んでもわからないと思うライブラリがあった際には、用途が似ているライブラリのReadmeを見てみるのも1つの手段かもしれません。</p>

<p>といったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SwiftでFacebookログインを始めよう！]]></title>
    <link href="http://grandbig.github.io/blog/2016/05/14/facebook-login-for-swift/"/>
    <updated>2016-05-14T15:30:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2016/05/14/facebook-login-for-swift</id>
    <content type="html"><![CDATA[<h4>Facebookログインの実装方法</h4>

<p>公式ページの<a href="https://developers.facebook.com/">facebook for developers</a>を見るのが、一番良いと思いますが、<br/>
あちこちページを飛ばされるので、順を追って説明することにします。<br/>
※ 本記事で利用しているFacebook SDKは <strong>v4.11.0</strong> です。</p>

<p><strong>1．Facebookログインを選択する</strong></p>

<p><img src="/images/facebook_login_1.png" alt="Facebookログインを選択" /></p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<p><strong>2．Get Startedを選択する</strong></p>

<p><img src="/images/facebook_login_2.png" alt="Get Startedを選択" /></p>

<p><strong>3．iOSを選択する</strong></p>

<p><img src="/images/facebook_login_3.png" alt="iOSを選択" /></p>

<p><strong>4．利用手順の概要を読む</strong></p>

<p><img src="/images/facebook_login_4.png" alt="利用手順の概要を読む" /></p>

<p><strong>5．Facebookアプリを作成する</strong></p>

<p><img src="/images/facebook_login_5.png" alt="Facebookアプリを作成" /></p>

<p>※ CocoaPodsでFacebook SDKを取り込むので、ダウンロードはしません。</p>

<p>「新しいアプリを作成」を選択すると、アプリ作成画面が表示されるため、任意の値を入力してください。</p>

<p><img src="/images/facebook_login_6.png" alt="任意の値を入力" /></p>

<p><strong>6．作成したFacebookアプリにiOSアプリ用の設定を追加する</strong></p>

<p><img src="/images/facebook_login_7.png" alt="一連のiOSアプリ用設定手順" /></p>

<p><img src="/images/facebook_login_8.png" alt="追加ボタンを選択" /></p>

<p><img src="/images/facebook_login_9.png" alt="iOSを選択" /></p>

<p>追加された設定項目に値を入力して、「変更を保存」ボタンを選択します。</p>

<ul>
<li>バンドルIDを入力</li>
<li>シングルサインオンボタンをONに変更</li>
</ul>


<p><img src="/images/facebook_login_10.png" alt="設定項目に値を入力" /></p>

<p>続いて、詳細設定でネイティブアプリでの利用を許可します。</p>

<p><img src="/images/facebook_login_18.png" alt="詳細設定" /></p>

<p><strong>7．Xcodeプロジェクトを用意する</strong></p>

<p>当然のことながら、Xcodeプロジェクトを作成します。</p>

<p><strong>8．<code>Podfile</code>を作成する</strong></p>

<p>```objective-c
source &lsquo;<a href="https://github.com/CocoaPods/Specs.git">https://github.com/CocoaPods/Specs.git</a>&rsquo;
platform :ios, &lsquo;8.0&rsquo;</p>

<h1>Facebook</h1>

<p>pod &lsquo;FBSDKCoreKit&rsquo;
pod &lsquo;FBSDKLoginKit&rsquo;
pod &lsquo;FBSDKShareKit&rsquo;
```</p>

<p><strong>9．<code>pod install</code>を実行する</strong></p>

<p><strong>10．Xcodeプロジェクトに必要な設定を追加</strong></p>

<p>必要な設定値を見るために、<br/>
下図のようにFacebookアプリページのiOS設定項目上の <strong>クイックスタート</strong> を選択します。</p>

<p><img src="/images/facebook_login_11.png" alt="クイックスタートを選択" /></p>

<p>すると、下図のページに遷移します。</p>

<p><img src="/images/facebook_login_12.png" alt="クイックスタートページ" /></p>

<p>この中で重要なのが <strong>Configure your info.plist</strong> です。<br/>
ここに書かれた設定値をXcodeに追加します。</p>

<p><img src="/images/facebook_login_13.png" alt="Configure your info.plist" /></p>

<p><img src="/images/facebook_login_14.png" alt="Xcodeに設定値を追加" /></p>

<p><strong>11．XcodeプロジェクトにiOS9 SDK対応の設定を追加</strong></p>

<p>iOS9 SDKよりHTTP通信が非推奨となったため、ATS設定を追加する必要があります。</p>

<p><img src="/images/facebook_login_15.png" alt="XcodeにATS設定を追加" /></p>

<p><strong>12．Facebookアプリをホワイトリストに追加する</strong></p>

<p><img src="/images/facebook_login_16.png" alt="ホワイトリストへの追加" /></p>

<p><strong>13．Bridge-Headerファイルを追加</strong></p>

<p>Swift実装なので、Bridge-Headerファイルを追加します。</p>

<p>```objective-c
// FacebookLoginSample-Bridging-Header.h</p>

<h1>ifndef FacebookLoginSample_Bridging_Header_h</h1>

<h1>define FacebookLoginSample_Bridging_Header_h</h1>

<h1>import &lt;FBSDKCoreKit/FBSDKCoreKit.h></h1>

<h1>import &lt;FBSDKLoginKit/FBSDKLoginKit.h></h1>

<h1>endif /<em> FacebookLoginSample_Bridging_Header_h </em>/</h1>

<p>```</p>

<p><strong>14．<code>AppDelegate.swift</code>に<code>FBSDKApplicationDelegate</code>への接続処理を追加</strong></p>

<p>```objective-c
// AppDelegate.swift</p>

<p>func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) &ndash;> Bool {</p>

<pre><code>FBSDKApplicationDelegate.sharedInstance().application(application, didFinishLaunchingWithOptions: launchOptions)
return true;
</code></pre>

<p>}</p>

<p>func application(application: UIApplication, openURL url: NSURL, sourceApplication: String?, annotation: AnyObject) &ndash;> Bool {</p>

<pre><code>return FBSDKApplicationDelegate.sharedInstance().application(application,
                                                             openURL: url,
                                                             sourceApplication: sourceApplication,
                                                             annotation: annotation)
</code></pre>

<p>}
```</p>

<p><strong>15．Facebook SDKが機能しているか確認</strong></p>

<p>Facebook SDKを搭載したつもりでも、一切機能していないと困りますよね？<br/>
ということでログ収集機能を使ってTestできたりします。<br/>
様々なログ収集が可能なようですが、公式ページにあるように最も簡単なアプリ起動ログ収集を実装します。</p>

<p>```objective-c
// AppDelegate.swift
func applicationDidBecomeActive(application: UIApplication) {</p>

<pre><code>FBSDKAppEvents.activateApp()
</code></pre>

<p>}
```</p>

<p><a href="https://www.facebook.com/analytics?__aref_src=devsite&amp;__aref_id=docs_ios_getting_started">アプリ用Analyticsダッシュボード</a>に遷移します。<br/>
ログを確認したいアプリ > アクティビティー > イベントを選択します。<br/>
すると「App Launches」の件数を確認することができます。</p>

<p><strong>16．ログインボタンを追加</strong></p>

<p>公式ではソースコードから追加しているので、その想定で書いていますが、もちろんStoryboardも利用できます。</p>

<p>```objective-c
// ViewController.swift
import UIKit</p>

<p>class ViewController: UIViewController, FBSDKLoginButtonDelegate {</p>

<pre><code>override func viewDidLoad() {
    super.viewDidLoad()

    let loginBtn : FBSDKLoginButton = FBSDKLoginButton()
    self.view.addSubview(loginBtn)
    loginBtn.center = self.view.center
    loginBtn.readPermissions = ["public_profile", "email", "user_friends"]
    loginBtn.delegate = self
}
</code></pre>

<p>}</p>

<p>func loginButton(loginButton: FBSDKLoginButton!, didCompleteWithResult result: FBSDKLoginManagerLoginResult!, error: NSError!) {</p>

<pre><code>print("ログイン処理を実行")

if (error != nil) {
    // エラーが発生した場合
    print("Process Error !")
} else if result.isCancelled {
    // ログインをキャンセルした場合
    print("User Cancelled")
} else {
    // その他
    print("Login Succeeded")
}
</code></pre>

<p>}</p>

<p>func loginButtonDidLogOut(loginButton: FBSDKLoginButton!) {</p>

<pre><code>print("ログアウト処理を実行")
</code></pre>

<p>}
```</p>

<p>結果、下図のような遷移が可能となります。</p>

<p><img src="/images/facebook_login_17.png" alt="Facebookログイン" /></p>

<h4>Facebookログインボタンのカスタム化</h4>

<p>因みに、Facebookログインボタンをカスタム化する方法を説明します。<br/>
折角なので、Storyboardでの方法として載せておきましょう。</p>

<p><strong>1．Storyboardにボタンを配置する</strong></p>

<p><img src="/images/facebook_login_19.png" alt="Storyboardにボタンを配置" /></p>

<p><strong>2．StoryboardからViewControllerにボタンアクションを接続する</strong></p>

<p><img src="/images/facebook_login_20.png" alt="ボタンアクションの接続" /><br/>
※ 上記キャプチャでは既に下記3の処理を書いてあるけど悪しからず&hellip;</p>

<p><strong>3．ログインアクションを追加</strong></p>

<p>```objective-c
// ViewController.swift
@IBAction func loginByFacebookID(sender: AnyObject) {</p>

<pre><code>let loginManager: FBSDKLoginManager = FBSDKLoginManager()
loginManager.logInWithReadPermissions(["public_profile", "email", "user_friends"], fromViewController: self) { (result, error) in
    if (error != nil) {
        // エラーが発生した場合
        print("Process error")
    } else if result.isCancelled {
        // ログインをキャンセルした場合
        print("Cancelled")
    } else {
        // その他
        print("Login Succeeded")
    }
}
</code></pre>

<p>}
```</p>

<p>さて、いかがでしたでしょうか？<br/>
Facebook SDKも徐々にバージョンアップしていますので、なかなか最新のライブラリに対応した記事がないこともあるでしょう。<br/>
そんなときに本記事を少しでも参考にしてもらえればと思います。<br/>
ということで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>



]]></content>
  </entry>
  
</feed>
