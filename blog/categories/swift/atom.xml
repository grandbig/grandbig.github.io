<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: swift | Takahiro Octopress Blog]]></title>
  <link href="http://grandbig.github.io/blog/categories/swift/atom.xml" rel="self"/>
  <link href="http://grandbig.github.io/"/>
  <updated>2017-10-09T23:43:03+09:00</updated>
  <id>http://grandbig.github.io/</id>
  <author>
    <name><![CDATA[Takahiro]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Clean Swiftを勉強してみよう！(3)]]></title>
    <link href="http://grandbig.github.io/blog/2017/10/09/clean-swift-3/"/>
    <updated>2017-10-09T22:23:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2017/10/09/clean-swift-3</id>
    <content type="html"><![CDATA[<h3>はじめに</h3>

<p><a href="https://grandbig.github.io/blog/2017/10/08/clean-swift-2/">前回</a>に引き続き、<a href="https://clean-swift.com/">Clean Swift</a>の実例サンプルについて書いていきたいと思います。<br/>
今回は、下記要件をアプリに追加して見ていきます。</p>

<p><img src="/images/clean-swift-3_1.png" alt="アプリ追加要件" /></p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h3>アプリの追加要件</h3>

<p>追加要件は以下です。</p>

<ul>
<li>マップのマーカをタップした後に表示されるInfoWindowをタップすると、レストラン情報ページに遷移する</li>
</ul>


<h3>フォルダ構成</h3>

<p>1つ画面を追加することになったため、今回のフォルダ構成としては下記になります。</p>

<p><code>javascript
CleanFoodLogger
├── Views
│    └── ViewController+Alert.swift
├── Models
│    ├── Restaurant.swift
│    └── CustomGMSMarker.swift
├── Workers
│    └── HotpepperWorker.swift
├── Services
│    └── HotpepperAPI.swift
├── Scenes
│    ├── MapView
│    │    ├── View
│    │    │    ├── CustomInfoWindow.xib
│    │    │    └── CustomInfoWindow.swift
│    │    ├── MapViewController.swift
│    │    ├── MapInteractor.swift
│    │    ├── MapModels.swift
│    │    ├── MapPresenter.swift
│    │    ├── MapRouter.swift
│    │    └── MapWorker.swift
│    ├── RestaurantInformation
│    │    ├── RestaurantInformationViewController.swift
│    │    ├── RestaurantInformationInteractor.swift
│    │    ├── RestaurantInformationModels.swift
│    │    ├── RestaurantInformationPresenter.swift
│    │    ├── RestaurantInformationRouter.swift
│    │    └── RestaurantInformationWorker.swift
├── AppDelegate.swift
├── Main.storyboard
├── Assets.xcassets
└── key.plist
</code></p>

<h3>アプリの実装</h3>

<p>レストラン情報ページに遷移する機能に関しては下図のようなデータフローになります。</p>

<p><img src="/images/clean-swift_4.png" alt="データフロー" /></p>

<h4>RestaurantInformation</h4>

<p>今回追加したファイルはこのフォルダ配下のみになるので、ここのみ説明します。</p>

<h5>RestaurantInformationModels.swift</h5>

<p><code>Model</code> は非常にシンプルです。</p>

<p>```objective-c
import UIKit</p>

<p>enum RestaurantInformation {</p>

<pre><code>enum Load {
    struct Request {
    }
    struct Response {
        var url: String
    }
    struct ViewModel {
        var url: String
    }
}
</code></pre>

<p>}
```</p>

<ul>
<li><code>Load</code>

<ul>
<li>レストラン情報を読み込む際に利用します</li>
</ul>
</li>
</ul>


<h5>RestaurantInformationInteractor.swift</h5>

<p><code>ViewController</code> から受けた依頼を必要があれば <code>Worker</code> を経由して実行し、 <code>Presenter</code> にデータを渡します。</p>

<p>```objective-c
import UIKit</p>

<p>protocol RestaurantInformationBusinessLogic {</p>

<pre><code>func loadRestaurantInformation(request: RestaurantInformation.Load.Request)
</code></pre>

<p>}</p>

<p>protocol RestaurantInformationDataStore {</p>

<pre><code>var urlString: String { get set }
</code></pre>

<p>}</p>

<p>class RestaurantInformationInteractor: RestaurantInformationBusinessLogic, RestaurantInformationDataStore {</p>

<pre><code>var presenter: RestaurantInformationPresentationLogic?
var worker: RestaurantInformationWorker?
var urlString: String = ""

// MARK: Load restaurant information

func loadRestaurantInformation(request: RestaurantInformation.Load.Request) {
    let response = RestaurantInformation.Load.Response(url: urlString)
    presenter?.presentRestaurantInformation(response: response)
}
</code></pre>

<p>}
```</p>

<ul>
<li><code>loadRestaurantInformation</code>

<ul>
<li>レストラン情報ページのURLが格納された <code>urlString</code> を <code>Presenter</code> に渡します</li>
</ul>
</li>
</ul>


<h5>RestaurantInformationPresenter.swift</h5>

<p><code>Interactor</code> から受け取ったデータを表示形式に変換して、<code>ViewController</code> に描画指示を出します。<br/>
今回は <code>Interactor</code> で保持した <code>urlString</code> を取得したかっただけなので、処理の出し分け等はなく、シンプルになっています。</p>

<p>```objective-c
import UIKit</p>

<p>protocol RestaurantInformationPresentationLogic {</p>

<pre><code>func presentRestaurantInformation(response: RestaurantInformation.Load.Response)
</code></pre>

<p>}</p>

<p>class RestaurantInformationPresenter: RestaurantInformationPresentationLogic {</p>

<pre><code>weak var viewController: RestaurantInformationDisplayLogic?

// MARK: Present restaurant information

func presentRestaurantInformation(response: RestaurantInformation.Load.Response) {
    let viewModel = RestaurantInformation.Load.ViewModel(url: response.url)
    viewController?.displayRestaurantInformation(viewModel: viewModel)
}
</code></pre>

<p>}
```</p>

<h5>RestaurantInformationViewController.swift</h5>

<p>そして <code>ViewController</code> について説明します。<br/>
下記で</p>

<ul>
<li><code>Interactor</code> に具体的な処理内容(表示ロジック)を問い合わせる</li>
<li><code>Presenter</code> からの指示を受けて、最適な <code>View</code> を描画する</li>
</ul>


<p>を実現しています。</p>

<p>```objective-c
import UIKit
import WebKit</p>

<p>protocol RestaurantInformationDisplayLogic: class {</p>

<pre><code>func displayRestaurantInformation(viewModel: RestaurantInformation.Load.ViewModel)
</code></pre>

<p>}</p>

<p>class RestaurantInformationViewController: UIViewController, RestaurantInformationDisplayLogic {</p>

<pre><code>var interactor: RestaurantInformationBusinessLogic?
var router: (NSObjectProtocol &amp; RestaurantInformationRoutingLogic &amp; RestaurantInformationDataPassing)?
private var webView: WKWebView!

// MARK: Object lifecycle

override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
    super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
    setup()
}

required init?(coder aDecoder: NSCoder) {
    super.init(coder: aDecoder)
    setup()
}

// MARK: Setup

private func setup() {
    let viewController = self
    let interactor = RestaurantInformationInteractor()
    let presenter = RestaurantInformationPresenter()
    let router = RestaurantInformationRouter()
    viewController.interactor = interactor
    viewController.router = router
    interactor.presenter = presenter
    presenter.viewController = viewController
    router.viewController = viewController
    router.dataStore = interactor
}

// MARK: Routing

override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
    if let scene = segue.identifier {
        let selector = NSSelectorFromString("routeTo\(scene)WithSegue:")
        if let router = router, router.responds(to: selector) {
            router.perform(selector, with: segue)
        }
    }
}

// MARK: View lifecycle

override func viewDidLoad() {
    super.viewDidLoad()

    self.title = "RestaurantInformation"
    configuraWebView()
    loadRestaurantInformation()
}

// MARK: Configuration

private func configuraWebView() {
    let webConfiguration = WKWebViewConfiguration()
    let frame = CGRect(x: 0, y: 0, width: self.view.frame.width, height: self.view.frame.height)
    webView = WKWebView(frame: frame, configuration: webConfiguration)
    webView.uiDelegate = self
    webView.navigationDelegate = self
    self.view.addSubview(webView)
}

// MARK: Load restaurant information

func loadRestaurantInformation() {
    let request = RestaurantInformation.Load.Request()
    interactor?.loadRestaurantInformation(request: request)
}

func displayRestaurantInformation(viewModel: RestaurantInformation.Load.ViewModel) {
    if let url = URL(string: viewModel.url) {
        let urlRequest = URLRequest(url: url)
        webView.load(urlRequest)
    }
}
</code></pre>

<p>}</p>

<p>extension RestaurantInformationViewController: WKUIDelegate {
}</p>

<p>extension RestaurantInformationViewController: WKNavigationDelegate {  <br/>
}
```</p>

<ul>
<li><code>loadRestaurantInformation()</code>

<ul>
<li>レストラン情報の読み込みを <code>Interactor</code> に依頼しています</li>
</ul>
</li>
<li><code>displayRestaurantInformation(viewModel: RestaurantInformation.Load.ViewModel)</code>

<ul>
<li><code>Presenter</code> から受けた指示に従って描画を実行しています</li>
<li>ここでは指定URLを用いてWebページを表示しています</li>
</ul>
</li>
</ul>


<p>今回は <code>RestaurantInformationRouter.swift</code> および <code>RestaurantInformationWorker.swift</code> については特に具体的な処理がないため説明は省略します。</p>

<h4>MapView</h4>

<p>マップ上に表示されるInfoWindowをタップしないと、レストラン情報ページに遷移できない要件であるため、 <code>MapView</code> 配下も少々変更が必要です。<br/>
この変更をもって、<code>RestaurantInformationInteractor</code> 内で値の入った <code>urlString</code> を扱うことになります。</p>

<p>関係各所の変更内容も簡単に書いておきます。</p>

<h5>Models</h5>

<p>まずは <code>Models/Restaurant.swift</code> です。</p>

<p>```objective-c
import Foundation</p>

<p>struct Restaurant: Equatable {</p>

<pre><code>var id: String
var name: String
var category: String
var imageURL: String
var latitude: Double
var longitude: Double
var restaurantURL: String // 追記
</code></pre>

<p>}</p>

<p>&lt;省略>
```</p>

<p>続いて <code>Models/CustomGMSMarker.swift</code> です。</p>

<p>```objective-c
import Foundation
import GoogleMaps</p>

<p>class CustomGMSMarker: GMSMarker {</p>

<pre><code>public var id: String!
public var name: String!
public var category: String!
public var imageURL: String!
public var restaurantURL: String! // 追記

/// 初期化
override init() {
    super.init()
}
</code></pre>

<p>}
```</p>

<h5>HotpepperAPI.swift</h5>

<p>構造体である <code>Restaurant</code> に変更が入ったので、 <code>Services/HotpepperAPI.swift</code> にも修正が必要になります。<br/>
(返却値である <code>Restaurant</code> を生成する部分で <code>restaurantURL</code> を追加する必要があるためです。)</p>

<p>```objective-c
import Foundation
import Alamofire
import SwiftyJSON</p>

<p>class HotpepperAPI: HotpepperProtocol {
  func fetchRestaurants(latitude: Double, longitude: Double, completionHandler: @escaping ([Restaurant], HotpepperError?) &ndash;> Void) {</p>

<pre><code>  let parameters = ["key": self.apiKey, "format": "json", "lat": latitude, "lng": longitude, "range": 3] as [String : Any]
  Alamofire.SessionManager.default.requestWithoutCache(baseURL, method: .get, parameters: parameters, encoding: URLEncoding.default, headers: nil).responseJSON { response in
      var restaurants: [Restaurant] = [Restaurant]()

      &lt;省略&gt;

      for shop in shops {
            let id = shop["id"].string ?? "ID不明"
            let name = shop["name"].string ?? "ショップ名不明"
            let category = shop["genre"]["name"].string ?? "カテゴリ不明"
            let imageURL = shop["photo"]["mobile"]["l"].string ?? ""
            let latitude = atof(shop["lat"].string ?? "0")
            let longitude = atof(shop["lng"].string ?? "0")

            // ここから修正
            let restaurantURL = shop["urls"]["pc"].string ?? ""
            let restaurant = Restaurant(id: id, name: name, category: category, imageURL: imageURL, latitude: latitude, longitude: longitude, restaurantURL: restaurantURL)
            // ここまで修正

            restaurants.append(restaurant)
        }

        completionHandler(restaurants, nil)
  }
</code></pre>

<p>}
```</p>

<h5>MapModels.swift</h5>

<p>レストラン情報ページを見るために、 <code>url</code> を受け渡す必要があります。<br/>
その処理を実行するために <code>Fetch</code> を追加しています。</p>

<p>```objective-c
import UIKit</p>

<p>enum Map {</p>

<pre><code>&lt;省略&gt;

// MARK: Fetch restaurant information

enum Fetch {
    struct Request {
        var urlString: String
    }
    struct Response {
    }
    struct ViewModel {
    }
}
</code></pre>

<p>}
```</p>

<h5>MapInteractor.swift</h5>

<p><code>MapInteractor.swift</code> では重要な変更を入れています。</p>

<p>```objective-c
import UIKit</p>

<p>protocol MapBusinessLogic {</p>

<pre><code>func initMapView(request: Map.Init.Request)
func searchRestaurants(request: Map.Search.Request)
func fetchRestaurantInformation(request: Map.Fetch.Request) // 追記
</code></pre>

<p>}</p>

<p>protocol MapDataStore {</p>

<pre><code>var urlString: String { get set } // 追記
</code></pre>

<p>}</p>

<p>class MapInteractor: MapBusinessLogic, MapDataStore {</p>

<pre><code>var presenter: MapPresentationLogic?
var worker = HotpepperWorker(hotpepper: HotpepperAPI())
var urlString: String = ""  // 追記
private var initView: Bool = false

&lt;省略&gt;

// 以下、追記
// MARK: Tap infoWindow

func fetchRestaurantInformation(request: Map.Fetch.Request) {
    urlString = request.urlString
    let response = Map.Fetch.Response()
    presenter?.presentFetchedRestaurantInformation(response: response)
}
</code></pre>

<p>}
```</p>

<ul>
<li><code>fetchRestaurantInformation(request: Map.Fetch.Request)</code>

<ul>
<li>マーカのInfoWindowをタップした際に、どのレストラン情報ページを表示すべきか把握する必要があります</li>
<li>そのため、 <code>Map.Fetch.Request</code> に格納された <code>urlString</code> を <code>MapDataStore</code> で定義された <code>urlString</code> に入力しています</li>
</ul>
</li>
<li><code>MapDataStore.urlString</code>

<ul>
<li>画面遷移時に値の受け渡しが必要な場合は <code>DataStore</code> プロトコルにフィールドを定義します</li>
<li>画面内で共通して使いまわしたい場合にも定義しておくと良いでしょう</li>
</ul>
</li>
</ul>


<h5>MapPresenter.swift</h5>

<p>一連の処理の流れ( <code>ViewController</code> → <code>Interactor</code> → <code>Presenter</code> )を書くために、具体的な実行処理はないものの、 <code>Presenter</code> を追加しています。</p>

<p>```objective-c
import UIKit</p>

<p>protocol MapPresentationLogic {</p>

<pre><code>func presentInitMapView(response: Map.Init.Response)
func presentSearchedRestaurants(response: Map.Search.Response)
func presentFetchedRestaurantInformation(response: Map.Fetch.Response)
</code></pre>

<p>}</p>

<p>class MapPresenter: MapPresentationLogic {</p>

<pre><code>weak var viewController: MapDisplayLogic?
private let zoomLevel: Float = 16.0

&lt;省略&gt;

// MARK: Present fetched restaurant information

func presentFetchedRestaurantInformation(response: Map.Fetch.Response) {
    let viewModel = Map.Fetch.ViewModel()
    viewController?.transitRestaurantInformation(viewModel: viewModel)
}
</code></pre>

<p>}
```</p>

<ul>
<li><code>presentFetchedRestaurantInformation</code>

<ul>
<li><code>ViewController</code> に画面遷移処理を依頼します</li>
</ul>
</li>
</ul>


<h5>MapViewController.swift</h5>

<p>ユーザからのアクションの受取口や、 <code>Interactor</code> への依頼処理、 <code>Presenter</code> からの指示を実行する処理などを変更しています。</p>

<p>```objective-c
import UIKit
import GoogleMaps</p>

<p>protocol MapDisplayLogic: class {</p>

<pre><code>func displayInitMap(viewModel: Map.Init.ViewModel)
func displaySearchedSuccess(viewModel: Map.Search.ViewModel)
func displaySearchedFailure(viewModel: Map.Search.ViewModel)
// 以下、追記
func transitRestaurantInformation(viewModel: Map.Fetch.ViewModel)
</code></pre>

<p>}</p>

<p>class MapViewController: UIViewController, MapDisplayLogic {</p>

<pre><code>var interactor: MapBusinessLogic?
var router: (NSObjectProtocol &amp; MapRoutingLogic &amp; MapDataPassing)?

@IBOutlet weak var mapView: GMSMapView!
var locationManager: CLLocationManager?

&lt;省略&gt;

// 以下追記
// MARK: Browse restaurant information

func fetchRestaurantInformation(urlString: String) {
    let request = Map.Fetch.Request(urlString: urlString)
    interactor?.fetchRestaurantInformation(request: request)
}

func transitRestaurantInformation(viewModel: Map.Fetch.ViewModel) {
    router?.routeToRestaurantInformation(segue: nil)
}

&lt;省略&gt;
</code></pre>

<p>}</p>

<p>&lt;省略></p>

<p>extension MapViewController: GMSMapViewDelegate {</p>

<pre><code>&lt;省略&gt;

// 以下追記
func mapView(_ mapView: GMSMapView, didTapInfoWindowOf marker: GMSMarker) {
    guard let cMarker = marker as? CustomGMSMarker else {
        return
    }
    fetchRestaurantInformation(urlString: cMarker.restaurantURL)
}
</code></pre>

<p>}
```</p>

<ul>
<li><code>func mapView(_ mapView: GMSMapView, didTapInfoWindowOf marker: GMSMarker)</code>

<ul>
<li>InfoWindowのタップ処理を <code>delegate</code> でキャッチすることができるため、追記しています</li>
<li>ここで、レストラン情報URLを <code>Interactor</code> に受け渡すメソッドを実行します</li>
</ul>
</li>
<li><code>fetchRestaurantInformation(urlString: String)</code>

<ul>
<li>レストラン情報URLを <code>Interactor</code> に渡すメソッドです</li>
</ul>
</li>
<li><code>transitRestaurantInformation</code>

<ul>
<li><code>Presenter</code> から指示を受けた後に、 <code>Router</code> に画面遷移を依頼しています</li>
</ul>
</li>
</ul>


<h5>MapRouter.swift</h5>

<p>今回、新たに画面遷移の処理を実装するため、 <code>MapRouter.swift</code> の処理を大幅に追加しています。</p>

<p>```objective-c
import UIKit</p>

<p>@objc protocol MapRoutingLogic {</p>

<pre><code>func routeToRestaurantInformation(segue: UIStoryboardSegue?)
</code></pre>

<p>}</p>

<p>protocol MapDataPassing {</p>

<pre><code>var dataStore: MapDataStore? { get }
</code></pre>

<p>}</p>

<p>class MapRouter: NSObject, MapRoutingLogic, MapDataPassing {</p>

<pre><code>weak var viewController: MapViewController?
var dataStore: MapDataStore?

// MARK: Routing

func routeToRestaurantInformation(segue: UIStoryboardSegue?) {
  if let segue = segue {
    let destinationVC = segue.destination as! RestaurantInformationViewController
    var destinationDS = destinationVC.router!.dataStore!
    passDataToRestaurantInformation(source: dataStore!, destination: &amp;destinationDS)
  } else {
    let storyboard = UIStoryboard(name: "Main", bundle: nil)
    let destinationVC = storyboard.instantiateViewController(withIdentifier: "RestaurantInformationViewController") as! RestaurantInformationViewController
    var destinationDS = destinationVC.router!.dataStore!
    passDataToRestaurantInformation(source: dataStore!, destination: &amp;destinationDS)
    navigateToRestaurantInformation(source: viewController!, destination: destinationVC)
  }
}

// MARK: Navigation

func navigateToRestaurantInformation(source: MapViewController, destination: RestaurantInformationViewController) {
  source.show(destination, sender: nil)
}

// MARK: Passing data

func passDataToRestaurantInformation(source: MapDataStore, destination: inout RestaurantInformationDataStore) {
    destination.urlString = source.urlString
}
</code></pre>

<p>}
```</p>

<ul>
<li><code>MapRoutingLogic</code>

<ul>
<li>画面遷移するためのメソッドを定義します</li>
</ul>
</li>
<li><code>MapDataPassing</code>

<ul>
<li><code>MapDataStore</code> をフィールドとして定義しています</li>
<li><code>MapInteractor</code> 内で定義したプロトコルが <code>MapDataStore</code> であり、先程定義した <code>urlString</code> を含みます</li>
</ul>
</li>
<li><code>routeToRestaurantInformation</code>

<ul>
<li>内部処理は基本的に毎回同じのお決まりと考えて良いでしょう</li>
</ul>
</li>
<li><code>navigateToRestaurantInformation</code>

<ul>
<li>実際の画面遷移処理として <code>show</code> メソッドを実行しています</li>
</ul>
</li>
<li><code>passDataToRestaurantInformation</code>

<ul>
<li>画面遷移元の <code>DataStore</code> から、画面遷移先の <code>DataStore</code> に値を受け渡しています</li>
</ul>
</li>
</ul>


<h3>まとめ</h3>

<p>以上が今回の要件追加に合わせて実装し直した内容になります。<br/>
本記事で扱ったソースコードは<a href="https://github.com/grandbig/CleanFoodLogger">CleanFoodLogger</a>にて公開しています。</p>

<p>今後は <code>RealmSwift</code> を用いた <code>CRUD</code> 処理だったり、 アプリでよく利用するUI面の話をできればと思います。<br/>
といったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Clean Swiftを勉強してみよう！(2)]]></title>
    <link href="http://grandbig.github.io/blog/2017/10/08/clean-swift-2/"/>
    <updated>2017-10-08T22:35:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2017/10/08/clean-swift-2</id>
    <content type="html"><![CDATA[<h3>はじめに</h3>

<p>今回は<a href="https://clean-swift.com/">Clean Swift</a>を用いた具体的な例について見ていきたいと思います。<br/>
題材として、下記のような要件を持つアプリを扱います。</p>

<p><img src="/images/clean-swift-2_1.png" alt="Clean Swiftの題材アプリ" /></p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h3>アプリの要件</h3>

<p>要件としては、下記の通りです。</p>

<ul>
<li>現在地を中心にマップを表示する</li>
<li>検索ボタンをタップして、現在地周辺のレストラン情報を取得する</li>
<li>マップに表示されたレストランのマーカをタップすると、レストラン情報の概要ウィンドウが表示される</li>
</ul>


<h3>フォルダ構成</h3>

<p>フォルダ構成は以下のようになっています。<br/>
※ 今回のアプリの名称を <code>CleanFoodLogger</code> とします。</p>

<p><code>javascript
CleanFoodLogger
├── Views
│    └── ViewController+Alert.swift
├── Models
│    ├── Restaurant.swift
│    └── CustomGMSMarker.swift
├── Workers
│    └── HotpepperWorker.swift
├── Services
│    └── HotpepperAPI.swift
├── Scenes
│    └── MapView
│         ├── View
│         │    ├── CustomInfoWindow.xib
│         │    └── CustomInfoWindow.swift
│         ├── MapViewController.swift
│         ├── MapInteractor.swift
│         ├── MapModels.swift
│         ├── MapPresenter.swift
│         ├── MapRouter.swift
│         └── MapWorker.swift
├── AppDelegate.swift
├── Main.storyboard
├── Assets.xcassets
└── key.plist
</code></p>

<p>それぞれの構成の意味について説明します。</p>

<h4>Views</h4>

<p><code>Scene</code> に寄らない共通ビュー系を格納します。</p>

<ul>
<li><code>ViewController+Alert.swift</code>

<ul>
<li><code>UIViewController</code> を拡張する形で実装</li>
<li>共通アラート表示処理を実装</li>
</ul>
</li>
</ul>


<h4>Models</h4>

<p><code>Scene</code> に寄らないモデル系を格納します。</p>

<ul>
<li><code>Restaurant.swift</code>

<ul>
<li>APIを通して取得したレストラン情報を格納するモデル</li>
</ul>
</li>
<li><code>CustomGMSMarker</code>

<ul>
<li><code>GMSMarker</code>を継承したカスタムクラス</li>
<li>マーカにショップ情報を追加して持たせたモデル</li>
</ul>
</li>
</ul>


<h4>Workers</h4>

<p><code>Scene</code> に寄らない <code>Clean Swift</code> で言うところの <code>Worker</code> 系を格納します。<br/>
※ 今回は、レストラン情報を取得するのに<a href="https://webservice.recruit.co.jp/hotpepper/reference.html">ホットペッパーAPI</a>を利用しています。</p>

<ul>
<li><code>HotpepperWorker.swift</code>

<ul>
<li>ホットペッパーAPI管理マネージャに当たる <code>Services/HotpepperAPI.swift</code> を通じて取得したレストラン情報を扱う</li>
</ul>
</li>
</ul>


<h4>Services</h4>

<p><code>Scene</code> に寄らない管理マネージャ系の共通処理を扱います。</p>

<ul>
<li><code>HotpepperAPI.swift</code>

<ul>
<li>ホットペッパーAPIを用いた具体的なロジックを実装</li>
</ul>
</li>
</ul>


<h4>Scenes</h4>

<p>ここは画面単位に <code>Clean Swift</code>のテンプレートを当て込んだ構成になります。<br/>
今回は簡単なサンプルなので1画面しかありません。<br/>
よって、 <code>Scenes</code> に格納しているのも <code>MapView</code> 1つになります。<br/>
<code>MapView</code> の配下は <code>Clean Swift</code> テンプレート一式になっています。</p>

<h3>アプリの実装</h3>

<p>続いて具体的なアプリの実装について見ていきます。<br/>
データフローとしては、下記の通りです。</p>

<p><img src="/images/clean-swift_3.png" alt="データフロー図" /></p>

<p>ではまずは、共通系の処理から説明します。</p>

<h4>Models</h4>

<p>この後の <code>Services</code> や <code>Workers</code> にも出てくるので、まずは <code>Models</code> から説明します。</p>

<h5>Restaurant.swift</h5>

<p>ホットペッパーAPIで取得したレストラン情報の一部を抜粋して格納するため、下記のような構成になっています。<br/>
今回は <code>==</code> で比較する処理を利用している箇所はありませんが、 <a href="https://github.com/Clean-Swift/CleanStore">Clean Store</a> を参考にしたので、そのまま残しています。</p>

<p>```objective-c
import Foundation</p>

<p>struct Restaurant: Equatable {</p>

<pre><code>var id: String
var name: String
var category: String
var imageURL: String
var latitude: Double
var longitude: Double
</code></pre>

<p>}</p>

<p>func ==(lhs: Restaurant, rhs: Restaurant) &ndash;> Bool {</p>

<pre><code>return lhs.id == rhs.id
    &amp;&amp; lhs.name == rhs.name
    &amp;&amp; lhs.category == rhs.category
    &amp;&amp; lhs.imageURL == rhs.imageURL
    &amp;&amp; lhs.latitude == rhs.latitude
    &amp;&amp; lhs.longitude == rhs.longitude
</code></pre>

<p>}
```</p>

<h5>CustomGMSMarker.swift</h5>

<p>マーカをタップした際に、ショップ情報を表示する <code>InfoWindow</code> を表示する要件があるため、 <code>GMSMarker</code> クラスを継承して、ショップ情報を追加しています。</p>

<p>```objective-c
import Foundation
import GoogleMaps</p>

<p>class CustomGMSMarker: GMSMarker {</p>

<pre><code>public var id: String!
public var name: String!
public var category: String!
public var imageURL: String!

/// 初期化
override init() {
    super.init()
}
</code></pre>

<p>}
```</p>

<h4>Workers</h4>

<p><code>Services</code> の説明に移る前に、<code>Protocol</code> を提供している <code>Workers</code> について見ていきます。</p>

<h5>HotpepperWorker.swift</h5>

<p>これは、</p>

<ul>
<li>API処理を扱うための <code>Worker</code> クラスを提供</li>
<li>外部へのインターフェースを定義したプロトコルの定義</li>
</ul>


<p>の役目を果たしています。</p>

<p>```objective-c
import Foundation</p>

<p>// MARK: &ndash; Hotpepper worker</p>

<p>class HotpepperWorker {</p>

<pre><code>var hotpepper: HotpepperProtocol

init(hotpepper: HotpepperProtocol) {
    self.hotpepper = hotpepper
}

func fetchRestaurants(latitude: Double, longitude: Double, completionHandler: @escaping ([Restaurant], HotpepperError?) -&gt; Void) {
    hotpepper.fetchRestaurants(latitude: latitude, longitude: longitude) { (restaurants, error) in
        DispatchQueue.main.async {
            completionHandler(restaurants, error)
        }
    }
}
</code></pre>

<p>}</p>

<p>// MARK: Hotpepper API</p>

<p>protocol HotpepperProtocol {</p>

<pre><code>// MARK: CRUD operations

func fetchRestaurants(latitude: Double, longitude: Double, completionHandler: @escaping ([Restaurant], HotpepperError?) -&gt; Void)
</code></pre>

<p>}</p>

<p>// MARK: &ndash; CRUD operation errors</p>

<p>enum HotpepperError: Equatable, Error {</p>

<pre><code>case CannotFetch(String)
</code></pre>

<p>}</p>

<p>func ==(lhs: HotpepperError, rhs: HotpepperError) &ndash;> Bool {</p>

<pre><code>switch (lhs, rhs) {
case (.CannotFetch(let a), .CannotFetch(let b)) where a == b: return true
default: return false
}
</code></pre>

<p>}
```</p>

<h4>Services</h4>

<p><code>Worker</code> で定義された外部へのインターフェースの挙動を実装したクラスに当たります。</p>

<h5>HotpepperAPI.swift</h5>

<p>今回は <code>HotpepperProtocol</code> を継承した <code>HotpepperAPI</code> 内で実際にホットペッパーAPIを叩いて処理しています。</p>

<p>```objective-c
import Foundation
import Alamofire
import SwiftyJSON</p>

<p>class HotpepperAPI: HotpepperProtocol {</p>

<pre><code>/// API Key
private var apiKey: String = String()
/// Geocoding APIのベースURL
private let baseURL: String = "https://webservice.recruit.co.jp/hotpepper/gourmet/v1/"

/// 初期化処理
// key.plistに定義したAPIKeyを取得してセット
init() {
    if let path = Bundle.main.path(forResource: "key", ofType: "plist") {
        if let dic = NSDictionary(contentsOfFile: path) as? [String: Any] {
            if let apiKey = dic["hotpepperApiKey"] as? String {
                self.apiKey = apiKey
            }
        }
    }
}

// HotpepperWorker.swift内のHotpepperProtocolインターフェースの具体的な処理
func fetchRestaurants(latitude: Double, longitude: Double, completionHandler: @escaping ([Restaurant], HotpepperError?) -&gt; Void) {
    let parameters = ["key": self.apiKey, "format": "json", "lat": latitude, "lng": longitude, "range": 3] as [String : Any]
    Alamofire.SessionManager.default.requestWithoutCache(baseURL, method: .get, parameters: parameters, encoding: URLEncoding.default, headers: nil).responseJSON { response in
        var restaurants: [Restaurant] = [Restaurant]()

        if response.result.isFailure {
            let defaultErrorMessage = "レストラン情報を取得できませんでした。"
            completionHandler([], HotpepperError.CannotFetch(response.result.error?.localizedDescription ?? defaultErrorMessage))
            return
        }

        let json = JSON(response.result.value as Any)
        guard let shops = json["results"]["shop"].array else {
            let defaultErrorMessage = "レストラン情報を取得できませんでした。"
            completionHandler([], HotpepperError.CannotFetch(response.result.error?.localizedDescription ?? defaultErrorMessage))
            return
        }

        for shop in shops {
            let id = shop["id"].string ?? "ID不明"
            let name = shop["name"].string ?? "ショップ名不明"
            let category = shop["genre"]["name"].string ?? "カテゴリ不明"
            let imageURL = shop["photo"]["mobile"]["l"].string ?? ""
            let latitude = atof(shop["lat"].string ?? "0")
            let longitude = atof(shop["lng"].string ?? "0")
            let restaurant = Restaurant(id: id, name: name, category: category, imageURL: imageURL, latitude: latitude, longitude: longitude)
            restaurants.append(restaurant)
        }

        completionHandler(restaurants, nil)
    }
}
</code></pre>

<p>}</p>

<p>// Clean Swiftとは無関係ですが、キャッシュなしリクエストをAlamofireを通して実装する処理
extension Alamofire.SessionManager {</p>

<pre><code>@discardableResult
open func requestWithoutCache(
    _ url: URLConvertible,
    method: HTTPMethod = .get,
    parameters: Parameters? = nil,
    encoding: ParameterEncoding = URLEncoding.default,
    headers: HTTPHeaders? = nil)
    -&gt; DataRequest {
        do {
            var urlRequest = try URLRequest(url: url, method: method, headers: headers)
            urlRequest.cachePolicy = .reloadIgnoringCacheData // &lt;&lt;== Cache disabled
            let encodedURLRequest = try encoding.encode(urlRequest, with: parameters)
            return request(encodedURLRequest)
        } catch {
            print(error)
            return request(URLRequest(url: URL(string: "http://example.com/wrong_request")!))
        }
}
</code></pre>

<p>}
```</p>

<h4>MapView</h4>

<p>ここから重要な <code>Clean Swift</code> を使った実装に入っていきます。<br/>
今回は共通 <code>Worker</code> のみ利用しているため、 <code>MapWorker.swift</code> は省略します。<br/>
また、画面遷移の処理もないため、 <code>MapRouter.swift</code> についても省略します。</p>

<h5>MapModels.swift</h5>

<p>Clean Swiftで今回扱う <code>Model</code> は以下の通りです。</p>

<p>```objective-c
import UIKit</p>

<p>enum Map {</p>

<pre><code>// MARK: Init mapView

enum Init {
    struct Request {
        var latitude: Double
        var longitude: Double
    }
    struct Response {
        var latitude: Double
        var longitude: Double
    }
    struct ViewModel {
        var latitude: Double
        var longitude: Double
        var zoomLevel: Float
    }
}

// MARK: Search restaurants

enum Search {
    struct Request {
        var latitude: Double
        var longitude: Double
    }
    struct Response {
        var restaurants: [Restaurant]
    }
    struct ViewModel {
        var restaurants: [Restaurant]
    }
}
</code></pre>

<p>}
```</p>

<ul>
<li><code>Init</code>

<ul>
<li>マップ画面の初期描画時に「現在地を中心としたマップ位置に移動する」際に利用</li>
</ul>
</li>
<li><code>Search</code>

<ul>
<li>「現在地周辺のレストランを検索する」際に利用</li>
</ul>
</li>
</ul>


<h5>MapInteractor.swift</h5>

<p><code>ViewController</code> から受け取った依頼を <code>Worker</code> を経由して取得した値を <code>Presenter</code> に渡します。</p>

<p>```objective-c
import UIKit</p>

<p>protocol MapBusinessLogic {</p>

<pre><code>func initMapView(request: Map.Init.Request)
func searchRestaurants(request: Map.Search.Request)
</code></pre>

<p>}</p>

<p>protocol MapDataStore {
}</p>

<p>class MapInteractor: MapBusinessLogic, MapDataStore {</p>

<pre><code>var presenter: MapPresentationLogic?
var worker = HotpepperWorker(hotpepper: HotpepperAPI())
private var initView: Bool = false

// MARK: Init mapView

func initMapView(request: Map.Init.Request) {
    if !initView {
        let response = Map.Init.Response(latitude: request.latitude, longitude: request.longitude)
        presenter?.presentInitMapView(response: response)
        initView = true
    }
}

// MARK: Search restaurants

func searchRestaurants(request: Map.Search.Request) {
    worker.fetchRestaurants(latitude: request.latitude, longitude: request.longitude) { (restaurants, error) in
        let response = Map.Search.Response(restaurants: restaurants)
        self.presenter?.presentSearchedRestaurants(response: response)
    }
}
</code></pre>

<p>}
```</p>

<ul>
<li><code>initMapView</code>

<ul>
<li>APIやローカルDBを利用する必要がないため、<code>Worker</code>は利用していません</li>
<li>初回だけ、実行すれば良い処理なので内部で定義した <code>initView</code> でハンドリングしています</li>
</ul>
</li>
<li><code>searchRestaurants</code>

<ul>
<li>ホットペッパーAPIによるデータ取得は <code>HotpepperWorker</code> に任せています</li>
<li><code>HotpepperWorker</code> を介して取得したデータを <code>Map.Search.Response</code> 形式に変換</li>
<li>それを <code>MapPresenter</code> に渡しています</li>
</ul>
</li>
</ul>


<h5>MapPresenter.swift</h5>

<p><code>Interactor</code> から受け取ったデータを表示形式に変換して、<code>ViewController</code> に描画指示を出します。</p>

<p>```objective-c
import UIKit</p>

<p>protocol MapPresentationLogic {</p>

<pre><code>func presentInitMapView(response: Map.Init.Response)
func presentSearchedRestaurants(response: Map.Search.Response)
</code></pre>

<p>}</p>

<p>class MapPresenter: MapPresentationLogic {</p>

<pre><code>weak var viewController: MapDisplayLogic?
private let zoomLevel: Float = 16.0

// MARK: Present init mapView

func presentInitMapView(response: Map.Init.Response) {
    let latitude = response.latitude
    let longitude = response.longitude
    let viewModel = Map.Init.ViewModel(latitude: latitude, longitude: longitude, zoomLevel: zoomLevel)
    viewController?.displayInitMap(viewModel: viewModel)
}

// MARK: Present searched restaurants

func presentSearchedRestaurants(response: Map.Search.Response) {
    let restaurants = response.restaurants
    let viewModel = Map.Search.ViewModel(restaurants: restaurants)
    if restaurants.count &gt; 0 {
        viewController?.displaySearchedSuccess(viewModel: viewModel)
        return
    }
    viewController?.displaySearchedFailure(viewModel: viewModel)
}
</code></pre>

<p>}
```</p>

<ul>
<li><code>presentInitMapView</code>

<ul>
<li>「現在地を中心としたマップ位置に移動する」ために <code>ViewController</code> に緯度/経度/ズームレベルを渡します</li>
</ul>
</li>
<li><code>presentSearchedRestaurants</code>

<ul>
<li>レストラン情報の有無で <code>ViewController</code> に出す指示を変えています</li>
<li>今回はシンプルな実装のため、<code>Map.Search.Response</code> から <code>Map.Search.ViewModel</code> に変換はありません</li>
</ul>
</li>
</ul>


<h5>MapViewController.swift</h5>

<p>最後に <code>ViewController</code> について説明します。<br/>
下記で</p>

<ul>
<li><code>Interactor</code> に具体的な処理内容(表示ロジック)を問い合わせる</li>
<li><code>Presenter</code> からの指示を受けて、最適な <code>View</code> を描画する</li>
</ul>


<p>を実現しています。</p>

<p>```objective-c
import UIKit
import GoogleMaps</p>

<p>protocol MapDisplayLogic: class {</p>

<pre><code>func displayInitMap(viewModel: Map.Init.ViewModel)
func displaySearchedSuccess(viewModel: Map.Search.ViewModel)
func displaySearchedFailure(viewModel: Map.Search.ViewModel)
</code></pre>

<p>}</p>

<p>class MapViewController: UIViewController, MapDisplayLogic {</p>

<pre><code>var interactor: MapBusinessLogic?
var router: (NSObjectProtocol &amp; MapRoutingLogic &amp; MapDataPassing)?

@IBOutlet weak var mapView: GMSMapView!
var locationManager: CLLocationManager?

// MARK: Object lifecycle

override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
    super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
    setup()
}

required init?(coder aDecoder: NSCoder) {
    super.init(coder: aDecoder)
    setup()
}

// MARK: Setup

private func setup() {
    let viewController = self
    let interactor = MapInteractor()
    let presenter = MapPresenter()
    let router = MapRouter()
    viewController.interactor = interactor
    viewController.router = router
    interactor.presenter = presenter
    presenter.viewController = viewController
    router.viewController = viewController
    router.dataStore = interactor
}

// MARK: Routing

override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
    if let scene = segue.identifier {
        let selector = NSSelectorFromString("routeTo\(scene)WithSegue:")
        if let router = router, router.responds(to: selector) {
            router.perform(selector, with: segue)
        }
    }
}

// MARK: View lifecycle

override func viewDidLoad() {
    super.viewDidLoad()

    configureMapView()
    configureLocationManager()
}

// MARK: Configuration
func configureMapView() {
    // GoogleMapの初期化
    mapView.isMyLocationEnabled = true
    mapView.mapType = GMSMapViewType.normal
    mapView.settings.compassButton = true
    mapView.settings.myLocationButton = true
    mapView.settings.compassButton = true
    mapView.delegate = self
}

func configureLocationManager() {
    // 位置情報関連の初期化
    self.locationManager = CLLocationManager()
    self.locationManager?.desiredAccuracy = kCLLocationAccuracyBest
    self.locationManager?.requestWhenInUseAuthorization()
    self.locationManager?.startUpdatingLocation()
    self.locationManager?.delegate = self
}

// MARK: Init mapView

func displayInitMap(viewModel: Map.Init.ViewModel) {
    // 初期描画時のマップ中心位置の移動
    let coordinate = CLLocationCoordinate2D(latitude: viewModel.latitude, longitude: viewModel.longitude)
    let camera = GMSCameraPosition.camera(withTarget: coordinate, zoom: viewModel.zoomLevel)
    mapView.camera = camera
}

// MARK: Search restaurants

func searchRestaurants() {
    guard let latitude = mapView.myLocation?.coordinate.latitude, let longitude = mapView.myLocation?.coordinate.longitude else {
        return
    }
    let request = Map.Search.Request(latitude: latitude, longitude: longitude)
    interactor?.searchRestaurants(request: request)
}

func displaySearchedSuccess(viewModel: Map.Search.ViewModel) {
    let restaurants = viewModel.restaurants
    for restaurant in restaurants {
        putMarker(restaurant: restaurant)
    }
}

func displaySearchedFailure(viewModel: Map.Search.ViewModel) {
    showAlert(title: "確認", message: "周辺にレストランは見つかりませんでした。") {
    }
}

@IBAction func tappedSearchButton(_ sender: Any) {
    searchRestaurants()
}

// MARK: Other
private func putMarker(restaurant: Restaurant) {
    let marker = CustomGMSMarker()
    marker.id = restaurant.id
    marker.name = restaurant.name
    marker.category = restaurant.category
    marker.imageURL = restaurant.imageURL
    marker.position = CLLocationCoordinate2D(latitude: restaurant.latitude, longitude: restaurant.longitude)
    marker.icon = UIImage(named: "RestaurantIcon")
    marker.appearAnimation = GMSMarkerAnimation.pop
    marker.map = mapView
}
</code></pre>

<p>}</p>

<p>extension MapViewController: CLLocationManagerDelegate {</p>

<pre><code>func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
    // マップの初期描画
    if let coordinate = locations.last?.coordinate {
        let request = Map.Init.Request(latitude: coordinate.latitude, longitude: coordinate.longitude)
        interactor?.initMapView(request: request)
    }
}
</code></pre>

<p>}</p>

<p>extension MapViewController: GMSMapViewDelegate {</p>

<pre><code>func mapView(_ mapView: GMSMapView, markerInfoWindow marker: GMSMarker) -&gt; UIView? {
    guard let cMarker = marker as? CustomGMSMarker else {
        return nil
    }

    cMarker.tracksInfoWindowChanges = true
    let view = CustomInfoWindow(frame: CGRect(x: 0, y: 0, width: 250, height: 265))
    view.setup(name: cMarker.name, category: cMarker.category, imageURL: cMarker.imageURL)

    return view
}
</code></pre>

<p>}
```</p>

<ul>
<li><code>configureMapView</code> / <code>configureLocationManager</code>

<ul>
<li>最低限必要な <code>ViewController</code> 上での設定処理</li>
<li>ここで <code>startUpdatingLocation</code> を実行することで現在地の更新を開始</li>
</ul>
</li>
<li><code>didUpdateLocations</code> → <code>displayInitMap</code>

<ul>
<li>初期起動時は <code>mapView.myLocation</code> から現在地の即時取得ができないため、<code>startUpdatingLocation</code> を利用しています</li>
<li>現在地が取得できたタイミングで <code>didUpdateLocations</code> を通るため、 <code>Interactor</code> にマップ中心位置の移動を依頼しています</li>
<li>位置を移動させるか否かは <code>ViewController</code> では判断しません</li>
</ul>
</li>
<li><code>tappedSearchButton</code> → <code>searchRestaurants</code> → <code>displaySearchedSuccess</code> / <code>displaySearchedFailure</code>

<ul>
<li>検索ボタンをタップした時に <code>searchRestaurants</code> を呼び出しています</li>
<li><code>Interactor</code> にレストラン情報の検索を依頼しています</li>
<li><code>Presenter</code> から <code>displaySearchedSuccess</code> または <code>displaySearchedFailure</code> の描画指示を受けて描画します</li>
<li><code>Presenter</code> から返却された <code>Map.Search.ViewModel</code> を利用して <code>putMarker</code> を実行することでマップにマーカをプロットします。</li>
<li><code>displaySearchedFailure</code> では、失敗したことをアラート表示することで表現しています</li>
</ul>
</li>
<li><code>GMSMapViewDelegate</code>

<ul>
<li>マーカタップ時の処理を実装しています</li>
</ul>
</li>
</ul>


<h3>まとめ</h3>

<p>さて如何でしたでしょうか？<br/>
次回は今回扱ったサンプルを拡張する形で実装し、説明していきたいと思います。<br/>
因みに、本記事のソースは <a href="https://github.com/grandbig/CleanFoodLogger">CleanFoodLogger</a>にて公開しています。<br/>
※ バージョン <code>1.0</code> を参照してください。</p>

<p>ということで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Clean Swiftを勉強してみよう！(1)]]></title>
    <link href="http://grandbig.github.io/blog/2017/09/25/clean-swift/"/>
    <updated>2017-09-25T23:42:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2017/09/25/clean-swift</id>
    <content type="html"><![CDATA[<h3>はじめに</h3>

<p>本日は<a href="https://clean-swift.com/">Clean Swift</a>について書いていきたいと思います。</p>

<h3>Clean Swiftとは</h3>

<p>Clean Swiftは簡単に言うと『<a href="https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html">Clean Architecture</a>のSwift版』です。  <br/>
参考までにClean Architectureの有名な図を掲載します。<br/>
※ <a href="https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html">Clean Architecture</a>より抜粋させて頂きました。<br/>
<img src="/images/clean-swift_1.jpg" alt="Clean Architecture" /></p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<p>Clean Swiftアーキテクチャを採用することで受けられる恩恵として下記が考えられます。</p>

<ul>
<li>各種コンポーネントの責務を細分化することで、Massive ViewControllerの解消に繋がる</li>
<li>データの方向性が一方向になるため、各種コンポーネントの相互依存性が減り、TDD開発が進めやすくなる</li>
<li>各種コンポーネントの責務がはっきりしているため、チーム開発する際に、実装が平準化される</li>
</ul>


<h3>コンポーネントの関係性</h3>

<p>各種コンポーネントの関係性を表した全体像が下図になります。<br/>
<img src="/images/clean-swift_2.png" alt="Clean Swift Architectureの図" /></p>

<p>この関係性を説明するにあたって、各種コンポーネントの責務を理解しておく必要があるのでそれぞれ見ていきましょう。</p>

<h3>各コンポーネントの説明</h3>

<h4>View</h4>

<p>特に他のアーキテクチャと大きく違わない認識です。</p>

<p><strong>責務：</strong><br/>
① iOSアプリの見た目を表現する</p>

<h4>ViewController</h4>

<p><code>Massive ViewController</code> になりがちな部分ですが、Clean Swiftでの責務は以下になります。</p>

<p><strong>責務：</strong><br/>
① <code>Interactor</code> に具体的な処理内容(表示ロジック)を問い合わせる<br/>
② <code>Presenter</code> からの指示を受けて、最適な <code>View</code> を描画する<br/>
③ <code>Router</code> に画面遷移を依頼する</p>

<p>具体例は下記になります。</p>

<p>```objective-c
import UIKit</p>

<p>protocol SampleViewDisplayLogic: class {
  func displaySomething(viewModel: SampleView.Something.ViewModel)
  func displayError(viewModel: SampleView.Something.ViewModel)
  func transitionToSomeWhere(viewModel: SampleView.Sometime.ViewModel)
}</p>

<p>class SampleViewController: UIViewController, SampleViewDisplayLogic {
  var interactor: SampleViewBusinessLogic?
  var router: (NSObjectProtocol &amp; SampleViewRoutingLogic &amp; SampleViewDataPassing)?</p>

<p>  // MARK: Object lifecycle
  override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {</p>

<pre><code>super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
setup()
</code></pre>

<p>  }</p>

<p>  required init?(coder aDecoder: NSCoder) {</p>

<pre><code>super.init(coder: aDecoder)
setup()
</code></pre>

<p>  }</p>

<p>  // MARK: Setup
  private func setup() {</p>

<pre><code>let viewController = self
let interactor = SampleViewInteractor()
let presenter = SampleViewPresenter()
let router = SampleViewRouter()
viewController.interactor = interactor
viewController.router = router
interactor.presenter = presenter
presenter.viewController = viewController
router.viewController = viewController
router.dataStore = interactor
</code></pre>

<p>  }</p>

<p>  // MARK: Routing
  override func prepare(for segue: UIStoryboardSegue, sender: Any?) {</p>

<pre><code>if let scene = segue.identifier {
  let selector = NSSelectorFromString("routeTo\(scene)WithSegue:")
  if let router = router, router.responds(to: selector) {
    router.perform(selector, with: segue)
  }
}
</code></pre>

<p>  }</p>

<p>  // MARK: View lifecycle
  override func viewDidLoad() {</p>

<pre><code>super.viewDidLoad()

fetchSomethingOnLoad()
</code></pre>

<p>  }</p>

<p>  // ① Interactorに具体的な処理内容を問い合わせる
  func fetchSomethingOnLoad() {</p>

<pre><code>let request = SampleView.Something.Request()
interactor?.fetchSomething(request: request)
</code></pre>

<p>  }</p>

<p>  // ② Presenterからの指示を受けてViewを描画する
  func displaySomething(viewModel: SampleView.Something.ViewModel) {</p>

<pre><code>// do something
</code></pre>

<p>  }</p>

<p>  func displayError(viewModel: SampleView.Something.ViewModel) {</p>

<pre><code>// do error something
</code></pre>

<p>  }</p>

<p>  // ③ Routerに画面遷移を依頼する
  func transitionToSomeWhere(viewModel: SampleView.Sometime.ViewModel) {</p>

<pre><code>// 画面遷移
router?.routeToSomeWhere(segue: nil)
</code></pre>

<p>  }
}
```</p>

<p>また、ユーザによるアクション起因の場合は下記のようにするだけです。</p>

<p><code>objective-c
@IBAction func tapSomeAction(_ sender: Any) {
  // ① Interactorに具体的な処理内容を問い合わせる
  let request = SampleView.Sometime.Request()
  interactor?.fetchSometime(request: request)
}
</code></p>

<p><code>Presenter</code> からの指示を受けて、 <code>ViewController</code> は描画処理を実行するため、見た目の整形などの <strong>描画処理自体</strong> は <code>ViewController</code> 内に書きます。</p>

<p>例えば、</p>

<p>・正方形の <code>UIView</code> を角丸にする/背景色を変更する/非表示にする etc<br/>
・マップにマーカを配置する/図形を描画する etc</p>

<h4>Interactor</h4>

<p><code>ViewController</code> から依頼を受け、 <code>Interactor</code> は下記を実施する責務を持っています。</p>

<p><strong>責務：</strong><br/>
① <code>Worker</code> と <code>Presenter</code> を仲介する<br/>
② どんな条件で、 <code>Worker</code> に何の処理を依頼するのかハンドリングする<br/>
③ <code>Worker</code> 経由で取得したレスポンスを <code>Presenter</code> に渡す</p>

<p>```objective-c
import UIKit</p>

<p>protocol SampleViewBusinessLogic {</p>

<pre><code>func fetchSomething(request: SampleView.Something.Request)
func fetchSometime(request: SampleView.Sometime.Request)
</code></pre>

<p>}</p>

<p>protocol SampleViewDataStore {
  // 画面遷移時にパラメータを受け取れるように定義
  var something: String { get set }
}</p>

<p>class SampleViewInteractor: SampleViewBusinessLogic, SampleViewDataStore {</p>

<pre><code>var presenter: SampleViewPresentationLogic?
var worker = SampleViewWorker?
var something: String!

func fetchSomething(request: SampleView.Something.Request) {
  // ① WorkerとPresenterを仲介する
  worker.fetch(success: { (object) in
    // 処理が成功した場合
    // ③ Worker経由で取得したレスポンスをPresenterに渡す  
    let response = SampleView.Something.Response(object: object, isError: false)
    self.presenter?.presentSomething(response: response)
  }, failure: { _ in
    // 処理が失敗した場合
    // ③ Worker経由で取得したレスポンスをPresenterに渡す  
    let response = SampleView.Something.Response(object: object, isError: true)
    self.presenter?.presentSomething(response: response)
  })

func fetchSometime(request: SampleView.Sometime.Request) {
  // ② どんな条件で、Workerに何の処理を依頼するのかハンドリングする
  if request.time &gt; Date() {
    let response = SampleView.Sometime.Response(future: true)
    presenter?.presentSometime(response: response)

    return
  }
  let response = SampleView.Sometime.Response(future: false)
  presenter?.presentSometime(response: response)
}

func fetchSomeWhat(request: SampleView.SomeWhat.Request) {
  // 画面遷移時に渡されたパラメータを利用した描画を実施したい場合
  let response = SampleView.Something.Response(object: something)
  self.presenter?.presentSomething(response: response)
}
</code></pre>

<p>}
```</p>

<h4>Worker</h4>

<p><code>Interactor</code> から受けた依頼を実行します。</p>

<p><strong>責務：</strong><br/>
① <code>API</code> 処理や <code>Core Data</code> / <code>Realm</code> などのアプリ内ローカルデータの処理をハンドリングする<br/>
② 成功/失敗レスポンスをハンドリングする</p>

<p>```objective-c
import UIKit</p>

<p>class SampleViewWorker {</p>

<pre><code>func fetch(success: @escaping ((SomeObject) -&gt; Void), failure: @escaping ((Error) -&gt; Void)) {
  // APIリクエストまたはローカルDBへのアクセスを実行してデータを取得
  // 具体的な処理は省略
  let obj: SomeObject = ...
  success(obj)
}) { (error) in
  failure(error)
}
</code></pre>

<p>}
```</p>

<h4>Presenter</h4>

<p><code>Interactor</code> から <code>Worker</code> 経由で取得したレスポンスを受け取った後に、 <code>Presenter</code> は下記を実行することを責務とします。</p>

<p><strong>責務：</strong><br/>
① 受け取ったレスポンスを元に最適な表示(成功/失敗などの表示)になるようハンドリングする<br/>
② 受け取ったレスポンスを <code>Model.ViewModel</code> 形式に変換する<br/>
③ <code>ViewController</code> に <code>Model.ViewModel</code> を渡して描画を依頼する</p>

<p>```objective-c
import UIKit</p>

<p>protocol SampleViewPresentationLogic {
  func presentSomething(response: SampleView.Something.Response)
}</p>

<p>class SampleViewPresenter: SampleViewPresentationLogic {
  weak var viewController: SampleViewDisplayLogic?</p>

<p>  // MARK: Present something</p>

<p>  func presentSomething(response: SampleView.Something.Response) {</p>

<pre><code>// ② 受け取ったレスポンスをModel.ViewModel形式に変換する
let viewModel = SampleView.Something.ViewModel(object: response.object)

// ① 受け取ったレスポンスを元に最適な表示(成功/失敗などの表示)になるようハンドリングする
if response.isError {
  // エラーがある場合
  // ③ ViewControllerにModel.ViewModelを渡して描画を依頼する  
  viewController?.displayError(viewModel: viewModel)
  return
}

// ③ ViewControllerにModel.ViewModelを渡して描画を依頼する
viewController?.displaySomething(viewModel: viewModel)
</code></pre>

<p>  }
}
```</p>

<h4>Model</h4>

<p>Clean Swiftアーキテクチャの肝といっても過言ではないのが <code>Model</code> です。</p>

<p><strong>責務：</strong><br/>
① 各種コンポーネントを切り離し、各種コンポーネント間のやり取りに利用される<br/>
② <code>Request</code> / <code>Response</code> / <code>ViewModel</code> の3つの構造体を持つ</p>

<p><strong>3つの構造体の説明：</strong><br/>
・ <code>Request</code><br/>
　　・ ユーザの操作をInputパラメータとして内包したデータ形式<br/>
　　・ <code>ViewController</code> から <code>Interactor</code> に渡される<br/>
・ <code>Response</code><br/>
　　・ <code>Worker</code> 処理結果を内包しているデータ形式<br/>
　　・ <code>Interactor</code> から <code>Presenter</code> に渡される<br/>
・ <code>ViewModel</code><br/>
　　・ <code>ViewController</code> での描画に即したデータ形式<br/>
　　・ <code>Presenter</code> から <code>ViewController</code> に渡される</p>

<p>```objective-c
import UIKit</p>

<p>enum SampleView {</p>

<p>  // MARK: Fetch something
  enum Something {</p>

<pre><code>struct Request {
}
struct Response {
  var object: SomeObject
  var isError: Bool
}
struct ViewModel {
  var object: SomeObject
}
</code></pre>

<p>  }</p>

<p>  // MARK: Fetch sometime
  enum Sometime {</p>

<pre><code>struct Request {
  ...
}
struct Response {
  ...
}
struct ViewModel {
  ...
}
</code></pre>

<p>  }
}
```</p>

<h3>データフローの例</h3>

<p>各コンポーネントの責務を理解した上で、コンポーネント間のフローの流れを見ていきましょう。</p>

<h4>ユーザがボタンをタップして通信処理後に取得データを描画するフロー</h4>

<p>ユーザが <code>View</code> 上のボタンをタップした後に、外部APIを叩いて取得したデータで <code>View</code> 描画するデータフローは下記になります。</p>

<p>① <code>ViewController</code> が <code>View</code> に対するユーザアクションを検知<br/>
② <code>ViewController</code> が <code>Interactor</code> に <code>Model.Request</code> を送って具体的な処理を依頼<br/>
③ <code>Interactor</code> が <code>Worker</code> に処理を依頼<br/>
④ <code>Worker</code> が通信処理した結果を <code>Interactor</code> に返却<br/>
⑤ <code>Interactor</code> が返却データを <code>Model.Response</code> に変換して、 <code>Presenter</code> に処理を依頼 <br/>
⑥ <code>Presenter</code> が受け渡されたデータを <code>Model.ViewModel</code> に変換して、 <code>ViewController</code> に描画を指示<br/>
⑦ <code>ViewController</code> が <code>View</code> に描画を反映</p>

<p><img src="/images/clean-swift_3.png" alt="データのフロー例１" /></p>

<p>※このフローでは画面遷移がないため、Routerへの繋がりはありません。</p>

<h4>ユーザがボタンをタップしてローカルDBからデータ取得して画面遷移するフロー</h4>

<p>ユーザが <code>View</code> 上のボタンをタップした後に、ローカルDB内データを取得して、画面遷移するデータフローは下記になります。</p>

<p>① <code>ViewController</code> が <code>View</code> に対するユーザアクションを検知<br/>
② <code>ViewController</code> が <code>Interactor</code> に <code>Model.Request</code> を送って具体的な処理を依頼<br/>
③ <code>Interactor</code> が <code>Worker</code> に処理を依頼<br/>
④ <code>Worker</code> がローカルDBから処理した結果を <code>Interactor</code> に返却<br/>
⑤ <code>Interactor</code> が返却データを <code>Model.Response</code> に変換して、 <code>Presenter</code> に処理を依頼 <br/>
⑥ <code>Presenter</code> が受け渡されたデータを <code>Model.ViewModel</code> に変換して、 <code>ViewController</code> に描画を指示<br/>
⑦ <code>ViewController</code> が <code>Router</code> に画面遷移を依頼<br/>
⑧ <code>Router</code> が依頼された画面先にデータを受け渡し、画面遷移を実行</p>

<p><img src="/images/clean-swift_4.png" alt="データのフロー例２" /></p>

<h3>まとめ</h3>

<p>まず、各種コンポーネントの責務と、そのコンポーネント間の関係性および抽象的なデータフローについて説明しました。<br/>
次回は具体的なサンプルを元にClean Swiftについて説明したいと思います。</p>

<p>参考URL:</p>

<ul>
<li><a href="https://clean-swift.com/clean-swift-ios-architecture/">Clean Swift公式ページ</a></li>
<li><a href="https://hackernoon.com/introducing-clean-swift-architecture-vip-770a639ad7bf">Introducing Clean Swift Architecture (VIP)</a></li>
<li><a href="https://swifting.io/blog/2016/09/07/architecture-wars-a-new-hope/">swifting.io: #24 Architecture Wars – A New Hope</a></li>
</ul>


<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Firebase NotificationをiOSで使ってみよう！]]></title>
    <link href="http://grandbig.github.io/blog/2017/09/18/firebase-notification/"/>
    <updated>2017-09-18T00:45:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2017/09/18/firebase-notification</id>
    <content type="html"><![CDATA[<h3>はじめに</h3>

<p>今回はFirebase Notificationについて見ていきたいと思います。<br/>
一昔前であれば、プロダクトごとにNotificationの仕組みを作り込んだり、共通基盤としてNotificationプロジェクトを推進していたりといった会社が多かった気がします。<br/>
また、未だにリッチなNotificationのプロダクトを生業として利益を上げている会社もあるので、それだけNotificationの仕組みは自作ではなくあるものを使いたいという需要が大きいのでしょう。<br/>
しかしながら、Firebaseの登場により、Notificationプロダクト市場もより加熱化しているのではないでしょうか。</p>

<p>筆者的にはGoogleが出す、それも無料のプロダクトであるわけなので、使わない手はないと思うわけです。<br/>
なんて偉そうなことを言いつつ、FireabseによるNotificationの仕組みを利用したことがなかったので、今回試しに使ってみることにしました。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h3>Firebaseの導入</h3>

<p>こちらの内容は<a href="https://grandbig.github.io/blog/2017/05/14/firebase-ios/">以前書いた記事</a>に任せたいと思います。</p>

<h3>APNs証明書の作成</h3>

<p>こちらに関しては、様々なサイトにて説明がされているので、そちらを見るなどした方が早いので省きます。<br/>
例えば <a href="http://qiita.com/natsumo/items/d5cc1d0be427ca3af1cb#6-apns%E7%94%A8%E8%A8%BC%E6%98%8E%E6%9B%B8cer%E3%81%AE%E4%BD%9C%E6%88%90">プッシュ通知に必要な証明書の作り方2017</a>など参考にすると良いでしょう。</p>

<h3>Firebase Notificationの利用</h3>

<p>さて、本題です。<br/>
Firebase Notificationを利用するための手順について説明します。</p>

<p>① 作成したAPNs証明書をダウンロードする<br/>
先程作成したAPNs証明書はキーチェーンに登録していると思います。<br/>
(Apple Developer Programで作成したAPNs証明書は必ずDLしてキーチェーンに登録しましょう。)<br/>
キーチェーンを開いて、該当の証明書をダウンロードします。</p>

<p>該当のAPNs証明書は <code>Apple Development IOS Push Services: xxxxx</code> のようになっているものです。<br/>
<img src="/images/firebase_notificcation_ios_1.png" alt="キーチェーンを開く" /></p>

<p>右クリックして書き出すを選択します。<br/>
<img src="/images/firebase_notificcation_ios_2.png" alt="証明書を書き出す" /></p>

<p>ファイル名とパスワードをつけて保存します。<br/>
<img src="/images/firebase_notificcation_ios_3.png" alt="ファイル名とパスワードの付け方" /></p>

<p>② ダウンロードしたAPNs証明書をFirebaseに登録する</p>

<p>FirebaseのConsoleを開き、設定画面に遷移します。<br/>
<img src="/images/firebase_notificcation_ios_4.png" alt="Firebase Consoleの設定画面" /></p>

<p>クラウドメッセージングタブを開き、APNs証明書をアップロードします。<br/>
<img src="/images/firebase_notificcation_ios_5.png" alt="Firebase Console クラウドメッセージングタブ" /></p>

<p>③ Firebaseの必要ライブラリを導入する<br/>
Firebaseの導入で<code>Core</code>ライブラリはインストールできているかもしれませんが、Notificationでは<code>Messaging</code>が必要になります。<br/>
よって、<code>Podfile</code>を下記のように修正して、<code>pod update</code>をする必要があります。</p>

<p>```objective-c</p>

<h1>Podfile</h1>

<p>use_frameworks!</p>

<p>target &ldquo;NotificationSample&rdquo; do
  # Normal libraries
  pod &lsquo;Firebase/Core&rsquo;
  pod &lsquo;Firebase/Messaging&rsquo;</p>

<p>  abstract_target &lsquo;Tests&rsquo; do</p>

<pre><code>inherit! :search_paths
target "NotificationSampleTests"
target "NotificationSampleUITests"
</code></pre>

<p>  end
end
```</p>

<p>④ ソースコードにFirebase Notificationが利用できるように実装する<br/>
続いて、ソースコードの設定です。</p>

<p>```objective-c
// AppDelegate.swift
import UIKit
import Firebase
import UserNotifications</p>

<p>@UIApplicationMain
class AppDelegate: UIResponder, UIApplicationDelegate, UNUserNotificationCenterDelegate, MessagingDelegate {
  var window: UIWindow?
  func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) &ndash;> Bool {</p>

<pre><code>// リモート通知 (iOS10に対応)
let authOptions: UNAuthorizationOptions = [.alert, .badge, .sound]
UNUserNotificationCenter.current().requestAuthorization(
  options: authOptions,
  completionHandler: {_, _ in })

// UNUserNotificationCenterDelegateの設定
UNUserNotificationCenter.current().delegate = self
// FCMのMessagingDelegateの設定
Messaging.messaging().delegate = self

// リモートプッシュの設定
application.registerForRemoteNotifications()
// Firebase初期設定
FirebaseApp.configure()

// アプリ起動時にFCMのトークンを取得し、表示する
let token = Messaging.messaging().fcmToken
print("FCM token: \(token ?? "")")

return true
</code></pre>

<p>  }</p>

<p>  // 省略</p>

<p>  func userNotificationCenter(_ center: UNUserNotificationCenter,</p>

<pre><code>                            willPresent notification: UNNotification,
                            withCompletionHandler completionHandler: @escaping (UNNotificationPresentationOptions) -&gt; Void) {
print("フロントでプッシュ通知受け取ったよ")
</code></pre>

<p>  }</p>

<p>  func messaging(_ messaging: Messaging, didRefreshRegistrationToken fcmToken: String) {</p>

<pre><code>print("Firebase registration token: \(fcmToken)")
</code></pre>

<p>  }
}
```</p>

<p>たったのこれだけでプッシュ通知の受信ができるようになります。</p>

<h3>Firebase Notificationを利用する</h3>

<p>設定が完了したため、Firebaseからプッシュ通知を送ってみましょう。</p>

<p>方法は簡単です。</p>

<p>① 左メニューから <code>Notification</code> を選択する<br/>
② 「新しいメッセージ」を選択する<br/>
③ 必要項目を入力して「メッセージを送る」を選択する</p>

<p><img src="/images/firebase_notificcation_ios_6.png" alt="Firebase Consoleからプッシュ通知を送る" /></p>

<p>これにより、下図のようにプッシュが届くことを確認できます。<br/>
<img src="/images/firebase_notificcation_ios_7.png" alt="端末にプッシュ通知が届く" /></p>

<h3>FirebaseにAPNs Keyを登録する方法</h3>

<p>さて、上記まででは、APNs証明書を作成して、Firebaseに登録する方法を説明しましたが、実はAPNs証明書よりも <code>APNs Key</code> というものの利用を推奨されています。<br/>
なので、こちらの方法も説明しておきます。</p>

<p>作成方法はいたって簡単です。</p>

<p>① Apple Developer Programの左メニューから<code>Keys &gt; All</code>を選択する<br/>
② 「＋」ボタンで新規作成する<br/>
③ Keyの名称を設定する<br/>
④ Service種別として<code>APNs</code>を選択する<br/>
⑤ Continueボタンを選択して作成する</p>

<p><img src="/images/firebase_notificcation_ios_8.png" alt="APNs Keyの作成方法" /></p>

<p>上記で作成した<code>APNs Key</code>をFirebase Console上で設定します。</p>

<p>Firebase Console > 設定 > クラウドメッセージング > iOSアプリの設定から<code>APNs認証キー</code>に設定します。</p>

<p><img src="/images/firebase_notificcation_ios_9.png" alt="APNs認証キーを設定" /></p>

<p>因みに、設定時に利用するIDはそれぞれ下記から取得します。</p>

<p><img src="/images/firebase_notificcation_ios_10.png" alt="キーID" /><br/>
<img src="/images/firebase_notificcation_ios_11.png" alt="App ID Prefix" /></p>

<h3>まとめ</h3>

<p>さて如何でしたでしょうか？<br/>
まだまだFirebase Console上からプッシュできるNotificationにも制限があるようですが、複雑なことをしない例えば「一斉お知らせ機能」のような形で利用するのであれば非常に良いのではないでしょうか？<br/>
今後もバージョンアップして使いやすくなることを期待しつつ、本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UICollectionViewCellをカスタム化しよう！]]></title>
    <link href="http://grandbig.github.io/blog/2017/08/06/custome-collectionview/"/>
    <updated>2017-08-06T03:41:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2017/08/06/custome-collectionview</id>
    <content type="html"><![CDATA[<h3>はじめに</h3>

<p>今回は基礎中の基礎ではあるものの、結構忘れがちなカスタム化についてメモ書きしておきたいと思います。<br/>
その題材として <code>UICollectionViewCell</code> を使ってみます。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h3>カスタムファイルの作成</h3>

<p>まずは <code>xib</code> ファイルを作成します。<br/>
今回は下記のように <code>UIImageView</code> を持たせるようにカスタム化させます。<br/>
(<code>CustomCollectionViewCell.xib</code>とします。)</p>

<p><img src="/images/custom-collection-view-1.png" alt="xibファイル" /></p>

<p>これと対となる<code>swift</code>ファイルを作成します。<br/>
(<code>CustomCollectionViewCell.swift</code>とします。)</p>

<p>```objective-c
// CustomCollectionViewCell.swift
import UIKit</p>

<p>class CustomCollectionViewCell: UICollectionViewCell {</p>

<p>  @IBOutlet weak var imageView: UIImageView!</p>

<p>  override init(frame: CGRect) {</p>

<pre><code>super.init(frame: frame)
self.xibViewSet()
</code></pre>

<p>  }</p>

<p>  required init?(coder aDecoder: NSCoder) {</p>

<pre><code>super.init(coder: aDecoder)!
self.xibViewSet()
</code></pre>

<p>  }</p>

<p>  internal func xibViewSet() {</p>

<pre><code>if let view = Bundle.main.loadNibNamed("CustomCollectionViewCell", owner: self, options: nil)?.first as? UIView {
  view.frame = self.bounds
  self.addSubview(view)
}
</code></pre>

<p>  }
}
```</p>

<p>この<code>xib</code>と<code>swift</code>ファイルを繋ぐために <code>xib</code>ファイルの<code>File's Owner</code>の<code>Custom Class</code>の<code>Class</code>にクラス名を入力します。</p>

<p><img src="/images/custom-collection-view-2.png" alt="xibとswiftの接続" /></p>

<h3>Storyboardにカスタム部品を配置</h3>

<p>続いて、先程作成したカスタム部品を<code>Storyboard</code>に配置します。<br/>
今回は <code>UICollectionViewCell</code> をカスタム化しているので、右メニューから <code>UICollectionView</code> をドラッグ&amp;ドロップして持ってきます。</p>

<p><img src="/images/custom-collection-view-3.png" alt="UICollectionViewをドラッグ&amp;ドロップ" /></p>

<p>持ってきた部品とカスタム化クラスを結びつけます。<br/>
<code>右メニュー &gt; Show the Identity inspector &gt; Custom Class &gt; Class</code> にクラス名を入力します。</p>

<p><img src="/images/custom-collection-view-4.png" alt="カスタムクラスへの接続" /></p>

<h3>CustomCollectionViewCellの表示</h3>

<p>ここまでくれば後はいつも通り<code>UICollectionView</code>を使えば良いだけです。</p>

<p>・ <code>Storyboard</code> 上で <code>Collection Reusable View</code> の <code>Identifier</code> に値を設定<br/>
・ 下記の通りソースコードを実装</p>

<p>```objective-c
import Foundation
import UIKit</p>

<p>class CreateShopMemoViewController: UIViewController, UICollectionViewDataSource {</p>

<p>  /// UICollectionView
  @IBOutlet weak var collectionView: UICollectionView!</p>

<p>  override func viewDidLoad() {</p>

<pre><code>super.viewDidLoad()
self.collectionView.dataSource = self
</code></pre>

<p>  }</p>

<p>  override func didReceiveMemoryWarning() {</p>

<pre><code>super.didReceiveMemoryWarning()
// Dispose of any resources that can be recreated.
</code></pre>

<p>  }</p>

<p>  // MARK: &ndash; UICollectionViewDataSource
  func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) &ndash;> UICollectionViewCell {</p>

<pre><code>let cell = collectionView.dequeueReusableCell(withReuseIdentifier: "CustomCell", for: indexPath) as? CustomCollectionViewCell   
// 画像を設定 (今回はサンプルのためNoImageIconというものがあることを想定しています)
cell?.imageView.image = UIImage(named: "NoImageIcon")

return cell!
</code></pre>

<p>  }</p>

<p>  func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) &ndash;> Int {</p>

<pre><code>return 1
</code></pre>

<p>  }
}
```</p>

<p>その結果は下記の通りです。</p>

<p><img src="/images/custom-collection-view-6.png" alt="CustomCollectionViewCellの表示" /></p>

<p>因みに、今回のように、Viewを1枚ペタッと貼るだけであれば、</p>

<p>```objective-c
// MARK: &ndash; UICollectionViewDataSource
func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) &ndash;> UICollectionViewCell {
  let cell = collectionView.dequeueReusableCell(withReuseIdentifier: &ldquo;CustomCell&rdquo;, for: indexPath) <br/>
  // 画像を設定 (今回はサンプルのためNoImageIconというものがあることを想定しています)
  cell.backgroundView = UIImageView(image: UIImage(named: &ldquo;NoImageIcon&rdquo;))</p>

<p>  return cell
}
```</p>

<p>とすれば良いだけです。</p>

<h3>まとめ</h3>

<p>今回は完全なるメモ書きでしたが、カスタム化の基礎なので、十二分に慣れておかないとですね。<br/>
と言ったところで本日はここまで。</p>

<p>参考</p>

<ul>
<li><a href="http://himaratsu.hatenablog.com/entry/ios/customview">カスタムViewをNibから初期化し、IBDesignableとIBInspectableで便利に使う</a></li>
<li><a href="http://qiita.com/taketomato/items/7bf3f1dc2690c76079fb">xib 化した UITableViewCell を使うときの Tips</a></li>
</ul>


<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
</feed>
