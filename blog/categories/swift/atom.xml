<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: swift | Takahiro Octopress Blog]]></title>
  <link href="http://grandbig.github.io/blog/categories/swift/atom.xml" rel="self"/>
  <link href="http://grandbig.github.io/"/>
  <updated>2016-01-19T01:17:09+09:00</updated>
  <id>http://grandbig.github.io/</id>
  <author>
    <name><![CDATA[Takahiro]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SwiftでGCDを使ってみよう！]]></title>
    <link href="http://grandbig.github.io/blog/2016/01/18/semaphore/"/>
    <updated>2016-01-18T09:26:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2016/01/18/semaphore</id>
    <content type="html"><![CDATA[<h4>GCDとは</h4>

<p>GCDとはGrand Central Dispatchの略で、iOSアプリでマルチスレッド処理を実行したいときに利用する手法です。<br/>
書き方は独特ですが、慣れてしまえば、簡単に使いこなすことができると思います。<br/>
今回は筆者が困ったときに使う方法について紹介していきます。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h4>メインスレッドの処理を妨げたくないとき</h4>

<p>iOSアプリでは描画はメインスレッドでしか実行できません。<br/>
(もし、それ以外で実行しようとすれば、アプリがダウンしてしまいます。)</p>

<p>筆者がアプリを開発しているときに、<br/>
検証のため、ログをローカルストレージに保存したい場面がありました。<br/>
ログ保存処理は一時的な検証のためであり、本来のメイン処理を妨げたくはありません。</p>

<p>ログ保存処理は <strong>描画を含まない処理</strong> であるため、<br/>
別にスレッドを立てて、そちらに任せてしまうことができます。<br/>
これにより、メインスレッドに影響を及ぼすことなく、処理を実行することができます。</p>

<p>下記にサンプルを載せます。</p>

<p>```objective-c
// ViewController.swift
import UIKit</p>

<p>class ViewController: UIViewController {</p>

<pre><code>let queue:dispatch_queue_t = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)

override func viewDidLoad() {
    super.viewDidLoad()

    dispatch_async(queue) {() -&gt; Void in
        // 別スレッドでの処理
        // 例えば、Realmを使った保存処理などを書く(今回は省略します)
    }

    // アラート表示処理
    let alertController:UIAlertController = UIAlertController(title: "確認", message: message, preferredStyle: .Alert)
    let okAction:UIAlertAction = UIAlertAction(title: "OK", style: .Default) { (alert) -&gt; Void in
        // OKを選択したときに実行される処理
    }
    alertController.addAction(okAction)
    presentViewController(alertController, animated: true, completion: nil)
}

&lt;省略&gt;
</code></pre>

<p>}
```</p>

<p>このように <strong>dispatch_async</strong> 内でRealmへのログ保存処理をすれば、<br/>
別スレッドでの処理となるため、<br/>
ログ保存処理を待たずにアラートの表示処理を実行することができます。</p>

<p><strong>dispatch_get_global_queue</strong> とその引数などの詳細は<a href="https://github.com/mixi-inc/iOSTraining/wiki/8.2-Grand-Central-Dispatch">8.2 Grand Central Dispatch</a>に非常に詳しく書かれているので、ぜひご参照ください。</p>

<h4>複数の非同期処理の情報で何か処理がしたいとき</h4>

<p>例えば、複数種類のWeb APIを叩いて、それぞれから取得した情報を合算して、画面に表示したいとします。<br/>
（別々にAPIを叩いて取得した情報を別々に返せば問題ない場面では当てはまらないので注意）</p>

<p>そんなときは <strong>dispatch_group_async</strong> と <strong>dispatch_group_notify</strong> を使います。</p>

<p>下記にサンプルを載せます。</p>

<p>```objective-c</p>

<h1>import UIKit</h1>

<p>class ViewControlelr:UIViewController {</p>

<pre><code>let queue:dispatch_queue_t = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)
let group:dispatch_group_t = dispatch_group_create()

&lt;省略&gt;

/**
指定都市の天気情報を取得する処理
*/
func getWeather(location:String, closure:(String) -&gt; Void) {
    Alamofire.request(.GET, "http://api.openweathermap.org/data/2.5/weather?APPID=&lt;自身のAPPID&gt;", parameters: 
        ["q":location]).response { (request, response, data, error) -&gt; Void in
        if(error == nil) {
            do {
                let dataDict = try NSJSONSerialization.JSONObjectWithData(data!, options: NSJSONReadingOptions.AllowFragments)
                let weatherArray:[AnyObject] = dataDict["weather"] as! [AnyObject]
                let weather:AnyObject = weatherArray[0]
                let description:String = weather["description"] as! String
                closure(description)
            } catch {
                print("例外が発生しました")
            }
        }
    }
}

/**
複数都市の天気情報を取得しログ出力する処理
*/
func getMultiLocationWeather() {
    var tokyoWeather:String = "unknown"
    var osakaWeather:String = "unknown"
    var saitamaWeather:String = "unknown"

    // グループに 「+1」
    dispatch_group_enter(self.group)
    dispatch_group_async(self.group, self.queue) { () -&gt; Void in
        self.getWeather("Tokyo, jp", closure: { (weather) -&gt; Void in
            tokyoWeather = weather
            // グループに 「-1」
            dispatch_group_leave(self.group)
        })
    }

    // グループに 「+1」
    dispatch_group_enter(self.group)
    dispatch_group_async(self.group, self.queue) { () -&gt; Void in
        self.getWeather("Osaka, jp", closure: { (weather) -&gt; Void in
            osakaWeather = weather
            // グループに 「-1」
            dispatch_group_leave(self.group)
        })
    }

    // グループに 「+1」
    dispatch_group_enter(self.group)
    dispatch_group_async(self.group, self.queue) { () -&gt; Void in
        self.getWeather("Saitama, jp", closure: { (weather) -&gt; Void in
            saitamaWeather = weather
            // グループに 「-1」
            dispatch_group_leave(self.group)
        })
    }

    // 全ての処理が終わったら実行される
    dispatch_group_notify(self.group, self.queue) { () -&gt; Void in
        print("Tokyo: \(tokyoWeather), Osaka: \(osakaWeather), Saitama: \(saitamaWeather)")
    }
}

&lt;省略&gt;
</code></pre>

<p>}
```</p>

<p>以上のように、3つの非同期処理で取得した情報を使って、文章を作成し、ログ出力することができます。</p>

<h4>非同期処理を同期処理にしたい(排他制御を使いたい)とき</h4>

<p>さて、こちらは正直、筆者は利用したいと思ったことがありません。<br/>
恐らく、かなり多機能なアプリで、極力多くの処理を並列に実行したい場合に必要なのかなと思ったりします。<br/>
では、なぜ書くかというと、先日スタックオーバーフローを見て気になったからです。</p>

<p>因みに、筆者のスタックオーバーフローユーザは<a href="http://ja.stackoverflow.com/users/8968/takahiro">こちら</a>です。</p>

<p><a href="https://blog.katty.in/2365">Objective-Cで非同期処理を同期処理にする方法。</a>の例をSwiftで書き直します。</p>

<p>```objective-c</p>

<h1>import UIKit</h1>

<p>class ViewController:UIViewController {</p>

<pre><code>let semaphore:dispatch_semaphore_t = dispatch_semaphore_create(0)
let queue:dispatch_queue_t = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)

&lt;省略&gt;

func printLog() {
    dispatch_async(queue) { () -&gt; Void in
        for(var i=0; i &lt; 5; i++) {
            sleep(1)
            print("Process: \(i)")
        }
        dispatch_semaphore_signal(self.semaphore)
    }

    print("wait...")
    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER)
    print("finish")
}

&lt;省略&gt;
</code></pre>

<p>}
```</p>

<p>実行してみれば、下記のようにログ出力されることがわかるでしょう。</p>

<p><code>objective-c
wait...
Process: 0
Process: 1
Process: 2
Process: 3
Process: 4
finish
</code></p>

<p>非同期処理を待ってから、 <strong>finish</strong> とログ出力されていることがわかります。<br/>
この例ではわかりやすさのため、 <strong>dispatch_async</strong> を使って、非同期処理を作り出しています。</p>

<p>iOSアプリの開発でよく利用する非同期処理と言えば、通信処理ではないでしょうか？<br/>
Swiftでは特に<a href="https://github.com/Alamofire/Alamofire">Alamofire</a>がよく利用されています。</p>

<p>Alamofireを使って、上記と似たことをやろうとすると、下記のように書くかもしれません。</p>

<p>```objective-c</p>

<h1>import UIKit</h1>

<p>class ViewController:UIViewController {</p>

<pre><code>let semaphore:dispatch_semaphore_t = dispatch_semaphore_create(0)
let queue:dispatch_queue_t = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)

&lt;省略&gt;

func getWeather() {
    Alamofire.request(.GET, "http://api.openweathermap.org/data/2.5/weather?APPID=&lt;自身のAPPID&gt;", parameters:
        [q: "Tokyo, jp"]).response { (request, response, data, error) -&gt; Void in
            if(error == nil) {
                do {
                    let dataDict = try NSJSONSerialization.JSONObjectWithData(data!, options: NSJSONReadingOptions.AllowFragments)
                    let weatherArray:[AnyObject] = dataDict["weather"] as! [AnyObject]
                    let weather:AnyObject = weatherArray[0]
                    let description:String = weather["description"] as! String

                    dispatch_semaphore_signal(semaphore)
                } catch {
                    print("例外が発生しました")
                }
            }
        }

    print("wait...")
    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER)
    print("finish")
}

&lt;省略&gt;
</code></pre>

<p>}
```</p>

<p>しかしながら、これは実行しても <strong>finish</strong> とログを出力することはありません。<br/>
理由は、<strong>dispatch_semaphore_wait</strong> を実行した後、メインスレッドを停止するのですが、<br/>
<code>Alamofire</code>の <strong>response</strong> のクロージャ処理はメインスレッドで実行されるため、<br/>
<strong>dispatch_semaphore_signal</strong> が実行されることがないからです。</p>

<p>実際に<code>Alamofire</code>の<code>ResponseSerialization.swift</code> > <code>Request</code> クラスを見てみましょう。</p>

<p>```objective-c
public func response(</p>

<pre><code>queue queue: dispatch_queue_t? = nil,
completionHandler: (NSURLRequest?, NSHTTPURLResponse?, NSData?, NSError?) -&gt; Void)
-&gt; Self
</code></pre>

<p>{</p>

<pre><code>delegate.queue.addOperationWithBlock {
    dispatch_async(queue ?? dispatch_get_main_queue()) {
        completionHandler(self.request, self.response, self.delegate.data, self.delegate.error)
    }
}

return self
</code></pre>

<p>}
```</p>

<p>となっていることがわかるはずです。</p>

<p>さて、いかがでしたでしょうか？<br/>
GCDは非常に便利な反面、迂闊に使うと思わぬ落とし穴にハマってしまうことがあります。<br/>
とは言え、<br/>
一度ハマってみないと身につかないのがプログラミングの世界だと思っているので、<br/>
ぜひじゃんじゃん使ってハマってみて頂ければと思います笑</p>

<p>と言ったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[QuickでSwiftコードのUnitテストをしよう！]]></title>
    <link href="http://grandbig.github.io/blog/2016/01/16/quick/"/>
    <updated>2016-01-16T19:49:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2016/01/16/quick</id>
    <content type="html"><![CDATA[<h4>Quickフレームワークを使おう！</h4>

<p>先日、XCTestによるiOSアプリのUnit TestとUI Testについて記事を書きました。<br/>
もちろんXCTestを使って、テストをすることに問題はありません。<br/>
ですが、XCTestは非常に独特な書式で、初めて使う人には取っ付きにくいかと思います。</p>

<p>そんな中、注目を集めているiOSアプリ用のテストフレームワークが<a href="https://github.com/Quick/Quick">Quick</a>です。<br/>
GitHubに書かれている通り、<a href="https://github.com/rspec/rspec">RSpec</a> / <a href="https://github.com/specta/specta">Specta</a> / <a href="https://github.com/onsi/ginkgo">Ginkgo</a>にインスパイアされて開発されているため、親しみやすい書式でテストコードを書くことができます。<br/>
(筆者もこれを機に親しもうと思います笑)</p>

<p>これまでiOSアプリのテストコードは独特で&hellip;と避けてきた方がいましたら、ぜひ <strong>Quick</strong> を導入してみて頂ければと思います。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h4>Quickの導入方法</h4>

<p>では、Quickを導入しましょう。<br/>
GitHubにも書いてありますが、CocoaPodsでの導入方法は下記です。<br/>
※ 説明用のプロジェクト名を <strong>QuickSample</strong> とします。</p>

<p>１．Podfileの作成</p>

<p>```objective-c</p>

<h1>Podfile</h1>

<p>use_frameworks!</p>

<p>def testing_pods</p>

<pre><code>pod 'Quick', '~&gt; 0.8.0'
pod 'Nimble', '3.0.0'
</code></pre>

<p>end</p>

<p>target &lsquo;QuickSampleTests&rsquo; do</p>

<pre><code>testing_pods
</code></pre>

<p>end</p>

<p>target &lsquo;QuickSampleUITests&rsquo; do</p>

<pre><code>testing_pods
</code></pre>

<p>end
```</p>

<p>２．CocoaPodsコマンドを実行<br/>
Podfileと同階層で<code>pod install</code>を実行</p>

<p>３．テストファイルを用意<br/>
プロジェクト作成時に<code>QuickSampleTests.swift</code>を作成しておいたので、それを編集します。</p>

<p>```objective-c
// QuickSampleTests.swift
import XCTest
import Quick
import Nimble
@testable import QuickSample</p>

<p>class QuickSampleTests: QuickSpec {</p>

<pre><code>override func spec() {
    // ここにテストコードを書いていきます。
}
</code></pre>

<p>}
```</p>

<p>これで<code>QuickSpec</code>をオーバーライドしたテスト用クラスになりました。<br/>
最低限の準備はこれで完了です。</p>

<h4>Quickでのテストコードの書式</h4>

<p>続いて、基本的なテストコードの書式を見ていきましょう。</p>

<p>１．<code>describe</code>：『何のテストをするのか』を記述</p>

<p>```objective-c
// テストコード
override func spec() {</p>

<pre><code>describe("天気情報をログ出力する") {
    // 「天気情報をログ出力する」ことをテストするためのコードを書いていきます。
}
</code></pre>

<p>}
```</p>

<p>２．<code>context</code>：『どういった条件のテストをするのか』を記述</p>

<p>```objective-c
// テストコード
override func spec() {</p>

<pre><code>describe("天気情報をログ出力する") {
    context("晴れの場合") {
        // 天気が晴れの場合のテスト
    }

    context("雨の場合") {
        // 天気が雨の場合のテスト
    }
}
</code></pre>

<p>}
```</p>

<p>３．<code>it</code>：『このテストはこういった結果になる』ということを記述</p>

<p>```objective-c
// テストコード
override func spec() {</p>

<pre><code>describe("天気情報をログ出力する") {
    context("晴れの場合") {
        // 天気が晴れの場合のテスト
        it("print out 'sunny'") {
            // 実行するテストコードをここに記述します
        }
    }

    &lt;省略&gt;
}
</code></pre>

<p>}
```</p>

<p>４．<code>expect('☓☓☓').to(△△△)</code>：『「☓☓☓」が「△△△」と等しい結果になる』ことを記述<br/>
ここは説明のために、テスト対象を<code>Weather.swift</code>として下記のようなコードだとします。<br/>
あくまでも<code>expect('☓☓☓').to(△△△)</code>の説明であるため、<code>Weather.getWeather</code>の処理は超簡単にしています。</p>

<p>```objective-c
// Weather.swift
class Weather:NSObject {</p>

<pre><code>&lt;省略&gt;

func getWeather() -&gt; String {
    return "sunny"
}

&lt;省略&gt;
</code></pre>

<p>}
```</p>

<p>続いてテストコードです。</p>

<p>```objective-c
// テストコード
override func spec() {</p>

<pre><code>describe("天気情報をログ出力する") {
    context("晴れの場合") {
        // 天気が晴れの場合のテスト
        it("print out 'sunny'") {
            let weather = Weather().getWeather()
            expect(weather).to(contain("sunny"))
        }
    }

    &lt;省略&gt;
}
</code></pre>

<p>}
```</p>

<p>補足すると、</p>

<p>・戻り値と期待値が完全一致する場合：<code>to(equal(△△△))</code><br/>
・戻り値が期待値の一部を含む場合：<code>to(contain(△△△))</code></p>

<p>といったように使い分けましょう。</p>

<p>５．非同期処理のテストをする場合<br/>
これまで同期処理を見てきましたが、今度は非同期処理を見ていきましょう。</p>

<p><code>Weather.swift</code>クラスに非同期処理を追加します。</p>

<p>```objective-c
// Weather.swift
class Weather:NSObject {</p>

<pre><code>&lt;省略&gt;

func getAsyncWeather(closure:(String) -&gt; Void) {
    Alamofire.request(.GET, "http://api.openweathermap.org/data/2.5/weather?APPID=&lt;自身のAPPIDを指定&gt;", parameters:
        ["q":"Tokyo,jp"]).response { (request, response, data, error) -&gt; Void in
        if(error == nil) {
            do {
                let dataDict = try NSJSONSerialization.JSONObjectWithData(data!, options: NSJSONReadingOptions.AllowFragments)
                let weatherArray:[AnyObject] = dataDict["weather"] as! [AnyObject]
                let weather:AnyObject = weatherArray[0]
                let description:String = weather["description"] as! String
                closure(description)
            } catch {
                clouser("exception")
            }
        }
}

&lt;省略&gt;
</code></pre>

<p>}
```</p>

<p>XCTestでも説明しましたが、<br/>
Swiftではスタブの代わりに <strong>manual mocking</strong> という手法を採用しています。<br/>
なので、通信処理はテストコード内で継承したクラスを作成して、そちらで定数を返すようにしましょう。</p>

<p>```objective-c
// テストコード
override func spec() {</p>

<pre><code>// manual mockingのための用意
class WeatherMock:Weather {
    override func getAsyncWeather(closure:(String) -&gt; Void) {
        closure("sunny")
    }
}

describe("天気情報を取得する") {
    context("晴れの場合") {
        // 天気が晴れの場合のテスト
        it("print out 'sunny'") {
            var result:String = ""
            let wm:WeatherMock = WeatherMock()
            wm.getAsyncWeather{(weather) -&gt; Void in
                result = weather
            }
            expect(result).toEventually(equal("sunny"))"
        }
    }

    &lt;省略&gt;
}
</code></pre>

<p>}
```</p>

<p>因みに、非同期処理では、<code>to</code>ではなく<code>toEventually</code>を利用します。<br/>
<code>expect(result).toEventually(equal("sunny"), timeout: 10)</code>と書けば、<br/>
任意のタイムアウトを設定可能です。</p>

<p>その他のメソッドを探したい場合は、<br/>
<strong>Pods > Nimble > ObjCExpectation.swift > NMBExpectation</strong> を確認してみてください。<br/>
また、<a href="https://github.com/Quick/Nimble">GitHubのNimble</a>も参考になります。</p>

<h4>Quickでのテスト結果</h4>

<p>テストの実行方法はXCTestと同じです。<br/>
<strong>Xcodeメニュー > Product > Test</strong> を選択してテストを実行しましょう。</p>

<p>結果は同じく、Xcodeの左メニューに表示されます。</p>

<p><img src="/images/quick.png" alt="Xcodeのテスト結果" /></p>

<p>また、ログでも細かな結果が出力されますので、<br/>
(少し見づらいですが)なぜかテストが成功しないといったことがあれば、<br/>
積極的に確認してみましょう。</p>

<p>さて、いかがでしたでしょうか？<br/>
今のところは <strong>XCTest</strong> もしくは <strong>Quick</strong> によるUnit テストが主流になると思います。<br/>
開発者の使いやすさに合わせて選んでみてください。</p>

<p>と言ったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[jazzyを使って、Swiftで書いたプロジェクトのリファレンスを自動生成しよう！]]></title>
    <link href="http://grandbig.github.io/blog/2016/01/12/jazzy/"/>
    <updated>2016-01-12T23:18:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2016/01/12/jazzy</id>
    <content type="html"><![CDATA[<h4>jazzyとは</h4>

<p>さて、本日は<a href="https://github.com/Realm/jazzy">jazzy</a>について書こうと思います。<br/>
jazzyはSwiftで書いたプロジェクトのリファレンスを自動で生成できるツールです。<br/>
最近、熱いMobile DatabaseであるRealmと同じチームが開発しているようです。<br/>
今のところ、他に良さそうなツールはないんじゃないでしょうか？</p>

<p>兎にも角にも、早速使ってみることにします。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h5>jazzyのインストール</h5>

<p>jazzyのインストールは簡単です。<br/>
下記コマンドを実行してください。</p>

<p><code>sudo gem install jazzy</code></p>

<h5>jazzyのコマンド</h5>

<p><code>jazzy -h</code>を実行してコマンドを確認してみましょう。<br/>
下記のような結果が得られるはずです。</p>

<p>```objective-c
Usage: jazzy</p>

<p>Options</p>

<pre><code>-o, --output FOLDER              Folder to output the HTML docs to
-c, --[no-]clean                 Delete contents of output directory before running. 
                                 WARNING: If --output is set to ~/Desktop, this will delete the ~/Desktop directory.
    --[no-]objc                  Generate docs for Objective-C.
    --umbrella-header PATH       Umbrella header for your Objective-C framework.
    --framework-root PATH        The root path to your Objective-C framework.
    --sdk [iphone|watch|appletv][os|simulator]|macosx
                                 The SDK for which your code should be built.
    --config PATH                Configuration file (.yaml or .json)
                                 Default: .jazzy.yaml in source directory or ancestor
-x arg1,arg2,…argN,              Arguments to forward to xcodebuild
    --xcodebuild-arguments
-s FILEPATH,                     File generated from sourcekitten output to parse
    --sourcekitten-sourcefile
    --source-directory DIRPATH   The directory that contains the source to be documented
-e, --exclude file1,file2,…fileN Files to be excluded from documentation
    --swift-version VERSION
-a, --author AUTHOR_NAME         Name of author to attribute in docs (e.g. Realm)
-u, --author_url URL             Author URL of this project (e.g. http://realm.io)
-m, --module MODULE_NAME         Name of module being documented. (e.g. RealmSwift)
    --module-version VERSION     module version. will be used when generating docset
    --copyright COPYRIGHT_MARKDOWN
                                 copyright markdown rendered at the bottom of the docs pages
    --readme FILEPATH            The path to a markdown README file
    --podspec FILEPATH
    --docset-icon FILEPATH
    --docset-path DIRPATH        The relative path for the generated docset
-r, --root-url URL               Absolute URL root where these docs will be stored
-d, --dash_url URL               Location of the dash XML feed e.g. http://realm.io/docsets/realm.xml)
-g, --github_url URL             GitHub URL of this project (e.g. https://github.com/realm/realm-cocoa)
    --github-file-prefix PREFIX  GitHub URL file prefix of this project (e.g. https://github.com/realm/realm-cocoa/tree/v0.87.1)
    --min-acl [private | internal | public]
                                 minimum access control level to document
    --[no-]skip-undocumented     Don't document declarations that have no documentation comments.
    --[no-]hide-documentation-coverage
                                 Hide "(X% documented)" from the generated documents
    --head HTML                  Custom HTML to inject into &lt;head&gt;&lt;/head&gt;.
    --theme [apple | fullwidth | DIRPATH]
                                 Which theme to use. Specify either 'apple' (default), 'fullwidth' or the path to your mustache templates and other assets for a custom theme.
-t, --template-directory DIRPATH DEPRECATED: Use --theme instead.
    --assets-directory DIRPATH   DEPRECATED: Use --theme instead.
-v, --version                    Print version number
-h, --help [TOPIC]               Available topics:
                                    usage   Command line options (this help message)
                                    config  Configuration file options
                                 ...or an option keyword, e.g. "dash"
</code></pre>

<p>```</p>

<p>ヘルプを見て頂ければ、なんとなく概要をつかめると思いますが、特に重要なものを説明します。</p>

<ol>
<li><code>-o FOLDER</code><br/>
リファレンスの出力場所を指定するコマンドです</li>
<li><code>--min-acl [private | internal | public]</code><br/>
リファレンスに出力するプロパティおよびメソッドの最低アクセス権限<br/>
例えば、<code>--min-acl public</code>を指定した場合、<code>private</code>や<code>internal</code>指定されたプロパティやメソッドはリファレンスに出力されません。</li>
<li><code>--skip-undocumented</code><br/>
ドキュメントコメントが書かれていないプロパティやメソッドはリファレンスに出力しません。</li>
<li><code>--author AUTHOR_NAME</code><br/>
リファレンスに開発者を明記します。</li>
<li><code>--author_url URL</code><br/>
リファレンス上に表記される開発者名にURlリンクを付与します。</li>
</ol>


<h4>Swift2.0以降でのドキュメントコメントの書き方について</h4>

<p>Swift2.0以降でのドキュメントコメントの書き方を見ていきます。<br/>
<strong>jazzy</strong> を使うことを前提にした書き方のみ記述します。</p>

<p>```objective-c
import UIKit</p>

<p>/**</p>

<p>UIViewControllerを継承したViewControllerクラス</p>

<p>*/
class ViewController: UIViewController {</p>

<pre><code>// MARK: Properties
/// 文字列を格納するためのサンプル変数
var sampleParam1:String?
/// 数値を格納するためのサンプル定数
let sampleParam2:Int = 0

&lt;省略&gt;

// MARK: Method
/**

ログを出力するメソッド

- parameter message: ログ出力したいメッセージ

*/
func sampleMethod(message: String) {
    print(message)
}

/**

trueフラグを返すメソッド

- returns: trueフラグ

*/
func sampleMethod2() -&gt; Bool {
    return true
}

/**

メッセージを生成するメソッド

- parameter message: 生成したいメッセージの一部分
- returns: 生成したメッセージ

*/
func sampleMethod3(message:String) -&gt; String {
    return "生成したメッセージ： \(message)"
}
</code></pre>

<p>}
```</p>

<p>ポイントは、</p>

<ul>
<li>クラス名にドキュメントコメントを必ずつけること</li>
<li>メソッドのDescriptionとParameterもしくはReturnとの間に1行をあけること</li>
<li><code>:param:</code>や<code>:returns:</code>といった古い書き方をしないこと</li>
</ul>


<p>です。</p>

<p>上記ポイントを踏まえた上で、<br/>
<code>jazzy --min-acl internal --skip-undocumented -o jazzy_doc --author Takahiro --author_url https://grandbig.github.io/</code><br/>
を実行してみましょう。<br/>
オプションは必要に応じてつけてください。</p>

<p>結果、下図のようなリファレンスが作成されます。</p>

<p><img src="/images/jazzy_1.png" alt="トップページ" /><br/>
こちらはトップページです。</p>

<p><img src="/images/jazzy_2.png" alt="クラスの説明" /><br/>
続いて、クラスを選択した際に表示されるクラスの説明ページ</p>

<p><img src="/images/jazzy_3.png" alt="クラスのプロパティの説明" /><br/>
各プロパティを選択すれば、その説明が表示されます。</p>

<p><img src="/images/jazzy_4.png" alt="クラスのメソッドの説明" /><br/>
各メソッドを選択すれば、その説明が表示されます。</p>

<p>いかがだったでしょうか？<br/>
リファレンスは第三者にソースコードを説明する上でも非常に重要なものです。<br/>
初めから書式ルールに沿ってコードを書いておけば、自動生成ツールで速攻リファレンスを作れますので、ぜひぜひ把握しておきましょう。</p>

<p>と言ったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SwiftでXCTestを使って単体テストとUIテストをしてみよう！]]></title>
    <link href="http://grandbig.github.io/blog/2016/01/11/xctest/"/>
    <updated>2016-01-11T19:17:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2016/01/11/xctest</id>
    <content type="html"><![CDATA[<h4>iOSアプリケーション開発でのテストとは</h4>

<p>さて、本日はiOSアプリケーションを開発する際のテストについて書きたいと思います。<br/>
元々、Objective-Cでは下記のテスト用のライブラリが使われてきました。</p>

<ul>
<li><a href="https://github.com/kiwi-bdd/Kiwi">Kiwi</a></li>
<li><a href="https://github.com/gh-unit/gh-unit">GHUnit</a></li>
<li><a href="https://github.com/specta/specta">Specta</a></li>
</ul>


<p>しかし、これらはあくまでもObjective-C時代にApple公式のテストフレームワークが充実する以前から活躍していたものです。今後、Swiftが普及するにつれて、これらのテストフレームワークもSwiftに最適化したものになっていくかもしれません。<br/>
とは言え、AppleもいつまでもOSSのテストフレームワークがなければならない状況は避け、Xcode内で完結することを目指していくかもしれません。<br/>
後ほど詳しく説明しますが、Xcode7からUIテストが新たに追加されたのも、その流れだと思っています。</p>

<p>本日は特に <strong>XCTest</strong> に焦点をあてた、iOSにおけるテストについて見ていきたいと思います。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h4>XCTestでUnit Test</h4>

<p>早速、XCTestの使い方について見ていきましょう。<br/>
Xcode7ではプロジェクトを新規作成する際にXCTest用のTargetを作成するか否かを選ぶことができます。<br/>
初めにチェックを入れていない場合は、途中で追加することが可能ですが、単体テストをすることは大切なので、チェックはつけておきましょう。</p>

<p><img src="/images/xctest_1.png" alt="プロジェクト作成時にXCTest用のTargetを作成" /></p>

<p>今回テストするソースコードは下記のようなシンプルなものにします。</p>

<p>```objective-c
import UIKit
import Alamofire</p>

<p>class ViewController: UIViewController {</p>

<pre><code>override func viewDidLoad() {
    super.viewDidLoad()
}

override func didReceiveMemoryWarning() {
    super.didReceiveMemoryWarning()
}

func showWeather() {
    self.getWeather{(description) -&gt; Void in
        print(description)
    }
}

func getWeather(closure:(String) -&gt; Void) {
    Alamofire.request(.GET, "http://api.openweathermap.org/data/2.5/weather?APPID=&lt;自身のAPPIDを指定&gt;", parameters:
        ["q":"Tokyo"]).response { (request, response, data, error) -&gt; Void in
        if(error == nil) {
            do {
                let dataDict = try NSJSONSerialization.JSONObjectWithData(data!, options: NSJSONReadingOptions.AllowFragments)
                let weatherArray:[AnyObject] = dataDict["weather"] as! [AnyObject]
                let weather:AnyObject = weatherArray[0]
                let description:String = weather["description"] as! String

                // アラートを表示
                self.showAlert(description)
            } catch {
                print("例外が発生しました！")
            }
        }
    }
}
</code></pre>

<p>}
```</p>

<p>今回は <strong>showWeather</strong> メソッドのUnit Testを書いていきます。<br/>
上記コードを見て頂くと、 <strong>showWeather</strong> メソッドは <strong>Open Weather Map API</strong> を使って東京の天気を取得し、それをログとして出力していることがわかると思います。<br/>
前半の <strong>Alamofire</strong> を使った通信処理はOSSライブラリを使っているわけで、この通信処理のテストがしたいわけではありません。<br/>
筆者が実施したいテストは後半の <strong>Open Weather Map API</strong> を使って <strong>取得した天気情報をログに出力する</strong> 部分です。<br/>
(本来はテストするまでもないのですが、テストの手法や考え方をメインに説明したいので、ソースは超簡単にしています。)</p>

<p>それを踏まえた上で、実際にテストコードを書いてみましょう。<br/>
&lt;Project名>Tests.swiftファイルを選択します。</p>

<p>```objective-c
import XCTest
@testable import SimpleApplication</p>

<p>class SimpleApplicationTests: XCTestCase {</p>

<pre><code>override func setUp() {
    super.setUp()
}

override func tearDown() {
    super.tearDown()
}

func testShowWeather() {
    class VCMock:ViewController {
        override func getWeather(closure:(String) -&gt; Void) {
            closure("test weather")
        }
    }

    let vcm:VCMock = VCMock()
    vcm.showWeather()
}
</code></pre>

<p>}
```</p>

<p>ポイントは</p>

<ol>
<li>テストメソッドの定義<br/>
テストメソッドは、 <strong>test + &lt;任意の文字列></strong> で命名しましょう。</li>
<li>スタブの定義<br/>
Swiftは <strong>manual mocking</strong> という手法を取ります。<br/>
これはテスト対象クラスを継承したクラスを定義し、テストしたいメソッドをオーバーライドします。<br/>
返却値等を固定文字列とすることで、スタブの作成となります。</li>
</ol>


<p>の2点です。</p>

<p>では、このテストを実行してみます。</p>

<p>まず、実行Targetに <strong>&lt;Project名>Tests</strong> を選択できるようにSchemeを編集します。</p>

<p><img src="/images/xctest_2.png" alt="Manage Schemes..." /></p>

<p><img src="/images/xctest_3.png" alt="Add Scheme" /></p>

<p><img src="/images/xctest_4.png" alt="Choose Testsファイル" /></p>

<p><img src="/images/xctest_5.png" alt="Set Scheme" /><br/>
実行するSchemeを <strong>&lt;Project名>Tests</strong> に設定し、実行デバイスをシミュレータにします。<br/>
(実機ではテスト実行できないからです。)</p>

<p><img src="/images/xctest_6.png" alt="Testを実行" /><br/>
Xcodeメニュー > Product > Test を選択してテストを実行します。</p>

<p><img src="/images/xctest_7.png" alt="テスト結果の確認" /><br/>
左メニューおよびコード上からテスト結果を確認できます。</p>

<p>メソッドが増えるごとにテストメソッドを増やしていきましょう。<br/>
テストファイルはクラス別に作成しておくと、第三者から見ても見やすいと思います。</p>

<h4>XCTestでUI Test</h4>

<p>続いて、Xcode7から追加されたUI Testの方法を見ていきたいと思います。<br/>
冒頭で説明した通り、プロジェクト作成時に <strong>include UI Tests</strong> を選択しておくことで、 <strong>&lt;Project名>UITests.swift</strong> ファイルが作成されます。</p>

<p>では、UI Test用に少しコードを修正してみます。</p>

<p>```objective-c
import UIKit
import Alamofire</p>

<p>class ViewController: UIViewController {</p>

<pre><code>override func viewDidLoad() {
    super.viewDidLoad()
}

override func didReceiveMemoryWarning() {
    super.didReceiveMemoryWarning()
}

@IBAction func getWeatherAction(sender: AnyObject) {
    self.getWeather { (description) -&gt; Void in
        self.showAlert(description)
    }
}

func getWeather(closure:(String) -&gt; Void) {
    Alamofire.request(.GET, "http://api.openweathermap.org/data/2.5/weather?APPID=&lt;自身のAPPIDを指定&gt;", parameters:
        ["q":"Tokyo"]).response { (request, response, data, error) -&gt; Void in
        if(error == nil) {
            do {
                let dataDict = try NSJSONSerialization.JSONObjectWithData(data!, options: NSJSONReadingOptions.AllowFragments)
                let weatherArray:[AnyObject] = dataDict["weather"] as! [AnyObject]
                let weather:AnyObject = weatherArray[0]
                let description:String = weather["description"] as! String

                // アラートを表示
                self.showAlert(description)
            } catch {
                print("例外が発生しました！")
            }
        }
    }
}

func showAlert(message:String) {
    let alertController:UIAlertController = UIAlertController(title: "確認", message: message, preferredStyle: .Alert)
    let okAction:UIAlertAction = UIAlertAction(title: "OK", style: .Default) { (alert) -&gt; Void in
        // OKを選択したときに実行される処理
    }
    alertController.addAction(okAction)

    presentViewController(alertController, animated: true, completion: nil)
}
</code></pre>

<p>}
```</p>

<p>これに伴い、画面にボタンを配置しました。<br/>
このボタンをタップすると、天気情報をアラートで表示してくれます。</p>

<p><img src="/images/xctest_8.png" alt="ボタンを配置" /></p>

<p><img src="/images/xctest_9.png" alt="アラートを表示" /></p>

<p>では、UI Testのテストコードを作成します。<br/>
UI Testの場合は、Xcodeの <strong>UI recording</strong> 機能を使って、手作業でコードを修正していきます。</p>

<p><img src="/images/xctest_10.png" alt="UI recording 開始ボタンをタップ" /></p>

<p><img src="/images/xctest_11.png" alt="UI recording 終了ボタンをタップ" /></p>

<p>すると、下記のようなコードが生成されました。</p>

<p>```objective-c
func testShowWeatherAlert() {</p>

<pre><code>let app = XCUIApplication()
app.buttons["GET Weather"].tap()
app.alerts["\U78ba\U8a8d"].collectionViews.buttons["OK"].tap()
</code></pre>

<p>}
```</p>

<p>しかし、このままではエラーが表示されるはずです。<br/>
理由はアラートのタイトルを日本語にしていたため、ASCIIコードで表示されてしまっているからです。<br/>
もし、指し示しているASCIIコードが理解できないようであれば、<a href="http://web-apps.nbookmark.com/ascii-converter/">ASCIIコード変換機</a>を使ってください。</p>

<p>ASCIIコード部分を修正した結果が下記となります。</p>

<p>```objective-c
func testShowWeatherAlert() {</p>

<pre><code>let app = XCUIApplication()
app.buttons["GET Weather"].tap()
app.alerts["確認"].collectionViews.buttons["OK"].tap()
</code></pre>

<p>}
```</p>

<p>テストコードが作成できましたので、実行Targetに &lt;Project名>UITests を選択できるようにSchemeを編集します。</p>

<p><img src="/images/xctest_12.png" alt="Manage Schemes..." /></p>

<p><img src="/images/xctest_13.png" alt="Add Scheme" /></p>

<p><img src="/images/xctest_14.png" alt="Choose Testsファイル" /></p>

<p><img src="/images/xctest_15.png" alt="Set Scheme" /><br/>
実行するSchemeを &lt;Project名>UITests に設定し、実行デバイスをシミュレータにします。<br/>
(実機ではテスト実行できないからです。)</p>

<p><img src="/images/xctest_6.png" alt="Testを実行" /><br/>
Xcodeメニュー > Product > Test を選択してテストを実行します。</p>

<p><img src="/images/xctest_16.png" alt="テスト結果の確認" /><br/>
左メニューおよびコード上からテスト結果を確認できます。</p>

<p>Unit Testと同様にメソッドが増えるごとにテストメソッドを増やしていきましょう。<br/>
テストファイルはクラス別に作成しておくと、第三者から見ても見やすいと思います。</p>

<p>いかがだったでしょうか？<br/>
今回は超簡単なサンプルコードで基本的なことについて説明しましたが、今後深く使っていくことで躓くこともあるかもしれません。<br/>
その際にはまたブログにて説明したいと思います。<br/>
ぜひ、単体テストとUIテストを駆使して、バグの少ないアプリを作っていきたいものです。</p>

<p>と言ったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOSアプリ開発で役立つオープンソースライブラリのまとめサイト]]></title>
    <link href="http://grandbig.github.io/blog/2015/10/25/ios-opensource/"/>
    <updated>2015-10-25T22:45:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2015/10/25/ios-opensource</id>
    <content type="html"><![CDATA[<h4>オープンソースライブラリは積極的に使おう！</h4>

<p>さて、本日は珍しくプログラミングそのものではなく、オープンソースライブラリのまとめサイトを紹介したいと思います。<br/>
と言っても、ほとんど皆さん当たり前のように使っていると思いますが笑。</p>

<p>Webアプリケーションと同じようにiOSアプリケーションでも当然の事ながらオープンソースのライブラリが存在します。<br/>
使いやすく役立つものから、ちょっとした心をくすぐるものまで様々なものがネット上にあふれています。<br/>
何の手がかりもなしに目的のものを探すのは困難だと思うので、筆者がよく使っているサイトを紹介します。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h5>Objective-Cならcocoa-CONTROLS</h5>

<p>こちらは最早、老舗と言えるかもしれません。<a href="https://www.cocoacontrols.com/platforms/ios/controls">cocoa-CONTROLS</a>はiOSおよびOSXアプリケーションの開発に利用可能なオープンソースライブラリをまとめてくれているサイトです。</p>

<p>下記が主な特徴となります。</p>

<ul>
<li>iOS, OSXで利用可能なライブラリが記載されています</li>
<li>Objective-Cだけでなく、Swiftで書かれたライブラリが記載されています(React Nativeもあります)</li>
<li>ライセンスによる検索が可能です。</li>
</ul>


<h5>SwiftならiOS cookies</h5>

<p>Swiftのライブラリを分野別にまとめたサイトが<a href="http://www.ioscookies.com/">iOS cookies</a>です。<br/>
こちらはcocoa-CONTROLSに比べて圧倒的にライブラリの数は少なくなりますが、各分野の有名ドコロのライブラリを抑えているので、目安にはなると思われます。</p>

<p>Swiftライブラリはまだまだしばらくはネット上で検索する必要が絶えないと思いますが、ふとした時に覗いてみると良いのではないでしょうか。</p>

<h4>その他の役立つサイトの紹介</h4>

<p>さて、アプリ開発をする上では、他にも必要なサイトがあります。<br/>
折角なので、それも紹介させてください。</p>

<h5>アプリのリリースに必要な画像を一式揃えよう</h5>

<p>アプリをリリースするためには様々なサイズの画像を用意する必要があります。<br/>
全てをいちいちメモして用意するのもたいへんなので、ここは<a href="http://makeappicon.com/">MakeAppicon</a>を使いましょう。<br/>
iOSだけでなくApple Watch用そしてAndroid用も一式そろえてくれます。</p>

<h5>アプリ関係の資料を作るなら実機つき画像が良いよね！</h5>

<p>アプリを紹介するための資料やアプリの使い方マニュアルなどを作る場合、アプリの実際の画面だけでも事足りるかもしれないのですが、どうせなら、iPhoneやAndroid端末の <strong>端末自体</strong> の画像もあった方がきれいな資料になりますよね？<br/>
そんなときには<a href="http://mockuphone.com/">MockUPhone</a>を使いましょう。</p>

<h5>アプリの画面内の色を設定するために&hellip;</h5>

<p>アプリの画面を作成するためには色を事細かに設定する必要が出てくるでしょう。<br/>
iOSではUIColorによる色設定を行うのですが、これがかなり特殊でありまして、Webアプリ出身者の筆者としてはなかなか苦労するところであります。<br/>
そんなときには<a href="http://www.peko-step.com/tool/tfcolor.html">RGB↔16進数変換サイト</a>と<a href="http://tobioka.net/wp-content/uploads/2012/05/hexrgb2uicolor.html">16進数↔UIColor変換サイト</a>を使うようにしています。</p>

<p>さて如何だったでしょうか。<br/>
もし、初めて知ったというサイトがあれば、ぜひ使ってみてください。<br/>
必ず役に立つこと請け合いです！<br/>
と言ったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
</feed>
