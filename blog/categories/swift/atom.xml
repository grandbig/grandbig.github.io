<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: swift | Takahiro Octopress Blog]]></title>
  <link href="http://grandbig.github.io/blog/categories/swift/atom.xml" rel="self"/>
  <link href="http://grandbig.github.io/"/>
  <updated>2017-04-16T16:05:52+09:00</updated>
  <id>http://grandbig.github.io/</id>
  <author>
    <name><![CDATA[Takahiro]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Dockerコンテナ内のUbuntuにSwiftサーバを立てよう！]]></title>
    <link href="http://grandbig.github.io/blog/2017/04/11/docker-for-mac-7/"/>
    <updated>2017-04-11T19:13:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2017/04/11/docker-for-mac-7</id>
    <content type="html"><![CDATA[<h3>はじめに</h3>

<p>さて本日はDockerつながりで『UbuntuにSwiftサーバを立ててみたい』と思います。<br/>
今後、ますます加熱する <strong>Server Side Swift</strong> を誰でも簡単に使えるように、きっとDockerを使う場面も増えてくることでしょう。<br/>
ということで早速見ていきたいと思います。</p>

<h3>Swiftのインストール方法</h3>

<p>次の手順に従って<code>swift</code>コマンドが叩けるところまで進めてみましょう。</p>

<p>１．KitematicでUbuntuを検索してDLする</p>

<p>まずはDockerコンテナを作ります。</p>

<p><img src="/images/docker_swift_1.png" alt="KitematicでUbuntuをダウンロード" /></p>

<p>※Ubuntuのバージョンは<code>Ubuntu 16.04.2 LTS</code>です。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<p>２．<code>Privileged mode</code>をONにする</p>

<p>Dockerコンテナのあるある話ですが、<code>Privileged mode</code>をONにしないとコマンド利用制限かかったりするので、忘れずにしておきましょう。</p>

<p><img src="/images/docker_swift_2.png" alt="Privileged modeをONにする" /></p>

<p>３．<code>PortFoward</code>を設定する</p>

<p>後々、Swiftサーバを立てた時にアクセスしたいので、Dockerにポートフォワード設定をしておきましょう。<br/>
後ほどSwiftサーバを起動したときに<code>8080</code>にアクセスすることになるので、</p>

<p><code>javascript
0.0.0.0:15700-&gt;8080/tcp
</code></p>

<p>という形でポートフォワードを設定します。<br/>
もちろんKitematicから設定可能です。</p>

<p>４．<code>apt-get</code>を最新化する</p>

<p>毎度のことですが、最新化しておきます。<br/>
まずは、Dockerコンテナにアクセスする。</p>

<p><code>javascript
$ docker exec -it ubuntu /bin/bash
</code></p>

<p>```javascript</p>

<h1>apt-get update</h1>

<h1>apt-get upgrade</h1>

<p>```</p>

<p>５．<code>wget</code>と<code>vim</code>をインストールする</p>

<p>後ほど利用するので<code>wget</code>と<code>vim</code>をインストールしておきます。</p>

<p>```javascript</p>

<h1>apt-get install wget</h1>

<h1>apt-get install vim</h1>

<p>```</p>

<p>６．Swiftサーバの依存モジュールをインストールする</p>

<p><a href="https://swift.org/download/#using-downloads">Swiftの公式サイト</a>にも書かれていますが、依存モジュールがあるのでインストールしましょう。</p>

<p>```javascript</p>

<h1>apt-get install clang libicu-dev</h1>

<p>```</p>

<p>７．Swiftパッケージをインストールする</p>

<p>Swiftサーバを立てるのに必要なものは2つあります。<br/>
それぞれ<code>wget</code>でインストールしましょう。<br/>
今回インストールするSwiftのバージョンは <strong>3.1</strong> です。</p>

<p>```javascript
// バイナリアーカイブの取得</p>

<h1>wget <a href="https://swift.org/builds/swift-3.1-release/ubuntu1604/swift-3.1-RELEASE/swift-3.1-RELEASE-ubuntu16.04.tar.gz">https://swift.org/builds/swift-3.1-release/ubuntu1604/swift-3.1-RELEASE/swift-3.1-RELEASE-ubuntu16.04.tar.gz</a></h1>

<p>// 署名ファイルの取得</p>

<h1>wget <a href="https://swift.org/builds/swift-3.1-release/ubuntu1604/swift-3.1-RELEASE/swift-3.1-RELEASE-ubuntu16.04.tar.gz.sig">https://swift.org/builds/swift-3.1-release/ubuntu1604/swift-3.1-RELEASE/swift-3.1-RELEASE-ubuntu16.04.tar.gz.sig</a></h1>

<p>```</p>

<p>８．PGP鍵をインポートする</p>

<p>次の手順で実施しますが、PGP(Pretty Good Privacy)の公開鍵を利用してSwiftパッケージが安全なものであると署名されたかどうかを検証します。<br/>
その前準備としてPGP鍵をインポートします。</p>

<p>```javascript</p>

<h1>gpg &mdash;keyserver hkp://pool.sks-keyservers.net \</h1>

<pre><code>  --recv-keys \
  '7463 A81A 4B2E EA1B 551F  FBCF D441 C977 412B 37AD' \
  '1BE1 E29A 084C B305 F397  D62A 9F59 7F4D 21A5 6D5F' \
  'A3BA FD35 56A5 9079 C068  94BD 63BC 1CFE 91D3 06C6'
</code></pre>

<p>gpg: requesting key 412B37AD from hkp server pool.sks-keyservers.net
gpg: requesting key 21A56D5F from hkp server pool.sks-keyservers.net
gpg: requesting key 91D306C6 from hkp server pool.sks-keyservers.net
gpg: /root/.gnupg/trustdb.gpg: trustdb created
gpg: key 412B37AD: public key &ldquo;Swift Automatic Signing Key #1 <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#111;&#58;&#x73;&#119;&#x69;&#102;&#x74;&#x2d;&#x69;&#x6e;&#102;&#x72;&#x61;&#115;&#x74;&#x72;&#117;&#x63;&#x74;&#117;&#x72;&#101;&#64;&#x73;&#x77;&#x69;&#x66;&#116;&#x2e;&#111;&#x72;&#x67;">&#115;&#x77;&#x69;&#102;&#x74;&#45;&#x69;&#110;&#102;&#114;&#97;&#x73;&#116;&#x72;&#117;&#99;&#116;&#x75;&#x72;&#101;&#64;&#x73;&#x77;&#x69;&#102;&#116;&#x2e;&#111;&#x72;&#103;</a>&rdquo; imported
gpg: key 21A56D5F: public key &ldquo;Swift 2.2 Release Signing Key <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#111;&#x3a;&#x73;&#x77;&#x69;&#x66;&#x74;&#x2d;&#x69;&#110;&#x66;&#x72;&#97;&#x73;&#116;&#114;&#x75;&#99;&#116;&#117;&#114;&#101;&#x40;&#115;&#x77;&#x69;&#102;&#x74;&#x2e;&#x6f;&#114;&#x67;">&#115;&#x77;&#105;&#102;&#116;&#x2d;&#x69;&#x6e;&#x66;&#114;&#x61;&#115;&#x74;&#x72;&#117;&#99;&#x74;&#117;&#114;&#101;&#x40;&#x73;&#119;&#105;&#x66;&#116;&#x2e;&#111;&#x72;&#103;</a>&rdquo; imported
gpg: key 91D306C6: public key &ldquo;Swift 3.x Release Signing Key <a href="&#x6d;&#97;&#x69;&#108;&#116;&#111;&#x3a;&#x73;&#x77;&#x69;&#x66;&#116;&#x2d;&#x69;&#110;&#x66;&#x72;&#x61;&#115;&#116;&#x72;&#x75;&#x63;&#116;&#x75;&#114;&#101;&#x40;&#115;&#119;&#x69;&#102;&#116;&#46;&#111;&#114;&#103;">&#x73;&#x77;&#105;&#102;&#116;&#45;&#x69;&#x6e;&#102;&#x72;&#x61;&#115;&#x74;&#x72;&#x75;&#99;&#116;&#x75;&#x72;&#x65;&#64;&#115;&#x77;&#105;&#x66;&#x74;&#46;&#111;&#x72;&#103;</a>&rdquo; imported
gpg: no ultimately trusted keys found
gpg: Total number processed: 3
gpg:               imported: 3  (RSA: 3)
```</p>

<p>９．PGP鍵で署名を検証する</p>

<p>公式で説明されている通り、<code>key</code>のリフレッシュをします。</p>

<p>```javascript</p>

<h1>gpg &mdash;keyserver hkp://pool.sks-keyservers.net &mdash;refresh-keys Swift</h1>

<p>```</p>

<p>続いて、署名を検証します。</p>

<p>```javascript</p>

<h1>gpg &mdash;verify swift-3.1-RELEASE-ubuntu16.04.tar.gz.sig</h1>

<p>gpg: assuming signed data in `swift-3.1-RELEASE-ubuntu16.04.tar.gz'
gpg: Signature made Tue Mar 28 07:36:36 2017 UTC using RSA key ID 91D306C6
gpg: Good signature from &ldquo;Swift 3.x Release Signing Key <a href="&#109;&#x61;&#x69;&#108;&#x74;&#x6f;&#x3a;&#x73;&#x77;&#x69;&#102;&#116;&#x2d;&#x69;&#x6e;&#x66;&#x72;&#x61;&#115;&#116;&#114;&#117;&#x63;&#116;&#117;&#114;&#x65;&#64;&#115;&#x77;&#105;&#x66;&#116;&#x2e;&#x6f;&#x72;&#x67;">&#115;&#119;&#105;&#102;&#116;&#45;&#x69;&#x6e;&#x66;&#114;&#97;&#115;&#x74;&#x72;&#x75;&#x63;&#116;&#x75;&#114;&#101;&#64;&#115;&#x77;&#x69;&#x66;&#116;&#x2e;&#111;&#x72;&#x67;</a>&rdquo;
gpg: WARNING: This key is not certified with a trusted signature!
gpg:          There is no indication that the signature belongs to the owner.
Primary key fingerprint: A3BA FD35 56A5 9079 C068  94BD 63BC 1CFE 91D3 06C6
```</p>

<p>正しいSwiftパッケージであることがわかります。</p>

<p>１０．パッケージを展開する</p>

<p>パッケージは圧縮されているので展開しましょう。</p>

<p>```javascript</p>

<h1>tar xzf swift-3.1-RELEASE-ubuntu16.04.tar.gz</h1>

<p>```</p>

<p>１１．パスを通す</p>

<p>さて、DLしたパッケージに対して検索パスを設定する必要があります。<br/>
Dockerコンテナには環境設定ファイルとして<code>.dockerenv</code>があるのでこちらにパスを記載します。</p>

<p>```javascript
// 解凍フォルダの名前が長いので名称を変更する</p>

<h1>mv swift-3.1-RELEASE-ubuntu16.04 swift</h1>

<p>// ファイルを開く</p>

<h1>vi .dockerenv</h1>

<p>// 下記のようにパスを書く
export PATH=/swift/usr/bin:&ldquo;${PATH}&rdquo;</p>

<p>// 環境設定を更新する</p>

<h1>source .dockerenv</h1>

<p>// 検索パスが通ったことを確認する</p>

<h1>which swift</h1>

<p>/swift/usr/bin/swift</p>

<h1>swift &mdash;version</h1>

<p>Swift version 3.1 (swift-3.1-RELEASE)
Target: x86_64-unknown-linux-gnu
```</p>

<p>１２．必要なモジュールをインストールする</p>

<p>このままで<code>swift</code>コマンドを叩いても下記のようにエラーが表示されます。</p>

<p><code>javascript
/swift/usr/bin/lldb: error while loading shared libraries: libedit.so.2: cannot open shared object file: No such file or directory
</code></p>

<p>どうやら必要なモジュールが足りないようですね&hellip;<br/>
ということで下記をインストールしましょう。</p>

<p>```javascript</p>

<h1>apt-get install libedit-dev</h1>

<h1>apt-get install libpython-dev</h1>

<h1>apt-get install libxml2-dev</h1>

<p>```</p>

<p>これで<code>swift</code>コマンドを実行できるようになります。<br/>
ついでに<code>Hello World</code>まで出力してみます。</p>

<p>```javascript</p>

<h1>swift</h1>

<p>Welcome to Swift version 3.1 (swift-3.1-RELEASE). Type :help for assistance.
  1> print(&ldquo;Hello, world!&rdquo;)
Hello, world!
```</p>

<h3>PerfectでSwiftサーバを立てよう！</h3>

<p>今回もSwiftサーバを立てるために<a href="https://github.com/PerfectlySoft/Perfect">Perfect</a>を利用します。<br/>
下記手順に従って進めましょう。</p>

<p>１．<code>git</code>をインストールする<br/>
まずは<code>Perfect</code>を<code>git</code>経由でダウンロードする必要があるので<code>git</code>をインストールしましょう。</p>

<p>```javascript</p>

<h1>apt-get install git</h1>

<p>```</p>

<p>２．<code>PerfectTemplate</code>をダウンロードする<br/>
簡潔にSwiftサーバを立てたいので<code>PerfectTemplate</code>をダウンロードします。</p>

<p>```javascript</p>

<h1>git clone <a href="https://github.com/PerfectlySoft/PerfectTemplate.git">https://github.com/PerfectlySoft/PerfectTemplate.git</a></h1>

<p>```</p>

<p>３．必要モジュールをインストールする<br/>
PerfectのGet Startedに書かれている通り、次の必要なモジュールをインストールします。</p>

<p>```javascript</p>

<h1>apt-get install openssl libssl-dev uuid-dev</h1>

<p>```</p>

<p>４．不足モジュールをインストールする<br/>
このままだと<code>swift build</code>実行しても下記エラーが出てしまいました。</p>

<p><code>javascript
error while loading shared libraries: libcurl.so.4: cannot open shared object file: No such file or directory
</code></p>

<p>上記解決のためにモジュールをインストールしましょう。</p>

<p>```javascript</p>

<h1>apt-get install libcurl4-openssl-dev</h1>

<p>```</p>

<p>５．<code>swift build</code>を実行する<br/>
さて、ビルドしましょう。</p>

<p>```javascript</p>

<h1>cd PerfectTemplate</h1>

<h1>swift build</h1>

<p>```</p>

<p>６．Swiftサーバを起動する<br/>
後は下記コマンドでSwiftサーバを起動しましょう。</p>

<p>```javascript</p>

<h1>.build/debug/PerfectTemplate</h1>

<p>[INFO] Starting HTTP server localhost on 0.0.0.0:8080
[INFO] Starting HTTP server localhost on 0.0.0.0:8181
```</p>

<p><img src="/images/docker_swift_3.png" alt="Swiftサーバにアクセス" /></p>

<h3>まとめ</h3>

<p>さていかがでしたでしょうか？<br/>
筆者個人としては、途中で何回かハマったものの、DockerコンテナのUbuntuにSwiftサーバを立てられたことに満足できました。<br/>
今回はサーバを立てるという基本的なものでしたが、今度はWeb APIを作成して、iOSアプリからアクセスしてみたりなど遊んでみたいと思います。</p>

<p>と言ったところで本日はここまで。</p>

<p>参考:</p>

<ul>
<li><a href="https://www.twilio.com/blog/2015/12/getting-started-with-swift-on-linux.html">Getting Started with Swift on Linux</a></li>
<li><a href="http://qiita.com/yonell/items/79bf4ee3cd65f69903ec">Ubuntu上でSwiftサーバーサイドフレームワークのPerfectを動かしてみた</a></li>
</ul>


<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SwinjectでDIを意識してみよう！]]></title>
    <link href="http://grandbig.github.io/blog/2017/04/09/swift-di/"/>
    <updated>2017-04-09T22:51:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2017/04/09/swift-di</id>
    <content type="html"><![CDATA[<h3>はじめに</h3>

<p>筆者はここ１年間、主にバックエンド構築にSpring Bootを利用してきました。<br/>
Spring Framework自体は2002年頃にリリースされたそうなのですが、Spring BootはSpringベースでのアプリ開発を楽にしてくれる新たな形で様々なSpringのFramework群を統合したものとのことです。<br/>
(Spring Bootでググると2〜3年前辺りからの記事が多い印象です。)</p>

<p>Springの特徴は何と言っても <strong>DI</strong> でしょう。<br/>
今回はそのSpringの代名詞とも言える <strong>DI</strong> をSwiftで扱ってみたいと思います。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h3>DIとは</h3>

<p>DIとは『Dependency Injection』の略語で、日本語だと依存性の注入と翻訳されたりします。<br/>
具体的に何者なのかと言うと、</p>

<ul>
<li>コンポーネント間の依存関係を排除するソフトウェアパターン (<a href="https://ja.wikipedia.org/wiki/%E4%BE%9D%E5%AD%98%E6%80%A7%E3%81%AE%E6%B3%A8%E5%85%A5">Wikipedia &ndash; 依存性の注入</a>)</li>
<li>これにより疎結合性が高まるので単体テストが書きやすい</li>
</ul>


<p>というものです。</p>

<p>Springベースのアプリでは基本パターンとして利用しています。<br/>
詳しい説明は省きますが、<br/>
Spring起動時に<code>Bean</code>化したオブジェクトを<code>@Autowired</code>アノテーションを利用することで、DIコンテナ経由で簡単に <strong>DI</strong> を利用することができます。</p>

<p>注意しておきたいこととして、<br/>
<code>Bean</code>定義したクラスは<code>@Autowired</code>アノテーションで呼び出される際、デフォルトでシングルトンパターンとして生成されたオブジェクトを呼び出しています。</p>

<h3>SwiftでDIするには？</h3>

<p>さて、そんなSpringの特徴的なDIですが、Swiftアプリで利用することはできるのでしょうか？<br/>
筆者が調べたところ、最も人気のあるSwift版DIライブラリとして<a href="https://github.com/Swinject/Swinject">Swinject</a>というものがあるようです。<br/>
本日時点でGitHub上のスター数が<code>1,432</code>となっており、なかなかの注目度かと思います。</p>

<p>しかも、下記のようにSwift3にも対応しているのが嬉しいですね！</p>

<p><code>objective-c
iOS 8.0+ / Mac OS X 10.10+ / watchOS 2.0+ / tvOS 9.0+
Swift 2.2 or 2.3
Xcode 7.0+
Swift 3
Xcode 8.0+
Carthage 0.18+ (if you use)
CocoaPods 1.1.1+ (if you use)
</code></p>

<p>実際に<code>Swinject</code>を利用してSwiftでのDIを試してみたいと思います。</p>

<h3>Swinjectの使い方</h3>

<p>では早速使ってみましょう。</p>

<h4>Swinjectのインストール</h4>

<p>CocoaPodsでインストールするために下記のように<code>Podfile</code>を作成しましょう。</p>

<p>```
// Podfile
source &lsquo;<a href="https://github.com/CocoaPods/Specs.git">https://github.com/CocoaPods/Specs.git</a>&rsquo;
platform :ios, &lsquo;8.0&rsquo; # or platform :osx, &lsquo;10.10&rsquo; if your target is OS X.</p>

<p>target &lsquo;SwinjectSample&rsquo; do
  use_frameworks!</p>

<p>  pod &lsquo;Swinject&rsquo;, &lsquo;~> 2.0.0&rsquo;
  pod &lsquo;SwinjectStoryboard&rsquo;, &lsquo;1.0.0&rsquo;
end
```</p>

<p>その後に<code>pod install</code>を実行しましょう。<br/>
これで<code>Swinject</code>の用意は完了です。</p>

<h4>DIしたいクラスの定義</h4>

<p>サンプルとしてDIしたいクラスを定義します。<br/>
具体的なクラスだけでなく <strong>プロトコル</strong> を定義しているのは、<br/>
後々、同じような<code>JavaProgrammer</code>クラスを作成したくなった際に便利だからです。<br/>
(ベースが同じで、拡張機能が必要になった際に、0から書き直す必要がなくなります。)</p>

<p>```objective-c
// Engineer.swift
import Foundation</p>

<p>protocol Engineer {</p>

<pre><code>var name: String? { get set }
func develop() -&gt; String
</code></pre>

<p>}</p>

<p>class SwiftProgrammer: Engineer {</p>

<pre><code>var name: String?

init(name: String?) {
    self.name = name
}

func develop() -&gt; String {
    return "Let's start developing a swift application!"
}
</code></pre>

<p>}
```</p>

<p>続いて、先程作成した<code>Engineer</code>を参照する<code>CompanyOwner</code>クラスを作成します。</p>

<p>```objective-c
// Company.swift
import Foundation</p>

<p>protocol Person {</p>

<pre><code>func hire() -&gt; String
</code></pre>

<p>}</p>

<p>class CompanyOwner: Person {</p>

<pre><code>let humanResource: Engineer

init(humanResource: Engineer) {
    self.humanResource = humanResource
}

func hire() -&gt; String {
    let name = humanResource.name ?? "someone"
    return "I'm hiring \(name). \(humanResource.develop())"
}
</code></pre>

<p>}
```</p>

<p>ここで<code>SwiftProgrammer</code>クラスでなく<code>Engineer</code>プロトコルを参照することで、<code>CompanyOwner</code>クラス自体が<code>SwiftProgrammer</code>クラスに依存することがなくなりました。<br/>
つまり<code>JavaProgrammer</code>を雇いたい<code>CompanyOwner</code>クラスが必要になった場合、作成するのは<code>JavaProgrammer</code>クラスのみで良くなります。<br/>
これはこれで<code>CompanyOwner</code>クラスに対して単体テストコードを書く時に<code>SwiftProgrammer</code>クラスに依存せずに書くことができます。</p>

<h4>DIコンテナへのクラスの登録</h4>

<p>さて、DIしたいクラスが定義できたので、そのクラスをDIコンテナに登録します。<br/>
公式ページによると<code>SwinjectStoryboard</code>を利用する場合と利用しない場合の2種類の方法があるそうですが、今回は簡単に対応可能な<code>SwinjectStoryboard</code>利用する方法で書いてみます。</p>

<p>サンプルとして、<code>ViewController.swift</code>でDIコンテナ経由で呼び出したクラスを利用したいとします。<br/>
その場合、下記のように、<code>ViewController.swift</code>にコンテナ定義を書きます。</p>

<p>```objective-c
// ViewController.swift
import UIKit
import SwinjectStoryboard</p>

<p>extension SwinjectStoryboard {</p>

<pre><code>class func setup() {
    // (1)
    defaultContainer.register(Engineer.self) { _ in SwiftProgrammer(name: "Takahiro") }
    // (2)
    defaultContainer.register(Person.self) { r in
        CompanyOwner(humanResource: r.resolve(Engineer.self)!)
    }
    // (3)
    defaultContainer.storyboardInitCompleted(ViewController.self) { r, c in
        c.person = r.resolve(Person.self)
    }
}
</code></pre>

<p>}
&hellip;
```</p>

<p>順々に説明すると、</p>

<ol>
<li><code>defaultContainer</code>に<code>Engineer</code>指定で<code>SwiftProgrammer(name: "Takahiro")</code>が呼び出されるように登録</li>
<li><code>defaultContainer</code>に<code>Person</code>指定で<code>CompanyOwner(humanResource: r.resolve(Engineer.self)!)</code>が呼び出されるように登録<br/>
※ 1で<code>Engineer</code>指定で<code>SwiftProgrammer(name: "Takahiro")</code>呼び出しをセットしているので、それが2の<code>CompanyOwner</code>の引数にセットされます。</li>
<li><code>defaultContainer</code>にDIコンテナ経由での呼び出し先と先ほどまで定義していた<code>Person</code>指定での呼び出し元を紐付け</li>
</ol>


<p>となっています。<br/>
これにより、下記のように<code>ViewController.swift</code>内でDIコンテナ経由で<code>Person</code>指定で想定した処理を呼び出すことができます。</p>

<p>```objective-c
// ViewController.swift</p>

<p>class ViewController: UIViewController {</p>

<pre><code>var person: Person?

override func viewDidLoad() {
    super.viewDidLoad()
    // Do any additional setup after loading the view, typically from a nib.
    print(person?.hire() ?? "I can't hire engineers.")
}

override func didReceiveMemoryWarning() {
    super.didReceiveMemoryWarning()
    // Dispose of any resources that can be recreated.
}
</code></pre>

<p>}
```</p>

<p>上記を見ると、<code>ViewController</code>クラスの中で<code>Person</code>をインスタンス化している箇所はないことがわかると思います。<br/>
つまり、DIコンテナ経由で<code>Person</code>を呼び出せているわけですね。</p>

<h3>まとめ</h3>

<p>さて、<code>Swinject</code>を利用してサンプルを書いてみた感想ですが&hellip;<br/>
正直、Spring Bootと比較すると、Swiftでは手動で書くべきところが多いと感じました。<br/>
また、様々な<code>UIViewController</code>にまたがって利用する場合は記載箇所に一工夫必要なのかなとも思いました。<br/>
(毎回、全<code>UIViewController</code>系のファイルに<code>setUp()</code>を書くわけにもいかないと思いますし&hellip;)</p>

<p>まだまだ未知数なところがあるので、継続して試してみたいところではあります。<br/>
と言ったところで本日はここまで。</p>

<p>参考：</p>

<ul>
<li><a href="http://permanent-til.me/archives/613">Spring BeanはSingletonだから、状態持たせるとバグるよ。</a></li>
<li><a href="http://qiita.com/chkkchy/items/5f59817beb3dff9c0c1e">SpringのDIとnewってなにがちがうんだっけ？</a></li>
<li><a href="https://github.com/Swinject/Swinject">Swinject</a></li>
<li><a href="http://dev.classmethod.jp/smartphone/swinject-dependency-injection/">Swinjectを使ったDependency Injection</a></li>
</ul>


<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Notificationとメインスレッド/サブスレッド]]></title>
    <link href="http://grandbig.github.io/blog/2017/02/12/notification-and-thread/"/>
    <updated>2017-02-12T17:15:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2017/02/12/notification-and-thread</id>
    <content type="html"><![CDATA[<h3>はじめに</h3>

<p>今日は久々にiOS関連の話を書きたいと思います。<br/>
正直なところSwiftを触って思ったのですが、今やXcodeではSwift3が標準装備されているため書き方が変わっており、業務で触らないまでも遅れを取らないように勉強しなきゃな&hellip;なんて感じてしまいました。</p>

<p>本日のお題は<br/>
『<code>Notification</code>はメインスレッド/サブスレッドのどちらで実行されるのか』<br/>
という話です。</p>

<p>筆者の理解では、普通に使う限りメインスレッドだと思っていたのですが、「使い方に寄るのでは？」なんて話題が上がったこともあって、調べてみたくなりました。<br/>
その調べ方と調査結果を書いていきます。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h3>Notificationとは</h3>

<p>まずは、<code>Notification</code>とは何かという話から始めましょう。<br/>
その名の通り、アプリ内で通知を行う仕組みを実装するために利用します。<br/>
少し前までは<code>NSNotification</code>という名前でしたので、こちらの名前の方がしっくりくるiOSエンジニアの方々は多いのではないでしょうか。</p>

<p>使い方は非常に簡単です。</p>

<p>１．監視対象のメソッドを登録する</p>

<p><img src="/images/notification_1.png" alt="監視対象のメソッドを登録" /></p>

<p><code>objective-c
// 登録時にはaddObserverメソッドを利用する
NotificationCenter.default.addObserver(self, selector: #selector(self.doSomething), name: NSNotification.Name("SomeNotification"), object: nil)
</code></p>

<p>２．監視対象メソッドの呼び出しを要求する</p>

<p><img src="/images/notification_2.png" alt="監視対象メソッドの呼び出し要求" /></p>

<p><code>objective-c
// 呼び出し要求時にはpostメソッドを利用する
NotificationCenter.default.post(name: NSNotification.Name("SomeNotification"), object: nil)
</code></p>

<p>３．監視対象メソッドを実行する</p>

<p><img src="/images/notification_3.png" alt="監視対象メソッドを実行" /></p>

<h3>Notificationとメインスレッド/サブスレッドの調査</h3>

<p>さて、本題に入ります。<br/>
<code>Notification</code>はメインスレッド/サブスレッドどちらで実行されるのでしょうか。</p>

<h4>普通に呼び出す場合</h4>

<p>まずは特異なことをせず、普通に実行してみます。<br/>
要件としては下記になります。</p>

<ul>
<li>アプリ起動時に<code>doSomething</code>メソッドを<code>NotificationCenter</code>に登録する</li>
<li>ボタンタップ時に<code>doSomething</code>メソッドの呼び出しを要求する</li>
<li><code>doSomething</code>メソッド内でメインスレッド/サブスレッドの判定処理を実行する</li>
</ul>


<p>ソースコードは下記となります。</p>

<p>```objective-c
// ViewController.swift
import UIKit</p>

<p>class ViewController: UIViewController {</p>

<pre><code>override func viewDidLoad() {
    super.viewDidLoad()
    NotificationCenter.default.addObserver(self, selector: #selector(doSomething), name: NSNotification.Name("SomeNotification"), object: nil)
}

override func didReceiveMemoryWarning() {
    super.didReceiveMemoryWarning()
}

func doSomething() {
    print("このメソッドは\(Thread.isMainThread)で動いています。(false: サブスレッド, true: メインスレッド)")
}
@IBAction func checkThread(_ sender: Any) {
    NotificationCenter.default.post(name: NSNotification.Name("SomeNotification"), object: nil)
}
</code></pre>

<p>}
```</p>

<p>結果は「呼び出し先の処理実行は <strong>メインスレッド</strong> 」となりました。</p>

<h4>GCDを利用して、サブスレッド内でメソッドを呼び出す</h4>

<p>次はサブスレッドで監視対象メソッドの呼び出し要求を実施します。<br/>
ソースコードは下記の通りです。</p>

<p>```objective-c
import UIKit</p>

<p>class ViewController: UIViewController {</p>

<pre><code>override func viewDidLoad() {
    super.viewDidLoad()
    NotificationCenter.default.addObserver(self, selector: #selector(doSomething), name: NSNotification.Name("SomeNotification"), object: nil)
}

override func didReceiveMemoryWarning() {
    super.didReceiveMemoryWarning()
}

func doSomething() {
    print("このメソッドは\(Thread.isMainThread)で動いています。(0: サブスレッド, 1: メインスレッド)")
}
@IBAction func checkThread(_ sender: Any) {
    DispatchQueue.global().async {
        NotificationCenter.default.post(name: NSNotification.Name("SomeNotification"), object: nil)
    }
}
</code></pre>

<p>}
```</p>

<p>結果は「呼び出し先の処理実行は <strong>サブスレッド</strong> 」となりました。</p>

<h4>GCDを利用して、メインスレッド内でメソッドを呼び出す</h4>

<p>今度はGCDを利用したメインスレッド内で監視対象メソッドの呼び出し要求を実施してみます。<br/>
ソースコードは下記の通りです。</p>

<p>```objective-c
import UIKit</p>

<p>class ViewController: UIViewController {</p>

<pre><code>override func viewDidLoad() {
    super.viewDidLoad()NotificationCenter.default.addObserver(self, selector: #selector(doSomething), name: NSNotification.Name("SomeNotification"), object: nil)
}

override func didReceiveMemoryWarning() {
    super.didReceiveMemoryWarning()
}

func doSomething() {
    print("このメソッドは\(Thread.isMainThread)で動いています。(0: サブスレッド, 1: メインスレッド)")
}
@IBAction func checkThread(_ sender: Any) {
    DispatchQueue.global().async {
        DispatchQueue.main.async {
            NotificationCenter.default.post(name: NSNotification.Name("SomeNotification"), object: nil)
        }
    }
}
</code></pre>

<p>}
```</p>

<p>結果は「呼び出し先の処理実行は <strong>メインスレッド</strong> 」となりました。</p>

<h3>まとめ</h3>

<p>調査結果をまとめると次の通りです。</p>

<p>「要求 <strong>元</strong> と <strong>同じスレッド</strong> で監視対象メソッドは実行されます。」<br/>
※登録時(<code>addObserver</code>)のスレッドは無関係です。</p>

<p>さて如何でしたでしょうか？<br/>
普段考えずに利用している様々な処理が実際にはどのスレッドで実行されるのか、どういった書き方をするとどのスレッドで実行されうるのか調べてみることも面白いですね。<br/>
ふとしたときにまた調べてみようと思います。<br/>
と言ったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ReSwiftを勉強してみよう！(2)]]></title>
    <link href="http://grandbig.github.io/blog/2016/12/06/reswift-2/"/>
    <updated>2016-12-06T00:00:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2016/12/06/reswift-2</id>
    <content type="html"><![CDATA[<h3>はじめに</h3>

<p>こちらは<a href="http://qiita.com/advent-calendar/2016/ios2">iOS その2 Advent Calendar 2016</a> 6日目の記事です。</p>

<p>今年は仕事でiOSを触る機会がめっきりと減ってしまったのですが、<br/>
「やはり１年を振り返るのならiOS Advent Calendarは欠かせないでしょう」ということで投稿することにしました。</p>

<p>最近、筆者が仕事で着手し始めた <strong>Redux</strong> に関連するということで <strong>ReSwift</strong> について見ていきたいと思います。<br/>
タイトルが <strong>(2)</strong> になっているのは、<br/>
以前に興味を持って自主的に取り組んでみた<a href="http://grandbig.github.io/blog/2016/09/03/reswift-1/">ReSwiftを勉強してみよう！(1)</a>の続きという意味です。<br/>
しかし、Advent Calendarの記事でもあるので本記事のみで完結する形で書きたいと思います。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<p>今回は公式GitHubに上がっている<a href="https://github.com/ReSwift/CounterExample-Navigation-TimeTravel">CounterExample-Navigation-TimeTravel</a>を元にReSwiftを勉強していきたいと思います。</p>

<h3>ReSwiftに出てくるモノと役割</h3>

<p>ReSwiftに出てくるモノと役割について改めて見直しをしてみましょう。</p>

<ul>
<li>Store

<ul>
<li>アプリ内で必ず1つの存在</li>
<li>アプリの状態を管理する</li>
<li>Stateを更新するための<code>dispatch</code>を提供する

<ul>
<li>言い換えれば<code>dispatch(action)</code>をすることでStoreにStateの変更を知らせられる</li>
</ul>
</li>
<li>Stateの状態を追えるように<code>subscribe</code>を提供する

<ul>
<li>言い換えれば<code>subscribe(listener)</code>をすることでlistenerは<code>getState</code>を通してStateの状態を取得できる</li>
</ul>
</li>
</ul>
</li>
</ul>


<p>サンプルでは下記が該当します。<br/>
Storeの宣言は下記のようになります。</p>

<p>```objective-c
// AppDelegate.swift
var mainStore = RecordingMainStore<AppState>(</p>

<pre><code>  reducer: AppReducer(),
  state: nil,
  typeMaps:[counterActionTypeMap, ReSwiftRouter.typeMap],
  recording: "recording.json"
</code></pre>

<p>)
```</p>

<p>このサンプルでは<a href="https://github.com/ReSwift/ReSwift-Recorder">ReSwiftRecorder</a>モジュールを利用しているため通常のStore宣言とは異なります。<br/>
ですが、重要なのは、<code>reducer</code>に<code>AppReducer()</code>を指定していることと、Storeが管理するStateの初期値を<code>state: nil</code>としているということです。</p>

<ul>
<li>State

<ul>
<li>アプリの状態</li>
</ul>
</li>
</ul>


<p>サンプルでは下記の通りです。</p>

<p>```objective-c
// AppState.swift
struct AppState: StateType, HasNavigationState {</p>

<pre><code>var counter: Int
var navigationState: NavigationState
</code></pre>

<p>}
```</p>

<p>サンプルでは<code>CounterViewController</code>でカウント数の増加および減少をさせる処理が実装されており、<br/>
<code>tabBarController</code>や<code>Button</code>のアクションなどで表示される画面を切り替える処理が実装されているため上記のように<code>counter</code>と<code>navigationState</code>の2つでアプリの状態を表すと定義しています。</p>

<ul>
<li>Action

<ul>
<li>何をするアクションなのかを表すオブジェクト</li>
<li><code>type</code>プロパティを必ず持つ</li>
</ul>
</li>
<li>ActionCreator

<ul>
<li>Actionを作成するメソッド</li>
</ul>
</li>
</ul>


<p>サンプルでは下記の通りです。</p>

<p>```objective-c
// CounterAction.swift
struct CounterActionIncrease: StandardActionConvertible {</p>

<pre><code>static let type = "COUNTER_ACTION_INCREASE"

init() {}
init(_ standardAction: StandardAction) {}

func toStandardAction() -&gt; StandardAction {
    return StandardAction(type: CounterActionIncrease.type, payload: [:], isTypedAction: true)
}
</code></pre>

<p>}
```</p>

<p>サンプルの<code>CounterAction.swift</code>の<code>CounterActionIncrease</code>はActionおよびActionCreatorの役割を兼ねています。</p>

<ul>
<li>Reducer

<ul>
<li>ActionとStateから新たなStateを作成して返す</li>
<li>ポイントはStateを更新するのではなく、 <strong>新しく作成したState</strong> を返すということ</li>
</ul>
</li>
</ul>


<p>サンプルでは下記の通りです。</p>

<p>```objective-c
// CounterReducer.swift
struct AppReducer: Reducer {</p>

<pre><code>func handleAction(action: Action, state: AppState?) -&gt; AppState {
    return AppState(
        counter: counterReducer(action: action, counter: state?.counter),
        navigationState: NavigationReducer.handleAction(action, state: state?.navigationState)
    )
}
</code></pre>

<p>}</p>

<p>func counterReducer(action: Action, counter: Int?) &ndash;> Int {</p>

<pre><code>var counter = counter ?? 0

switch action {
case _ as CounterActionIncrease:
    counter += 1
case _ as CounterActionDecrease:
    counter -= 1
default:
    break
}

return counter
</code></pre>

<p>}
```</p>

<p>サンプルでは、<code>handleAction</code>メソッドで「引数として受け取った<code>action</code>と<code>state</code>から作成した<code>AppState</code>を返却」しています。<br/>
カウントアップの処理がReducerに伝わった場合には、<br/>
<code>counterReducer</code>メソッドでそのActionに合わせて新たに必要なStateの情報を生成しています。<br/>
(カウントアップの場合は<code>CounterActionIncrease</code>アクションなので<code>counter += 1</code>しています。)</p>

<h3>ReSwiftに出てくるモノ同士の連携</h3>

<p>1個1個のモノと役割については理解が進みました。<br/>
続いて、それらの連携について見ていきましょう。<br/>
そのためには<code>ViewController</code>を見ていくのがわかりやすいかなと思います。</p>

<h4>カウントアップ・ダウンに見る連携</h4>

<p>まずは<code>CounterViewController</code>ですが、<br/>
「+」や「-」ボタンをタップすることで画面中央に表示されたカウントを増減させる画面です。</p>

<p>```objective-c
// CounterViewController.swift
import UIKit
import ReSwift
import ReSwiftRouter</p>

<p>class CounterViewController: UIViewController, StoreSubscriber, Routable {</p>

<p>  static let identifier = &ldquo;CounterViewController&rdquo;</p>

<p>  @IBOutlet var counterLabel: UILabel!</p>

<p>  override func viewWillAppear(_ animated: Bool) {</p>

<pre><code>mainStore.subscribe(self)
</code></pre>

<p>  }</p>

<p>  override func viewWillDisappear(_ animated: Bool) {</p>

<pre><code>mainStore.unsubscribe(self)
</code></pre>

<p>  }</p>

<p>  func newState(state: AppState) {</p>

<pre><code>// 新規Stateをキャッチ
// 画面のラベルを更新
counterLabel.text = "\(state.counter)"
</code></pre>

<p>  }</p>

<p>  @IBAction func increaseButtonTapped(_ sender: Any) {</p>

<pre><code>mainStore.dispatch(
  CounterActionIncrease()
)
</code></pre>

<p>  }</p>

<p>  @IBAction func decreaseButtonTapped(_ sender: Any) {</p>

<pre><code>mainStore.dispatch(
  CounterActionDecrease()
)
</code></pre>

<p>  }
}
```</p>

<p>細かく見ていきましょう。<br/>
Storeの役割で説明した「Stateの状態を追えるように<code>subscribe</code>を提供する」に相当する部分が、</p>

<p>```objective-c
override func viewWillAppear(_ animated: Bool) {
  mainStore.subscribe(self)
}</p>

<p>override func viewWillDisappear(_ animated: Bool) {
  mainStore.unsubscribe(self)
}
```</p>

<p>になります。<br/>
<code>viewWillAppear</code>で<code>subscribe</code>を実行することで、その画面が表示されるときにStateの監視を開始して、<code>viewWillDisappear</code>で<code>unsubscribe</code>を実行することで、その画面が非表示になるときにStateの監視を終了することにしています。</p>

<p>また、「Stateを更新するための<code>dispatch</code>を提供する」に相当する部分が、</p>

<p>```objective-c
@IBAction func increaseButtonTapped(_ sender: Any) {
  mainStore.dispatch(</p>

<pre><code>CounterActionIncrease()
</code></pre>

<p>  )
}</p>

<p>@IBAction func decreaseButtonTapped(_ sender: Any) {
  mainStore.dispatch(</p>

<pre><code>CounterActionDecrease()
</code></pre>

<p>  )
}
```</p>

<p>になります。<br/>
ユーザが「+」ボタンをタップしたときに<code>increaseButtonTapped</code>が呼び出されます。<br/>
そのときに上記アクションが実行されたことを<code>dispatch</code>を実行することでStoreに知らせています。<br/>
<code>decreaseButtonTapped</code>も同様です。</p>

<h4>画面切り替えに見る連携</h4>

<p>続いて<code>tabBarController</code>による画面の切り替えですが、これもこのサンプルでは状態変化として扱っています。<br/>
ただし、<code>ReSwiftRouter</code>モジュールで役割を担っているので、これを利用すれば開発者が新たに書く部分は非常に少なくなります。</p>

<p><code>UITabBarControllerDelegate</code>を利用してタブをタップしたタイミングをキャッチします。
そのときに、<code>ReSwiftRouter</code>の<code>SetRouteAction</code>を利用してタブによる画面切り替えのアクションをStoreに伝えています。</p>

<p>```objective-c
// AppDelegate.swift
extension AppDelegate: UITabBarControllerDelegate {</p>

<p>  func tabBarController(_ tabBarController: UITabBarController,</p>

<pre><code>shouldSelect viewController: UIViewController) -&gt; Bool {

if viewController is CounterViewController {

  mainStore.dispatch(
    SetRouteAction(["TabBarViewController", CounterViewController.identifier])
  )
} else if viewController is StatsViewController {
  mainStore.dispatch(
    SetRouteAction(["TabBarViewController", StatsViewController.identifier])
  )
}
    return false
</code></pre>

<p>  }
}
```</p>

<p>因みに、<code>SetRouteAction</code>は下記のように定義されています。</p>

<p>```objective-c
public struct SetRouteAction: StandardActionConvertible {</p>

<p>  let route: Route
  let animated: Bool
  public static let type = &ldquo;RE_SWIFT_ROUTER_SET_ROUTE&rdquo;</p>

<p>  public init (_ route: Route, animated: Bool = true) {</p>

<pre><code>self.route = route
self.animated = animated
</code></pre>

<p>  }</p>

<p>  public init(_ action: StandardAction) {</p>

<pre><code>self.route = action.payload!["route"] as! Route
self.animated = action.payload!["animated"] as! Bool
</code></pre>

<p>  }</p>

<p>  public func toStandardAction() &ndash;> StandardAction {</p>

<pre><code>return StandardAction(
  type: SetRouteAction.type,
  payload: ["route": route as AnyObject, "animated": animated as AnyObject],
  isTypedAction: true
)
</code></pre>

<p>  }<br/>
}
```</p>

<p>中身を見てみると<code>CounterAction</code>と同様に<code>toStandardAction</code>を利用しているのがわかります。<br/>
デバッグしていくとわかりますが、<code>tabBarController</code>を通した画面の切り替えでは、カウントアップやカウントダウンは無関係であるため<code>AppReducer</code>ではcountの状態を増減させることはありません。<br/>
変化するのは<code>AppState.navigationState</code>のみです。<br/>
こちらも追っていくとわかるのですが、下記の<code>NavigationReducer</code>に処理が引き継がれています。</p>

<p>```objective-c
public struct NavigationReducer {</p>

<p>  public static func handleAction(_ action: Action, state: NavigationState?) &ndash;> NavigationState {</p>

<pre><code>let state = state ?? NavigationState()

switch action {
case let action as SetRouteAction:
  return setRoute(state, setRouteAction: action)
case let action as SetRouteSpecificData:
  return setRouteSpecificData(state, route: action.route, data: action.data)
default:
  break
}

return state
</code></pre>

<p>  }</p>

<p>  static func setRoute(_ state: NavigationState, setRouteAction: SetRouteAction) &ndash;> NavigationState {</p>

<pre><code>var state = state

state.route = setRouteAction.route
state.changeRouteAnimated = setRouteAction.animated

return state
</code></pre>

<p>  }</p>

<pre><code>&lt;省略&gt;
</code></pre>

<p>}
```</p>

<p>このように、<code>NavigationReducer</code>の中で<code>NavigationState</code>型のオブジェクトを生成して返しています。<br/>
なので、アプリの状態である<code>AppState</code>が持つのは、</p>

<ul>
<li>counter: アプリのカウント状態</li>
<li>navigationState: アプリの画面状態</li>
</ul>


<p>と言えます。</p>

<h3>まとめ</h3>

<p>相変わらず、(流行っていないというのもあるかもしれませんが&hellip;)ReSwiftに関する日本語の記事が少ないですね。<br/>
恐らく、Web業界のようにFluxやReduxが実際のサービスに取り入れられているとは言い難いのでしょう。<br/>
その理由として考えられるのは、iOSの場合はデフォルトとしてStoryboardやViewControllerというものが存在し、Appleもそれをそのまま利用することを推奨しているからかもしれません。<br/>
しかしながら、複雑なアプリが世の中で求められるようになるに従って『ViewControllerの肥大化』や『複数人での開発による統一性の崩れ』といった課題により真剣に考えざるを得なくなってきました
。<br/>
必ずしも、これらの課題を解決するためにReSwiftを使わなければならないということはないのですが、1つの方法論として知っておくことで選択肢も増えてきます。<br/>
ただ、WebでReact&amp;Reduxを取り入れるのと同様に理解するためのハードルが高くもあるので現場で嫌がられることもあるかもしれません。<br/>
また、保守性として高いとは決して言えません。開発メンバーの入れ替えが発生したときにReSwiftを勉強するコストが発生します。<br/>
Webと違ってそこまで浸透しているとは言えないため、より導入が難しいと言えるでしょう。<br/>
ここにある種の矛盾が生じているわけですね&hellip;</p>

<p>筆者がちょうどReact&amp;Reduxに触れる機会が増えてきたため、良い機会だと思って、iOSでのReSwiftの利用メリットなどを合わせて考えていきたいと思っています。<br/>
そろそろ個人でのアプリ開発も復活させたい気持ちもありますし、その際には積極的に導入してみようかな&hellip;</p>

<p>と言ったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Server Side SwiftでMongoDBと遊んでみる]]></title>
    <link href="http://grandbig.github.io/blog/2016/12/05/swift-perfect-mongo/"/>
    <updated>2016-12-05T00:00:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2016/12/05/swift-perfect-mongo</id>
    <content type="html"><![CDATA[<h3>はじめに</h3>

<p>こちらは<a href="http://qiita.com/advent-calendar/2016/swift2">Swift その2 Advent Calendar 2016</a> 5日目の記事です。<br/>
今年は筆者が興味を持っている <strong>Server Side Swift</strong> について書きたいと思います。
Swiftサーバを立てるために、<a href="http://grandbig.github.io/blog/2016/10/30/swift-perfect/">以前の記事</a>でも利用した<a href="https://github.com/PerfectlySoft/Perfect">Perfect</a>を使います。</p>

<p>ただ単にSwiftサーバを立てても面白くないので、提供されているMongoDB接続モジュールを利用して遊んでみようと思います。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h3>SwiftによるAP・DBサーバの構築</h3>

<p>早速、Perfectを用いてSwiftによるAP・DBサーバを構築しようと思います。<br/>
基本的には<a href="https://github.com/PerfectlySoft/Perfect-MongoDB">ReadMe</a>に従えば良いのですが、丁寧に１つずつ見ていきます。</p>

<h4>必要モジュールのインストール</h4>

<p>流石に <strong>Homebrew</strong> はインストールされている方が多いと思いますが、入れていない方は下記コマンドで入れましょう。</p>

<p><code>
/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
</code></p>

<p>また今回は <strong>MongoDB</strong> を利用するため、 <strong>mongodb</strong> および <strong>mongo-c</strong> をインストールする必要があります。<br/>
mongodbに関しては、</p>

<p><code>
brew install mongodb
</code></p>

<p>でOKです。(自動起動などに関しては<a href="http://grandbig.github.io/blog/2016/11/20/brew-install-db/">こちら</a>を参照ください。)<br/>
続いて、mongo-cは</p>

<p><code>
brew install mongo-c
</code></p>

<p>でインストール完了できるはずです。</p>

<h4>xcodeprojを作成</h4>

<h5>テンプレートのダウンロード</h5>

<p>0からPerfectを用いてサーバを構築しても良いのですが、Perfectではテンプレートを用意してくれています。<br/>
せっかくなので <code>git clone</code> してテンプレートをダウンロードして使いましょう。</p>

<p><code>
git clone https://github.com/PerfectlySoft/PerfectTemplate.git
cd PerfectTemplate
</code></p>

<h5>MongoDBモジュールを利用するように編集</h5>

<p><strong>Perfect-MongoDB</strong> を利用するので、<code>Package.swift</code>を編集しましょう。</p>

<p>```objective-c
import PackageDescription</p>

<p>let package = Package(</p>

<pre><code>name: "PerfectTemplate",
targets: [],
dependencies: [
    .Package(url: "https://github.com/PerfectlySoft/Perfect-HTTPServer.git", majorVersion: 2, minor: 0),
    .Package(url:"https://github.com/PerfectlySoft/PerfectLib.git", majorVersion: 2, minor: 0),
    .Package(url:"https://github.com/PerfectlySoft/Perfect-MongoDB.git", majorVersion: 2, minor: 0)
]
</code></pre>

<p>)
```</p>

<p>ReadMeでは <strong>Perfect-HTTPServer</strong> は書かれていないのですが、これを使った方が便利なので、テンプレートに残したまま進めます。</p>

<h5>Packageからxcodeprojを作成</h5>

<p><code>Package.swift</code>の編集が終わったら、下記コマンドを実行して<code>xcodeproj</code>ファイルを作成しましょう。</p>

<p><code>
swift package generate-xcodeproj
</code></p>

<p>そうすれば下図のような結果が得られるはずです。</p>

<p><img src="/images/perfect-mongo_1.png" alt="フォルダ構成" /></p>

<h4>MongoDBにデータを作成</h4>

<p>サンプルを作成するためにもデータがなきゃ話になりませんよね？<br/>
ということでデータを入れましょう。</p>

<p>```
// MongoDBにアクセス
$ mongo</p>

<p>// DBとCollectionの作成</p>

<blockquote><p>use test;
db.createCollection(&lsquo;testCollection&rsquo;);
{ &ldquo;ok&rdquo; : 1 }</p></blockquote>

<p>// DBの確認</p>

<blockquote><p>show dbs;
local  0.000GB
test   0.000GB</p></blockquote>

<p>// Collectionの確認</p>

<blockquote><p>show collections
testCollection</p></blockquote>

<p>// データのインサート</p>

<blockquote><p>db.testCollection.insert({name: &lsquo;takahiro&rsquo;, age: 30, hobby: &lsquo;blog&rsquo;});
WriteResult({ &ldquo;nInserted&rdquo; : 1 })
db.testCollection.insert({name: &lsquo;ichiro&rsquo;, age: 43, hobby: &lsquo;baseball&rsquo;});
WriteResult({ &ldquo;nInserted&rdquo; : 1 })</p></blockquote>

<p>// データの確認</p>

<blockquote><p>db.testCollection.find()
{ &ldquo;<em>id&rdquo; : ObjectId(&ldquo;58391469a8589d99c931303c&rdquo;), &ldquo;name&rdquo; : &ldquo;takahiro&rdquo;, &ldquo;age&rdquo; : 30, &ldquo;hobby&rdquo; : &ldquo;blog&rdquo; }
{ &ldquo;</em>id&rdquo; : ObjectId(&ldquo;58392222a8589d99c931303d&rdquo;), &ldquo;name&rdquo; : &ldquo;ichiro&rdquo;, &ldquo;age&rdquo; : 43, &ldquo;hobby&rdquo; : &ldquo;baseball&rdquo; }
```</p></blockquote>

<h4>MongoDBにアクセスして全データを取得</h4>

<p>データの作成も完了したので、実際にGETリクエストでMongoDBからデータを取得する処理を書いてみましょう。<br/>
(ReadMeではPerfect-HTTPServerを利用しない方法で書かれていたため本記事とは若干異なります。)</p>

<h5>テンプレートファイルの確認</h5>

<p>まずは、初めから作成されている処理内容を確認します。<br/>
説明は下記ソースコードにコメントを書いたので参照ください。</p>

<p>```objective-c
// main.swift
import PerfectLib
import PerfectHTTP
import PerfectHTTPServer</p>

<p>// HTTPサーバの生成
let server = HTTPServer()</p>

<p>// リクエストに対するルーティングを設定
var routes = Routes()
routes.add(method: .get, uri: &ldquo;/&rdquo;, handler: {</p>

<pre><code>request, response in
// レスポンスヘッダーの設定
response.setHeader(.contentType, value: "text/html")
// レスポンスボディの設定
response.appendBody(string: "&lt;html&gt;&lt;title&gt;Hello, world!&lt;/title&gt;&lt;body&gt;Hello, world!&lt;/body&gt;&lt;/html&gt;")
// レスポンス完了処理
response.completed()
}
</code></pre>

<p>)</p>

<p>// サーバにルーティング設定を適用
server.addRoutes(routes)</p>

<p>// ポートを設定
server.serverPort = 8181</p>

<p>// ドキュメントルートのパスを設定
server.documentRoot = &ldquo;./webroot&rdquo;</p>

<p>// arguments.swiftで定義されているメソッド
// 更なるサーバ定義が必要な場合はここを見ましょう(SSLなど)
configureServer(server)</p>

<p>do {</p>

<pre><code>// HTTPサーバの起動
try server.start()
</code></pre>

<p>} catch PerfectError.networkError(let err, let msg) {</p>

<pre><code>print("Network error thrown: \(err) \(msg)")
</code></pre>

<p>}
```</p>

<p>上記をXcodeをからRunさせた状態で <code>http://localhost:8181</code> にアクセスしてみましょう。<br/>
Hello Worldの結果が得られるはずです。</p>

<p><img src="/images/perfect-mongo_2.png" alt="Hello World" /></p>

<h5>MongoDB関連処理ファイルの作成</h5>

<p>続いて、MongoDBへの接続・切断やデータ取得などの処理を作成していきます。<br/>
これは別クラスの中に書いていきましょう。</p>

<p>今回はMongoDB関連の処理をハンドリングするということで<code>mongoHandler.swift</code>というファイルを作成します。<br/>
因みにただ作成しただけでは、XcodeがCompile対象として正しく認識してくれないので、自身で設定を変えましょう。<br/>
下図のようにTARGETSから実行ファイルを選択して、Compile Sourcesとして<code>mongoHandler.swift</code>を追加してください。</p>

<p><img src="/images/perfect-mongo_3.png" alt="Compile Sourcesに追加" /></p>

<p>では実際のソースを見ていきましょう。</p>

<p>```objective-c
// mongoHandler.swift</p>

<p>import PerfectLib
import PerfectHTTP
import MongoDB</p>

<p>class MongoHandler {</p>

<p>  var client: MongoClient?
  var database: MongoDatabase?
  var collection: MongoCollection?</p>

<p>  // MongoDBへの接続処理
  fileprivate func connect() {</p>

<pre><code>// コネクション確立
client = try! MongoClient(uri: "mongodb://localhost")

// testデータベースへの接続
database = client?.getDatabase(name: "test")

// testCollectionコレクションへの接続
self.collection = database?.getCollection(name: "testCollection")
</code></pre>

<p>  }</p>

<p>  // MongoDBからの切断処理
  fileprivate func close() {</p>

<pre><code>collection?.close()
database?.close()
client?.close()
</code></pre>

<p>  }</p>

<p>  func searchAll(request: HTTPRequest, _ response: HTTPResponse) {</p>

<pre><code>// MongoDBへの接続
connect()
// 指定コレクションが見つからない場合は処理終了
guard let collection = self.collection else {
  return
}

// データ全件取得のためBSONオブジェクトを初期化してクエリとして設定
let fnd = collection.find(query: BSON())

// データ格納用に配列を定義
var arr = [String]()

// 取得したデータを配列に格納する
// fndはMongoCursor型であり、for文での繰り返し処理が可能
for x in fnd! {
    arr.append(x.asString)
}

// JSONStringに変換
let returning = "{\"data\":[\(arr.joined(separator: ","))]}"

// レスポンスデータとして設定
response.appendBody(string: returning)
// レスポンス処理完了
response.completed()

// MongoDBから切断
close()
</code></pre>

<p>  }
}
```</p>

<p>MongoDBへの接続・切断処理は共通処理となることは容易に想像できるため、切り出しました。</p>

<h5>main.swiftからmongoHandler.swiftを呼び出す</h5>

<p>さて、<code>main.swift</code>から<code>mongoHandler.swift</code>を呼び出してみましょう。</p>

<p>```objective-c
// main.swift
// MongoHandlerの初期化
let mongoHandler = MongoHandler()</p>

<p>// GETリクエストでMongoDBのデータ全取得
routes.add(method: .get, uri: &ldquo;/mongo&rdquo;, handler: {</p>

<pre><code>request, response in
mongoHandler.searchAll(request: request, response)
</code></pre>

<p>})
```</p>

<p>これで<code>http://localhost:8181</code>にアクセスすれば下図のような結果が得られるはずです。</p>

<p><img src="/images/perfect-mongo_4.png" alt="データ全件取得結果" /></p>

<h4>MongoDBにアクセスして指定のクエリでデータを取得</h4>

<p>全件取得の方法はわかったので、続いてクエリありの検索を実行してみましょう。<br/>
先程述べた通り、下記のようなデータが格納されています。</p>

<p>```
// データの確認</p>

<blockquote><p>db.testCollection.find()
{ &ldquo;<em>id&rdquo; : ObjectId(&ldquo;58391469a8589d99c931303c&rdquo;), &ldquo;name&rdquo; : &ldquo;takahiro&rdquo;, &ldquo;age&rdquo; : 30, &ldquo;hobby&rdquo; : &ldquo;blog&rdquo; }
{ &ldquo;</em>id&rdquo; : ObjectId(&ldquo;58392222a8589d99c931303d&rdquo;), &ldquo;name&rdquo; : &ldquo;ichiro&rdquo;, &ldquo;age&rdquo; : 43, &ldquo;hobby&rdquo; : &ldquo;baseball&rdquo; }
```</p></blockquote>

<p><code>name</code>、<code>age</code>、<code>hobby</code>を指定して検索するのはそんなに難しくないと思います。</p>

<h5>nameを指定してデータを取得</h5>

<p>わかりやすいところからと言うことで<code>name</code>を指定してデータを取得してみます。<br/>
まずは<code>mongoHandler.swift</code>にクエリ指定のメソッドを追加しましょう。</p>

<p>```objective-c
// mongoHandler.swift
import PerfectLib
import PerfectHTTP
import MongoDB</p>

<p>class MongoHandler {</p>

<pre><code>var client: MongoClient?
var database: MongoDatabase?
var collection: MongoCollection?

    fileprivate func connect() {

    // open a connection
    client = try! MongoClient(uri: "mongodb://localhost")

    // set database, assuming "test" exists
    database = client?.getDatabase(name: "test")

    // define collection
    self.collection = database?.getCollection(name: "testCollection")
}

fileprivate func close() {
    collection?.close()
    database?.close()
    client?.close()
}

    // searchAllメソッドは省略

    // =====ここから追加========================================================
    func search(query: BSON, request: HTTPRequest, _ response: HTTPResponse) {
        // MongoDBへの接続
        connect()

        // 指定コレクションが見つからない場合は処理終了
  guard let collection = self.collection else {
      return
  }

  // クエリを指定して検索
  let fnd = collection.find(query: query)

  // データ格納用に配列を定義
  var arr = [String]()

        // 取得したデータを配列に格納する
    // fndはMongoCursor型であり、for文での繰り返し処理が可能
  for x in fnd! {
      arr.append(x.asString)
  }

  // JSONStringに変換
  let returning = "{\"data\":[\(arr.joined(separator: ","))]}"

  // レスポンスデータとして設定
  response.appendBody(string: returning)
        // レスポンス処理完了
  response.completed()

        // MongoDBから切断
  close()
}
</code></pre>

<p>}
```</p>

<p><code>searchAll</code>との違いは引数に<code>BSON</code>型の<code>query</code>を追加しているところです。</p>

<p>続いて、<code>main.swift</code>にGETリクエストで<code>name</code>パラメータをキャッチできるように処理を追加していきましょう。</p>

<p>```objective-c
// main.swift
import PerfectLib
import PerfectHTTP
import PerfectHTTPServer
import MongoDB                  // ここを追加</p>

<p>// 省略</p>

<p>// nameパラメータを指定したGETリクエストのハンドリング
routes.add(method: .get, uri: &ldquo;/mongo/name/{name}&rdquo;, handler: {
  request, response in</p>

<pre><code>// BSON型オブジェクトの初期化(クエリとして渡す)
</code></pre>

<p>  let bson = BSON()
  defer {</p>

<pre><code>    // 処理完了時にBSONオブジェクトを削除
bson.close()
</code></pre>

<p>  }</p>

<pre><code>// クエリとして渡すパラメータをセット
</code></pre>

<p>  bson.append(key: &ldquo;name&rdquo;, string: request.urlVariables[&ldquo;name&rdquo;]!)</p>

<pre><code>// クエリを指定して検索
</code></pre>

<p>  mongoHandler.search(query: bson, request: request, response)
})
```</p>

<p>これだけで準備万端です。<br/>
<code>http://localhost:8181/name/takahiro</code>にアクセスすると下記結果が得られます。</p>

<p><img src="/images/perfect-mongo_5.png" alt="nameパラメータを指定したGETリクエスト結果" />_</p>

<h5>ObjectIdを指定してデータを取得</h5>

<p>続いて、少しクエリの書き方に迷うかもしれない<code>ObjectId</code>を指定したデータ検索をしてみましょう。<br/>
<code>mongoHandler.swift</code>には特に変更がありません。<br/>
<code>main.swift</code>のみ変更していきます。</p>

<p>```objective-c
// main.swift
import PerfectLib
import PerfectHTTP
import PerfectHTTPServer
import MongoDB
import libmongoc                // ここを追加</p>

<p>// 省略</p>

<p>// ObjectIdパラメータを指定したGETリクエストのハンドリング
routes.add(method: .get, uri: &ldquo;/mongo/oid/{oid}&rdquo;, handler: {
  request, response in</p>

<pre><code>// BSON型オブジェクトの初期化(クエリとして渡す)
</code></pre>

<p>  let bson = BSON()
  defer {</p>

<pre><code>    // 処理完了時にBSONオブジェクトを削除
bson.close()
</code></pre>

<p>  }</p>

<pre><code>// bson_oid_t型のオブジェクトの初期化
</code></pre>

<p>  var oid: bson_oid_t = bson_oid_t()</p>

<pre><code>// String型からbson_oid_t型に変換
</code></pre>

<p>  bson_oid_init_from_string(&amp;oid, request.urlVariables[&ldquo;oid&rdquo;])</p>

<pre><code>// クエリとして渡すパラメータをセット
</code></pre>

<p>  bson.append(key: &ldquo;_id&rdquo;, oid: oid)</p>

<pre><code>// クエリを指定して検索
</code></pre>

<p>  mongoHandler.search(query: bson, request: request, response)
})
```</p>

<p>肝なのが、<code>import libmongoc</code>をしているということです。<br/>
このライブラリの各種メソッドを利用することでServer Side Swiftから<code>ObjectId</code>を指定したデータ検索が可能になります。</p>

<p>少し詳しく説明すると、<br/>
クエリとして<code>ObjectId</code>を渡すためには<code>public func append(key k: String, oid: bson_oid_t) -&gt; Bool</code>を利用する必要があります。<br/>
しかし、このメソッドの第二引数をよく見ると、<code>bson_oid_t</code>型となっています。</p>

<p>GETリクエストの時点で<code>bson_oid_t</code>型でパラメータを渡すわけにもいかないので、  サーバサイド側で変換する必要があります。<br/>
そのために利用するメソッドが<code>void bson_oid_init_from_string (bson_oid_t *oid, const char *str);</code>です。<br/>
筆者もSwiftで初めて利用したのですが、このメソッドは戻り値が<code>void</code>型のため何も返ってきません。<br/>
が、第一引数に参照渡しとして<code>bson_oid_t</code>型オブジェクトを設定することで、メソッドの処理結果が<code>oid</code>に格納されます。<br/>
これでめでたくクエリとして<code>ObjectId</code>が設定できるわけです。</p>

<p>では、<code>http://localhost:8181/oid/58392222a8589d99c931303d</code>にアクセスしてみましょう。</p>

<p><img src="/images/perfect-mongo_6.png" alt="ObjectIdパラメータを指定したGETリクエスト結果" /></p>

<h4>MongoDBにデータを保存</h4>

<p>検索に関してはざっと見てきたので、MongoDBへの保存処理も見ていきましょう。</p>

<h5>insertメソッドでデータを保存</h5>

<p>保存には<code>MongoClient</code>の<code>insert</code>メソッドを利用します。<br/>
(他にも<code>save</code>メソッドもあります。)</p>

<p>まずは <code>mongoHandler.swift</code> へのメソッド追加からです。</p>

<p>```objective-c
// mongoHandler.swift
func save(query: BSON, request: HTTPRequest, response: HTTPResponse) {</p>

<pre><code>// MongoDBへの接続
connect()

// 指定コレクションが見つからない場合は処理終了
</code></pre>

<p>  guard let collection = self.collection else {</p>

<pre><code>return
</code></pre>

<p>  }</p>

<pre><code>// データの保存処理
</code></pre>

<p>  let insert = collection.insert(document: query) as MongoResult</p>

<pre><code>// データ保存結果によって返却値を変更
</code></pre>

<p>  var returning = &ldquo;Failed&rdquo;
  switch insert {
  case .success:</p>

<pre><code>returning = "Succeeded"
</code></pre>

<p>  default:</p>

<pre><code>returning = "Failed"
</code></pre>

<p>  }</p>

<pre><code>// レスポンスデータとして設定
</code></pre>

<p>  response.appendBody(string: returning)</p>

<pre><code>// レスポンス処理完了
</code></pre>

<p>  response.completed()</p>

<pre><code>// MongoDBから切断
</code></pre>

<p>  close()
}
```</p>

<p>次にPOSTで届いたリクエストパラメータがJSONStringなのでDictionary型に変換します。<br/>
その処理を <code>decode.swift</code> ファイルを新規作成して追加します。</p>

<p>```objective-c
// decode.swift
import PerfectHTTPServer
import PerfectLib</p>

<p>func decode(postBody: String?) &ndash;> [String: Any]? {
  do {</p>

<pre><code>guard let decoded = try postBody?.jsonDecode() as? [String:Any] else {
  return [:]
}
print(decoded)
return decoded
} catch {
return [:]
}
</code></pre>

<p>}
```</p>

<p>そして <code>main.swift</code> にPOSTリクエストのハンドリング処理を書きます。</p>

<p>```objective-c
// main.swift
routes.add(method: .post, uri: &ldquo;/mongo/&rdquo;, handler: {</p>

<pre><code>request, response in
// BSON型オブジェクトの初期化(クエリとして渡す)
</code></pre>

<p>  let bson = BSON()
  defer {</p>

<pre><code>    // 処理完了時にBSONオブジェクトを削除
bson.close()
</code></pre>

<p>  }</p>

<pre><code>// JSONString型をDictionary型に変換
</code></pre>

<p>  let decodedParam = decode(postBody: request.postBodyString)</p>

<pre><code>// 各パラメータ単位でBSONオブジェクトに格納
</code></pre>

<p>  for (key, value) in decodedParam! {</p>

<pre><code>  switch key {
  case "name":
      bson.append(key: "name", string: value as! String)
  case "age":
      bson.append(key: "age", int32: Int32(value as! Int))
  case "hobby":
      bson.append(key: "hobby", string: value as! String)
  default:
      break
  }
</code></pre>

<p>  }</p>

<pre><code>// データ保存
</code></pre>

<p>  mongoHandler.save(query: bson, request: request, response: response)
})
```</p>

<p>これで処理は完成です。<br/>
ではPOSTリクエストを投げてみましょう。</p>

<p><code>
$ curl http://localhost:8181/mongo -X POST -H "Content-Type: application/json" -d '{"name":"Hanako", "age": 24, "hobby": "game"}'
</code></p>

<p>再度、MongoDBを検索してみると下記のような結果が得られるはずです。</p>

<p>```
// データの確認</p>

<blockquote><p>db.testCollection.find()
{ &ldquo;<em>id&rdquo; : ObjectId(&ldquo;58391469a8589d99c931303c&rdquo;), &ldquo;name&rdquo; : &ldquo;takahiro&rdquo;, &ldquo;age&rdquo; : 30, &ldquo;hobby&rdquo; : &ldquo;blog&rdquo; }
{ &ldquo;</em>id&rdquo; : ObjectId(&ldquo;58392222a8589d99c931303d&rdquo;), &ldquo;name&rdquo; : &ldquo;ichiro&rdquo;, &ldquo;age&rdquo; : 43, &ldquo;hobby&rdquo; : &ldquo;baseball&rdquo; }
{ &ldquo;_id&rdquo; : ObjectId(&ldquo;583afcaedcab265c1821fb51&rdquo;), &ldquo;name&rdquo; : &ldquo;Hanako&rdquo;, &ldquo;age&rdquo; : 24, &ldquo;hobby&rdquo; : &ldquo;game&rdquo; }
```</p></blockquote>

<p>因みに、<code>main.swift</code>でリクエストパラメータとして取得した<code>age</code>を <strong>Int32</strong> 型に変換しているのには理由があります。<br/>
これを仮に <code>bson.append(key: "age", int: value as! Int)</code> とした場合、MongoDBには <code>NumberLong</code>として保存されてしまいます。 <br/>
これは32bitか64bitかの違いですね。</p>

<h5>insertメソッドのMongoInsertFlagについて</h5>

<p>先程、<code>insert</code>メソッドを利用しましたが、実は第一引数のみ持っている <code>insert</code> メソッドを利用していました。<br/>
実は他にも <code>public func insert(document: BSON, flag: MongoInsertFlag = .none) -&gt; Result</code> といった第二引数を持つ <code>insert</code> メソッドが存在します。</p>

<p>少し気になったのでこの <code>MongoInsertFlag</code>について調べてみました。<br/>
<code>MongoInsertFlag</code>は<code>MongoCollection.swift</code>内に <strong>enum</strong> として定義されています。</p>

<p>```objective-c
public enum MongoInsertFlag: Int {</p>

<pre><code>case none
case continueOnError
case noValidate

var mongoFlag: mongoc_insert_flags_t {
    switch self {
    case .none:
        return MONGOC_INSERT_NONE
    case .continueOnError:
        return MONGOC_INSERT_CONTINUE_ON_ERROR
    case .noValidate:
        return mongoc_insert_flags_t(rawValue: MONGOC_INSERT_NO_VALIDATE)
    }
}
</code></pre>

<p>}
```</p>

<p>ここで<code>MONGOC_INSERT_NONE</code>, <code>MONGOC_INSERT_CONTINUE_ON_ERROR</code>, <code>MONGOC_INSERT_NO_VALIDATE</code>の3つがフラグとして用意されていることがわかります。<br/>
これらはそれぞれ次のような意味とのことです。</p>

<ul>
<li><code>MONGOC_INSERT_NONE</code>

<ul>
<li>特別何もしません。</li>
</ul>
</li>
<li><code>MONGOC_INSERT_CONTINUE_ON_ERROR</code>

<ul>
<li>途中でエラーが発生したとしても後続の<code>insert</code>処理がある場合は続ける</li>
</ul>
</li>
<li><code>MONGOC_INSERT_NO_VALIDATE</code>

<ul>
<li>インサート前に値のバリデーションチェックをしない

<ul>
<li>MongoDBへの保存処理前にAPサーバ時点などでバリデーションチェックはした方が良い</li>
</ul>
</li>
<li>これをすることで処理時間を短縮することができる</li>
</ul>
</li>
</ul>


<h4>MongoDBのデータを更新</h4>

<p>MongoDBへの更新処理も見ていきましょう。</p>

<h5>updateメソッドでデータを保存</h5>

<p>保存には<code>MongoClient</code>の<code>update</code>メソッドを利用します。</p>

<p><code>mongoHandler.swift</code>にメソッドを追加します。</p>

<p>```objective-c
// mongoHandler.swift
func update(update: BSON, selector: BSON, request: HTTPRequest, response: HTTPResponse) {</p>

<pre><code>// MongoDBへの接続
connect()

// 指定コレクションが見つからない場合は処理終了
</code></pre>

<p>  guard let collection = self.collection else {</p>

<pre><code>return
</code></pre>

<p>  }</p>

<pre><code>// データの更新
</code></pre>

<p>  let updated = collection.update(update: update, selector: query)</p>

<pre><code>// データ更新結果によって返却値を変更
</code></pre>

<p>  var returning = &ldquo;Failed&rdquo;
  switch updated {
  case .success:</p>

<pre><code>returning = "Succeeded"
</code></pre>

<p>  default:</p>

<pre><code>returning = "Failed"
</code></pre>

<p>  }</p>

<pre><code>// レスポンスデータとして設定
</code></pre>

<p>  response.appendBody(string: returning)</p>

<pre><code>// レスポンス処理完了
</code></pre>

<p>  response.completed()</p>

<pre><code>// MongoDBから切断
</code></pre>

<p>  close()
}
```</p>

<p>そして <code>main.swift</code> にPUTリクエストのハンドリング処理を書きます。</p>

<p>```objective-c
// main.swift
routes.add(method: .post, uri: &ldquo;/mongo/&rdquo;, handler: {</p>

<pre><code>request, response in
// BSON型オブジェクトの初期化(更新内容として渡す)
</code></pre>

<p>  let updateBson = BSON()</p>

<pre><code>// BSON型オブジェクトの初期化(クエリとして渡す)
let selectorBson = BSON()
</code></pre>

<p>  defer {</p>

<pre><code>    // 処理完了時にBSONオブジェクトを削除
updateBson.close()
    selectorBson.close()
</code></pre>

<p>  }</p>

<pre><code>// JSONString型をDictionary型に変換
</code></pre>

<p>  let decodedParam = decode(postBody: request.postBodyString)</p>

<pre><code>// 各パラメータ単位でBSONオブジェクトに格納
</code></pre>

<p>  for (key, value) in decodedParam! {</p>

<pre><code>  switch key {
  case "name":
      updateBson.append(key: "name", string: value as! String)
  case "age":
      updateBson.append(key: "age", int32: Int32(value as! Int))
  case "hobby":
      updateBson.append(key: "hobby", string: value as! String)
  default:
      break
  }
</code></pre>

<p>  }</p>

<pre><code>// データ更新
</code></pre>

<p>  mongoHandler.update(update: updateBson, query: selectorBson, request: request, response: response)
})
```</p>

<p>基本的にはPOSTと同じ感じで処理を書くことができます。<br/>
しかしながら気をつけなくてはいけないのが、<strong>$setが利用できない</strong> ということです。<br/>
通常、MongoDBでは、 <strong>$setを使わないと</strong> &hellip;</p>

<p>```
// データの確認</p>

<blockquote><p>db.testCollection.find();
{ &ldquo;_id&rdquo; : ObjectId(&ldquo;583afcaedcab265c1821fb51&rdquo;), &ldquo;name&rdquo; : &ldquo;Hanako&rdquo;, &ldquo;age&rdquo; : 24, &ldquo;hobby&rdquo; : &ldquo;game&rdquo; }</p></blockquote>

<p>// データの更新</p>

<blockquote><p>db.testCollection.update({_id: ObjectId(&ldquo;583afcaedcab265c1821fb51&rdquo;)}, {&ldquo;hobby&rdquo;: &ldquo;go shopping&rdquo;});</p></blockquote>

<p>// データの確認</p>

<blockquote><p>db.testCollection.find();
{ &ldquo;_id&rdquo; : ObjectId(&ldquo;583afcaedcab265c1821fb51&rdquo;), &ldquo;hobby&rdquo; : &ldquo;go shopping&rdquo; }
```</p></blockquote>

<p>となってしまいます。<br/>
現状、<code>Perfect-MongoDB</code>に実装されているメソッドを見ると<code>$set</code>はないようです。<br/>
そのため、今回はあえてPOST同様に全てのパラメータをクライアント側から下記のように投げることにしました。</p>

<p><code>
$ curl http://localhost:8181/mongo/583afcaedcab265c1821fb51 -X PUT -H "Content-Type: application/json" -d '{"name" : "Hanako", "age" : 24, "hobby": "game"}'
</code></p>

<h5>updateメソッドのMongoUpdateFlagについて</h5>

<p><code>update</code>メソッドにも実は<code>MongoUpdateFlag</code>というオプションを設定できるメソッドが存在します。<br/>
<code>MongoUpdateFlag</code>は<code>MongoInsertFlag</code>と同じく <strong>enum</strong> として定義されています。</p>

<p>```objective-c
public enum MongoUpdateFlag: Int {</p>

<pre><code>case none
case upsert
case multiUpdate
case noValidate

var mongoFlag: mongoc_update_flags_t {
    switch self {
    case .none:
        return MONGOC_UPDATE_NONE
    case .upsert:
        return MONGOC_UPDATE_UPSERT
    case .multiUpdate:
        return MONGOC_UPDATE_MULTI_UPDATE
    case .noValidate:
        return mongoc_update_flags_t(rawValue: MONGOC_UPDATE_NO_VALIDATE)
    }
}
</code></pre>

<p>}
```</p>

<p>それぞれのフラグの意味は下記の通りです。</p>

<ul>
<li><code>MONGO_UPDATE_NONE</code>

<ul>
<li>特別何もしません</li>
</ul>
</li>
<li><code>MONGOC_UPDATE_UPSERT</code>

<ul>
<li>検索に引っかからない場合は<code>insert</code>します</li>
</ul>
</li>
<li><code>MONGOC_UPDATE_MULTI_UPDATE</code>

<ul>
<li>検索にヒットする件数が複数の場合は全て更新します</li>
</ul>
</li>
<li><code>MONGOC_UPDATE_NO_VALIDATE</code>

<ul>
<li>アップデート前に値のバリデーションチェックをしません</li>
</ul>
</li>
</ul>


<h4>MongoDBのデータを削除</h4>

<p>MongoDBからのデータ削除処理も見ていきましょう。</p>

<h5>removeメソッドでデータを保存</h5>

<p>保存には<code>MongoClient</code>の<code>remove</code>メソッドを利用します。</p>

<p><code>mongoHandler.swift</code>にメソッドを追加します。</p>

<p>```objective-c
// mongoHandler.swift
func delete(query: BSON, request: HTTPRequest, response: HTTPResponse) {</p>

<pre><code>// MongoDBへの接続
connect()

// 指定コレクションが見つからない場合は処理終了
</code></pre>

<p>  guard let collection = self.collection else {</p>

<pre><code>return
</code></pre>

<p>  }</p>

<pre><code>// データ削除処理
</code></pre>

<p>  let removed = collection.remove(selector: query, flag: .none)</p>

<pre><code>// データ削除結果によって返却値を変更
</code></pre>

<p>  var returning = &ldquo;Failed&rdquo;    <br/>
  switch removed {
  case .success:</p>

<pre><code>returning = "Succeeded"
</code></pre>

<p>  default:</p>

<pre><code>returning = "Failed"
</code></pre>

<p>  }</p>

<pre><code>// レスポンスデータとして設定
</code></pre>

<p>  response.appendBody(string: returning)</p>

<pre><code>// レスポンス処理完了
</code></pre>

<p>  response.completed()</p>

<pre><code>// MongoDBから切断
</code></pre>

<p>  close()
}
```</p>

<p>そして <code>main.swift</code> にDELETEリクエストのハンドリング処理を書きます。</p>

<p>```objective-c
// main.swift
routes.add(method: .delete, uri: &ldquo;/mongo/{oid}&rdquo;, handler: {
  request, response in</p>

<pre><code>// BSON型オブジェクトの初期化(クエリとして渡す)
</code></pre>

<p>  let bson = BSON()
  defer {</p>

<pre><code>    // 処理完了時にBSONオブジェクトを削除
bson.close()
</code></pre>

<p>  }</p>

<p>  var oid: bson_oid_t = bson_oid_t()
  bson_oid_init_from_string(&amp;oid, request.urlVariables[&ldquo;oid&rdquo;])
  bson.append(key: &ldquo;_id&rdquo;, oid: oid)</p>

<pre><code>// データ削除
</code></pre>

<p>  mongoHandler.delete(query: bson, request: request, response: response)
})
```</p>

<p>下記のようなDELETEリクエストを投げてみればデータが削除されていることが確認できるはずです。</p>

<p><code>
$ curl http://localhost:8181/mongo/583afcaedcab265c1821fb51 -X DELETE -H "Content-Type: application/json"
</code></p>

<h5>removeメソッドのMongoRemoveFlagについて</h5>

<p><code>remove</code>メソッドにも実は<code>MongoRemoveFlag</code>というオプションを設定できるメソッドが存在します。<br/>
<code>MongoRemoveFlag</code>は<code>MongoUpdateFlag</code>と同じく <strong>enum</strong> として定義されています。</p>

<p>```objective-c
public enum MongoRemoveFlag: Int {</p>

<pre><code>case none
case singleRemove

var mongoFlag: mongoc_remove_flags_t {
    switch self {
    case .none:
        return MONGOC_REMOVE_NONE
    case .singleRemove:
        return MONGOC_REMOVE_SINGLE_REMOVE
    }
}
</code></pre>

<p>}
```</p>

<p>フラグの意味は下記の通りです。</p>

<ul>
<li><code>MONGOC_REMOVE_NONE</code>

<ul>
<li>特に何のオプションもつけません。</li>
<li>検索にヒットしたデータは全て削除します。</li>
</ul>
</li>
<li><code>MONGOC_REMOVE_SINGLE_REMOVE</code>

<ul>
<li>初めに該当したデータ1件のみを削除します。</li>
</ul>
</li>
</ul>


<h3>まとめ</h3>

<p>以上で基本的なCRUDに対応したAPサーバとDBサーバをSwiftとMongoDBで構築することができました。<br/>
これから何かサービスでも&hellip;と思っていたら時間切れ&hellip;<br/>
今回は一旦ここまでとしたいと思いますが、今後の展望としてはSwift製iOSアプリと連携させてiOSアプリを作成するか、もしくはReact / Reduxを使ったWebサービスと連携させたいと企んでいます。<br/>
処理速度とかリソースの消費具合とかは全然比較もしていないのでわからないですが、Swiftによるサーバサイド構築によるメリットも今後Appleさんが？明らかにしてくれるかもしれません。</p>

<p>何と言っても新しい技術や取り組みは楽しいですね！！<br/>
と言ったところで本日はここまで。</p>

<h3>参考URL</h3>

<ul>
<li><a href="http://perfect.org/docs/MongoDB.html">Perfect MongoDB Documentation</a></li>
<li><a href="http://mongoc.org/libbson/1.3.5/bson_oid_init_from_string.html">Libbson API Reference: Bson Oid Init</a></li>
<li><a href="http://mongoc.org/libmongoc/1.4.0/updating-document.html">Libbson API Reference: Update Document</a></li>
<li><a href="http://mongoc.org/libmongoc/1.0.0/mongoc_insert_flags_t.html">MongoDB C Driver API Reference: Insert Flag</a></li>
<li><a href="http://mongoc.org/libmongoc/1.2.3/mongoc_update_flags_t.html">MongoDB C Driver API Reference: Update Flag</a></li>
<li><a href="http://mongoc.org/libmongoc/1.3.2/mongoc_remove_flags_t.html">MongoDB C Driver API Reference: Remove Flag</a></li>
</ul>


<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
</feed>
