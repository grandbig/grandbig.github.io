<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: swift | Takahiro Octopress Blog]]></title>
  <link href="http://grandbig.github.io/blog/categories/swift/atom.xml" rel="self"/>
  <link href="http://grandbig.github.io/"/>
  <updated>2020-02-22T20:13:26+09:00</updated>
  <id>http://grandbig.github.io/</id>
  <author>
    <name><![CDATA[Takahiro]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SwiftUIの基礎を理解しよう！(1)〜簡単な装飾とボタンアクション〜]]></title>
    <link href="http://grandbig.github.io/blog/2020/02/22/swiftui-1/"/>
    <updated>2020-02-22T17:59:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2020/02/22/swiftui-1</id>
    <content type="html"><![CDATA[<h3>はじめに</h3>

<p>さて、本日はXcode11から新規似追加された <code>SwiftUI</code> によるiOSアプリ開発について勉強していきたいと思います。</p>

<p>筆者がぱっと見る限り、 <code>SwiftUI</code> は、</p>

<ul>
<li>ホットリロードによる手動ビルドの手間の改善</li>
<li><code>xib</code> や <code>storyboard</code> によるUI実装のレビューの難しさの解消</li>
</ul>


<p>に一役買っていると感じました。</p>

<p>また、 <code>SwiftUI</code> での書き方自体は、<br/>
これまでのiOSアプリの書き方に慣れている人にとっては、やはりそれなりの準備期間は必要になりそうです。<br/>
( <code>RxSwift</code> 使いの方々にとっては比較的とっかかりやすいという話もあります。 )</p>

<p>ということもあり、<br/>
実際の業務にて <code>SwiftUI</code> を利用するシーンはまだそこまで増えることはないかもしれませんが、<br/>
iOSアプリ開発の実装方法の幅を増やすに越したことはないでしょう。</p>

<p>では、少しずつ <code>SwiftUI</code> について勉強していきたいと思います。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h3>Hello World!</h3>

<p>さて、まずは新規に <code>SwiftUI</code> プロジェクトを作成した場合、</p>

<p>```objective-c
// ContentView.swift
import SwiftUI</p>

<p>struct ContentView: View {</p>

<pre><code>var body: some View {
    Text("Hello, World!")
}
</code></pre>

<p>}</p>

<p>struct ContentView_Previews: PreviewProvider {</p>

<pre><code>static var previews: some View {
    ContentView()
}
</code></pre>

<p>}
```</p>

<p>といった形で <code>Hello World!</code> プロジェクトが作成されます。</p>

<p>シミュレータを起動することなく、ホットリロードしながら開発するには、<br/>
<code>Resume</code> ボタンをクリックします。</p>

<p><img src="/images/swiftui-1_1.png" alt="ホットリロードによる開発のためにResumeを実行する" /></p>

<p>その結果、以下のように、あたかもシミュレータが起動したかのような状態で開発を進めることができます。</p>

<p><img src="/images/swiftui-1_2.png" alt="ホットリロード状態での開発" /></p>

<h3>UIの作成方法</h3>

<p>具体的に <code>SwiftUI</code> でどのようにUIを作成するのでしょうか。</p>

<p>慣れれば、コードベースで全て書き上げることができると思いますが、<br/>
慣れないうちは、GUIと併用して実装するのが良いかと思います。</p>

<h4>bodyプロパティ</h4>

<p><code>SwiftUI</code> で実装する上で最も基本的かつ重要なことは、 <code>body</code> プロパティです。<br/>
<code>body</code> プロパティは 計算型の <code>View</code> 型プロパティです。<br/>
この <code>body</code> に各種パーツを設定した <code>View</code> をセットすることでUIを表現します。</p>

<p>言い換えると、『 <code>body</code> には様々なパーツを包括した1つの <code>View</code> をセットする』ということです。</p>

<p>例えば、</p>

<p>```objective-c
struct ContentView: View {</p>

<pre><code>var body: some View {
    Text("hoge")
    Text("fuga")
}
</code></pre>

<p>}
```</p>

<p>といったことはできず、</p>

<p>```objective-c
struct ContentView: View {</p>

<pre><code>var body: some View {
    VStack {
      Text("hoge")
      Text("fuga")
    }
}
</code></pre>

<p>}
```</p>

<p>のように <code>VStack</code> , <code>HStack</code> , <code>Group</code> など <code>View</code> を包括するパーツを利用してまとめる必要があります。</p>

<p>先程記載した通り、コードベースで直接 <code>VStack</code> で囲っても良いですし、<br/>
慣れないうちは <code>Command</code> キーを押しながら <code>Text</code> をクリックしメニューを表示させます。</p>

<p><img src="/images/swiftui-1_3.png" alt="VStackなどを追加するためのメニュー" /></p>

<p>ここから <code>Embed in VStack</code> を選択すれば、コードに <code>VStack</code> を挿入してくれます。</p>

<h4>Textの装飾</h4>

<p>続いて、パーツの装飾方法について見ていきます。<br/>
今回は最もシンプルな例として、 <code>Text</code> を扱います。</p>

<p>GUIから編集する方法はシンプルで、</p>

<ol>
<li>コード上で対象パーツにカーソルをあわせる</li>
<li>プレビュー上で対象パーツを選択する</li>
</ol>


<p>のどちらかを実行することで、右メニューで編集が可能になります。</p>

<p><img src="/images/swiftui-1_4.png" alt="右メニューでTextの装飾" /></p>

<p>右メニューから、</p>

<ul>
<li>Textの文言</li>
<li>フォントの各種設定</li>
<li>Padding</li>
<li>Frame (Width / Height)</li>
</ul>


<p>がデフォルトで用意されており変更が可能です。</p>

<p>また、 <code>Add Modifier</code> から多種多様なプロパティ設定を追加することができます。<br/>
(単純な装飾に限らないようですが。。。)</p>

<p><img src="/images/swiftui-1_5.png" alt="Textに各種プロパティを設定" /></p>

<p>因みに、GUIから各種設定を追加すると、<br/>
<code>.foregroundColor(Color.blue)</code> のように省略なしの表記でコードに挿入される場合がありますが、<br/>
<code>.foregroundColor(.blue)</code> とすることも、もちろん可能です。</p>

<p>```objective-c
// こんな感じで省略表記は可能です。
Text(&ldquo;Hello, World!&rdquo;)</p>

<pre><code>.font(.largeTitle)
.fontWeight(.heavy)
.foregroundColor(.blue)
.padding(.all, 20.0)
.background(.black)
</code></pre>

<p>```</p>

<h4>Buttonアクション</h4>

<p>最後にボタンをタップシた際のアクションの実装について簡単に触れておきましょう。<br/>
今回は、サンプルとして、「ボタンをタップした際にアラートを表示する」ことを試してみます。</p>

<p>実装は次の通りです。</p>

<p>```objective-c
struct ContentView: View {</p>

<pre><code>/// アラートの表示フラグ
@State private var isShown = true

var body: some View {
    VStack(spacing: 20.0) {
        Text("Hello, World!")
        Button(action: {
            // ボタンをタップすると、表示に切り替え
            self.isShown = true
        }) {
            Text("Button")
        }
        // isPresentedがtrueになった場合にアラートを表示する
        .alert(isPresented: $isShown) {
            Alert(title: Text("Tapped Button"))
        }
    }
}
</code></pre>

<p>}
```</p>

<p>冒頭で <code>@State</code> 属性を用いて <code>isShown</code> フラグを定義することで、<br/>
<code>View</code> 内で扱うことが可能となり、そのプロパティの状態に従って描画を実行できるようになります。</p>

<p>ここでは、ボタンタップ時に発火される <code>Button(action: { ... })</code> で、<br/>
<code>isShown</code> フラグを切り替えます。<br/>
そして後続の <code>alert</code> で <code>isPresented</code> に <code>isShown</code> フラグを判定として利用することでアラートを表示します。</p>

<h3>まとめ</h3>

<p>さて、まずは、ほんの少しの表面だけ <code>SwiftUI</code> に触れてみました。<br/>
まだまだ複雑なアプリを開発するには練習が全然足りないため、継続して学びつつブログに書き起こせていければと思います。</p>

<p>と言ったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SwiftでiOS&Androidアプリを開発！？〜Scadeチュートリアル〜]]></title>
    <link href="http://grandbig.github.io/blog/2020/01/19/scade-hello-world/"/>
    <updated>2020-01-19T01:07:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2020/01/19/scade-hello-world</id>
    <content type="html"><![CDATA[<h3>はじめに</h3>

<p>昨今、 <code>Flutter</code> や <code>React Native</code> などによるiOSアプリとAndroidアプリの同時作成が少しずつ現実的に実践されるようになってきており、<br/>
筆者的には、2010年代前半以来のリブームのように感じられる今日此頃です。</p>

<p>2010年代前半は、Facebookを筆頭に、最終的にはフルネイティブに舵を切り直すプロダクトが多かったイメージがあるのですが、<br/>
各種OSの浸透および安定化に伴い、今回の流れはある程度続く可能性があるのではと思わずにはいられません。</p>

<p>しかしながら、 <code>Flutter</code> は <code>Dart</code> というGoogle製の言語を利用し、<br/>
<code>React Native</code> は <code>JavaScript</code> および <code>React</code> の知識が必要になります。</p>

<p> 既に <code>Swift</code> でのiOSアプリの開発や <code>Kotlin</code> によるAndroidアプリの開発に慣れているエンジニアであれば、<br/>
 言語書式が比較的似ていることから、OSやIDEの違いさえ把握できれば学習コストは大幅に抑えられる可能性があります。</p>

<p> 一方で、それでは両OSアプリの同時作成の恩恵に預かることができないため、<br/>
 何か良いものがないかな〜と思っていたところ、<br/>
『 <a href="https://www.infoq.com/jp/news/2019/08/scade-swift-android-development/">Scadeは、Swiftを使用してAndroidアプリ開発を可能にすることを目指す</a>』という記事を見つけました。</p>

<p>これは面白そうだなということで、今回は<a href="https://www.scade.io/">Scade</a>について見てみたいと思います。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h3>Scadeとは</h3>

<p>公式ホームページによると、 <code>Scade</code> とは『次世代のモバイルアプリの開発基盤』と言われています。</p>

<p>具体的にできることとしては、</p>

<ul>
<li><code>Swift</code> 言語でiOS&amp;Androidの両OSのアプリを開発できる</li>
<li><code>SCADE Simulator</code> という <code>Scade</code> アプリ内で提供されているシミュレータが利用できる</li>
<li><code>Xcode</code> や <code>Android Studio</code> で利用している各々専用のシミュレータも利用できる</li>
<li>GUI上でアプリをデザインすることができる</li>
</ul>


<p>などがあります。</p>

<p>Swift5にてABIの安定化を達成したこともあってか <code>Scade</code> 自体のバージョンも <code>v1.0</code> に到達しています。</p>

<p>しかしながら、現在、最新の <code>Scade</code> は <strong>Xcode11</strong> ( つまり <strong>Swift5.0</strong> )までしか対応しておらず、<br/>
お使いのMacで <code>Xcode11.3</code> が入っている場合は <code>Scade IDE</code> 上でのコンパイルに失敗してしまうため注意が必要です。</p>

<h3>チュートリアル &ndash; Hello World</h3>

<p>何はともあれ、 <code>Scade IDE</code> を使ってチュートリアルを進めてみましょう。<br/>
<code>Scade</code> のドキュメントは非常に充実しており、チュートリアルとして <code>Hello World</code> が用意されています。</p>

<p>参考：<a href="https://docs.scade.io/docshttps://docs.scade.io/docs">Scade: チュートリアル &ndash; Hello World</a></p>

<p>上記リンク先に動画付きで説明がなされているので、大筋で困ることはないと思います。<br/>
ただ、ドキュメントが古いのか、全く同じように作成することはできなかったため、紹介がてら使い方を見ていきたいと思います。</p>

<p>まず、ソフトウェアのDLページですが、<a href="https://www.scade.io/download/">こちら</a>になります。<br/>
※無料で利用できます。</p>

<h4>プロジェクトの作成</h4>

<p>続いて、プロジェクトの作成方法を説明します。</p>

<p>① ナビゲーションバーから、Scade Projectを選択する</p>

<p><img src="/images/scade_1.png" alt="Scadeプロジェクトを作成する" /></p>

<p>② プロジェクト名を決める</p>

<p><img src="/images/scade_2.png" alt="プロジェクト名を決める" /></p>

<p>これだけで、IDE上に②で指定した名前のプロジェクト名が作成されていることを確認できると思います。</p>

<p><img src="/images/scade_3.png" alt="IDE上に作成されたプロジェクト" /></p>

<h4>レイアウトの作成</h4>

<p><code>Scade</code> の特徴でも説明したように、 <code>Xcode</code> や <code>Android Studio</code> 同様にGUIからレイアウトを決めることが可能になっています。<br/>
今回は、『チュートリアルのHello World』ということで下図のようなレイアウトを作成します。</p>

<p><img src="/images/scade_4.png" alt="チュートリアルHello Worldのレイアウト" /></p>

<p>では説明していきましょう。</p>

<p>① main.pageファイルを開く</p>

<p><img src="/images/scade_5.png" alt="main.pageファイルを開く" /></p>

<p>② 右メニューのPaletteのWidgetsからLabelとButtonをドラッグ＆ドロップする</p>

<p><img src="/images/scade_6.png" alt="右メニューのPaletteのWidgetsからLabelとButtonをドラッグ＆ドロップする" /></p>

<p>③ 右メニューのPaletteのLayoutsからGrid1つとVertical2つをドラッグ＆ドロップする</p>

<p><img src="/images/scade_7.png" alt="右メニューのPaletteのLayoutsからGrid1つとVertical2つをドラッグ＆ドロップする" /></p>

<p>④ Grid内にVerticalを2つ子要素として追加し、それぞれのVerticalの子要素としてLabelとButtonを追加する</p>

<p><img src="/images/scade_8.png" alt="Grid内にVerticalを2つ子要素として追加し、それぞれのVerticalの子要素としてLabelとButtonを追加する" /></p>

<p>⑤ Gridの上下左右にレイアウトを設定する</p>

<p><img src="/images/scade_9.png" alt="Gridの上下左右にレイアウトを設定する " /></p>

<p>⑥ Label側のVerticalのレイアウトを設定する</p>

<p><img src="/images/scade_10.png" alt="Label側のVerticalのレイアウトを設定する" /></p>

<p>⑦ Button側のVerticalのレイアウトを設定する</p>

<p><img src="/images/scade_11.png" alt="Button側のVerticalのレイアウトを設定する" /></p>

<p>⑧ Labelのレイアウトと色を設定する</p>

<p><img src="/images/scade_12.png" alt="Labelのレイアウトと色を設定する" /></p>

<p>⑨ Buttonのレイアウトと色を設定する</p>

<p><img src="/images/scade_13.png" alt="Buttonのレイアウトと色を設定する" /></p>

<h4>実行処理の実装</h4>

<p>今回のチュートリアルでは、下記機能を持たせます。</p>

<ul>
<li>ボタンをタップしたときにラベルの文字列を変更する</li>
</ul>


<p>これを実現するために、 <code>main.page.swift</code> ファイルを開き、実行処理を書きます。</p>

<p><img src="/images/scade_14.png" alt="main.page.swiftファイルに実行処理を書く" /></p>

<p>```objective-c
// main.page.swift
import ScadeKit</p>

<p>class MainPageAdapter: SCDLatticePageAdapter {</p>

<pre><code>// page adapter initialization
override func load(_ path: String) {        
    super.load(path)

// ①
    let button1 = self.page!.getWidgetByName("button1") as! SCDWidgetsButton

// ②
    button1.onClick.append(SCDWidgetsEventHandler{ _ in
  // ③
        let label =  self.page!.getWidgetByName("label1") as! SCDWidgetsLabel
        label.text = "Swift on Android rocks"
    })
}
</code></pre>

<p>}
```</p>

<p>処理内容を説明すると、下記の通りです。</p>

<p>① <code>getWidgetByName</code> を使ってボタン要素を取得しています<br/>
② <code>onClick</code> でボタンのタップを補足し、 <code>append</code> で処理を追加しています<br/>
③ ラベルの文字列変更のために <code>getWidgetByName</code> で取得したラベルの <code>text</code> に変更したい文字列を代入しています</p>

<h4>シミュレータでの確認方法</h4>

<p>左上からターゲットとなるプロジェクトを選択すると、実行するシミュレータを選択できます。</p>

<p><img src="/images/scade_15.png" alt="シミュレータでの確認方法" /></p>

<p>シミュレータを選択した後で、三角の実行ボタンを押下することでシミュレータを実行できます。</p>

<p><img src="/images/scade_16.png" alt="実行したシミュレータ" /></p>

<p>因みに、下図のように簡単にシミュレータの端末を変更する機能も備わっています。</p>

<p><img src="/images/scade_17.png" alt="シミュレータの端末を変更" /></p>

<h3>まとめ</h3>

<p>さて、如何でしたでしょうか？<br/>
SwiftでiOS/Androidアプリを同時に開発できるなんて夢のような企画ですよね！</p>

<p>ただ、</p>

<ul>
<li>Swiftバージョンへの追従ができていない</li>
<li><code>Scade</code> のIDEが <code>Eclipse</code> ベースでもっさりしている</li>
<li><code>Xcode</code> と同じ名称の部品があるので、同じように使えると思うと案外うまくいかない</li>
</ul>


<p>といった課題も感じました。</p>

<p>しかしながら、 <code>Scade</code> が実用レベルに到達するようになれば、 <code>Flutter</code> や <code>React Native</code> と同じく1つの選択肢として普及するようになる可能性もあることでしょう&hellip;</p>

<p>まあ、今回は単純に発想が面白かったということで紹介にとどめたいと思います。<br/>
と言ったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS13から利用できるBackgroundTasksを使ってみよう！]]></title>
    <link href="http://grandbig.github.io/blog/2019/09/22/backgroundtasks/"/>
    <updated>2019-09-22T17:09:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2019/09/22/backgroundtasks</id>
    <content type="html"><![CDATA[<h3>はじめに</h3>

<p>今回はiOS13で新たに追加された <code>BackgroundTasks Framework</code> について見ていきたいと思います。<br/>
基本的には、 <a href="https://developer.apple.com/videos/play/wwdc2019/707/">WWDC2019動画の『Advances in App Background Execution』</a>を見ながら実践してみました。</p>

<p>ですが、微妙に躓くところもあったのでメモとして残しておきたいと思います。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h3>BackgroundTasksとは</h3>

<p>まず、 <code>BackgroundTasks</code> の説明です。<br/>
<code>BackgroundTasks</code> はiOS13から利用できる新しいFrameworkになります。<br/>
<code>BackgroundTasks</code> には大きく分けて下記2つのAPIが存在します。</p>

<ol>
<li>Background Processing Tasks</li>
<li>Background App Refresh Tasks</li>
</ol>


<h4>Background Processing Tasks</h4>

<p><code>Background Processing Tasks</code> は以下シーンでの利用が想定されています。</p>

<ul>
<li>(急を要しない)後々の実行で良いメンテナンス処理</li>
<li>Core MLを利用した機械学習のトレーニング処理</li>
</ul>


<p>そのため、 <strong>数分間</strong> の処理実行が許されています。<br/>
また、 <code>requiresExternalPower</code> というフラグを <code>true</code> にすることで、CPU消耗によるプロセスキルをさせないよう制御することができます。<br/>
(iOSの世界でこれって結構スゴイ気がしますね。)</p>

<h4>Background App Refresh Tasks</h4>

<p><code>Background App Refresh Tasks</code> は以下シーンでの利用が想定されています。</p>

<ul>
<li>30秒以内で完了できる処理</li>
<li>1日を通してアプリを最新に保つために必要な処理</li>
</ul>


<p>これまで上記のような対応をする際には <code>Background Fetch</code> を利用していたことと思いますが、<br/>
今回の新APIの発表により、旧APIはdeprecatedになったそうです。</p>

<p><code>objective-c
// deprecated対象
UIApplication.setMinimumBackgroundFetchInterval(_:)
UIApplicationDelegate.application(_:performFetchWithCompletionHandler:)
</code></p>

<h3>BackgroundTasksの使い方</h3>

<p>続いて具体的な使い方を見ていきます。</p>

<h4>ソースコードを書き始めるまでの下準備</h4>

<p><strong>① Xccode上でCapabilityを追加します</strong><br/>
バックグラウンド処理を利用する場合はこれまで通り <code>Capability</code> の <code>Background Modes</code> が必要になります。<br/>
Xcode11で追加する方法が少々変わっているので気をつけましょう。</p>

<p><img src="/images/backgroundtasks_1.png" alt="Background Modesを追加します" /></p>

<p><strong>② Background Modesにチェックを入れます</strong><br/>
今回は、 <code>Background Processing Tasks</code> と <code>Background App Refresh Tasks</code> なので下図の通りです。</p>

<p><img src="/images/backgroundtasks_2.png" alt="必要なBackground Modesにチェックを入れます" /></p>

<p><strong>③ Info.plistにIdentifierを登録します</strong><br/>
<code>Info.plist</code> に <code>Permitted background task scheduler identifiers</code> を追加します。<br/>
また、 <code>Background Processing Tasks</code> と <code>Background App Refresh Tasks</code> 用にそれぞれ <code>Identifier</code> を定義します。</p>

<p>因みに、この <code>Identifier</code> は例によってユニークであることが求められるので、<br/>
<code>com.xxxx.XXXXSample.process</code> , <code>com.xxxx.XXXXSample.refresh</code> といったDNSの逆書きが推奨されています。</p>

<p><img src="/images/backgroundtasks_3.png" alt="Info.plistに必要なIdentifierを登録します" /></p>

<h4>ソースコードの実装</h4>

<p>ここまででソースコード以外の準備は完了です。<br/>
続いて、ソースコードを書いていきましょう。</p>

<p><code>Background Processing Tasks</code> と <code>Background App Refresh Tasks</code> それぞれ記載します。</p>

<h5>Background Processing Tasks</h5>

<p><strong>① BackgroundTasksをimportします</strong></p>

<p><code>objective-c
// AppDelegate.swift
import UIKit
import BackgroundTasks
</code></p>

<p><strong>② didFinishLaunchWithOptions内にバックグラウンドタスクを登録します</strong></p>

<p>```objective-c
// AppDelegate.swift
@UIApplicationMain
class AppDelegate: UIResponder, UIApplicationDelegate {</p>

<pre><code>...
func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool {
    // Override point for customization after application launch.

    // 第一引数: Info.plistで定義したIdentifierを指定
    // 第二引数: タスクを実行するキューを指定。nilの場合は、デフォルトのバックグラウンドキューが利用されます。
    // 第三引数: 実行する処理
    BGTaskScheduler.shared.register(forTaskWithIdentifier: "com.MeasurementSample.refresh", using: nil) { task in
        // バックグラウンド処理したい内容 ※後述します
        self.handleAppProcessing(task: task as! BGProcessingTask)
    }
    return true
</code></pre>

<p>  }
}
```</p>

<p><strong>③ バックグラウンドタスクにスケジューリングします</strong></p>

<p>```objective-c
private func scheduleAppProcessing() {</p>

<pre><code>// Info.plistで定義したIdentifierを指定
let request = BGProcessingTaskRequest(identifier: "com.MeasurementSample.refresh")
// 通信が発生するか否かを指定
request.requiresNetworkConnectivity = false
// CPU監視の必要可否を設定
request.requiresExternalPower = true

do {
    // スケジューラーに実行リクエストを登録
    try BGTaskScheduler.shared.submit(request)
} catch {
    print("Could not schedule app processing: \(error)")
}
</code></pre>

<p>}</p>

<p>func applicationDidEnterBackground(_ application: UIApplication) {</p>

<pre><code>// バックグラウンド起動に移ったときにルケジューリング登録
scheduleAppProcessing()
</code></pre>

<p>}
```</p>

<p><strong>④ 実際に実行する処理を定義します</strong></p>

<p>```objective-c
// AppDelegate.swift
// サンプル用のOperation
class PrintOperation: Operation {</p>

<pre><code>let id: Int

init(id: Int) {
    self.id = id
}

override func main() {
    print("this operation id is \(self.id)")
}
</code></pre>

<p>}</p>

<p>@UIApplicationMain
class AppDelegate: UIResponder, UIApplicationDelegate {
  &hellip;
  private func handleAppProcessing(task: BGProcessingTask) {</p>

<pre><code>  // 1日の間、何度も実行したい場合は、1回実行するごとに新たにスケジューリングに登録します
  scheduleAppRefresh()

  let queue = OperationQueue()
  queue.maxConcurrentOperationCount = 1

  // 時間内に実行完了しなかった場合は、処理を解放します
  // バックグラウンドで実行する処理は、次回に回しても問題ない処理のはずなので、これでOK
  task.expirationHandler = {
      queue.cancelAllOperations()
  }

  // サンプルの処理をキューに詰めます
  let array = [1, 2, 3, 4, 5]
  array.enumerated().forEach { arg in
      let (offset, value) = arg
      let operation = PrintOperation(id: value)
      if offset == array.count - 1 {
          operation.completionBlock = {
              // 最後の処理が完了したら、必ず完了したことを伝える必要があります
              task.setTaskCompleted(success: operation.isFinished)
          }
      }
      queue.addOperation(operation)
  }
</code></pre>

<p>  }
}
```</p>

<h5>Background App Refresh Tasks</h5>

<p><strong>① BackgroundTasksをimportします</strong></p>

<p><code>objective-c
// AppDelegate.swift
import UIKit
import BackgroundTasks
</code></p>

<p><strong>② didFinishLaunchWithOptions内にバックグラウンドタスクを登録します</strong></p>

<p>```objective-c
// AppDelegate.swift
@UIApplicationMain
class AppDelegate: UIResponder, UIApplicationDelegate {</p>

<pre><code>...
func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool {
    // Override point for customization after application launch.

    // 第一引数: Info.plistで定義したIdentifierを指定
    // 第二引数: タスクを実行するキューを指定。nilの場合は、デフォルトのバックグラウンドキューが利用されます。
    // 第三引数: 実行する処理
    BGTaskScheduler.shared.register(forTaskWithIdentifier: "com.MeasurementSample.refresh", using: nil) { task in
        // バックグラウンド処理したい内容 ※後述します
        self.handleAppRefresh(task: task as! BGAppRefreshTask)
    }
    return true
</code></pre>

<p>  }
}
```</p>

<p><strong>③ バックグラウンドタスクにスケジューリングします</strong></p>

<p>```objective-c
private func scheduleAppRefresh() {</p>

<pre><code>// Info.plistで定義したIdentifierを指定
let request = BGAppRefreshTaskRequest(identifier: "com.MeasurementSample.refresh")
// 最低で、どの程度の期間を置いてから実行するか指定
request.earliestBeginDate = Date(timeIntervalSinceNow: 15 * 60)

do {
    // スケジューラーに実行リクエストを登録
    try BGTaskScheduler.shared.submit(request)
} catch {
    print("Could not schedule app refresh: \(error)")
}
</code></pre>

<p>}</p>

<p>func applicationDidEnterBackground(_ application: UIApplication) {</p>

<pre><code>// バックグラウンド起動に移ったときにルケジューリング登録
scheduleAppRefresh()
</code></pre>

<p>}
```</p>

<p><strong>④ 実際に実行する処理を定義します</strong></p>

<p>```objective-c
// AppDelegate.swift
// サンプル用のOperation
class PrintOperation: Operation {</p>

<pre><code>let id: Int

init(id: Int) {
    self.id = id
}

override func main() {
    print("this operation id is \(self.id)")
}
</code></pre>

<p>}</p>

<p>@UIApplicationMain
class AppDelegate: UIResponder, UIApplicationDelegate {
  &hellip;
  private func handleAppRefresh(task: BGAppRefreshTask) {</p>

<pre><code>  // 1日の間、何度も実行したい場合は、1回実行するごとに新たにスケジューリングに登録します
  scheduleAppRefresh()

  let queue = OperationQueue()
  queue.maxConcurrentOperationCount = 1

  // 時間内に実行完了しなかった場合は、処理を解放します
  // バックグラウンドで実行する処理は、次回に回しても問題ない処理のはずなので、これでOK
  task.expirationHandler = {
      queue.cancelAllOperations()
  }

  // サンプルの処理をキューに詰めます
  let array = [1, 2, 3, 4, 5]
  array.enumerated().forEach { arg in
      let (offset, value) = arg
      let operation = PrintOperation(id: value)
      if offset == array.count - 1 {
          operation.completionBlock = {
              // 最後の処理が完了したら、必ず完了したことを伝える必要があります
              task.setTaskCompleted(success: operation.isFinished)
          }
      }
      queue.addOperation(operation)
  }
</code></pre>

<p>  }
}
```</p>

<h3>BackgroundTasksのデバッグ方法</h3>

<p>上記で実装が完了しました。<br/>
実際に挙動を試すためには、特別な手順が必要になります。</p>

<p>① アプリを起動します<br/>
② アプリをバックグラウンドに移します(登録トリガーのためです)<br/>
③ 再度アプリを起動します<br/>
④ Xcodeで <code>Pause Program Execution</code> をタップします</p>

<p><img src="/images/backgroundtasks_4.png" alt="Pause Program Executionをタップします" /></p>

<p>⑤ LLDBに以下コマンドを入力して実行します</p>

<p>```objective-c
// Background Processing Tasksの場合
e -l objc &mdash; (void)[[BGTaskScheduler sharedScheduler] _simulateLaunchForTaskWithIdentifier:@&ldquo;com.MeasurementSample.process&rdquo;]</p>

<p>// Background App Refresh Tasksの場合
e -l objc &mdash; (void)[[BGTaskScheduler sharedScheduler] _simulateLaunchForTaskWithIdentifier:@&ldquo;com.MeasurementSample.refresh&rdquo;]
```</p>

<p>⑥ 再度、Xcodeで <code>Pause Program Execution</code> をタップします</p>

<p>以上で実際の実行処理が見れるようになるはずです。</p>

<p>因みに、実行処理の期限切れを試したい場合は、以下のように⑤のLLDBで以下を入力して実行します</p>

<p>```objective-c
// Background Processing Tasksの場合
e -l objc &mdash; (void)[[BGTaskScheduler sharedScheduler] _simulateExpirationForTaskWithIdentifier:@&ldquo;com.MeasurementSample.process&rdquo;]</p>

<p>// Background App Refresh Tasksの場合
e -l objc &mdash; (void)[[BGTaskScheduler sharedScheduler] _simulateExpirationForTaskWithIdentifier:@&ldquo;com.MeasurementSample.refresh&rdquo;]
```</p>

<h3>ハマったところ</h3>

<p>筆者が試しに実装してハマったところを参考までに載せておこうと思います。<br/>
筆者の場合、なぜかシミュレータで実行しようとすると、以下のエラーが発生してしまいました。</p>

<p><code>objective-c
BGTaskSchedulerErrorDomain Code=1 "(null)"
</code></p>

<p>これは、<a href="https://developer.apple.com/documentation/backgroundtasks/refreshing_and_maintaining_your_app_using_background_tasks">サンプルコード</a>で試しても同様でした。<br/>
ただ、実機で試したところ問題なく通ったんですよね&hellip;</p>

<h3>まとめ</h3>

<p>さて如何でしたでしょうか。<br/>
iOS13で追加された新APIは旧バージョンサポートのため、
すぐには利用されないかもしれませんが、iOS13の普及に伴い、利用シーンは確実に増えていくことでしょう。<br/>
そのため、サンプル程度の実装でも、使い方を学んでおくことは今後の役に立つと思っています。</p>

<p>と言ったところで本日はここまで。</p>

<ul>
<li>参考URL:

<ul>
<li><a href="https://developer.apple.com/videos/play/wwdc2019/707/">WWDC2019 &ndash; Advances in App Background Execution</a></li>
<li><a href="https://developer.apple.com/documentation/backgroundtasks">Apple Documentation &ndash; BackgroundTasks</a></li>
</ul>
</li>
</ul>


<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOSアプリ開発に便利なLLDBのp/po/ｖコマンドを覚えよう！]]></title>
    <link href="http://grandbig.github.io/blog/2019/09/07/po-v-command/"/>
    <updated>2019-09-07T20:02:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2019/09/07/po-v-command</id>
    <content type="html"><![CDATA[<h3>はじめに</h3>

<p>筆者はこれまでLLDBコマンドでは <code>po</code> を利用することが多かったのですが、<br/>
WWDC2019のビデオである<a href="https://developer.apple.com/videos/play/wwdc2019/429/">LLDB: Beyond &ldquo;po&rdquo;</a>を視聴して改めて <code>v</code> コマンドの使いやすさを勉強しました。</p>

<p>今回はその <code>v</code> コマンドについて実例を交えながら見ていきたいと思います。
( <code>p</code> や <code>po</code> コマンドでなぜか変数の中身が見れない&hellip;と思っていた方、必見です。 )</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h3>p/po/vコマンドについて</h3>

<p>まず、各種コマンドについて簡単に見ていきます。</p>

<h4>poコマンドについて</h4>

<p><code>po</code> は <code>print object</code> の略だそうです。 <br/>
<code>po</code> は <code>expression</code> コマンドのエイリアス(ショートカット機能)であり、簡略化して書くことができます。</p>

<p>具体的には、以下の通りです。</p>

<p>```objective-c
(lldb) expression &mdash;object-description &mdash; engineer</p>

<p>(lldb) po engineer
```</p>

<p>また、 <code>po</code> は式を評価した結果のオブジェクトを返すため、非常に見やすい形式で出力されます。<br/>
早速例を見てみましょう。</p>

<p>下記のような構造体が定義されているとします。</p>

<p><code>objective-c
struct iOSEngineer {
  var name: string
  var age: Int
  var specialty: [String]
  var swiftLevel: Int
  var obcLevel: Int
}
</code></p>

<p>これを初期化した直後にブレークポイントで止めているとしましょう。</p>

<p><code>objective-c
let engineer = iOSEngineer(name: "Ichiro", age: 33, specialty: ["gps", "bluetooth", "animation"], swiftLevel: 3, obcLevel: 2)
</code></p>

<p>ブレークポイントで止めた状態で <code>po</code> コマンドを打ち出すと、</p>

<p>```objective-c
(lldb) po engineer
▿ iOSEngineer
  &ndash; name : &ldquo;Ichiro&rdquo;
  &ndash; age : 33
  ▿ specialty : 3 elements</p>

<pre><code>- 0 : "gps"
- 1 : "bluetooth"
- 2 : "animation"
</code></pre>

<ul>
<li>swiftLevel : 3</li>
<li>obcLevel : 2
```</li>
</ul>


<p>という出力結果が得られます。</p>

<h4>pコマンドについて</h4>

<p><code>p</code> は <code>print</code> の略だそうで、<code>po</code> と同じくコンパイルして式を評価します。<br/>
<code>po</code> と異なるのは、出力結果の形式です。<br/>
以下はその例です。</p>

<p>```objective-c
(lldb) p engineer
(Sample.iOSEngineer) $R4 = {
  name = &ldquo;Ichiro&rdquo;
  age = 33
  specialty = 3 values {</p>

<pre><code>[0] = "gps"
[1] = "bluetooth"
[2] = "animation"
</code></pre>

<p>  }
  swiftLevel = 3
  obcLevel = 2
}
```</p>

<p><code>po</code> と違って <code>$R4</code> のような名前がつけられていることがわかります。<br/>
この <code>$R4</code> のような名前を引数に指定して <code>po</code> や <code>p</code> コマンドを実行することができます。</p>

<p>```objective-c
(lldb) p $R4.name
(String) $R10 = &ldquo;Ichiro&rdquo;</p>

<p>(lldb) po $R4.name
&ldquo;Ichiro&rdquo;
```</p>

<p>このように以前の結果から更に値を取得するような場面で使い勝手が非常に良いです。</p>

<p>もちろん <code>p</code> も <code>expression</code> コマンドのエイリアスになっています。</p>

<p>```objective-c
(lldb) expression &mdash; engineer
(MeasurementSample.iOSEngineer) $R16 = {
  name = &ldquo;Ichiro&rdquo;
  age = 33
  specialty = 3 values {</p>

<pre><code>[0] = "gps"
[1] = "bluetooth"
[2] = "animation"
</code></pre>

<p>  }
  swiftLevel = 3
  obcLevel = 2
}
```</p>

<h4>vコマンドについて</h4>

<p><code>v</code> は <code>variable</code> の略のようです。<br/>
出力形式自体は <code>p</code> コマンドと同じになっています。</p>

<p>```objective-c
(lldb) v engineer
(MeasurementSample.iOSEngineer) engineer = {
  name = &ldquo;Ichiro&rdquo;
  age = 33
  specialty = 3 values {</p>

<pre><code>[0] = "gps"
[1] = "bluetooth"
[2] = "animation"
</code></pre>

<p>  }
  swiftLevel = 3
  obcLevel = 2
}
```</p>

<p><code>po</code> や <code>p</code> と同じくエイリアスなのですが、 <code>expression</code> ではなく <code>frame variable</code> コマンドのエイリアスです。</p>

<p>```objective-c
(lldb) frame variable engineer
(MeasurementSample.iOSEngineer) engineer = {
  name = &ldquo;Ichiro&rdquo;
  age = 33
  specialty = 3 values {</p>

<pre><code>[0] = "gps"
[1] = "bluetooth"
[2] = "animation"
</code></pre>

<p>  }
  swiftLevel = 3
  obcLevel = 2
}
```</p>

<p>一見、 <code>p</code> コマンドを使えば良いのでは？と思われそうですが、 <code>v</code> コマンドは以下の特徴があります。</p>

<ul>
<li>コンパイルしないため、結果の出力が速い</li>
<li>メモリから変数を読み込み、動的解決を複数回繰り返すことで、サブフィールドの読み込みが可能</li>
</ul>


<p>上記のどちらにも言えることですが、代わりに式の評価ができないので使い分けが必要です。</p>

<h3>vコマンドの便利機能</h3>

<p>もう少し具体的に <code>v</code> コマンドの良さを見ていきましょう。</p>

<p>次のように定義された構造体があったとします。</p>

<p>```objective-c
protocol Engineer {</p>

<pre><code>var name: String { get set }
var age: Int { get set }
var specialty: [String] { get set }
</code></pre>

<p>}</p>

<p>struct iOSEngineer: Engineer {</p>

<pre><code>var name: String
var age: Int
var specialty: [String]
var swiftLevel: Int
var obcLevel:Int
</code></pre>

<p>}
```</p>

<p>上記の通り、 <code>iOSEngineer</code> はプロトコル <code>Engineer</code> に準拠しています。<br/>
加えて独自に <code>swiftLevel</code> と <code>obcLevel</code> という変数を持ちます。</p>

<p>この構造体を下記のように初期化している場面があったとします。</p>

<p><code>objective-c
let engineer: Engineer = iOSEngineer(name: "Ichiro", age: 33, specialty: ["gps", "bluetooth", "animation"], swiftLevel: 3, obcLevel: 2)
</code></p>

<p>これを <code>p</code> や <code>po</code> コマンドで <code>iOSEngineer</code> 独自のフィールドである <code>swiftLevel</code> を出力させようとすると、</p>

<p><code>objective-c
(lldb) p engineer.swiftLevel
error: &lt;EXPR&gt;:3:1: error: value of type 'Engineer' has no member 'swiftLevel'
engineer.swiftLevel
^~~~~~~~ ~~~~~~~~~~
</code></p>

<p>このようなエラーが表示されます。<br/>
<code>p</code> や <code>po</code> コマンドは1回しか動的解決をしないため、<br/>
<code>Engineer</code> 型として格納された <code>engineer</code> には <code>swiftLevel</code> はメンバ変数として持ち合わせていないと見なされてしまうのです。</p>

<p>もちろん、<code>p</code> や <code>po</code> コマンドは式の評価が可能なので</p>

<p><code>objective-c
(lldb) p (engineer as! iOSEngineer).swiftLevel
(Int) $R20 = 3
</code></p>

<p>のようにキャストすることで中身を見ることはできます。<br/>
ですが、少々手間ではありますよね&hellip;<br/>
(深い階層のサブフィールドを見ようとすればするほど&hellip;)</p>

<p>これが <code>v</code> コマンドでは、</p>

<p><code>objective-c
(lldb) v engineer.swiftLevel
(Int) engineer.swiftLevel = 3
</code></p>

<p>とキャストせずとも結果を得ることができます。</p>

<h3>filter機能</h3>

<p>もう一つ、LLDBコマンドを利用する上で役立つのが <code>filter</code> 機能です。<br/>
折角なので使い方を見ていきましょう。</p>

<h4>filter機能の紹介</h4>

<p>フィールドの多い変数や、その変数と同じ型の要素を数十個持つ配列などを出力させる場合、とてもではないですが特定のフィールドを見つけることは困難です。</p>

<p>そんな時には <code>filter</code> 機能を利用して、特定の型であれば、特定のフィールドのみを表示するといったことができます。<br/>
指定の方法は簡単で、</p>

<p><code>objective-c
type filter add &lt;Xcodeのプロジェクト名&gt;.&lt;型の名前&gt; --child &lt;フィールド名&gt;
</code></p>

<p>のようにするだけです。<br/>
筆者の例で言えば、</p>

<p><code>objective-c
type filter add Sample.iOSEngineer --child name
</code></p>

<p>のような感じです。</p>

<p>これにより、</p>

<p><code>objective-c
(lldb) v engineer
(MeasurementSample.iOSEngineer) engineer = (name = "Ichiro")
</code></p>

<p>のように今必要のないフィールドを省略して、結果を得ることができます。<br/>
※便宜上、 <code>v</code> コマンドを使いましたが <code>p</code> コマンドでも同じ結果を得ることができます。</p>

<p>因みに、機能利用後は忘れずに <code>filter</code> を解除しましょう。</p>

<p><code>objective-c
type filter delete &lt;Xcodeプロジェクト名&gt;.&lt;型の名前&gt;
</code></p>

<p>で解除できます。</p>

<h4>filter機能の限界</h4>

<p>因みに、 <code>filter</code> 機能も万能ではなく、場合によっては複数回 <code>filter</code> をセットすることで結果を得なければいけないこともあります。<br/>
例えば、</p>

<p>```objective-c
protocol Engineer {</p>

<pre><code>var name: String { get set }
var age: Int { get set }
var specialty: [String] { get set }
</code></pre>

<p>}</p>

<p>struct iOSEngineer: Engineer {</p>

<pre><code>var name: String
var age: Int
var specialty: [String]
var swiftLevel: Int
var obcLevel:Int
</code></pre>

<p>}</p>

<p>struct WebEngineer: Engineer {</p>

<pre><code>var name: String
var age: Int
var specialty: [String]
var htmlLevel: Int
var cssLevel: Int
var jsLevel: Int
</code></pre>

<p>}
```</p>

<p>のように新たに <code>Engineer</code> プロトコルに準拠した <code>WebEngineer</code> を定義し、以下のような配列を作成します。</p>

<p>```objective-c
let engineer1 = WebEngineer(name: &ldquo;Taro&rdquo;, age: 30, specialty: [&ldquo;react&rdquo;], htmlLevel: 2, cssLevel: 1, jsLevel: 1)
let engineer2 = WebEngineer(name: &ldquo;Jiro&rdquo;, age: 35, specialty: [&ldquo;vue&rdquo;], htmlLevel: 3, cssLevel: 2, jsLevel: 4)
let engineer3 = iOSEngineer(name: &ldquo;Saburo&rdquo;, age: 25, specialty: [&ldquo;gps&rdquo;, &ldquo;bluetooth&rdquo;], swiftLevel: 3, obcLevel: 2)
let engineer4 = WebEngineer(name: &ldquo;Shiro&rdquo;, age: 28, specialty: [&ldquo;react&rdquo;, &ldquo;vue&rdquo;, &ldquo;angular&rdquo;], htmlLevel: 4, cssLevel: 4, jsLevel: 5)</p>

<p>let engineers = [engineer1, engineer2, engineer3, engineer4]
```</p>

<p><code>engineers</code> をそのまま <code>v</code> コマンドで出力すると少し見えにくそうなので <code>filter</code> 機能が利用したいのですが、<br/>
<code>Engineer</code> に準拠しているからと言って</p>

<p><code>objective-c
(lldb) type filter add Sample.Engineer --child name
</code></p>

<p>としても思ったようには動かず、全フィールドが出力されてしまいます。</p>

<p>そこで、</p>

<p><code>objective-c
(lldb) type filter add Sample.iOSEngineer --child name
(lldb) type filter add Sample.WebEngineer --child name
</code></p>

<p>としてやれば、</p>

<p><code>objective-c
(lldb) v engineers
([Engineer]) engineers = 4 values {
  [0] = (name = "Taro")
  [1] = (name = "Jiro")
  [2] = (name = "Saburo")
  [3] = (name = "Shiro")
</code></p>

<p>このように期待した結果を得ることができます。</p>

<h3>まとめ</h3>

<p>さて如何でしたでしょうか。<br/>
<code>p</code> , <code>po</code> , <code>v</code> コマンドは各々用途がありそうですが、特に <code>v</code> コマンドの利便性を感じてもらえたら幸いです。<br/>
筆者も積極的に <code>v</code> コマンドを使っていきたいと思います。</p>

<p>といったところで本日はここまで。</p>

<p>参考URL:</p>

<ul>
<li><a href="https://developer.apple.com/videos/play/wwdc2019/429/">LLDB: Beyond &ldquo;po&rdquo;</a></li>
</ul>


<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOSアプリのパフォーマンス計測に『os.signpost』を活用しよう！]]></title>
    <link href="http://grandbig.github.io/blog/2019/09/07/os-signpost/"/>
    <updated>2019-09-07T16:22:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2019/09/07/os-signpost</id>
    <content type="html"><![CDATA[<h3>はじめに</h3>

<p>これまでメソッドの処理時間を計測するには、<br/>
<code>Date</code> 関数の <code>timeIntervalSince</code> メソッドを以下のように利用する場面が度々ありました。</p>

<p><code>objective-c
let beginDate = Date()
sample()
let endDate = Date()
let time = endDate.timeIntervalSince(beginDate)
print(time)
</code></p>

<p>しかし実は <code>iOS12</code> から <code>os.signpost</code> を利用してもっと便利に処理時間を計測することができるようになりました。<br/>
本日は <code>os.signpost</code> を利用したことをメモとして記録しておきます。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h3>os.signpostのメリット・デメリット</h3>

<p><code>os.signpost</code> を利用すると何が良いかと言うと、</p>

<ul>
<li>最小/最大/平均の処理時間が自動で計測できる</li>
<li>CPU使用率など <code>Instruments</code> による他の計測結果と並行して状況を把握できる</li>
</ul>


<p>などが上げられます。</p>

<p>一方でデメリットは <code>os.signpost</code> がiOS12以降でしか利用できないということです。<br/>
よって、iOS11以下をサポートするアプリの場合、</p>

<p>```objective-c
if #available(iOS 12, *) {</p>

<pre><code>...
</code></pre>

<p>}
```</p>

<p>の条件分岐をした上で <code>os.signpost</code> を利用する必要があります。<br/>
しかし、これは時間が解決してくれるでしょう。<br/>
(あまり気にするデメリットではないということです。)</p>

<h3>os.signpostの使い方</h3>

<p>それでは早速、 <code>os.signpost</code> を使ってみましょう。<br/>
<code>os.signpost</code> は特にSDKを追加することなく、 <code>import</code> が可能です。</p>

<p>① <code>import os.signpost</code> を追加する</p>

<p>② OSLogオブジェクトを初期化する</p>

<p><a href="https://developer.apple.com/documentation/os/oslog/2320726-init">Apple Developer Document: OSLog &ndash; init</a>に記載のある通り、初期化をします。</p>

<p><code>objective-c
let osLog = OSLog(subsystem: "com.takahiro.MeasurementSample", category: "loop")
</code></p>

<p><code>subsystem</code> には <code>com.your_company.your_subsystem_name</code> の形で定義するようにと例として書かれています。<br/>
<code>category</code> はログのカテゴリ分けに利用できるため、カテゴリ種別で命名すると良いでしょう。</p>

<p>③ 計測開始時に <code>OSSignpostType</code> に <code>.begin</code> を指定した <code>os_signpost</code> メソッドを呼び出す</p>

<p><a href="https://developer.apple.com/documentation/os/3019241-os_signpost">Apple Developer Document: os_signpost</a>に記載のあるメソッドを呼び出します。</p>

<p><code>objective-c
os_signpost(.begin, log: osLog, name: "sample")
</code></p>

<p>④ 計測完了時に <code>OSSignpostType</code> に <code>.end</code> を指定した <code>os_signpost</code> メソッドを呼び出す</p>

<p>③と同じメソッドですが、計測完了時には <code>OSSignpostType</code> に <code>end</code> を指定します。</p>

<p><code>objective-c
os_signpost(.end, log: osLog, name: "sample")
</code></p>

<p>これで、後は <code>Instruments</code> を起動して、<code>os_signpost</code> を追加して計測すればOKです。</p>

<p>今回は、下記のようなサンプルを用意して計測してみます。</p>

<p>```objective-c
// ViewController.swift
import UIKit
import os.signpost</p>

<p>class ViewController: UIViewController {</p>

<pre><code>override func viewDidLoad() {
    super.viewDidLoad()
    // Do any additional setup after loading the view.
}

@IBAction func tapButton(_ sender: Any) {
    let osLog = OSLog(subsystem: "com.takahiro.MeasurementSample", category: "loop")
    os_signpost(.begin, log: osLog, name: "sample")
    sample()
    os_signpost(.end, log: osLog, name: "sample")
}

private func sample() {
    for i in 0 ..&lt; 100000 {
        print(i)
    }
}
</code></pre>

<p>}
```</p>

<h3>os.signpostでの計測結果</h3>

<p><code>Instruments</code> で計測した結果は下記のように見ることができます。</p>

<p><img src="/images/os-signpost.png" alt="Instrumentsのos.signpostの計測結果" /></p>

<p>上記結果から、計測処理が <code>平均88.97 [ms]</code> かかっていることがわかります。<br/>
またこの処理の実行中はCPUが100%に張り付いていることも見て取れます。</p>

<p>今回はサンプルなので <code>print</code> で1万回出力するメソッドを計測しました。<br/>
本物のアプリではボトルネックとなる処理を見つけ、如何にして処理を改善できないか検討することになるでしょう。</p>

<h3>まとめ</h3>

<p>いかがでしたでしょうか。<br/>
iOS13のリリースが近づいてきた(iOS12の普及が十分に達しつつある)今だからこそ改めて <code>signpost</code> を積極的に利用していきましょう。<br/>
といったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
</feed>
