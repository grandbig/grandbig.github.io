<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: swift | Takahiro Octopress Blog]]></title>
  <link href="http://grandbig.github.io/blog/categories/swift/atom.xml" rel="self"/>
  <link href="http://grandbig.github.io/"/>
  <updated>2016-02-13T21:14:38+09:00</updated>
  <id>http://grandbig.github.io/</id>
  <author>
    <name><![CDATA[Takahiro]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Swift2.xでのシングルトンパターンとクラスメソッド / インスタンスメソッド]]></title>
    <link href="http://grandbig.github.io/blog/2016/02/06/swift2-singleton/"/>
    <updated>2016-02-06T11:41:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2016/02/06/swift2-singleton</id>
    <content type="html"><![CDATA[<h4>シングルトンを使用したクラスでクラスメソッドとインスタンスメソッドを定義する</h4>

<p>本日は、</p>

<ul>
<li>Swift2.xでのシングルトンパターンのクラスの定義の仕方</li>
<li>そのクラスにおけるクラスメソッドとインスタンスメソッドの定義の仕方</li>
<li>クラスメソッドとインスタンスメソッドの呼び出し方</li>
</ul>


<p>について見ていきたいと思います。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h5>シングルトンパターンのクラスの定義</h5>

<p>まず、シングルトンパターンのクラスの定義の方法を見ていきましょう。<br/>
Swift1.2までとSwift2.xでは定義の仕方が異なります。<br/>
ここではSwift2.xの場合のみ書きます。</p>

<p>```objective-c
class SingletonSample:NSObject {</p>

<pre><code>// シングルトンパターンとして定義
static let sharedInstance:SingletonSample = SingletonSample()

private init() {
}
</code></pre>

<p>}
```</p>

<p>インスタンスは1つしか作られないので、</p>

<ul>
<li>内容に変更がない変数ということで<code>let</code>を使用</li>
<li>SingletonSampleクラスにおける固有の値ということで<code>static</code>を使用</li>
<li>外部クラスからインスタンス化することを防ぐために<code>private</code>で<code>init</code>を定義</li>
</ul>


<p>となっています。</p>

<p>シングルトンパターンのクラスを利用するときは、<br/>
<code>SingletonSample.sharedInstance</code>でOKです。<br/>
これで1つのインスタンスを使い回すことができます。</p>

<h5>インスタンスメソッドの定義</h5>

<p>次にシングルトンパターンにおけるインスタンスメソッドの定義方法について見ていきましょう。<br/>
まずは、定義する側です。</p>

<p>```objective-c
class SingletonSample:NSObject {</p>

<pre><code>...
// インスタンスメソッドの定義
func sampleInstanceMethod() {
    ...
}
...
</code></pre>

<p>}
```</p>

<p>インスタンスメソッドを使うときは</p>

<p><code>objective-c
SingletonSample.sharedInstance.sampleMethod()
</code></p>

<p>という形で使うことができます。<br/>
<code>SingletonSample.sharedInstance</code>で1つのインスタンスを使うことができるので、通常のクラスと使い方は同じですよね。</p>

<h5>クラスメソッドの定義</h5>

<p>最後にシングルトンパターンにおけるクラスメソッドの定義方法について見ていきましょう。<br/>
まずは、定義する側です。</p>

<p>```objective-c
class SingletonSample:NSObject {</p>

<pre><code>...
// クラスメソッドの定義
class func sampleClassMethod() {
    ...
}
...
</code></pre>

<p>}
```</p>

<p>クラスメソッドを使うときは</p>

<p><code>objective-c
SingletonSample.sampleClassMethod()
</code></p>

<p>という形で使うことができます。<br/>
クラスメソッドはクラスをインスタンス化する必要なく、利用できるメソッドなので、<br/>
<code>SingletonSample.sharedInstance</code>とインスタンスを通して利用せずに、 <strong>クラス名+メソッド名</strong> で利用できるんですね。</p>

<p>本日は簡単ですが、以上になります。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[位置情報サービスの許可アラートに表示する文字数について]]></title>
    <link href="http://grandbig.github.io/blog/2016/01/31/location-alert-number-of-characters/"/>
    <updated>2016-01-31T22:55:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2016/01/31/location-alert-number-of-characters</id>
    <content type="html"><![CDATA[<h4>位置情報サービスの許可アラートに文字数制限はあるのか！？</h4>

<p>位置情報サービスを利用するアプリの場合、位置情報サービスの利用許可を求めるアラートが表示されます。<br/>
これはアプリで位置情報を利用するために必須の機能であり、これなくしては、<code>CoreLocation.framework</code>を通して、位置情報を利用することはできません。</p>

<p>とここまではiOSエンジニアで位置情報サービスを扱ったアプリを開発した方々にとっては周知の事実かと思います。<br/>
しかし、その許可アラートには『 <strong>どのくらいの文字を記載することができるのか</strong> 』まで気にする方はあまり多くないかもしれません。</p>

<p>ふと気になったので、試してみました。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<p>Local Notification / Remote Notificationは文字数に制限があるということで以前から述べられてきました。<br/>
例えば、下記が参考になると思います。</p>

<ul>
<li><a href="http://www.hangout.co.jp/blog/archives/295">iOSのプッシュ通知の文字数とデータサイズの制限</a></li>
<li><a href="http://iot.mb.cloud.nifty.com/iotcolumn/%E6%96%87%E5%AD%97%E6%95%B0%E5%88%B6%E9%99%90%E3%83%97%E3%83%83%E3%82%B7%E3%83%A5%E9%80%9A%E7%9F%A5">文字数制限を知って効果的にプッシュ通知を利用しよう！</a></li>
<li><a href="http://qiita.com/mono0926/items/df03c61adc56934e2e7a">iOSのPUSH通知(APNS)の特徴・ノウハウまとめ(iOS 9まで対応)</a></li>
</ul>


<p>では、位置情報サービスを利用する際に表示される許可アラートに表示可能な文字数に制限はあるのでしょうか？<br/>
iOS9ではLocal Notification / Remote Notificationの制限は4KB(4096Bytes)とのことなので、このくらいいけるのでしょうか&hellip;。</p>

<p>はい。結果です。<br/>
全角で <strong>3938文字</strong> まで行けました。<br/>
これは<code>Info.plist</code>に記載できた文字数です。<br/>
これ以上は入力しても<code>Info.plist</code>に表示されないんですね&hellip;。<br/>
ただ、設定 > 位置情報サービス > アプリ に表示される文言はもう少し行けてるんですよ&hellip;。</p>

<p>たぶんLocal Notification / Remote Notificationと同じ制限な気がしますね。<br/>
まだまだiOS7やiOS8に対応する必要もあるでしょうし、長すぎるとそもそもユーザに対するハードルを上げることになるので全くオススメできませんよね。</p>

<p>ま、文字数は気にしすぎずに、Appleが言うように極力短く的確に書くにこしたことはないと思います。</p>

<p>参考までにキャプチャを貼っておきます。</p>

<p><img src="/images/corelocation_alert.png" alt="位置情報サービス許可アラート" /><br/>
アラート内をスクロールして全文を読むことができます。</p>

<p>といったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swiftでドキュメントコメントを正しく書こう！]]></title>
    <link href="http://grandbig.github.io/blog/2016/01/24/swift-document-comment/"/>
    <updated>2016-01-24T00:13:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2016/01/24/swift-document-comment</id>
    <content type="html"><![CDATA[<h4>Swiftでのドキュメントコメントの書き方を覚えよう！</h4>

<p>先日、<a href="http://grandbig.github.io/blog/2016/01/12/jazzy/">jazzy: リファレンス自動生成ツール</a>の記事を書きました。<br/>
その中で幾つかのドキュメントコメントの書き方を紹介しましたが、改めて説明しておきたいと思います。</p>

<p>Swiftではドキュメントコメントの中でマークアップ言語の書式が有効に働きます。<br/>
代表的なマークアップ言語の書式は下記の通りです。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h4>マークアップ言語の書式</h4>

<h5>見出し</h5>

<p>```objective-c</p>

<h1>最大見出し</h1>

<h2>大見出し</h2>

<h3>中見出し</h3>

<h4>見出し</h4>

<h5>小見出し</h5>

<h6>最小見出し</h6>

<p>```</p>

<p><img src="/images/documment_comment_1.png" alt="見出しを書いた場合" /></p>

<h5>リスト</h5>

<p>```objective-c
&ndash; リスト項目１</p>

<pre><code>- リスト小項目１
- リスト小項目２
- リスト小項目３
</code></pre>

<ul>
<li>リスト項目２</li>
<li>リスト項目３
```</li>
</ul>


<p><img src="/images/documment_comment_2.png" alt="リストを書いた場合" /></p>

<h5>順序リスト</h5>

<p>```objective-c
1. 順序リスト項目１</p>

<pre><code>1. 小順序リスト項目１
2. 小順序リスト項目２
3. 小順序リスト項目３
</code></pre>

<ol>
<li>順序リスト項目２</li>
<li>順序リスト項目３
```</li>
</ol>


<p><img src="/images/documment_comment_3.png" alt="順序リストを書いた場合" /></p>

<h5>ItalicとBold</h5>

<p>```objective-c
normal</p>

<p><em>Italic</em></p>

<p><strong>Bold</strong>
```</p>

<p><img src="/images/documment_comment_4.png" alt="ItalicとBold" /></p>

<h5>URLリンク</h5>

<p><code>objective-c
[URLリンク](https://developer.apple.com/jp/)
</code></p>

<p><img src="/images/documment_comment_5.png" alt="URLリンク" /></p>

<h5>罫線</h5>

<p>```objective-c
abcdefg</p>

<hr />

<p>123456</p>

<hr />

<p>あいうえお</p>

<hr />

<p>かきくけこ
```</p>

<p><img src="/images/documment_comment_6.png" alt="罫線" /></p>

<h5>コード表記</h5>

<p>(Octopressの都合上、ここでは書き方が異なりますが、ご了承ください。)</p>

<p>` ` `<br/>
self.sampleMethod()<br/>
` ` `</p>

<p><img src="/images/documment_comment_7.png" alt="コード表記" /></p>

<h4>Swiftのドキュメントコメントの書式</h4>

<h5>MARK</h5>

<p>```objective-c
// MARK: &ndash; Properties
var sample:String = &ldquo;sampleProperty&rdquo;</p>

<p>// MARK: &ndash; Method
func sampleMethod() {</p>

<pre><code>print("This is sampleMethod.")
</code></pre>

<p>}
```</p>

<p><img src="/images/documment_comment_8.png" alt="MARK" /></p>

<h5>FIXME</h5>

<p>```objective-c
func sampleMethod() {</p>

<pre><code>// FIXME: - ログ出力ではなく、アラートを出す
print("This is sampleMethod.")
</code></pre>

<p>}
```</p>

<p><img src="/images/documment_comment_9.png" alt="FIXME" /></p>

<h5>TODO</h5>

<p>```objective-c
func sampleMethod() {</p>

<pre><code>// TODO: - ログ出力ではなく、何か処理を書く(まだ決まっていないけど)
print("This is sampleMethod.")
</code></pre>

<p>}
```</p>

<p><img src="/images/documment_comment_10.png" alt="TODO" /></p>

<h5>Parameter / Throws / Returns</h5>

<p>```objective-c
/**
 サンプルメソッド</p>

<ul>
<li>parameter name: パラメータの書き方</li>
<li>throws: 例外処理の書き方</li>
<li><p>returns: 戻り値の書き方
*/
func sampleMethod2(name:String) throws &ndash;> String {</p>

<p>  return &ldquo;result: &rdquo; + name
}
```</p></li>
</ul>


<p><img src="/images/documment_comment_11.png" alt="Parameter / Throws / Returns" /></p>

<h5>Description内で利用可能な文言</h5>

<p>この他にクラス, プロパティ, メソッドの説明(Description)を書く際に利用可能な予約語的なものが幾つかあります。</p>

<p><code>objective-c
/**
 - Attention: 注意書き
 - Author: 作成者が一人の場合
 - Authors: 作成者が複数人の場合
 - Bug: バグの詳細
 - Copyright: 著作権の所在
 - Date: 日付(作成日, 更新日など)
 - Experiment: 実験内容
 - Important: 重要事項
 - Invariant: 不変事項
 - Note: その他、必要事項
 - Precondition: 事前条件
 - Postcondition: 事後条件
 - Remark: 備考
 - Requires: 要求事項
 - SeeAlso: 参照事項
 - Since: いつから実装されているか
 - Version: バージョン
 - Warning: 警告                 
*/
</code>
上記のように書くことで、 <strong>太字</strong> かつ <strong>各用語に属する説明</strong> が付与されます。</p>

<p><img src="/images/documment_comment_12.png" alt="予約語1" /></p>

<p><img src="/images/documment_comment_13.png" alt="予約語2" /></p>

<h4>まとめ</h4>

<p>さて、いかがだったでしょうか？<br/>
これだけ知っていれば、ほぼ確実に困ることはないと思います。<br/>
どこまで頑張って書くかは開発者次第かもしれませんが、やはり初めてコードを見る人でも極力伝わるようにしておくことは必要不可欠かと思います。</p>

<p>といったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SwiftでGCDを使ってみよう！]]></title>
    <link href="http://grandbig.github.io/blog/2016/01/18/semaphore/"/>
    <updated>2016-01-18T09:26:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2016/01/18/semaphore</id>
    <content type="html"><![CDATA[<h4>GCDとは</h4>

<p>GCDとはGrand Central Dispatchの略で、iOSアプリでマルチスレッド処理を実行したいときに利用する手法です。<br/>
書き方は独特ですが、慣れてしまえば、簡単に使いこなすことができると思います。<br/>
今回は筆者が困ったときに使う方法について紹介していきます。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h4>メインスレッドの処理を妨げたくないとき</h4>

<p>iOSアプリでは描画はメインスレッドでしか実行できません。<br/>
(もし、それ以外で実行しようとすれば、アプリがダウンしてしまいます。)</p>

<p>筆者がアプリを開発しているときに、<br/>
検証のため、ログをローカルストレージに保存したい場面がありました。<br/>
ログ保存処理は一時的な検証のためであり、本来のメイン処理を妨げたくはありません。</p>

<p>ログ保存処理は <strong>描画を含まない処理</strong> であるため、<br/>
別にスレッドを立てて、そちらに任せてしまうことができます。<br/>
これにより、メインスレッドに影響を及ぼすことなく、処理を実行することができます。</p>

<p>下記にサンプルを載せます。</p>

<p>```objective-c
// ViewController.swift
import UIKit</p>

<p>class ViewController: UIViewController {</p>

<pre><code>let queue:dispatch_queue_t = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)

override func viewDidLoad() {
    super.viewDidLoad()

    dispatch_async(queue) {() -&gt; Void in
        // 別スレッドでの処理
        // 例えば、Realmを使った保存処理などを書く(今回は省略します)
    }

    // アラート表示処理
    let alertController:UIAlertController = UIAlertController(title: "確認", message: message, preferredStyle: .Alert)
    let okAction:UIAlertAction = UIAlertAction(title: "OK", style: .Default) { (alert) -&gt; Void in
        // OKを選択したときに実行される処理
    }
    alertController.addAction(okAction)
    presentViewController(alertController, animated: true, completion: nil)
}

&lt;省略&gt;
</code></pre>

<p>}
```</p>

<p>このように <strong>dispatch_async</strong> 内でRealmへのログ保存処理をすれば、<br/>
別スレッドでの処理となるため、<br/>
ログ保存処理を待たずにアラートの表示処理を実行することができます。</p>

<p><strong>dispatch_get_global_queue</strong> とその引数などの詳細は<a href="https://github.com/mixi-inc/iOSTraining/wiki/8.2-Grand-Central-Dispatch">8.2 Grand Central Dispatch</a>に非常に詳しく書かれているので、ぜひご参照ください。</p>

<h4>複数の非同期処理の情報で何か処理がしたいとき</h4>

<p>例えば、複数種類のWeb APIを叩いて、それぞれから取得した情報を合算して、画面に表示したいとします。<br/>
（別々にAPIを叩いて取得した情報を別々に返せば問題ない場面では当てはまらないので注意）</p>

<p>そんなときは <strong>dispatch_group_async</strong> と <strong>dispatch_group_notify</strong> を使います。</p>

<p>下記にサンプルを載せます。</p>

<p>```objective-c</p>

<h1>import UIKit</h1>

<p>class ViewControlelr:UIViewController {</p>

<pre><code>let queue:dispatch_queue_t = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)
let group:dispatch_group_t = dispatch_group_create()

&lt;省略&gt;

/**
指定都市の天気情報を取得する処理
*/
func getWeather(location:String, closure:(String) -&gt; Void) {
    Alamofire.request(.GET, "http://api.openweathermap.org/data/2.5/weather?APPID=&lt;自身のAPPID&gt;", parameters: 
        ["q":location]).response { (request, response, data, error) -&gt; Void in
        if(error == nil) {
            do {
                let dataDict = try NSJSONSerialization.JSONObjectWithData(data!, options: NSJSONReadingOptions.AllowFragments)
                let weatherArray:[AnyObject] = dataDict["weather"] as! [AnyObject]
                let weather:AnyObject = weatherArray[0]
                let description:String = weather["description"] as! String
                closure(description)
            } catch {
                print("例外が発生しました")
            }
        }
    }
}

/**
複数都市の天気情報を取得しログ出力する処理
*/
func getMultiLocationWeather() {
    var tokyoWeather:String = "unknown"
    var osakaWeather:String = "unknown"
    var saitamaWeather:String = "unknown"

    // グループに 「+1」
    dispatch_group_enter(self.group)
    dispatch_group_async(self.group, self.queue) { () -&gt; Void in
        self.getWeather("Tokyo, jp", closure: { (weather) -&gt; Void in
            tokyoWeather = weather
            // グループに 「-1」
            dispatch_group_leave(self.group)
        })
    }

    // グループに 「+1」
    dispatch_group_enter(self.group)
    dispatch_group_async(self.group, self.queue) { () -&gt; Void in
        self.getWeather("Osaka, jp", closure: { (weather) -&gt; Void in
            osakaWeather = weather
            // グループに 「-1」
            dispatch_group_leave(self.group)
        })
    }

    // グループに 「+1」
    dispatch_group_enter(self.group)
    dispatch_group_async(self.group, self.queue) { () -&gt; Void in
        self.getWeather("Saitama, jp", closure: { (weather) -&gt; Void in
            saitamaWeather = weather
            // グループに 「-1」
            dispatch_group_leave(self.group)
        })
    }

    // 全ての処理が終わったら実行される
    dispatch_group_notify(self.group, self.queue) { () -&gt; Void in
        print("Tokyo: \(tokyoWeather), Osaka: \(osakaWeather), Saitama: \(saitamaWeather)")
    }
}

&lt;省略&gt;
</code></pre>

<p>}
```</p>

<p>以上のように、3つの非同期処理で取得した情報を使って、文章を作成し、ログ出力することができます。</p>

<h4>非同期処理を同期処理にしたい(排他制御を使いたい)とき</h4>

<p>さて、こちらは正直、筆者は利用したいと思ったことがありません。<br/>
恐らく、かなり多機能なアプリで、極力多くの処理を並列に実行したい場合に必要なのかなと思ったりします。<br/>
では、なぜ書くかというと、先日スタックオーバーフローを見て気になったからです。</p>

<p>因みに、筆者のスタックオーバーフローユーザは<a href="http://ja.stackoverflow.com/users/8968/takahiro">こちら</a>です。</p>

<p><a href="https://blog.katty.in/2365">Objective-Cで非同期処理を同期処理にする方法。</a>の例をSwiftで書き直します。</p>

<p>```objective-c</p>

<h1>import UIKit</h1>

<p>class ViewController:UIViewController {</p>

<pre><code>let semaphore:dispatch_semaphore_t = dispatch_semaphore_create(0)
let queue:dispatch_queue_t = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)

&lt;省略&gt;

func printLog() {
    dispatch_async(queue) { () -&gt; Void in
        for(var i=0; i &lt; 5; i++) {
            sleep(1)
            print("Process: \(i)")
        }
        dispatch_semaphore_signal(self.semaphore)
    }

    print("wait...")
    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER)
    print("finish")
}

&lt;省略&gt;
</code></pre>

<p>}
```</p>

<p>実行してみれば、下記のようにログ出力されることがわかるでしょう。</p>

<p><code>objective-c
wait...
Process: 0
Process: 1
Process: 2
Process: 3
Process: 4
finish
</code></p>

<p>非同期処理を待ってから、 <strong>finish</strong> とログ出力されていることがわかります。<br/>
この例ではわかりやすさのため、 <strong>dispatch_async</strong> を使って、非同期処理を作り出しています。</p>

<p>iOSアプリの開発でよく利用する非同期処理と言えば、通信処理ではないでしょうか？<br/>
Swiftでは特に<a href="https://github.com/Alamofire/Alamofire">Alamofire</a>がよく利用されています。</p>

<p>Alamofireを使って、上記と似たことをやろうとすると、下記のように書くかもしれません。</p>

<p>```objective-c</p>

<h1>import UIKit</h1>

<p>class ViewController:UIViewController {</p>

<pre><code>let semaphore:dispatch_semaphore_t = dispatch_semaphore_create(0)
let queue:dispatch_queue_t = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)

&lt;省略&gt;

func getWeather() {
    Alamofire.request(.GET, "http://api.openweathermap.org/data/2.5/weather?APPID=&lt;自身のAPPID&gt;", parameters:
        [q: "Tokyo, jp"]).response { (request, response, data, error) -&gt; Void in
            if(error == nil) {
                do {
                    let dataDict = try NSJSONSerialization.JSONObjectWithData(data!, options: NSJSONReadingOptions.AllowFragments)
                    let weatherArray:[AnyObject] = dataDict["weather"] as! [AnyObject]
                    let weather:AnyObject = weatherArray[0]
                    let description:String = weather["description"] as! String

                    dispatch_semaphore_signal(semaphore)
                } catch {
                    print("例外が発生しました")
                }
            }
        }

    print("wait...")
    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER)
    print("finish")
}

&lt;省略&gt;
</code></pre>

<p>}
```</p>

<p>しかしながら、これは実行しても <strong>finish</strong> とログを出力することはありません。<br/>
理由は、<strong>dispatch_semaphore_wait</strong> を実行した後、メインスレッドを停止するのですが、<br/>
<code>Alamofire</code>の <strong>response</strong> のクロージャ処理はメインスレッドで実行されるため、<br/>
<strong>dispatch_semaphore_signal</strong> が実行されることがないからです。</p>

<p>実際に<code>Alamofire</code>の<code>ResponseSerialization.swift</code> > <code>Request</code> クラスを見てみましょう。</p>

<p>```objective-c
public func response(</p>

<pre><code>queue queue: dispatch_queue_t? = nil,
completionHandler: (NSURLRequest?, NSHTTPURLResponse?, NSData?, NSError?) -&gt; Void)
-&gt; Self
</code></pre>

<p>{</p>

<pre><code>delegate.queue.addOperationWithBlock {
    dispatch_async(queue ?? dispatch_get_main_queue()) {
        completionHandler(self.request, self.response, self.delegate.data, self.delegate.error)
    }
}

return self
</code></pre>

<p>}
```</p>

<p>となっていることがわかるはずです。</p>

<p>さて、いかがでしたでしょうか？<br/>
GCDは非常に便利な反面、迂闊に使うと思わぬ落とし穴にハマってしまうことがあります。<br/>
とは言え、<br/>
一度ハマってみないと身につかないのがプログラミングの世界だと思っているので、<br/>
ぜひじゃんじゃん使ってハマってみて頂ければと思います笑</p>

<p>と言ったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[QuickでSwiftコードのUnitテストをしよう！]]></title>
    <link href="http://grandbig.github.io/blog/2016/01/16/quick/"/>
    <updated>2016-01-16T19:49:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2016/01/16/quick</id>
    <content type="html"><![CDATA[<h4>Quickフレームワークを使おう！</h4>

<p>先日、XCTestによるiOSアプリのUnit TestとUI Testについて記事を書きました。<br/>
もちろんXCTestを使って、テストをすることに問題はありません。<br/>
ですが、XCTestは非常に独特な書式で、初めて使う人には取っ付きにくいかと思います。</p>

<p>そんな中、注目を集めているiOSアプリ用のテストフレームワークが<a href="https://github.com/Quick/Quick">Quick</a>です。<br/>
GitHubに書かれている通り、<a href="https://github.com/rspec/rspec">RSpec</a> / <a href="https://github.com/specta/specta">Specta</a> / <a href="https://github.com/onsi/ginkgo">Ginkgo</a>にインスパイアされて開発されているため、親しみやすい書式でテストコードを書くことができます。<br/>
(筆者もこれを機に親しもうと思います笑)</p>

<p>これまでiOSアプリのテストコードは独特で&hellip;と避けてきた方がいましたら、ぜひ <strong>Quick</strong> を導入してみて頂ければと思います。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h4>Quickの導入方法</h4>

<p>では、Quickを導入しましょう。<br/>
GitHubにも書いてありますが、CocoaPodsでの導入方法は下記です。<br/>
※ 説明用のプロジェクト名を <strong>QuickSample</strong> とします。</p>

<p>１．Podfileの作成</p>

<p>```objective-c</p>

<h1>Podfile</h1>

<p>use_frameworks!</p>

<p>def testing_pods</p>

<pre><code>pod 'Quick', '~&gt; 0.8.0'
pod 'Nimble', '3.0.0'
</code></pre>

<p>end</p>

<p>target &lsquo;QuickSampleTests&rsquo; do</p>

<pre><code>testing_pods
</code></pre>

<p>end</p>

<p>target &lsquo;QuickSampleUITests&rsquo; do</p>

<pre><code>testing_pods
</code></pre>

<p>end
```</p>

<p>２．CocoaPodsコマンドを実行<br/>
Podfileと同階層で<code>pod install</code>を実行</p>

<p>３．テストファイルを用意<br/>
プロジェクト作成時に<code>QuickSampleTests.swift</code>を作成しておいたので、それを編集します。</p>

<p>```objective-c
// QuickSampleTests.swift
import XCTest
import Quick
import Nimble
@testable import QuickSample</p>

<p>class QuickSampleTests: QuickSpec {</p>

<pre><code>override func spec() {
    // ここにテストコードを書いていきます。
}
</code></pre>

<p>}
```</p>

<p>これで<code>QuickSpec</code>をオーバーライドしたテスト用クラスになりました。<br/>
最低限の準備はこれで完了です。</p>

<h4>Quickでのテストコードの書式</h4>

<p>続いて、基本的なテストコードの書式を見ていきましょう。</p>

<p>１．<code>describe</code>：『何のテストをするのか』を記述</p>

<p>```objective-c
// テストコード
override func spec() {</p>

<pre><code>describe("天気情報をログ出力する") {
    // 「天気情報をログ出力する」ことをテストするためのコードを書いていきます。
}
</code></pre>

<p>}
```</p>

<p>２．<code>context</code>：『どういった条件のテストをするのか』を記述</p>

<p>```objective-c
// テストコード
override func spec() {</p>

<pre><code>describe("天気情報をログ出力する") {
    context("晴れの場合") {
        // 天気が晴れの場合のテスト
    }

    context("雨の場合") {
        // 天気が雨の場合のテスト
    }
}
</code></pre>

<p>}
```</p>

<p>３．<code>it</code>：『このテストはこういった結果になる』ということを記述</p>

<p>```objective-c
// テストコード
override func spec() {</p>

<pre><code>describe("天気情報をログ出力する") {
    context("晴れの場合") {
        // 天気が晴れの場合のテスト
        it("print out 'sunny'") {
            // 実行するテストコードをここに記述します
        }
    }

    &lt;省略&gt;
}
</code></pre>

<p>}
```</p>

<p>４．<code>expect('☓☓☓').to(△△△)</code>：『「☓☓☓」が「△△△」と等しい結果になる』ことを記述<br/>
ここは説明のために、テスト対象を<code>Weather.swift</code>として下記のようなコードだとします。<br/>
あくまでも<code>expect('☓☓☓').to(△△△)</code>の説明であるため、<code>Weather.getWeather</code>の処理は超簡単にしています。</p>

<p>```objective-c
// Weather.swift
class Weather:NSObject {</p>

<pre><code>&lt;省略&gt;

func getWeather() -&gt; String {
    return "sunny"
}

&lt;省略&gt;
</code></pre>

<p>}
```</p>

<p>続いてテストコードです。</p>

<p>```objective-c
// テストコード
override func spec() {</p>

<pre><code>describe("天気情報をログ出力する") {
    context("晴れの場合") {
        // 天気が晴れの場合のテスト
        it("print out 'sunny'") {
            let weather = Weather().getWeather()
            expect(weather).to(contain("sunny"))
        }
    }

    &lt;省略&gt;
}
</code></pre>

<p>}
```</p>

<p>補足すると、</p>

<p>・戻り値と期待値が完全一致する場合：<code>to(equal(△△△))</code><br/>
・戻り値が期待値の一部を含む場合：<code>to(contain(△△△))</code></p>

<p>といったように使い分けましょう。</p>

<p>５．非同期処理のテストをする場合<br/>
これまで同期処理を見てきましたが、今度は非同期処理を見ていきましょう。</p>

<p><code>Weather.swift</code>クラスに非同期処理を追加します。</p>

<p>```objective-c
// Weather.swift
class Weather:NSObject {</p>

<pre><code>&lt;省略&gt;

func getAsyncWeather(closure:(String) -&gt; Void) {
    Alamofire.request(.GET, "http://api.openweathermap.org/data/2.5/weather?APPID=&lt;自身のAPPIDを指定&gt;", parameters:
        ["q":"Tokyo,jp"]).response { (request, response, data, error) -&gt; Void in
        if(error == nil) {
            do {
                let dataDict = try NSJSONSerialization.JSONObjectWithData(data!, options: NSJSONReadingOptions.AllowFragments)
                let weatherArray:[AnyObject] = dataDict["weather"] as! [AnyObject]
                let weather:AnyObject = weatherArray[0]
                let description:String = weather["description"] as! String
                closure(description)
            } catch {
                clouser("exception")
            }
        }
}

&lt;省略&gt;
</code></pre>

<p>}
```</p>

<p>XCTestでも説明しましたが、<br/>
Swiftではスタブの代わりに <strong>manual mocking</strong> という手法を採用しています。<br/>
なので、通信処理はテストコード内で継承したクラスを作成して、そちらで定数を返すようにしましょう。</p>

<p>```objective-c
// テストコード
override func spec() {</p>

<pre><code>// manual mockingのための用意
class WeatherMock:Weather {
    override func getAsyncWeather(closure:(String) -&gt; Void) {
        closure("sunny")
    }
}

describe("天気情報を取得する") {
    context("晴れの場合") {
        // 天気が晴れの場合のテスト
        it("print out 'sunny'") {
            var result:String = ""
            let wm:WeatherMock = WeatherMock()
            wm.getAsyncWeather{(weather) -&gt; Void in
                result = weather
            }
            expect(result).toEventually(equal("sunny"))"
        }
    }

    &lt;省略&gt;
}
</code></pre>

<p>}
```</p>

<p>因みに、非同期処理では、<code>to</code>ではなく<code>toEventually</code>を利用します。<br/>
<code>expect(result).toEventually(equal("sunny"), timeout: 10)</code>と書けば、<br/>
任意のタイムアウトを設定可能です。</p>

<p>その他のメソッドを探したい場合は、<br/>
<strong>Pods > Nimble > ObjCExpectation.swift > NMBExpectation</strong> を確認してみてください。<br/>
また、<a href="https://github.com/Quick/Nimble">GitHubのNimble</a>も参考になります。</p>

<h4>Quickでのテスト結果</h4>

<p>テストの実行方法はXCTestと同じです。<br/>
<strong>Xcodeメニュー > Product > Test</strong> を選択してテストを実行しましょう。</p>

<p>結果は同じく、Xcodeの左メニューに表示されます。</p>

<p><img src="/images/quick.png" alt="Xcodeのテスト結果" /></p>

<p>また、ログでも細かな結果が出力されますので、<br/>
(少し見づらいですが)なぜかテストが成功しないといったことがあれば、<br/>
積極的に確認してみましょう。</p>

<p>さて、いかがでしたでしょうか？<br/>
今のところは <strong>XCTest</strong> もしくは <strong>Quick</strong> によるUnit テストが主流になると思います。<br/>
開発者の使いやすさに合わせて選んでみてください。</p>

<p>と言ったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
</feed>
