<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: swift | Takahiro Octopress Blog]]></title>
  <link href="http://grandbig.github.io/blog/categories/swift/atom.xml" rel="self"/>
  <link href="http://grandbig.github.io/"/>
  <updated>2016-04-16T15:46:06+09:00</updated>
  <id>http://grandbig.github.io/</id>
  <author>
    <name><![CDATA[Takahiro]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[PromiseKitを使ってみよう！]]></title>
    <link href="http://grandbig.github.io/blog/2016/04/09/swift-promisekit/"/>
    <updated>2016-04-09T23:07:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2016/04/09/swift-promisekit</id>
    <content type="html"><![CDATA[<h4>SwiftでPromiseライブラリを使ってみよう</h4>

<p>さて、前回から引き続きSwiftでのPromiseライブラリについて見ていきたいと思います。<br/>
今回はPromiseライブラリのSwift界隈で有名な <strong>PromiseKit</strong> について見ていきます。</p>

<h4>PromiseKitのインストール</h4>

<p>早速、 <strong>PromiseKit</strong> の導入について紹介します。<br/>
筆者の場合、Xcode7.3を利用しているため、Swift2.2を扱うことになります。<br/>
<a href="https://github.com/mxcl/PromiseKit">GitHub</a>で紹介されている下記の導入方法では <strong>2.2.1</strong> がインストールされます。<br/>
しかし、このバージョンはSwift2.2に対応していないため、エラーが発生します。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<p>```objective-c
use_frameworks!</p>

<p>pod &ldquo;PromiseKit&rdquo;, &ldquo;~>2.0&rdquo;
```</p>

<p><a href="http://promisekit.org/">PromiseKitの公式ドキュメントページ</a>を見ると、Newsの項目でバージョン <strong>3.1.0</strong> でSwift2.2に対応したと書かれています。<br/>
そこで、今回は、</p>

<p>```objective-c
use_frameworks!</p>

<p>pod &ldquo;PromiseKit&rdquo;, &ldquo;3.1.0&rdquo;
```</p>

<p>とすることで、Xcode7.3でも問題なく、PromiseKitを扱えるようにしました。</p>

<h4>PromiseKitで非同期処理を直列に書いてみよう</h4>

<p>前回のBrightFutureで紹介した処理をPromiseKitで書いてみようと思います。<br/>
まずは、非同期処理をPromiseKitを使って定義します。</p>

<p>```objective-c
func p(msg: String) &ndash;> Promise<String>{</p>

<pre><code>let promise = Promise&lt;String&gt; { (fulfill, reject) in
    let queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)
    dispatch_async(queue, { 
        sleep(1)
        dispatch_sync(dispatch_get_main_queue(), {
            print(msg)
            fulfill(msg)
        })
    })
}

return promise
</code></pre>

<p>}
```</p>

<p>では、これを呼び出してみましょう。</p>

<p>```objective-c
p(&ldquo;Hello&rdquo;).then { (msg1) &ndash;> Promise<String> in</p>

<pre><code>return p("Good Evening")
</code></pre>

<p>}.then { (msg2) &ndash;> Promise<String> in</p>

<pre><code>return p("Good Bye")
</code></pre>

<p>}
```</p>

<p>ネストが浅い状態で複数の非同期処理を書くことができました。<br/>
また、BrightFutureと大きな違いはなく書くことできました。</p>

<h4>PromiseKitで非同期処理を並列に書いてみよう</h4>

<p>続いて、複数の非同期処理を並列に実行する場合を考えてみます。<br/>
順番に処理をする必要がなく、処理が完了したものから反映していきたい場合などに使いますね。</p>

<p>非同期処理自体は先程と同じものを使います。<br/>
では、並列に処理を呼び出してみましょう。</p>

<p>```objective-c
// 実行したい非同期処理を定義
let p1 = ps.p_promiseKit(&ldquo;Method1&rdquo;)
let p2 = ps.p_promiseKit(&ldquo;Method2&rdquo;)
let p3 = ps.p_promiseKit(&ldquo;Method3&rdquo;)</p>

<p>// まとめて非同期処理を実行
when([p1, p2, p3]).then { (result: [String]) &ndash;> AnyPromise in</p>

<pre><code>return AnyPromise(bound: Promise())
</code></pre>

<p>}
```</p>

<p>先に書いた直列処理では、1秒間隔でログが出力されたかと思います。<br/>
ここでは同時に実行したため、ほぼ同時に3つのログが出力されたはずです。</p>

<p>さて如何だったでしょうか？<br/>
SwiftでもPromiseライブラリはたくさん出てきました。<br/>
<a href="https://github.com/Thomvis/BrightFutures">BrightFuture</a>, <a href="https://github.com/mxcl/PromiseKit">PromiseKit</a>, <a href="https://github.com/ReactKit/SwiftTask">SwiftTask</a>のいずれを利用するかは開発者の判断になるかと思います。<br/>
個人的にはPromiseKitはGitHub上に似た名称のブランチがたくさんあるのをどうにかして欲しいなと思ってたりします笑</p>

<p>また、時間があるときにPromiseを使って何かやりたいと思います。<br/>
と言ったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[BrightFutureを使ってみよう！]]></title>
    <link href="http://grandbig.github.io/blog/2016/04/03/bright-future/"/>
    <updated>2016-04-03T17:11:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2016/04/03/bright-future</id>
    <content type="html"><![CDATA[<h4>SwiftでPromiseライブラリを使ってみよう</h4>

<p>最近は更新頻度が落ちてしまっていますが、久々に更新します。<br/>
(iPhoneSEが発表されたことですし笑)</p>

<p>さて、本日はSwift版Promiseライブラリとしては割と有名な <strong>BrightFuture</strong> ライブラリを使ってみたいと思います。<br/>
筆者は、新しいことに取り組む際は、JSで例を見た方がわかりやすかったりするので、Node.jsのPromiseと交えながら紹介していきたいと思います。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h4>Promiseとは</h4>

<p>まずは、Promiseの存在について軽く触れておきます。<br/>
<a href="http://azu.github.io/promises-book/">JS Promiseの本</a>によると、Promiseとは『非同期処理を抽象化したオブジェクトとそれを操作する仕組み』のことだそうです。<br/>
これだけ読むと理解しがたいと思うので、筆者が感じるPromiseの良さをざっくり書くと&hellip;</p>

<ul>
<li>非同期処理を繰り返す場合でも、深いネストにならない</li>
<li>非同期処理を繰り返す場合でも、見かけ上、直列的に処理を書ける</li>
</ul>


<p>ということにつきると思います。</p>

<p>具体的な例については、Node.jsで説明します。</p>

<h4>Node.jsでのPromiseの例</h4>

<p>早速、見ていきます。<br/>
Node.jsで非同期処理を定義する場合、</p>

<p>```javascript
// 非同期処理を持ったメソッド
function p(msg, callback) {</p>

<pre><code>setTimeout(function() {
    callback(msg);
}, 1000);
</code></pre>

<p>}
```</p>

<p>となります。<br/>
このメソッドを繰り返し実行する場合、</p>

<p>```javascript
p(&ldquo;Hello&rdquo;, function(msg1) {</p>

<pre><code>console.log(msg1 + ", date: " + new Date());
p("Good Evening", function(msg2) {
    console.log(msg2 + ", date: " + new Date());
    p("Good Bye", function(msg3) {
        console.log(msg3 + ", date: " + new Date());
    });
});
</code></pre>

<p>});
```</p>

<p>のようになります。<br/>
ネスト深いですね&hellip;。</p>

<p>これをPromiseを用いて書き直してみましょう。<br/>
まずはメソッドの定義にPromiseを適用します。</p>

<p>```javascript
function p(msg) {</p>

<pre><code>return new Promise(function(resolve) {
    setTimeout(function() {
        resolve(msg);
    }, 1000);
});
</code></pre>

<p>}
```</p>

<p>こうすることで、呼び出し側で下記のように浅いネストで書くことができます。</p>

<p>```javascript
p(&ldquo;Hello&rdquo;).then(function(msg1) {</p>

<pre><code>console.log(msg1 + ", date: " + new Date());
return p("Good Evening");
</code></pre>

<p>})
.then(function(msg2) {</p>

<pre><code>console.log(msg2 + ", date: " + new Date());
return p("Good Bye")
</code></pre>

<p>})
.then(function(msg3) {</p>

<pre><code>console.log(msg3 + ", date: " + new Date());
</code></pre>

<p>});
```</p>

<p>うむ。かなり浅くなりましたね。<br/>
これをSwiftで書くとどうなるのでしょうか？</p>

<h4>SwiftでのPromiseの例</h4>

<p>Swiftでも非同期処理を定義する場合、</p>

<p>```objective-c
func p(msg: String, closure: (String &ndash;> ())) {</p>

<pre><code>let queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)
dispatch_async(queue, {
    sleep(1)
    dispatch_sync(dispatch_get_main_queue(), {
        closure(msg)
    })
})
</code></pre>

<p>}
```</p>

<p>のように書けたりします。<br/>
これを複数回呼び出す場合、</p>

<p>```objective-c
p(&ldquo;Hello&rdquo;) { (msg1) in</p>

<pre><code>print(msg1 + ", date: \(NSDate())")
p("Good Evening") { (msg2) in
    print(msg2 + ", date: \(NSDate())")
    p("Good Bye") { (msg3) in
        print(msg3 + ", date: \(NSDate())")
    }
}
</code></pre>

<p>}
```</p>

<p>のようになります。<br/>
同様にネストが深くなりますね&hellip;。</p>

<p>では、Promiseでネストを改善しましょう。<br/>
Swiftでは、OSSの<a href="https://github.com/Thomvis/BrightFutures">BrightFuture</a>を利用します。<br/>
導入はいつも通りCocoaPodsを使いました。</p>

<p>1． Podfileに下記を記載</p>

<p>```objective-c
source &lsquo;<a href="https://github.com/CocoaPods/Specs.git">https://github.com/CocoaPods/Specs.git</a>&rsquo;
platform :ios, &lsquo;8.0&rsquo;
use_frameworks!</p>

<p>pod &lsquo;BrightFutures&rsquo;
```</p>

<p>2．<code>pod install</code>を実行</p>

<p>導入が完了したら、処理を書き換えていきます。<br/>
メソッドにPromiseを適用しましょう。</p>

<p>```objective-c
func p_future(msg: String) &ndash;> Future&lt;String, NoError> {</p>

<pre><code>let promise = Promise&lt;String, NoError&gt;()
let queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)

dispatch_async(queue, {
    sleep(1)
    dispatch_sync(dispatch_get_main_queue(), {
        promise.success(msg)
    })
})

return promise.future
</code></pre>

<p>}
```</p>

<p>これを呼び出すときは下記のように書けます。</p>

<p>```objective-c
p_future(&ldquo;Hello&rdquo;).flatMap { msg1 in</p>

<pre><code>print(msg1 + ", date: \(NSDate())")
p_future("Good Evening")
</code></pre>

<p>}.flatMap { msg2 in</p>

<pre><code>print(msg2 + ", date: \(NSDate())")
p_future("Good Bye")
</code></pre>

<p>}.onSuccess { (msg3) in</p>

<pre><code>print(msg3)
</code></pre>

<p>}
```</p>

<p>ネストが浅くなりましたね。<br/>
こうして比較してみると、Node.jsとSwiftで呼び出し側の書き方はかなり似ていますね。<br/>
Swiftだけを眺めてみてもよくわからないという方はNode.jsの方も見てみると良いと思います。</p>

<p>今回はかなり基本的な例を書かせて頂きましたが、参考になれば幸いです。<br/>
といったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SwiftでTupleを活用しよう！]]></title>
    <link href="http://grandbig.github.io/blog/2016/03/12/swift-tuple/"/>
    <updated>2016-03-12T23:09:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2016/03/12/swift-tuple</id>
    <content type="html"><![CDATA[<h4>Tupleとは</h4>

<p>さて、本日はSwiftの <strong>Tuple</strong> について見ていきます。<br/>
<strong>Tuple</strong> とは『複数の型の値を一組にまとめる』ときに利用します。</p>

<p>続いて具体的な使い方を紹介します。</p>

<h5>valueのみの格納</h5>

<p><code>objective-c
let sample = (201603, "TEST", true)
print("0番目の値は\(sample.0), 1番目の値は\(sample.1), 2番目の値は\(sample.2)")
</code></p>

<p>これを実行すると、</p>

<p><code>objective-c
0番目の値は201603, 1番目の値はTEST, 2番目の値はtrue
</code></p>

<p>のように出力されます。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h5>key, valueの格納</h5>

<p><code>objective-c
let sample = (num: 201603, str: "TEST", flag: true)
print("0番目の値は\(sample.num)", 1番目の値は\(sample.str), 2番目の値は\(sample.flag))
print("0番目の値は\(sample.0), 1番目の値は\(sample.1), 2番目の値は\(sample.2)")
</code></p>

<p>これを実行すると、</p>

<p><code>objective-c
0番目の値は201603, 1番目の値はTEST, 2番目の値はtrue
0番目の値は201603, 1番目の値はTEST, 2番目の値はtrue
</code>
のように出力されます。<br/>
key, valueの関係で書いても、数値指定が可能です。</p>

<p>数値指定ができることから、部分的にkeyを指定することができます。</p>

<p><code>objective-c
let sample = (201603, str: "TEST", flag: true)
print("0番目の値は\(sampel.0), 1番目の値は\(sample.str), 2番目の値は\(sample.flag)")
</code></p>

<p>これを実行すると、</p>

<p><code>objective-c
0番目の値は201603, 1番目の値はTEST, 2番目の値はtrue
</code></p>

<p>と出力されます。</p>

<h4>TupleとArray, Dictionaryの違いは？</h4>

<p><strong>Tuple</strong> が真新しく見えるかというと実はそうでもないというのが筆者の感想でありました。<br/>
というのも、ここまでの話では『ArrayやDictionaryで代用できるのでは？』と思えたためです。</p>

<p>それぞれ比較してみましょう。</p>

<h5>TupleとArrayを比較</h5>

<p>まずは、 <strong>Tuple</strong> とArrayの比較です。</p>

<p>```objective-c
// Array
let arraySample = [201603, &ldquo;TEST&rdquo;, true]
print(arraySample[0])</p>

<p>// Tuple
let tupleSample = (201603, &ldquo;TEST&rdquo;, true)
print(tupleSample.0)
```</p>

<ul>
<li>2つの違い

<ul>
<li>書式が異なる(Tupleの方が簡易)</li>
<li>Arrayは要素の追加と削除が可能だが、Tupleはできない</li>
</ul>
</li>
<li>2つの同じところ

<ul>
<li>異なる型の値を格納できる(Arrayは<code>AnyObject</code>にすれば良い)</li>
<li>値渡し</li>
</ul>
</li>
</ul>


<h5>TupleとDictionaryを比較</h5>

<p>次に、 <strong>Tuple</strong> とDictionaryの比較です。</p>

<p>```objective-c
// Dictionary
let dictSample = [&ldquo;numValue&rdquo;: 201603, &ldquo;strValue&rdquo;: &ldquo;TEST&rdquo;, &ldquo;flagValue&rdquo;: true]
print(dictSample[&ldquo;numValue&rdquo;])</p>

<p>// Tuple
let tupleSample = (numValue: 201603, strValue: &ldquo;TEST&rdquo;, flagValue: true)
print(tupleSample.numValue)
```</p>

<p><strong>Tuple</strong> とDictionaryの違いと同一点はArrayと比較した場合と同じです。</p>

<ul>
<li>2つの違い

<ul>
<li>書式が異なる(Tupleの方が簡易)</li>
<li>Dictionaryは要素の追加と削除が可能だが、Tupleはできない</li>
</ul>
</li>
<li>2つの同じところ

<ul>
<li>異なる型の値を格納できる(DictionaryはValueを<code>AnyObject</code>にすれば良い)</li>
<li>値渡し</li>
</ul>
</li>
</ul>


<h4>まとめ</h4>

<p>正直、『こういったところでは  <strong>Tuple</strong> を必ず利用したい』という利用シーンがあまり思い浮かびません&hellip;。<br/>
書式が簡単でとっつきやすいという良さはあるかもしれませんが、<br/>
実際に利用した際にその本当の意義を感じることができるのかもしれませんね。</p>

<p>と言ったところで、本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[今更だけど使ってみようSwiftyJson]]></title>
    <link href="http://grandbig.github.io/blog/2016/03/06/swiftyjson/"/>
    <updated>2016-03-06T22:34:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2016/03/06/swiftyjson</id>
    <content type="html"><![CDATA[<h4>SwiftyJsonの便利さを改めて確かめてみる</h4>

<p>さて、筆者の個人的な諸事情により、なかなか時間が取れないため、<br/>
完全に新しいことを書けないでいる今日このごろです。<br/>
今更ながら書くか否か迷ったのですが、<br/>
折角、習慣化しているブログ投稿をSTOPさせたくもないので、<br/>
Swift屋にとっては当たり前となっているであろう<a href="https://github.com/SwiftyJSON/SwiftyJSON">SwiftyJson</a>について書こうと思います。<br/>
何を隠そう、筆者は今までSwiftyJsonの存在は把握していたものの、<br/>
自身で変換して書くことに拘っていたので触っていませんでした。<br/>
がしかし、食わず嫌いは如何なものかということで触ってみることにしました。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h4>CocoaPodsでインストール</h4>

<p>まずは、インストールです。<br/>
<code>CocoaPods</code>, <code>Carthage</code>, <code>Swift Package Manager</code>に対応した良心的なライブラリです。<br/>
筆者はいつも通り<code>CocoaPods</code>を使います。<br/>
今回も<code>Open Weather Map API</code>をサンプルに利用したいので<a href="https://github.com/Alamofire/Alamofire">Alamofire</a>も合わせてインストールします。</p>

<p>```objective-c
platform :ios, &lsquo;8.0&rsquo;
use_frameworks!</p>

<p>target &lsquo;SwiftyJsonSample&rsquo; do</p>

<pre><code>pod 'Alamofire', '~&gt; 3.0'
pod 'SwiftyJSON', :git =&gt; 'https://github.com/SwiftyJSON/SwiftyJSON.git'
</code></pre>

<p>end
```</p>

<h4>SwiftyJsonで何が便利になったのか</h4>

<p>さて、早速、<code>SwiftyJson</code>を使うことで何が便利になるのか見てみたいと思います。<br/>
まずは、便利にする前のベースのコードをご覧下さい。</p>

<p>```objective-c
Alamofire.request(.GET, &ldquo;<a href="http://api.openweathermap.org/data/2.5/weather?APPID=">http://api.openweathermap.org/data/2.5/weather?APPID=</a>&lt;あなた自身のAPPID>&rdquo;,</p>

<pre><code>parameters:["q":location]).responseJSON { (response) -&gt; Void in
    if response.result.isSuccess {
        guard let value = response.result.value else {
            // 値の取得に失敗した場合
            return
        }
        guard let weatherArray:AnyObject? = value["weather"] else {
            // 値の取得に失敗した場合
            return
        }
        guard let weather = weatherArray?[0] else {
            // 値の取得に失敗した場合
            return
        }
        guard let description = weather["description"] as? String else {
            // 値の取得に失敗した場合
            return
        }

        print(description)
    }
</code></pre>

<p>}
```</p>

<p>前回の記事で紹介した<code>guard statement</code>を使うことでネストが浅くなっていますね。<br/>
これはわかりやすさのために、バラけて書いたのですが、<br/>
元々 <strong>description</strong> の値が欲しいのであれば、</p>

<p>```objective-c
Alamofire.request(.GET, &ldquo;<a href="http://api.openweathermap.org/data/2.5/weather?APPID=">http://api.openweathermap.org/data/2.5/weather?APPID=</a>&lt;あなた自身のAPPID>&rdquo;,</p>

<pre><code>parameters:["q":location]).responseJSON { (response) -&gt; Void in
    if response.result.isSuccess {
        guard let description = response.result.value?["weather"]??[0]["description"] else {
            // 値の取得に失敗した場合
            return
        }
        print(description!)
    }
</code></pre>

<p>}
```</p>

<p>とすればかなり短く書けます。<br/>
しかしながら、素人にとって <strong>オプショナル型</strong> や <strong>アンラップ</strong> は相当わかりにくいと言えます。<br/>
これが<code>SwiftyJson</code>を利用することで細かい上記のことを気にすることなく、<br/>
WEBで扱うようにJSONを扱えます。<br/>
もちろんSwiftでは重要なことなので、<br/>
<a href="http://qiita.com/maiki055/items/b24378a3707bd35a31a8">どこよりも分かりやすいSwiftの"?&ldquo;と&rdquo;!"</a>を参考に正しく理解しましょう。</p>

<p>さて、<code>SwiftyJson</code>を使うと次のように書けます。</p>

<p>```objective-c
Alamofire.request(.GET, &ldquo;<a href="http://api.openweathermap.org/data/2.5/weather?APPID=">http://api.openweathermap.org/data/2.5/weather?APPID=</a>&lt;あなた自身のAPPID>&rdquo;,</p>

<pre><code>parameters:["q":location]).responseJSON { (response) -&gt; Void in
    if response.result.isSuccess {
        guard let data = response.result.value else {
            return
        }
        let json = JSON(data)
        guard let description = json["weather"][0]["description"] else {
            return
        }
        print(description)
    }
</code></pre>

<p>}
```</p>

<p>多少行数は増えているものの、<br/>
<strong>オプショナル型</strong> の <strong>アンラップ化</strong> を気にせず書けていることがわかると思います。<br/>
そう、まるでWEBでJSONを扱うかのように&hellip;。</p>

<p>オプショナル型の値が内部にオプショナル型の値を持っているなど、<br/>
<code>??</code>と書く状況を作りかねないことがあっても<code>SwiftyJson</code>では考えなくて良いんですね。<br/>
う〜ん。便利。</p>

<p>他にもたくさんの使い道があるため機会があれば積極的に利活用していこうと思います。<br/>
また、これまでスルーしてきた他の便利ライブラリについてもちょくちょくその便利さを追求していこうと思います。</p>

<p>と言ったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift2.0で追加された新機能を見てみよう！]]></title>
    <link href="http://grandbig.github.io/blog/2016/02/29/swift-2-new-function/"/>
    <updated>2016-02-29T21:38:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2016/02/29/swift-2-new-function</id>
    <content type="html"><![CDATA[<h4>今更だけど見てみたいSwift2.0で追加された新機能</h4>

<p>さて、本日は表題通り、今更なんだけど&hellip;Swift2.0で追加された新機能について見ていきたいと思います。<br/>
Swift2.0では下記3つの新機能が追加されました。</p>

<ul>
<li><code>guard statement</code></li>
<li><code>do-catch</code>, <code>try</code>, <code>defer</code></li>
<li><code>Protocol Extension</code></li>
</ul>


<p>これらの使いどころやメリットなど見ていきたいと思います。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h4>guard statementについて</h4>

<p>まずは<code>guard statement</code>について見ていきます。</p>

<h5>用途について</h5>

<p>条件分岐(<code>if 〜 else 〜</code>)で利用します。<br/>
例えば、Open Weather Map APIでのリクエストでは</p>

<p>```objective-c
Alamofire.request(.GET, &ldquo;<a href="http://api.openweathermap.org/data/2.5/weather?APPID=">http://api.openweathermap.org/data/2.5/weather?APPID=</a>&lt;あなた自身のAPPID>&rdquo;,</p>

<pre><code>parameters:["q":location]).responseJSON { (response) -&gt; Void in
    if response.result.isSuccess {
        guard let value = response.result.value else {
            // 値の取得に失敗した場合
            return
        }
        guard let weatherArray:AnyObject? = value["weather"] else {
            // 値の取得に失敗した場合
            return
        }
        guard let weather = weatherArray?[0] else {
            // 値の取得に失敗した場合
            return
        }
        guard let description = weather["description"] as? String else {
            // 値の取得に失敗した場合
            return
        }

        print(description)
    }
</code></pre>

<p>}</p>

<p>```</p>

<p>のように書くことができます。<br/>
以前であれば、下記のようにこれでもかってくらいネストしていたのですが、可読性が向上します。</p>

<p>```objective-c
Alamofire.request(.GET, &ldquo;<a href="http://api.openweathermap.org/data/2.5/weather?APPID=">http://api.openweathermap.org/data/2.5/weather?APPID=</a>&lt;あなた自身のAPPID>&rdquo;,</p>

<pre><code>parameters:["q":location]).responseJSON { (response) -&gt; Void in
    if response.result.isSuccess {
        if let value = response.result.value {
            if let weatherArray = value["weather"] {
                if let weather = weatherArray?[0] {
                    if let description = weather["description"] as? String {
                        print(description)
                    }
                }
            }
        }
    }
</code></pre>

<p>}
```</p>

<h4>do-catch, try, deferについて</h4>

<p>続いて、<code>do-catch</code>, <code>try</code>, <code>defer</code>について見ていきます。</p>

<h5>用途について</h5>

<p>基本的には、例外処理を実行したい場合に使います。<br/>
想定外の例外が発生した場合にアプリが落ちないようにしないことはもちろんのこと、<br/>
想定した例外処理が発生した場合にもそれ相応の処理を実施することがあるので、<br/>
そういったときに使います。</p>

<p>まずは、呼び出し元を書きます。</p>

<p>```objective-c
// エラー種別の設定
enum MyError: ErrorType {</p>

<pre><code>case NilError
case StringError
</code></pre>

<p>}</p>

<p>// サンプルメソッド
func sampleMethod(param: String?) throws &ndash;> String {</p>

<pre><code>defer {
    print("メソッドが呼ばれました！")
}

if param == nil {
    throw MyError.NilError
} else if param == "Error" {
    throw MyError.StringError
}

return param
</code></pre>

<p>}
```</p>

<p><code>throw</code>で例外を投げる際にエラー種別を渡す必要があるため、エラー種別を設定します。<br/>
<code>defer</code>は例外発生の有無に関わらず、 <strong>必ず実行する処理内容</strong> を書きます。</p>

<p>続いて、呼び出し先を書きます。</p>

<p>```objective-c
do {</p>

<pre><code>let result = try self.sampleThrowMethod("Error")
print(result)
</code></pre>

<p>} catch MyError.NilError {</p>

<pre><code>print("nilがパラメータとして渡されました")
</code></pre>

<p>} catch MyError.StringError {</p>

<pre><code>print("Error文字列がパラメータとして渡されました")
</code></pre>

<p>} catch {</p>

<pre><code>print("想定外のErrorが発生しました")
</code></pre>

<p>}
```</p>

<p><code>do-catch</code>は例外発生別にその後の処理を分けるために利用します。<br/>
<code>try!</code>で強制実行する場合は<code>do-catch</code>は不要ですが、<br/>
アプリがダウンしては元も子もないのでオススメしません。</p>

<h4>Protocol Extension</h4>

<p>最後に<code>Protocol Extension</code>です。</p>

<h5>用途について</h5>

<p>筆者のイメージではObjective-Cで言うところの <strong>カテゴリ</strong> の用途に近いのかなと思っています。<br/>
Objective-Cのカテゴリと異なるのは指定した既存クラスにメソッドを追加するのではなく、<br/>
<strong>プロトコル</strong> にメソッドを追加するので拡張性や柔軟性が高いようです。</p>

<p>```objective-c
// MyProtocol.swift
protocol MyProtocol {</p>

<pre><code>func pico()
</code></pre>

<p>}</p>

<p>extension MyProtocol {</p>

<pre><code>func pico() {
    print("プロトコルメソッドを追加しました")
}
</code></pre>

<p>}
```</p>

<p>定義したメソッドを下記のように呼び出せます。</p>

<p>```objective-c
// ViewController.swift
class ViewController: UIViewController, MyProtocol {</p>

<pre><code>override func viewDidLoad() {
    super.viewDidLoad()

    self.pico()
}
</code></pre>

<p>}
```</p>

<h4>まとめ</h4>

<p>さて如何でしたでしょうか？<br/>
今更ですが、Swift2.0の新機能について見てきました。<br/>
個人的には<code>guard statement</code>はかなり利用したいなと思っています。<br/>
ネストが多発しがちなSwiftでは活躍の場面が目に浮かびます。<br/>
<code>do-catch</code>は待ち望んだ機能ですし、逆に今までなかったのが信じられないくらいですよね？<br/>
より安定したSwift製アプリを作成することができると想像するとワクワクしますね。</p>

<p>といったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
</feed>
