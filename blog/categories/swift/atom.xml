<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: swift | Takahiro Octopress Blog]]></title>
  <link href="http://grandbig.github.io/blog/categories/swift/atom.xml" rel="self"/>
  <link href="http://grandbig.github.io/"/>
  <updated>2017-06-05T00:16:51+09:00</updated>
  <id>http://grandbig.github.io/</id>
  <author>
    <name><![CDATA[Takahiro]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Mapに好きな画像を配置しよう！ Swift編]]></title>
    <link href="http://grandbig.github.io/blog/2017/06/04/put-annotation-2/"/>
    <updated>2017-06-04T21:24:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2017/06/04/put-annotation-2</id>
    <content type="html"><![CDATA[<h3>はじめに</h3>

<p>実に3年半ほど前のブログを始めた当初、<a href="https://grandbig.github.io/blog/2013/09/28/put-annotation/">Mapに好きな画像を配置しよう！</a>といった記事を書いたことがありました。<br/>
駆け出しのiOSエンジニアであった当時の筆者はお世辞にもObjective-CやiOS自体について詳しいとは言い難きスキルレベルでした。<br/>
(当時のブログ記事に不必要な記述があるかとは思いますが、あえてそのまま残しています。)</p>

<p>それから月日を経て、Swiftで同じ実装をするタイミングがあったことで、本記事を書こうと思い、今に至ります。<br/>
簡単な内容ではありますが、感慨深く書かせて頂いています笑</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h3>CustomAnnotationを作成しよう</h3>

<p>当時と同じ手法で実装してみます。</p>

<p>```objective-c
import Foundation
import MapKit</p>

<p>class CustomAnnotation:NSObject, MKAnnotation {
  public var coordinate: CLLocationCoordinate2D
  public var title: String?
  public var subtitle: String?</p>

<p>  init(coordinate: CLLocationCoordinate2D, title: String, subtitle: String) {</p>

<pre><code>self.coordinate = coordinate
self.title = title
self.subtitle = subtitle

super.init()
</code></pre>

<p>  }
}
```</p>

<p>上記では、<code>MKAnnotation</code>を拡張し、<code>coordinate</code> / <code>title</code> / <code>subtitle</code>を初期化時に一斉に設定できるようなイニシャライザを用意しました。</p>

<h3>Mapに画像を配置しよう</h3>

<p>さて、ではMapに画像を配置する方法を見ていきます。</p>

<p>```objective-c
import UIKit
import MapKit</p>

<p>class ViewController: UIViewController, MKMapViewDelegate {
  @IBOutlet weak var mapView: MKMapView!</p>

<p>  override func viewDidLoad() {</p>

<pre><code>super.viewDidLoad()

// マップ関連の初期化処理
self.mapView.delegate = self
self.mapView.setUserTrackingMode(MKUserTrackingMode.followWithHeading, animated: true)

// CustomAnnotationの初期化
let ann = CustomAnnotation.init(coordinate: CLLocationCoordinate2D.init(latitude: 35.685623, longitude: 139.763153), title: "TEST", subtitle: "test")
// CustomAnnotationをマップに配置
self.mapView.addAnnotation(ann)
</code></pre>

<p>  }</p>

<p>  &lt;省略></p>

<p>  // MARK: MKMapViewDelegate
  func mapView(_ mapView: MKMapView, viewFor annotation: MKAnnotation) &ndash;> MKAnnotationView? {</p>

<pre><code>if (annotation is MKUserLocation) {
  // ユーザの現在地の青丸マークは置き換えない
  return nil
} else {
  // CustomAnnotationの場合に画像を配置
  let identifier = "Pin"
  var annotationView: MKAnnotationView? = mapView.dequeueReusableAnnotationView(withIdentifier: identifier)
  if annotationView == nil {
    annotationView = MKAnnotationView.init(annotation: annotation, reuseIdentifier: identifier)
  }
  annotationView?.image = UIImage.init(named: "xxxx") // 任意の画像名
  annotationView?.annotation = annotation
  annotationView.canShowCallout = true  // タップで吹き出しを表示
  return annotationView
}
</code></pre>

<p>  }
}
```</p>

<p>結果は次のようになります。<br/>
<img src="/images/annotationpractice6.png" alt="Mapに画像を表示" /></p>

<h3>まとめ</h3>

<p>昔は様々なサイトを参考にしながら、解読しながら書いていたソースがすんなりと書くことができました。<br/>
今回の記事を通して、もっと他にもSwiftに書き直しても良い記事がありそうだなと思いました。
まあ、タイミング見てですかね&hellip;といったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[FirebaseをiOSで使ってみよう！]]></title>
    <link href="http://grandbig.github.io/blog/2017/05/14/firebase-ios/"/>
    <updated>2017-05-14T16:30:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2017/05/14/firebase-ios</id>
    <content type="html"><![CDATA[<h3>はじめに</h3>

<p>今や商用で利用している人も珍しくないであろうFirebaseを触ってみようと思います！<br/>
と言うのも、最近Stackoveflowを眺めている時にFirebaseに関する質問を時たま見かけるようになったからです。<br/>
(筆者はまともにFirebaseを使ったことがないため、この機会に使ってみようと思い立ちました。)</p>

<p>ということで、初歩の初歩から見ていきたいと思います。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<!-- more -->


<h3>Firebaseの導入</h3>

<p>まずは何と言っても利用方法ですよね？<br/>
ほとんどGoogleが用意してくれているため、本当に簡単にできます。</p>

<p>１．Firebaseの公式ページにアクセス<br/>
まずは、<a href="https://console.firebase.google.com/?hl=ja">Firebaseの公式ページ</a>に遷移して、新規プロジェクトを作成しましょう。</p>

<p><img src="/images/firebase_ios_1.png" alt="Firebaseの新規プロジェクトを作成" /></p>

<p>２．iOSアプリにFirebaseを追加<br/>
１で新規プロジェクトが作成できたため、続いてiOSアプリにFirebaseを追加しましょう。</p>

<p>追加対象のXcodeプロジェクトを作成します。<br/>
<img src="/images/firebase_ios_2.png" alt="Xcodeプロジェクトの作成" /></p>

<p>Firebase管理ページから「iOSアプリにFirebaseを追加」を選択します。<br/>
<img src="/images/firebase_ios_3.png" alt="iOSアプリにFirebaseを追加" /></p>

<p>plistファイルをDLしてXcodeプロジェクトに追加します。<br/>
<img src="/images/firebase_ios_4.png" alt="plistファイルをXcodeプロジェクトに追加" /></p>

<p>続いて、<code>CocoaPods</code>でFrameworkをインストールします。<br/>
<img src="/images/firebase_ios_5.png" alt="CocoaPodsでFrameworkを追加" /></p>

<p><code>Podfile</code>には下記を記載しました。</p>

<p>```objective-c</p>

<h1>Podfile</h1>

<p>use_frameworks!</p>

<p>target &ldquo;FirebaseSample&rdquo; do
  # Normal libraries
  pod &lsquo;Firebase/Core&rsquo;</p>

<p>  abstract_target &lsquo;Tests&rsquo; do</p>

<pre><code>inherit! :search_paths
target "FirebaseSampleTests"
target "FirebaseSampleUITests"
</code></pre>

<p>  end
end
```</p>

<p>そして、<code>.xcworkspace</code>ファイルを開いて、下図の指示の通り<code>AppDelegate.swift</code>にコードを追加します。</p>

<p><img src="/images/firebase_ios_6.png" alt="AppDelegate.swiftにコードを追加" /></p>

<p>```objective-c
import UIKit
import Firebase // ここを追記</p>

<p>@UIApplicationMain
class AppDelegate: UIResponder, UIApplicationDelegate {</p>

<pre><code>var window: UIWindow?

func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -&gt; Bool {
    // Override point for customization after application launch.
    FIRApp.configure()　// ここを追記
    return true
}
</code></pre>

<p>}
```</p>

<p>これでFirebase管理画面にiOSプロジェクトとの紐付けが完了したことがわかります。</p>

<p><img src="/images/firebase_ios_7.png" alt="iOSプロジェクトへのFirebase紐付け完了" /></p>

<h3>Firebaseの導入を確認</h3>

<p>ここまででFirebaseの導入が完了したものの、正しく導入できたかどうかわからないかと思います。<br/>
そういうときには<code>DebugView</code>を利用しましょう。</p>

<p>１．XcodeプロジェクトにFirebaseのデバッグ設定を追加<br/>
Target > Edit Scheme > Run > Arguments を見てみましょう。</p>

<p><img src="/images/firebase_ios_8.png" alt="Firebaseデバッグ設定を追加" /></p>

<p><code>-FIRDebugEnabled</code>をONにしておくことでデバッグが可能になります。<br/>
デバッグ機能を利用しない場合は明示的に<code>-FIRDebugDisabled</code>をONにしましょう。<br/>
(<a href="https://support.google.com/firebase/answer/7201382?hl=ja&amp;utm_id=ad">Google公式ページ</a>によると一度デバッグ機能を有効化すると<code>-FIRDebugDisabled</code>を指定しないと無効化しないそうです。)</p>

<p>２．Xcodeからデバッグ状況を確認<br/>
上記設定を追加した状態で実機でアプリを起動してみましょう。<br/>
すると、Xcodeのコンソールログ欄に下図のようにログが出力されるようになります。</p>

<p><img src="/images/firebase_ios_9.png" alt="Xcodeにログが出力されます" /></p>

<p>３．Firebase管理サイトでデバッグ状況を確認<br/>
Firebase管理サイトからもデバッグ状況を確認できます。</p>

<p><img src="/images/firebase_ios_10.png" alt="Firebase管理サイトでデバッグ状況を確認" /></p>

<h3>まとめ</h3>

<p>これでFirebaseをiOSに追加することができました。非常に簡単ですね！<br/>
サイドメニューを見るだけでも、非常に多くの機能を有しているようなので、少しずつ試してみたいと思いますが、まずは導入まで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[QuickでSwiftコードのUnitテストをしよう！(2)]]></title>
    <link href="http://grandbig.github.io/blog/2017/05/06/quick-2/"/>
    <updated>2017-05-06T19:39:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2017/05/06/quick-2</id>
    <content type="html"><![CDATA[<h3>はじめに</h3>

<p>今回は久しぶりに<code>Quick</code>を使ったSwiftコードでのUnitテストについて見ていきたいと思います。<br/>
<a href="https://grandbig.github.io/blog/2016/01/16/quick/">前回</a>記事を書いてから実に1年以上経過しました。<br/>
当時、筆者はテスト駆動型での開発を業務で実行することがありませんでした。
最近は当たり前に単体テストを書かずにコードを書くことがありえないという開発環境になってきました。<br/>
しかし、それはWEBの世界に閉じており、iOSの世界では未だ、単体テストを書く工数が見合わないといった話が議論されていたりします。<br/>
言わんとすることはわからんでもないものの、WEBの世界でもテスト駆動型開発が広まるまではきっと同じような話をしていたのではないかと思ったりしています。<br/>
つまり、今後はiOSでも単体テストを書かないなんてありえないといった世界になるのでは？と期待しているのです。</p>

<p>そんな期待を抱きつつ、本記事を書いていきたいと思います。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h3>テスト内容</h3>

<p>今回テスト内容として<code>Realm</code>に関わる処理を取り上げたいと思います。<br/>
狙いとしてはSpring BootでWEBアプリケーションを開発したときで言うところの<code>Repository</code>に関するテストといったイメージになります。</p>

<h3>テスト対象処理</h3>

<p>さて、具体的なテストの対象となる処理を書きます。</p>

<p>```objective-c
// ViewController.swift
import UIKit
import RealmSwift</p>

<p>class ViewController: UIViewController {
  &lt;省略></p>

<p>  // IDからデータを検索
  func searchEngineerById(_ id: Int) &ndash;> Engineer? {</p>

<pre><code>let realm = try! Realm()
let engineers = realm.objects(Engineer.self).filter("id == \(id)")
if engineers.count &gt; 0 {
  return engineers[0]
}
return nil
</code></pre>

<p>  }</p>

<p>  // 名前からデータを検索
  func searchEngineerByName(_ name: String) &ndash;> Results<Engineer>? {</p>

<pre><code>let realm = try! Realm()
let engineers = realm.objects(Engineer.self).filter("name == '\(name)'")
if engineers.count &gt; 0 {
  return engineers
}
return nil
</code></pre>

<p>  }</p>

<p>  // 保存しているデータ数を取得
  func countEngineer() &ndash;> Int {</p>

<pre><code>let realm = try! Realm()
return realm.objects(Engineer.self).count
</code></pre>

<p>  }</p>

<p>  // 新規データ作成
  func createEngineer(name: String, level: Int, skills: [String]) {</p>

<pre><code>if searchEngineerByName(name) != nil {
  // 既に検索結果がある場合は処理を終了
  return
}

// 検索結果がない場合は処理を継続
let skillList = List&lt;Skill&gt;()
for skill in skills {
  let newSkill = Skill()
  newSkill.name = skill
  skillList.append(newSkill)
}

let engineer = Engineer()
engineer.id = countEngineer()
engineer.name = name
engineer.level = level
engineer.skills.append(objectsIn: skillList)
let realm = try! Realm()

try! realm.write {
  realm.create(Engineer.self, value: engineer, update: false)
}
</code></pre>

<p>  }</p>

<p>  // IDを元にレベルを更新
  func updateEngineerLevelById(_ id: Int, level: Int) &ndash;> Bool {</p>

<pre><code>if let engineer = searchEngineerById(id) {
  // 検索結果がある場合は処理を継続
  let realm = try! Realm()
  try! realm.write {
    engineer.level = level
  }
  return true
}

// 検索結果がない場合は処理を終了
return false
</code></pre>

<p>  }</p>

<p>  // IDを元にスキルを更新
  func updateEngineerSkillById(_ id: Int, skills: [String]) &ndash;> Bool {</p>

<pre><code>if let engineer = searchEngineerById(id) {
  // 検索結果がある場合は処理を継続
  let realm = try! Realm()
  try! realm.write {
    for skill in skills {
      let newSkill = Skill()
      newSkill.name = skill
      engineer.skills.append(newSkill)
    }
  }
  return true
}

// 検索結果がない場合は処理を終了
return false
</code></pre>

<p>  }
}
```</p>

<h3>Quickの導入方法</h3>

<p>Swift3になっていることもあるので、念のためQuickの導入方法を書いておきたいと思います。<br/>
(<code>Realm</code>も使っていることに注意してください。)</p>

<p><code>CocoaPods</code>にて導入します。</p>

<p>```objective-c</p>

<h1>Podfile</h1>

<p>use_frameworks!</p>

<p>target &ldquo;QuickTestSample&rdquo; do
  # Normal libraries
  pod &lsquo;RealmSwift&rsquo;</p>

<p>  abstract_target &lsquo;Tests&rsquo; do</p>

<pre><code>inherit! :search_paths
target "QuickTestSampleTests"
target "QuickTestSampleUITests"

pod 'Quick'
pod 'Nimble'
</code></pre>

<p>  end
end</p>

<p>post_install do |installer|
  installer.pods_project.targets.each do |target|</p>

<pre><code>target.build_configurations.each do |config|
  config.build_settings['SWIFT_VERSION'] = '3.0'
end
</code></pre>

<p>  end
end
```</p>

<h3>Quickでのテストコードの実装</h3>

<p>早速、Quickでのテストコードを実装していきましょう。</p>

<h4>Quickでテスト実行するための準備</h4>

<p>Quickでテストを実行するためには、テスト用に用意されたファイルのクラスを変更する必要があります。</p>

<p>```objective-c
// QuickTestSampleTests
import XCTest
import Quick
import Nimble
@testable import QuickTestSample</p>

<p>class QuickTestSampleTests: QuickSpec {
  override func spec() {</p>

<pre><code>...
</code></pre>

<p>  }
}
```</p>

<h4>テスト用データの作成について</h4>

<p>今回、<code>Realm</code>関連の処理を実装するにあたって悩んだのが、モック用のデータをどうするかという問題です。<br/>
今回取り上げている処理がかなりシンプルな処理であるため、<strong>manual mocking</strong> で作成するのも微妙です。</p>

<p>結果、下記のように実装しました。</p>

<p>```objective-c
// QuickTestSampleTests
import XCTest
import Quick
import Nimble
import RealmSwift   // 追加
@testable import QuickTestSample</p>

<p>class QuickTestSampleTests: QuickSpec {</p>

<p>  override func spec() {</p>

<pre><code>describe("Realm Database") {
  // テスト用のRealmデータ保存ファイルを作成
  // 保存場所はdefault.realmと同じでファイル名のみtest.realmに変更
  var config = Realm.Configuration()
  config.fileURL = config.fileURL!.deletingLastPathComponent().appendingPathComponent("test.realm")
  Realm.Configuration.defaultConfiguration = config
  // 上記の設定情報を利用してRealmを扱う
  let realm = try! Realm(configuration: config)

  beforeEach {
    // テスト用にモックデータを追加
    let engineer = Engineer()
    engineer.name = "mock_name"
    engineer.level = 1
    let skill = Skill()
    skill.name = "mock_skill_name"
    engineer.skills.append(skill)

    try! realm.write {
      realm.create(Engineer.self, value: engineer, update: false)
    }

    expect(engineer).notTo(beNil())
  }

  &lt;省略&gt;

  afterEach {
    // テスト終了後にデータを全て削除
    try! realm.write {
      realm.deleteAll()
    }
  }
}
</code></pre>

<p>  }<br/>
}
```</p>

<p>このように、最低限必要なモックデータをテスト用の<code>Realm</code>のデータベースに作成してみました。<br/>
<code>Realm</code>の使い方さえ間違えなければ、こちらでテストしたい独自処理には影響を与えないはずです。</p>

<p>上記のソースコードにコメントとして書いていますが、ポイントとしては下記の通りです。</p>

<ul>
<li>実際のアプリで利用する<code>Realm</code>ファイルとは別のテスト用の<code>Realm</code>ファイルを利用する</li>
<li>テスト実行前にテスト用のモックデータを作成する</li>
<li>テスト実行後はテスト用のモックデータを全て削除する</li>
</ul>


<h4>テストの記載箇所</h4>

<p>さて、実際にテストを実装すると下記のようになります。</p>

<p>```objective-c
// QuickTestSampleTests
&lt;省略></p>

<p>override func spec() {
  var subject: ViewController!
  describe(&ldquo;Realm Database&rdquo;) {</p>

<pre><code>beforeEach {
  &lt;省略&gt;
}

describe("searchEngineerById") {
  it("find realm data by id") {
    let engineer = subject.searchEngineerById(0)
    expect(engineer).notTo(beNil())
    expect(engineer?.name).to(equal("mock_name"))
  }
}

afterEach {
  &lt;省略&gt;
}
</code></pre>

<p>  }
}</p>

<p>&lt;省略>
```</p>

<p>ポイント次の通りです。</p>

<ul>
<li>テストの内容は<code>beforeEach</code>と<code>afterEach</code>の間に書く</li>
<li>メソッドごとにテストを記載していることをわかりやすくするために、<code>describe</code>でメソッドごとにくくる</li>
<li>テストで確かめたい内容次第で<code>notTo</code> / <code>to</code> / <code>equal</code> などを使い分ける</li>
</ul>


<h4>テストの内容</h4>

<p>では、テスト内容の詳細を個別に見ていきたいと思います。</p>

<h5>searchEngineerByIdのテスト</h5>

<p>まずは、<code>searchEngineerById</code>のテストを書きます。<br/>
このメソッドは検索成功時に<code>Engineer</code>型のオブジェクトを返し、検索失敗時には<code>nil</code>を返します。</p>

<p>そのため、このメソッドに対するテストとしては、</p>

<ul>
<li>検索成功：取得内容の整合性をチェック</li>
<li>検索失敗：<code>nil</code>であることをチェック</li>
</ul>


<p>を書くことになります。</p>

<p>```objective-c
// QuickTestSampleTests
describe(&ldquo;searchEngineerById&rdquo;) {
  // 取得内容の整合性チェック
  it(&ldquo;find realm data by id&rdquo;) {</p>

<pre><code>let engineer = subject.searchEngineerById(0)
expect(engineer).notTo(beNil())
expect(engineer?.name).to(equal("mock_name"))
expect(engineer?.skills[0].name).to(equal("mock_skill_name"))
</code></pre>

<p>  }</p>

<p>  // nilであることのチェック
  it(&ldquo;cannot find realm data by id&rdquo;) {</p>

<pre><code>let engineer = subject.searchEngineerById(1)
expect(engineer).to(beNil())
</code></pre>

<p>  }
}
```</p>

<h5>searchEngineerByNameのテスト</h5>

<p>続いて、<code>searchEngineerByName</code>のテストを書きます。<br/>
このメソッドは検索成功時に<code>List&lt;Engineer&gt;</code>型のオブジェクトを返し、検索失敗時には<code>nil</code>を返します。</p>

<p>そのため、このメソッドに対するテストとしては、</p>

<ul>
<li>検索成功：取得内容の整合性およびカウント数のチェック</li>
<li>検索失敗：<code>nil</code>であることをチェック</li>
</ul>


<p>を書くことになります。</p>

<p>```objective-c
describe(&ldquo;searchEngineerByName&rdquo;) {
  // 取得内容の整合性およびカウント数のチェック
  it(&ldquo;find realm data by name&rdquo;) {</p>

<pre><code>let engineers = subject.searchEngineerByName("mock_name")
expect(engineers).notTo(beNil())
expect(engineers?.count).to(equal(1))
expect(engineers?[0].name).to(equal("mock_name"))
expect(engineers?[0].skills[0].name).to(equal("mock_skill_name"))
</code></pre>

<p>  }</p>

<p>  // nilであることのチェック
  it(&ldquo;cannot find realm data by name&rdquo;) {</p>

<pre><code>let engineers = subject.searchEngineerByName("mock_mistake_name")
expect(engineers).to(beNil())
</code></pre>

<p>  }
}
```</p>

<h5>countEngineerのテスト</h5>

<p>次は<code>countEngineer</code>のテストを書きます。<br/>
このメソッドは検索成功時にデータのレコード数を返却します。<br/>
検索失敗時の処理は独自実装していないため成功時のテストのみ書きます。</p>

<p>```objective-c
describe(&ldquo;countEngineer&rdquo;) {
  // カウント数のチェック
  it(&ldquo;count realm data&rdquo;) {</p>

<pre><code>let count = subject.countEngineer()
expect(count).to(equal(1))
</code></pre>

<p>  }
}
```</p>

<h5>createEngineerのテスト</h5>

<p>今度は<code>createEngineer</code>のテストを書きます。<br/>
このメソッドは同名の<code>Engineer</code>オブジェクトが保存されている場合は、新規オブジェクトを作成しないということがポイントです。</p>

<p>そのため、このメソッドに対するテストとしては、</p>

<ul>
<li>新規<code>Engineer</code>オブジェクト作成が成功した場合：取得内容の整合性およびカウント数のチェック</li>
<li>新規<code>Engineer</code>オブジェクト作成が失敗した場合：カウント数が変わっていないことをチェック</li>
</ul>


<p>を書くことになります。</p>

<p>```objective-c
describe(&ldquo;createEngineer&rdquo;) {
  // カウント数が変わっていないことのチェック
  it(&ldquo;cannot create engineer&rdquo;) {</p>

<pre><code>subject.createEngineer(name: "mock_name", level: 1, skills: ["swift"])
let engineers = subject.searchEngineerByName("mock_name")
expect(engineers).notTo(beNil())
expect(engineers?.count).to(equal(1))
</code></pre>

<p>  }</p>

<p>  // 取得内容の整合性およびカウント数のチェック
  it(&ldquo;create new engineer&rdquo;) {</p>

<pre><code>subject.createEngineer(name: "takahiro", level: 1, skills: ["swift", "spring boot", "react.js"])
let engineers = subject.searchEngineerByName("takahiro")
expect(engineers).notTo(beNil())
expect(engineers?.count).to(equal(1))
expect(engineers?[0].name).to(equal("takahiro"))
expect(engineers?[0].skills.count).to(equal(3))
expect(engineers?[0].skills[0].name).to(equal("swift"))
expect(engineers?[0].skills[1].name).to(equal("spring boot"))
expect(engineers?[0].skills[2].name).to(equal("react.js"))
</code></pre>

<p>  }
}
```</p>

<h5>updateEngineerLevelByIdのテスト</h5>

<p><code>updateEngineerLevelById</code>のテストを書きます。<br/>
このメソッドは成功可否に応じて<code>true / false</code>を返却します。</p>

<p>そのため、このメソッドに対するテストとしては、</p>

<ul>
<li>更新成功：<code>true</code>であることをチェック</li>
<li>更新失敗：<code>false</code>であることをチェック</li>
</ul>


<p>を書くことになります。</p>

<p>```objective-c
describe(&ldquo;updateEngineerLevelById&rdquo;) {
  // trueであることをチェック
  it(&ldquo;update level for realm data by id&rdquo;) {</p>

<pre><code>let updated = subject.updateEngineerLevelById(0, level: 2)
let engineer = subject.searchEngineerById(0)
expect(updated).to(beTrue())
expect(engineer?.level).to(equal(2))
</code></pre>

<p>  }</p>

<p>  // falseであることをチェック
  it(&ldquo;cannot update level for realm data by id&rdquo;) {</p>

<pre><code>let updated = subject.updateEngineerLevelById(2, level: 2)
expect(updated).to(beFalse())
</code></pre>

<p>  }
}
```</p>

<h5>updateEngineerSkillByIdのテスト</h5>

<p><code>updateEngineerSkillById</code>のテストを書きます。<br/>
このメソッドは成功可否に応じて<code>true / false</code>を返却します。</p>

<p>そのため、このメソッドに対するテストとしては、</p>

<ul>
<li>更新成功：<code>true</code>であることをチェック</li>
<li>更新失敗：<code>false</code>であることをチェック</li>
</ul>


<p>を書くことになります。</p>

<p>```objective-c
describe(&ldquo;updateEngineerSkillById&rdquo;) {
  // trueであることをチェック
  it(&ldquo;update skill for realm data by id&rdquo;) {</p>

<pre><code>let updated = subject.updateEngineerSkillById(0, skills: ["mock_skill_name_2"])
let engineer = subject.searchEngineerById(0)
expect(updated).to(beTrue())
expect(engineer?.skills.count).to(equal(2))
expect(engineer?.skills[0].name).to(equal("mock_skill_name"))
expect(engineer?.skills[1].name).to(equal("mock_skill_name_2"))
</code></pre>

<p>  }</p>

<p>  // falseであることをチェック
  it(&ldquo;cannot update skill for realm data by id&rdquo;) {</p>

<pre><code>let updated = subject.updateEngineerSkillById(2, skills: ["mock_skill_name_2"])
expect(updated).to(beFalse())
</code></pre>

<p>  }
}
```</p>

<h3>Quickでのテストコードの書式</h3>

<p>今回新たに出た書式についてまとめておきます。</p>

<h4>notTo</h4>

<p>対象と異なることを期待するときに利用します。</p>

<ul>
<li>書式例：<code>expect(engineer).notTo(beNil())</code></li>
<li>期待値：<code>engineer</code>オブジェクトが<code>nil</code>でない</li>
</ul>


<h4>to</h4>

<p>対象と一致することを期待するときに利用します。</p>

<h5>equalと組み合わせた場合</h5>

<ul>
<li>書式例：<code>expect(engineer?.name).to(equal("mock_name"))</code></li>
<li>期待値：<code>engineer</code>オブジェクトの<code>name</code>プロパティが<code>mock_name</code>と一致すること</li>
</ul>


<h5>beTrue / beFalseと組み合わせた場合</h5>

<ul>
<li>書式例：<code>expect(updated).to(beTrue())</code></li>
<li>期待値：<code>updated</code>の値が<code>true</code>と一致すること</li>
</ul>


<h4>beNil / equal / beTrue / beFalse</h4>

<p>それぞれ、</p>

<ul>
<li>beNil()：<code>nil</code>であること</li>
<li>equal()：引数の値であること(数字や文字列などを引数に設定します)</li>
<li>beTrue()：<code>true</code>であること</li>
<li>beFalse()：<code>false</code>であること</li>
</ul>


<p>を意味します。</p>

<h3>まとめ</h3>

<p>さて如何でしたでしょうか。<br/>
今回は最近の経験を元にiOSでテスト駆動型の開発をするなら&hellip;をイメージして書いてみました。<br/>
次はもっと複雑なパターンのテストを試しに書いてみても良いかなと思いつつ、本日はここまで。</p>

<p>参考:</p>

<ul>
<li><a href="https://realm.io/jp/docs/swift/latest/#realm-3">Realm公式ドキュメント</a></li>
<li><a href="https://news.realm.io/jp/news/rachel-bobbins-testing-view-controllers-quick/">Quickを使ってビューコントローラをテストする</a></li>
<li><a href="https://github.com/Quick/Quick/blob/master/Documentation/ja/ConfiguringQuick.md">Quickの挙動をカスタマイズしましょう</a></li>
<li><a href="https://github.com/Quick/Quick/blob/master/Documentation/ja/QuickExamplesAndGroups.md">QuickのExamplesとExample Groupsで、たくさんのテストでも整理整頓</a></li>
</ul>


<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift3でRealmSwiftを使ってみよう！]]></title>
    <link href="http://grandbig.github.io/blog/2017/05/06/swift3-realm/"/>
    <updated>2017-05-06T02:06:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2017/05/06/swift3-realm</id>
    <content type="html"><![CDATA[<h3>はじめに</h3>

<p>約2年前に画期的なモバイルデータベースとして<a href="https://realm.io/jp/">Realm</a>について紹介させて頂きました。<br/>
当時はSwift専用のものがなかったため、Objective-C用のものをブリッジヘッダーファイルを作成することで利用していました。<br/>
現在はかなり多くのアプリでも利用され、広く浸透していると共に、<code>SwiftRealm</code>が作られ、Swift専用化しています。</p>

<p>今回は、以前、筆者が書いた<a href="http://grandbig.github.io/blog/2015/06/07/swift-realm/">SwiftでRealmを使ってみよう！</a>を<code>SwiftRealm</code>で書き直す形でSwift3での<code>Realm</code>の使い方を見ていきたいと思います。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h3>RealmSwiftの導入方法</h3>

<p><code>CocoaPods</code>を利用して導入してみます。<br/>
(<code>Carthage</code>での利用方法も公式サイトにて紹介されています。)</p>

<p>```objective-c</p>

<h1>Podfile</h1>

<p>use_frameworks!</p>

<p>target &ldquo;RealmSwiftSample&rdquo; do
  # Normal libraries
  pod &lsquo;RealmSwift&rsquo;</p>

<p>  abstract_target &lsquo;Tests&rsquo; do</p>

<pre><code>inherit! :search_paths
target "RealmSwiftSampleTests"
target "RealmSwiftSampleUITests"
</code></pre>

<p>  end
end</p>

<p>post_install do |installer|
  installer.pods_project.targets.each do |target|</p>

<pre><code>target.build_configurations.each do |config|
  config.build_settings['SWIFT_VERSION'] = '3.0'
end
</code></pre>

<p>  end
end
```</p>

<p>因みに、<code>abstract_target</code>は複数targetにまたがって利用したいライブラリがある場合に利用します。<br/>
(上記の例はテストでのみ利用するライブラリがある場合に利用する書式です。)<br/>
また、<code>post_install do |installer|</code>〜<code>end</code>までの書式はSwiftのバージョンを指定するために追加します。</p>

<p><code>Podfile</code>ができたら<code>pod install</code>を実行して<code>xcworkspace</code>ファイルを開きましょう。</p>

<h3>保存オブジェクトの生成</h3>

<p>Objective-C用のときは<code>RLMObject</code>型のクラスを作成していましたが、<code>RealmSwift</code>では単に<code>Object</code>型のクラスを作成します。</p>

<p>```objective-c
// Engineer.swift</p>

<p>import Foundation
import RealmSwift</p>

<p>// Skillクラス
class Skill: Object {</p>

<pre><code>dynamic var name: String = ""
</code></pre>

<p>}</p>

<p>// Engineerクラス
class Engineer: Object {</p>

<pre><code>dynamic var id: Int = 0
dynamic var name: String = ""
dynamic var level: Int = 0
let skills = List&lt;Skill&gt;()
dynamic var created: Double = Date().timeIntervalSince1970
dynamic var updated: Double = Date().timeIntervalSince1970

// プライマリーキーの設定
override static func primaryKey() -&gt; String? {
    return "id"
}

// インデックスの設定
override static func indexedProperties() -&gt; [String] {
    return ["level"]
}
</code></pre>

<p>}
```</p>

<p>Objective-C用の<code>Realm</code>では<code>RLMArray</code>型として<code>skills</code>を作成していましたが、<code>RealmSwift</code>では<code>List&lt;Skill&gt;</code>型として作成できます。<br/>
こちらの方が直感的でわかりやすいですね。<br/>
因みに、<code>dynamic var skills = List&lt;Skill&gt;()</code>と書くとエラーが発生するので<code>List</code>を利用する場合は<code>let</code>にしましょう。</p>

<h3>オブジェクトのインサート/アップデート</h3>

<p>先程作成したオブジェクトを保存する方法について紹介しましょう。</p>

<p>```objective-c
// ViewController.swift
import UIKit
import RealmSwift</p>

<p>class ViewController: UIViewController {</p>

<pre><code>override func viewDidLoad() {
    super.viewDidLoad()
    // 新規オブジェクトをインサート
    createEngineer(name: "test1", level: 1, skills: ["swift", "objective-c"])
}

&lt;省略&gt;

func createEngineer(name: String, level: Int, skills: [String]) {
    // Skill型オブジェクトに変換してList&lt;Skill&gt;に格納
    let skillList = List&lt;Skill&gt;()
    for skill in skills {
        let newSkill = Skill()
        newSkill.name = skill
        skillList.append(newSkill)
    }

    let realm = try! Realm()

    // Engineer型オブジェクトの作成
    let engineer = Engineer()
    engineer.id = realm.objects(Engineer.self).count
    engineer.name = name
    engineer.level = level
    engineer.skills.append(objectsIn: skillList)

    // Realmへのオブジェクトの書き込み
    try! realm.write {
        realm.add(engineer)
    }
}
</code></pre>

<p>}
```</p>

<p>Objective-Cの際は<code>realm.beginWriteTransaction()</code>や<code>realm.commitWriteTransaction()</code>などわざわざ書いていたものの、<code>RealmSwift</code>では非常にコンパクトに書けますね。<br/>
因みに、アップデートであれば、</p>

<p><code>objective-c
try! realm write {
  engineer.name = "takahiro"
}
</code></p>

<p>のようにすれば良さそうです。</p>

<h3>データの確認</h3>

<p>今は、Mac App Storeから<code>Realm Browser</code>アプリをインストールすることで簡単にデータ確認が可能になっています。</p>

<p>手順は以下の通りです。<br/>
１．<code>Realm Browser</code>を起動する<br/>
２．<code>Realm</code>ファイルを選択して開く</p>

<p>そうすることで、下記のようにデータを確認することができます。</p>

<p><img src="/images/swift3-realm1.png" alt="Realm BrowserでEngineerオブジェクトを確認" /><br/>
<img src="/images/swift3-realm2.png" alt="Realm BrowserでSkillオブジェクトを確認" /></p>

<p>注意すべきこととしては、シミュレータだと<code>realm</code>ファイルを探すのに骨が折れるかもくらいでしょうか&hellip;<br/>
<code>/Users/&lt;username&gt;/Library/Developer/CoreSimulator/Devices/&lt;simulator-uuid&gt;/data/Containers/Data/Application/&lt;application-uuid&gt;/Documents/default.realm</code>にありますので該当するファイルを検索するなどして探しましょう。</p>

<h3>まとめ</h3>

<p>さて、如何でしたでしょうか。<br/>
筆者は久しぶりに<code>Realm</code>を触ったため、以前利用していたときよりも『だいぶ変わったな』と正直思いました。<br/>
ですが、<code>RealmSwift</code>になったことで、より<code>Swift</code>らしい書き方ができると思いますし、単純に記述量も少なく書けるような気がしています。<br/>
今後も多くのアプリで利用されることでしょうし、知っておいて損は絶対になさそうですね。<br/>
ということで本日はここまで。</p>

<p>参考:</p>

<ul>
<li><a href="http://qiita.com/shu223/items/e9d0145a2087da0d6d46">CocoaPods でビルド設定を追加する</a></li>
<li><a href="https://guides.cocoapods.org/using/the-podfile.html">CocoaPods公式サイトでの説明</a></li>
<li><a href="http://stackoverflow.com/questions/28465706/how-to-find-my-realm-file/28465803#28465803">stackoverflow &ndash; How to find my realm file?</a></li>
<li><a href="https://realm.io/jp/docs/swift/latest/">Realm公式ドキュメント</a></li>
</ul>


<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swiftで使いたいんだけど思うように使えないsubscript]]></title>
    <link href="http://grandbig.github.io/blog/2017/04/23/swift-base-3/"/>
    <updated>2017-04-23T23:03:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2017/04/23/swift-base-3</id>
    <content type="html"><![CDATA[<h3>はじめに</h3>

<p>さて、今日はSwiftの <code>String</code> 型に関するメモです。<br/>
何かできそうなのに実は面倒だという話があったのでちょろっと忘れないように書いておきます。</p>

<h3>文字列から文字を取り出したい！</h3>

<p>プログラミングを書いているときに、たまに『文字列から文字を取り出したい！』ということがあるかと思います。<br/>
JavaScriptなら <code>charAt</code> を利用するだけで任意の場所の文字を取得することができますが、Swiftだと意外に面倒でした&hellip;</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<p><code>objective-c
func sample1() {
  let chrSample1 = "こんにちは"
  // 先頭文字の取得
  print(chrSample1.characters[chrSample1.startIndex]) // こ
  // 先頭から1つ先の文字を取得
  let secondIndex = chrSample1.index(after: chrSample1.startIndex)  // ん
  print(chrSample1.characters[secondIndex])
  // 末尾の文字を取得
  let lastBeforeIndex = chrSample1.index(before: chrSample1.endIndex) // は
  print(chrSample1.characters[lastBeforeIndex])
}
</code></p>

<p>上記のように場所を指定する必要があります。<br/>
下記のように数字で指定しようとすると全て静的解析でエラー判断されます。</p>

<p><code>objective-c
func sample1() {
  let chrSample1 = "こんにちは"
  print(chrSample1.characters[0]) // エラー
  print(chrSample1[0])            // エラー
  print(chrSample1.subscript(0))  // エラー
}
</code></p>

<h3>まとめ</h3>

<p>案外ハマる場面がある気がするので、試しておくと良かったりしますね。<br/>
今回は単なるメモ書きでした。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
</feed>
