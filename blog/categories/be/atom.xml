<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: BE | Takahiro Octopress Blog]]></title>
  <link href="http://grandbig.github.io/blog/categories/be/atom.xml" rel="self"/>
  <link href="http://grandbig.github.io/"/>
  <updated>2017-08-06T04:18:04+09:00</updated>
  <id>http://grandbig.github.io/</id>
  <author>
    <name><![CDATA[Takahiro]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Server Side SwiftでMongoDBと遊んでみる]]></title>
    <link href="http://grandbig.github.io/blog/2016/12/05/swift-perfect-mongo/"/>
    <updated>2016-12-05T00:00:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2016/12/05/swift-perfect-mongo</id>
    <content type="html"><![CDATA[<h3>はじめに</h3>

<p>こちらは<a href="http://qiita.com/advent-calendar/2016/swift2">Swift その2 Advent Calendar 2016</a> 5日目の記事です。<br/>
今年は筆者が興味を持っている <strong>Server Side Swift</strong> について書きたいと思います。
Swiftサーバを立てるために、<a href="http://grandbig.github.io/blog/2016/10/30/swift-perfect/">以前の記事</a>でも利用した<a href="https://github.com/PerfectlySoft/Perfect">Perfect</a>を使います。</p>

<p>ただ単にSwiftサーバを立てても面白くないので、提供されているMongoDB接続モジュールを利用して遊んでみようと思います。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h3>SwiftによるAP・DBサーバの構築</h3>

<p>早速、Perfectを用いてSwiftによるAP・DBサーバを構築しようと思います。<br/>
基本的には<a href="https://github.com/PerfectlySoft/Perfect-MongoDB">ReadMe</a>に従えば良いのですが、丁寧に１つずつ見ていきます。</p>

<h4>必要モジュールのインストール</h4>

<p>流石に <strong>Homebrew</strong> はインストールされている方が多いと思いますが、入れていない方は下記コマンドで入れましょう。</p>

<p><code>
/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
</code></p>

<p>また今回は <strong>MongoDB</strong> を利用するため、 <strong>mongodb</strong> および <strong>mongo-c</strong> をインストールする必要があります。<br/>
mongodbに関しては、</p>

<p><code>
brew install mongodb
</code></p>

<p>でOKです。(自動起動などに関しては<a href="http://grandbig.github.io/blog/2016/11/20/brew-install-db/">こちら</a>を参照ください。)<br/>
続いて、mongo-cは</p>

<p><code>
brew install mongo-c
</code></p>

<p>でインストール完了できるはずです。</p>

<h4>xcodeprojを作成</h4>

<h5>テンプレートのダウンロード</h5>

<p>0からPerfectを用いてサーバを構築しても良いのですが、Perfectではテンプレートを用意してくれています。<br/>
せっかくなので <code>git clone</code> してテンプレートをダウンロードして使いましょう。</p>

<p><code>
git clone https://github.com/PerfectlySoft/PerfectTemplate.git
cd PerfectTemplate
</code></p>

<h5>MongoDBモジュールを利用するように編集</h5>

<p><strong>Perfect-MongoDB</strong> を利用するので、<code>Package.swift</code>を編集しましょう。</p>

<p>```objective-c
import PackageDescription</p>

<p>let package = Package(</p>

<pre><code>name: "PerfectTemplate",
targets: [],
dependencies: [
    .Package(url: "https://github.com/PerfectlySoft/Perfect-HTTPServer.git", majorVersion: 2, minor: 0),
    .Package(url:"https://github.com/PerfectlySoft/PerfectLib.git", majorVersion: 2, minor: 0),
    .Package(url:"https://github.com/PerfectlySoft/Perfect-MongoDB.git", majorVersion: 2, minor: 0)
]
</code></pre>

<p>)
```</p>

<p>ReadMeでは <strong>Perfect-HTTPServer</strong> は書かれていないのですが、これを使った方が便利なので、テンプレートに残したまま進めます。</p>

<h5>Packageからxcodeprojを作成</h5>

<p><code>Package.swift</code>の編集が終わったら、下記コマンドを実行して<code>xcodeproj</code>ファイルを作成しましょう。</p>

<p><code>
swift package generate-xcodeproj
</code></p>

<p>そうすれば下図のような結果が得られるはずです。</p>

<p><img src="/images/perfect-mongo_1.png" alt="フォルダ構成" /></p>

<h4>MongoDBにデータを作成</h4>

<p>サンプルを作成するためにもデータがなきゃ話になりませんよね？<br/>
ということでデータを入れましょう。</p>

<p>```
// MongoDBにアクセス
$ mongo</p>

<p>// DBとCollectionの作成</p>

<blockquote><p>use test;
db.createCollection(&lsquo;testCollection&rsquo;);
{ &ldquo;ok&rdquo; : 1 }</p></blockquote>

<p>// DBの確認</p>

<blockquote><p>show dbs;
local  0.000GB
test   0.000GB</p></blockquote>

<p>// Collectionの確認</p>

<blockquote><p>show collections
testCollection</p></blockquote>

<p>// データのインサート</p>

<blockquote><p>db.testCollection.insert({name: &lsquo;takahiro&rsquo;, age: 30, hobby: &lsquo;blog&rsquo;});
WriteResult({ &ldquo;nInserted&rdquo; : 1 })
db.testCollection.insert({name: &lsquo;ichiro&rsquo;, age: 43, hobby: &lsquo;baseball&rsquo;});
WriteResult({ &ldquo;nInserted&rdquo; : 1 })</p></blockquote>

<p>// データの確認</p>

<blockquote><p>db.testCollection.find()
{ &ldquo;<em>id&rdquo; : ObjectId(&ldquo;58391469a8589d99c931303c&rdquo;), &ldquo;name&rdquo; : &ldquo;takahiro&rdquo;, &ldquo;age&rdquo; : 30, &ldquo;hobby&rdquo; : &ldquo;blog&rdquo; }
{ &ldquo;</em>id&rdquo; : ObjectId(&ldquo;58392222a8589d99c931303d&rdquo;), &ldquo;name&rdquo; : &ldquo;ichiro&rdquo;, &ldquo;age&rdquo; : 43, &ldquo;hobby&rdquo; : &ldquo;baseball&rdquo; }
```</p></blockquote>

<h4>MongoDBにアクセスして全データを取得</h4>

<p>データの作成も完了したので、実際にGETリクエストでMongoDBからデータを取得する処理を書いてみましょう。<br/>
(ReadMeではPerfect-HTTPServerを利用しない方法で書かれていたため本記事とは若干異なります。)</p>

<h5>テンプレートファイルの確認</h5>

<p>まずは、初めから作成されている処理内容を確認します。<br/>
説明は下記ソースコードにコメントを書いたので参照ください。</p>

<p>```objective-c
// main.swift
import PerfectLib
import PerfectHTTP
import PerfectHTTPServer</p>

<p>// HTTPサーバの生成
let server = HTTPServer()</p>

<p>// リクエストに対するルーティングを設定
var routes = Routes()
routes.add(method: .get, uri: &ldquo;/&rdquo;, handler: {</p>

<pre><code>request, response in
// レスポンスヘッダーの設定
response.setHeader(.contentType, value: "text/html")
// レスポンスボディの設定
response.appendBody(string: "&lt;html&gt;&lt;title&gt;Hello, world!&lt;/title&gt;&lt;body&gt;Hello, world!&lt;/body&gt;&lt;/html&gt;")
// レスポンス完了処理
response.completed()
}
</code></pre>

<p>)</p>

<p>// サーバにルーティング設定を適用
server.addRoutes(routes)</p>

<p>// ポートを設定
server.serverPort = 8181</p>

<p>// ドキュメントルートのパスを設定
server.documentRoot = &ldquo;./webroot&rdquo;</p>

<p>// arguments.swiftで定義されているメソッド
// 更なるサーバ定義が必要な場合はここを見ましょう(SSLなど)
configureServer(server)</p>

<p>do {</p>

<pre><code>// HTTPサーバの起動
try server.start()
</code></pre>

<p>} catch PerfectError.networkError(let err, let msg) {</p>

<pre><code>print("Network error thrown: \(err) \(msg)")
</code></pre>

<p>}
```</p>

<p>上記をXcodeをからRunさせた状態で <code>http://localhost:8181</code> にアクセスしてみましょう。<br/>
Hello Worldの結果が得られるはずです。</p>

<p><img src="/images/perfect-mongo_2.png" alt="Hello World" /></p>

<h5>MongoDB関連処理ファイルの作成</h5>

<p>続いて、MongoDBへの接続・切断やデータ取得などの処理を作成していきます。<br/>
これは別クラスの中に書いていきましょう。</p>

<p>今回はMongoDB関連の処理をハンドリングするということで<code>mongoHandler.swift</code>というファイルを作成します。<br/>
因みにただ作成しただけでは、XcodeがCompile対象として正しく認識してくれないので、自身で設定を変えましょう。<br/>
下図のようにTARGETSから実行ファイルを選択して、Compile Sourcesとして<code>mongoHandler.swift</code>を追加してください。</p>

<p><img src="/images/perfect-mongo_3.png" alt="Compile Sourcesに追加" /></p>

<p>では実際のソースを見ていきましょう。</p>

<p>```objective-c
// mongoHandler.swift</p>

<p>import PerfectLib
import PerfectHTTP
import MongoDB</p>

<p>class MongoHandler {</p>

<p>  var client: MongoClient?
  var database: MongoDatabase?
  var collection: MongoCollection?</p>

<p>  // MongoDBへの接続処理
  fileprivate func connect() {</p>

<pre><code>// コネクション確立
client = try! MongoClient(uri: "mongodb://localhost")

// testデータベースへの接続
database = client?.getDatabase(name: "test")

// testCollectionコレクションへの接続
self.collection = database?.getCollection(name: "testCollection")
</code></pre>

<p>  }</p>

<p>  // MongoDBからの切断処理
  fileprivate func close() {</p>

<pre><code>collection?.close()
database?.close()
client?.close()
</code></pre>

<p>  }</p>

<p>  func searchAll(request: HTTPRequest, _ response: HTTPResponse) {</p>

<pre><code>// MongoDBへの接続
connect()
// 指定コレクションが見つからない場合は処理終了
guard let collection = self.collection else {
  return
}

// データ全件取得のためBSONオブジェクトを初期化してクエリとして設定
let fnd = collection.find(query: BSON())

// データ格納用に配列を定義
var arr = [String]()

// 取得したデータを配列に格納する
// fndはMongoCursor型であり、for文での繰り返し処理が可能
for x in fnd! {
    arr.append(x.asString)
}

// JSONStringに変換
let returning = "{\"data\":[\(arr.joined(separator: ","))]}"

// レスポンスデータとして設定
response.appendBody(string: returning)
// レスポンス処理完了
response.completed()

// MongoDBから切断
close()
</code></pre>

<p>  }
}
```</p>

<p>MongoDBへの接続・切断処理は共通処理となることは容易に想像できるため、切り出しました。</p>

<h5>main.swiftからmongoHandler.swiftを呼び出す</h5>

<p>さて、<code>main.swift</code>から<code>mongoHandler.swift</code>を呼び出してみましょう。</p>

<p>```objective-c
// main.swift
// MongoHandlerの初期化
let mongoHandler = MongoHandler()</p>

<p>// GETリクエストでMongoDBのデータ全取得
routes.add(method: .get, uri: &ldquo;/mongo&rdquo;, handler: {</p>

<pre><code>request, response in
mongoHandler.searchAll(request: request, response)
</code></pre>

<p>})
```</p>

<p>これで<code>http://localhost:8181</code>にアクセスすれば下図のような結果が得られるはずです。</p>

<p><img src="/images/perfect-mongo_4.png" alt="データ全件取得結果" /></p>

<h4>MongoDBにアクセスして指定のクエリでデータを取得</h4>

<p>全件取得の方法はわかったので、続いてクエリありの検索を実行してみましょう。<br/>
先程述べた通り、下記のようなデータが格納されています。</p>

<p>```
// データの確認</p>

<blockquote><p>db.testCollection.find()
{ &ldquo;<em>id&rdquo; : ObjectId(&ldquo;58391469a8589d99c931303c&rdquo;), &ldquo;name&rdquo; : &ldquo;takahiro&rdquo;, &ldquo;age&rdquo; : 30, &ldquo;hobby&rdquo; : &ldquo;blog&rdquo; }
{ &ldquo;</em>id&rdquo; : ObjectId(&ldquo;58392222a8589d99c931303d&rdquo;), &ldquo;name&rdquo; : &ldquo;ichiro&rdquo;, &ldquo;age&rdquo; : 43, &ldquo;hobby&rdquo; : &ldquo;baseball&rdquo; }
```</p></blockquote>

<p><code>name</code>、<code>age</code>、<code>hobby</code>を指定して検索するのはそんなに難しくないと思います。</p>

<h5>nameを指定してデータを取得</h5>

<p>わかりやすいところからと言うことで<code>name</code>を指定してデータを取得してみます。<br/>
まずは<code>mongoHandler.swift</code>にクエリ指定のメソッドを追加しましょう。</p>

<p>```objective-c
// mongoHandler.swift
import PerfectLib
import PerfectHTTP
import MongoDB</p>

<p>class MongoHandler {</p>

<pre><code>var client: MongoClient?
var database: MongoDatabase?
var collection: MongoCollection?

    fileprivate func connect() {

    // open a connection
    client = try! MongoClient(uri: "mongodb://localhost")

    // set database, assuming "test" exists
    database = client?.getDatabase(name: "test")

    // define collection
    self.collection = database?.getCollection(name: "testCollection")
}

fileprivate func close() {
    collection?.close()
    database?.close()
    client?.close()
}

    // searchAllメソッドは省略

    // =====ここから追加========================================================
    func search(query: BSON, request: HTTPRequest, _ response: HTTPResponse) {
        // MongoDBへの接続
        connect()

        // 指定コレクションが見つからない場合は処理終了
  guard let collection = self.collection else {
      return
  }

  // クエリを指定して検索
  let fnd = collection.find(query: query)

  // データ格納用に配列を定義
  var arr = [String]()

        // 取得したデータを配列に格納する
    // fndはMongoCursor型であり、for文での繰り返し処理が可能
  for x in fnd! {
      arr.append(x.asString)
  }

  // JSONStringに変換
  let returning = "{\"data\":[\(arr.joined(separator: ","))]}"

  // レスポンスデータとして設定
  response.appendBody(string: returning)
        // レスポンス処理完了
  response.completed()

        // MongoDBから切断
  close()
}
</code></pre>

<p>}
```</p>

<p><code>searchAll</code>との違いは引数に<code>BSON</code>型の<code>query</code>を追加しているところです。</p>

<p>続いて、<code>main.swift</code>にGETリクエストで<code>name</code>パラメータをキャッチできるように処理を追加していきましょう。</p>

<p>```objective-c
// main.swift
import PerfectLib
import PerfectHTTP
import PerfectHTTPServer
import MongoDB                  // ここを追加</p>

<p>// 省略</p>

<p>// nameパラメータを指定したGETリクエストのハンドリング
routes.add(method: .get, uri: &ldquo;/mongo/name/{name}&rdquo;, handler: {
  request, response in</p>

<pre><code>// BSON型オブジェクトの初期化(クエリとして渡す)
</code></pre>

<p>  let bson = BSON()
  defer {</p>

<pre><code>    // 処理完了時にBSONオブジェクトを削除
bson.close()
</code></pre>

<p>  }</p>

<pre><code>// クエリとして渡すパラメータをセット
</code></pre>

<p>  bson.append(key: &ldquo;name&rdquo;, string: request.urlVariables[&ldquo;name&rdquo;]!)</p>

<pre><code>// クエリを指定して検索
</code></pre>

<p>  mongoHandler.search(query: bson, request: request, response)
})
```</p>

<p>これだけで準備万端です。<br/>
<code>http://localhost:8181/name/takahiro</code>にアクセスすると下記結果が得られます。</p>

<p><img src="/images/perfect-mongo_5.png" alt="nameパラメータを指定したGETリクエスト結果" />_</p>

<h5>ObjectIdを指定してデータを取得</h5>

<p>続いて、少しクエリの書き方に迷うかもしれない<code>ObjectId</code>を指定したデータ検索をしてみましょう。<br/>
<code>mongoHandler.swift</code>には特に変更がありません。<br/>
<code>main.swift</code>のみ変更していきます。</p>

<p>```objective-c
// main.swift
import PerfectLib
import PerfectHTTP
import PerfectHTTPServer
import MongoDB
import libmongoc                // ここを追加</p>

<p>// 省略</p>

<p>// ObjectIdパラメータを指定したGETリクエストのハンドリング
routes.add(method: .get, uri: &ldquo;/mongo/oid/{oid}&rdquo;, handler: {
  request, response in</p>

<pre><code>// BSON型オブジェクトの初期化(クエリとして渡す)
</code></pre>

<p>  let bson = BSON()
  defer {</p>

<pre><code>    // 処理完了時にBSONオブジェクトを削除
bson.close()
</code></pre>

<p>  }</p>

<pre><code>// bson_oid_t型のオブジェクトの初期化
</code></pre>

<p>  var oid: bson_oid_t = bson_oid_t()</p>

<pre><code>// String型からbson_oid_t型に変換
</code></pre>

<p>  bson_oid_init_from_string(&amp;oid, request.urlVariables[&ldquo;oid&rdquo;])</p>

<pre><code>// クエリとして渡すパラメータをセット
</code></pre>

<p>  bson.append(key: &ldquo;_id&rdquo;, oid: oid)</p>

<pre><code>// クエリを指定して検索
</code></pre>

<p>  mongoHandler.search(query: bson, request: request, response)
})
```</p>

<p>肝なのが、<code>import libmongoc</code>をしているということです。<br/>
このライブラリの各種メソッドを利用することでServer Side Swiftから<code>ObjectId</code>を指定したデータ検索が可能になります。</p>

<p>少し詳しく説明すると、<br/>
クエリとして<code>ObjectId</code>を渡すためには<code>public func append(key k: String, oid: bson_oid_t) -&gt; Bool</code>を利用する必要があります。<br/>
しかし、このメソッドの第二引数をよく見ると、<code>bson_oid_t</code>型となっています。</p>

<p>GETリクエストの時点で<code>bson_oid_t</code>型でパラメータを渡すわけにもいかないので、  サーバサイド側で変換する必要があります。<br/>
そのために利用するメソッドが<code>void bson_oid_init_from_string (bson_oid_t *oid, const char *str);</code>です。<br/>
筆者もSwiftで初めて利用したのですが、このメソッドは戻り値が<code>void</code>型のため何も返ってきません。<br/>
が、第一引数に参照渡しとして<code>bson_oid_t</code>型オブジェクトを設定することで、メソッドの処理結果が<code>oid</code>に格納されます。<br/>
これでめでたくクエリとして<code>ObjectId</code>が設定できるわけです。</p>

<p>では、<code>http://localhost:8181/oid/58392222a8589d99c931303d</code>にアクセスしてみましょう。</p>

<p><img src="/images/perfect-mongo_6.png" alt="ObjectIdパラメータを指定したGETリクエスト結果" /></p>

<h4>MongoDBにデータを保存</h4>

<p>検索に関してはざっと見てきたので、MongoDBへの保存処理も見ていきましょう。</p>

<h5>insertメソッドでデータを保存</h5>

<p>保存には<code>MongoClient</code>の<code>insert</code>メソッドを利用します。<br/>
(他にも<code>save</code>メソッドもあります。)</p>

<p>まずは <code>mongoHandler.swift</code> へのメソッド追加からです。</p>

<p>```objective-c
// mongoHandler.swift
func save(query: BSON, request: HTTPRequest, response: HTTPResponse) {</p>

<pre><code>// MongoDBへの接続
connect()

// 指定コレクションが見つからない場合は処理終了
</code></pre>

<p>  guard let collection = self.collection else {</p>

<pre><code>return
</code></pre>

<p>  }</p>

<pre><code>// データの保存処理
</code></pre>

<p>  let insert = collection.insert(document: query) as MongoResult</p>

<pre><code>// データ保存結果によって返却値を変更
</code></pre>

<p>  var returning = &ldquo;Failed&rdquo;
  switch insert {
  case .success:</p>

<pre><code>returning = "Succeeded"
</code></pre>

<p>  default:</p>

<pre><code>returning = "Failed"
</code></pre>

<p>  }</p>

<pre><code>// レスポンスデータとして設定
</code></pre>

<p>  response.appendBody(string: returning)</p>

<pre><code>// レスポンス処理完了
</code></pre>

<p>  response.completed()</p>

<pre><code>// MongoDBから切断
</code></pre>

<p>  close()
}
```</p>

<p>次にPOSTで届いたリクエストパラメータがJSONStringなのでDictionary型に変換します。<br/>
その処理を <code>decode.swift</code> ファイルを新規作成して追加します。</p>

<p>```objective-c
// decode.swift
import PerfectHTTPServer
import PerfectLib</p>

<p>func decode(postBody: String?) &ndash;> [String: Any]? {
  do {</p>

<pre><code>guard let decoded = try postBody?.jsonDecode() as? [String:Any] else {
  return [:]
}
print(decoded)
return decoded
} catch {
return [:]
}
</code></pre>

<p>}
```</p>

<p>そして <code>main.swift</code> にPOSTリクエストのハンドリング処理を書きます。</p>

<p>```objective-c
// main.swift
routes.add(method: .post, uri: &ldquo;/mongo/&rdquo;, handler: {</p>

<pre><code>request, response in
// BSON型オブジェクトの初期化(クエリとして渡す)
</code></pre>

<p>  let bson = BSON()
  defer {</p>

<pre><code>    // 処理完了時にBSONオブジェクトを削除
bson.close()
</code></pre>

<p>  }</p>

<pre><code>// JSONString型をDictionary型に変換
</code></pre>

<p>  let decodedParam = decode(postBody: request.postBodyString)</p>

<pre><code>// 各パラメータ単位でBSONオブジェクトに格納
</code></pre>

<p>  for (key, value) in decodedParam! {</p>

<pre><code>  switch key {
  case "name":
      bson.append(key: "name", string: value as! String)
  case "age":
      bson.append(key: "age", int32: Int32(value as! Int))
  case "hobby":
      bson.append(key: "hobby", string: value as! String)
  default:
      break
  }
</code></pre>

<p>  }</p>

<pre><code>// データ保存
</code></pre>

<p>  mongoHandler.save(query: bson, request: request, response: response)
})
```</p>

<p>これで処理は完成です。<br/>
ではPOSTリクエストを投げてみましょう。</p>

<p><code>
$ curl http://localhost:8181/mongo -X POST -H "Content-Type: application/json" -d '{"name":"Hanako", "age": 24, "hobby": "game"}'
</code></p>

<p>再度、MongoDBを検索してみると下記のような結果が得られるはずです。</p>

<p>```
// データの確認</p>

<blockquote><p>db.testCollection.find()
{ &ldquo;<em>id&rdquo; : ObjectId(&ldquo;58391469a8589d99c931303c&rdquo;), &ldquo;name&rdquo; : &ldquo;takahiro&rdquo;, &ldquo;age&rdquo; : 30, &ldquo;hobby&rdquo; : &ldquo;blog&rdquo; }
{ &ldquo;</em>id&rdquo; : ObjectId(&ldquo;58392222a8589d99c931303d&rdquo;), &ldquo;name&rdquo; : &ldquo;ichiro&rdquo;, &ldquo;age&rdquo; : 43, &ldquo;hobby&rdquo; : &ldquo;baseball&rdquo; }
{ &ldquo;_id&rdquo; : ObjectId(&ldquo;583afcaedcab265c1821fb51&rdquo;), &ldquo;name&rdquo; : &ldquo;Hanako&rdquo;, &ldquo;age&rdquo; : 24, &ldquo;hobby&rdquo; : &ldquo;game&rdquo; }
```</p></blockquote>

<p>因みに、<code>main.swift</code>でリクエストパラメータとして取得した<code>age</code>を <strong>Int32</strong> 型に変換しているのには理由があります。<br/>
これを仮に <code>bson.append(key: "age", int: value as! Int)</code> とした場合、MongoDBには <code>NumberLong</code>として保存されてしまいます。 <br/>
これは32bitか64bitかの違いですね。</p>

<h5>insertメソッドのMongoInsertFlagについて</h5>

<p>先程、<code>insert</code>メソッドを利用しましたが、実は第一引数のみ持っている <code>insert</code> メソッドを利用していました。<br/>
実は他にも <code>public func insert(document: BSON, flag: MongoInsertFlag = .none) -&gt; Result</code> といった第二引数を持つ <code>insert</code> メソッドが存在します。</p>

<p>少し気になったのでこの <code>MongoInsertFlag</code>について調べてみました。<br/>
<code>MongoInsertFlag</code>は<code>MongoCollection.swift</code>内に <strong>enum</strong> として定義されています。</p>

<p>```objective-c
public enum MongoInsertFlag: Int {</p>

<pre><code>case none
case continueOnError
case noValidate

var mongoFlag: mongoc_insert_flags_t {
    switch self {
    case .none:
        return MONGOC_INSERT_NONE
    case .continueOnError:
        return MONGOC_INSERT_CONTINUE_ON_ERROR
    case .noValidate:
        return mongoc_insert_flags_t(rawValue: MONGOC_INSERT_NO_VALIDATE)
    }
}
</code></pre>

<p>}
```</p>

<p>ここで<code>MONGOC_INSERT_NONE</code>, <code>MONGOC_INSERT_CONTINUE_ON_ERROR</code>, <code>MONGOC_INSERT_NO_VALIDATE</code>の3つがフラグとして用意されていることがわかります。<br/>
これらはそれぞれ次のような意味とのことです。</p>

<ul>
<li><code>MONGOC_INSERT_NONE</code>

<ul>
<li>特別何もしません。</li>
</ul>
</li>
<li><code>MONGOC_INSERT_CONTINUE_ON_ERROR</code>

<ul>
<li>途中でエラーが発生したとしても後続の<code>insert</code>処理がある場合は続ける</li>
</ul>
</li>
<li><code>MONGOC_INSERT_NO_VALIDATE</code>

<ul>
<li>インサート前に値のバリデーションチェックをしない

<ul>
<li>MongoDBへの保存処理前にAPサーバ時点などでバリデーションチェックはした方が良い</li>
</ul>
</li>
<li>これをすることで処理時間を短縮することができる</li>
</ul>
</li>
</ul>


<h4>MongoDBのデータを更新</h4>

<p>MongoDBへの更新処理も見ていきましょう。</p>

<h5>updateメソッドでデータを保存</h5>

<p>保存には<code>MongoClient</code>の<code>update</code>メソッドを利用します。</p>

<p><code>mongoHandler.swift</code>にメソッドを追加します。</p>

<p>```objective-c
// mongoHandler.swift
func update(update: BSON, selector: BSON, request: HTTPRequest, response: HTTPResponse) {</p>

<pre><code>// MongoDBへの接続
connect()

// 指定コレクションが見つからない場合は処理終了
</code></pre>

<p>  guard let collection = self.collection else {</p>

<pre><code>return
</code></pre>

<p>  }</p>

<pre><code>// データの更新
</code></pre>

<p>  let updated = collection.update(update: update, selector: query)</p>

<pre><code>// データ更新結果によって返却値を変更
</code></pre>

<p>  var returning = &ldquo;Failed&rdquo;
  switch updated {
  case .success:</p>

<pre><code>returning = "Succeeded"
</code></pre>

<p>  default:</p>

<pre><code>returning = "Failed"
</code></pre>

<p>  }</p>

<pre><code>// レスポンスデータとして設定
</code></pre>

<p>  response.appendBody(string: returning)</p>

<pre><code>// レスポンス処理完了
</code></pre>

<p>  response.completed()</p>

<pre><code>// MongoDBから切断
</code></pre>

<p>  close()
}
```</p>

<p>そして <code>main.swift</code> にPUTリクエストのハンドリング処理を書きます。</p>

<p>```objective-c
// main.swift
routes.add(method: .post, uri: &ldquo;/mongo/&rdquo;, handler: {</p>

<pre><code>request, response in
// BSON型オブジェクトの初期化(更新内容として渡す)
</code></pre>

<p>  let updateBson = BSON()</p>

<pre><code>// BSON型オブジェクトの初期化(クエリとして渡す)
let selectorBson = BSON()
</code></pre>

<p>  defer {</p>

<pre><code>    // 処理完了時にBSONオブジェクトを削除
updateBson.close()
    selectorBson.close()
</code></pre>

<p>  }</p>

<pre><code>// JSONString型をDictionary型に変換
</code></pre>

<p>  let decodedParam = decode(postBody: request.postBodyString)</p>

<pre><code>// 各パラメータ単位でBSONオブジェクトに格納
</code></pre>

<p>  for (key, value) in decodedParam! {</p>

<pre><code>  switch key {
  case "name":
      updateBson.append(key: "name", string: value as! String)
  case "age":
      updateBson.append(key: "age", int32: Int32(value as! Int))
  case "hobby":
      updateBson.append(key: "hobby", string: value as! String)
  default:
      break
  }
</code></pre>

<p>  }</p>

<pre><code>// データ更新
</code></pre>

<p>  mongoHandler.update(update: updateBson, query: selectorBson, request: request, response: response)
})
```</p>

<p>基本的にはPOSTと同じ感じで処理を書くことができます。<br/>
しかしながら気をつけなくてはいけないのが、<strong>$setが利用できない</strong> ということです。<br/>
通常、MongoDBでは、 <strong>$setを使わないと</strong> &hellip;</p>

<p>```
// データの確認</p>

<blockquote><p>db.testCollection.find();
{ &ldquo;_id&rdquo; : ObjectId(&ldquo;583afcaedcab265c1821fb51&rdquo;), &ldquo;name&rdquo; : &ldquo;Hanako&rdquo;, &ldquo;age&rdquo; : 24, &ldquo;hobby&rdquo; : &ldquo;game&rdquo; }</p></blockquote>

<p>// データの更新</p>

<blockquote><p>db.testCollection.update({_id: ObjectId(&ldquo;583afcaedcab265c1821fb51&rdquo;)}, {&ldquo;hobby&rdquo;: &ldquo;go shopping&rdquo;});</p></blockquote>

<p>// データの確認</p>

<blockquote><p>db.testCollection.find();
{ &ldquo;_id&rdquo; : ObjectId(&ldquo;583afcaedcab265c1821fb51&rdquo;), &ldquo;hobby&rdquo; : &ldquo;go shopping&rdquo; }
```</p></blockquote>

<p>となってしまいます。<br/>
現状、<code>Perfect-MongoDB</code>に実装されているメソッドを見ると<code>$set</code>はないようです。<br/>
そのため、今回はあえてPOST同様に全てのパラメータをクライアント側から下記のように投げることにしました。</p>

<p><code>
$ curl http://localhost:8181/mongo/583afcaedcab265c1821fb51 -X PUT -H "Content-Type: application/json" -d '{"name" : "Hanako", "age" : 24, "hobby": "game"}'
</code></p>

<h5>updateメソッドのMongoUpdateFlagについて</h5>

<p><code>update</code>メソッドにも実は<code>MongoUpdateFlag</code>というオプションを設定できるメソッドが存在します。<br/>
<code>MongoUpdateFlag</code>は<code>MongoInsertFlag</code>と同じく <strong>enum</strong> として定義されています。</p>

<p>```objective-c
public enum MongoUpdateFlag: Int {</p>

<pre><code>case none
case upsert
case multiUpdate
case noValidate

var mongoFlag: mongoc_update_flags_t {
    switch self {
    case .none:
        return MONGOC_UPDATE_NONE
    case .upsert:
        return MONGOC_UPDATE_UPSERT
    case .multiUpdate:
        return MONGOC_UPDATE_MULTI_UPDATE
    case .noValidate:
        return mongoc_update_flags_t(rawValue: MONGOC_UPDATE_NO_VALIDATE)
    }
}
</code></pre>

<p>}
```</p>

<p>それぞれのフラグの意味は下記の通りです。</p>

<ul>
<li><code>MONGO_UPDATE_NONE</code>

<ul>
<li>特別何もしません</li>
</ul>
</li>
<li><code>MONGOC_UPDATE_UPSERT</code>

<ul>
<li>検索に引っかからない場合は<code>insert</code>します</li>
</ul>
</li>
<li><code>MONGOC_UPDATE_MULTI_UPDATE</code>

<ul>
<li>検索にヒットする件数が複数の場合は全て更新します</li>
</ul>
</li>
<li><code>MONGOC_UPDATE_NO_VALIDATE</code>

<ul>
<li>アップデート前に値のバリデーションチェックをしません</li>
</ul>
</li>
</ul>


<h4>MongoDBのデータを削除</h4>

<p>MongoDBからのデータ削除処理も見ていきましょう。</p>

<h5>removeメソッドでデータを保存</h5>

<p>保存には<code>MongoClient</code>の<code>remove</code>メソッドを利用します。</p>

<p><code>mongoHandler.swift</code>にメソッドを追加します。</p>

<p>```objective-c
// mongoHandler.swift
func delete(query: BSON, request: HTTPRequest, response: HTTPResponse) {</p>

<pre><code>// MongoDBへの接続
connect()

// 指定コレクションが見つからない場合は処理終了
</code></pre>

<p>  guard let collection = self.collection else {</p>

<pre><code>return
</code></pre>

<p>  }</p>

<pre><code>// データ削除処理
</code></pre>

<p>  let removed = collection.remove(selector: query, flag: .none)</p>

<pre><code>// データ削除結果によって返却値を変更
</code></pre>

<p>  var returning = &ldquo;Failed&rdquo;    <br/>
  switch removed {
  case .success:</p>

<pre><code>returning = "Succeeded"
</code></pre>

<p>  default:</p>

<pre><code>returning = "Failed"
</code></pre>

<p>  }</p>

<pre><code>// レスポンスデータとして設定
</code></pre>

<p>  response.appendBody(string: returning)</p>

<pre><code>// レスポンス処理完了
</code></pre>

<p>  response.completed()</p>

<pre><code>// MongoDBから切断
</code></pre>

<p>  close()
}
```</p>

<p>そして <code>main.swift</code> にDELETEリクエストのハンドリング処理を書きます。</p>

<p>```objective-c
// main.swift
routes.add(method: .delete, uri: &ldquo;/mongo/{oid}&rdquo;, handler: {
  request, response in</p>

<pre><code>// BSON型オブジェクトの初期化(クエリとして渡す)
</code></pre>

<p>  let bson = BSON()
  defer {</p>

<pre><code>    // 処理完了時にBSONオブジェクトを削除
bson.close()
</code></pre>

<p>  }</p>

<p>  var oid: bson_oid_t = bson_oid_t()
  bson_oid_init_from_string(&amp;oid, request.urlVariables[&ldquo;oid&rdquo;])
  bson.append(key: &ldquo;_id&rdquo;, oid: oid)</p>

<pre><code>// データ削除
</code></pre>

<p>  mongoHandler.delete(query: bson, request: request, response: response)
})
```</p>

<p>下記のようなDELETEリクエストを投げてみればデータが削除されていることが確認できるはずです。</p>

<p><code>
$ curl http://localhost:8181/mongo/583afcaedcab265c1821fb51 -X DELETE -H "Content-Type: application/json"
</code></p>

<h5>removeメソッドのMongoRemoveFlagについて</h5>

<p><code>remove</code>メソッドにも実は<code>MongoRemoveFlag</code>というオプションを設定できるメソッドが存在します。<br/>
<code>MongoRemoveFlag</code>は<code>MongoUpdateFlag</code>と同じく <strong>enum</strong> として定義されています。</p>

<p>```objective-c
public enum MongoRemoveFlag: Int {</p>

<pre><code>case none
case singleRemove

var mongoFlag: mongoc_remove_flags_t {
    switch self {
    case .none:
        return MONGOC_REMOVE_NONE
    case .singleRemove:
        return MONGOC_REMOVE_SINGLE_REMOVE
    }
}
</code></pre>

<p>}
```</p>

<p>フラグの意味は下記の通りです。</p>

<ul>
<li><code>MONGOC_REMOVE_NONE</code>

<ul>
<li>特に何のオプションもつけません。</li>
<li>検索にヒットしたデータは全て削除します。</li>
</ul>
</li>
<li><code>MONGOC_REMOVE_SINGLE_REMOVE</code>

<ul>
<li>初めに該当したデータ1件のみを削除します。</li>
</ul>
</li>
</ul>


<h3>まとめ</h3>

<p>以上で基本的なCRUDに対応したAPサーバとDBサーバをSwiftとMongoDBで構築することができました。<br/>
これから何かサービスでも&hellip;と思っていたら時間切れ&hellip;<br/>
今回は一旦ここまでとしたいと思いますが、今後の展望としてはSwift製iOSアプリと連携させてiOSアプリを作成するか、もしくはReact / Reduxを使ったWebサービスと連携させたいと企んでいます。<br/>
処理速度とかリソースの消費具合とかは全然比較もしていないのでわからないですが、Swiftによるサーバサイド構築によるメリットも今後Appleさんが？明らかにしてくれるかもしれません。</p>

<p>何と言っても新しい技術や取り組みは楽しいですね！！<br/>
と言ったところで本日はここまで。</p>

<h3>参考URL</h3>

<ul>
<li><a href="http://perfect.org/docs/MongoDB.html">Perfect MongoDB Documentation</a></li>
<li><a href="http://mongoc.org/libbson/1.3.5/bson_oid_init_from_string.html">Libbson API Reference: Bson Oid Init</a></li>
<li><a href="http://mongoc.org/libmongoc/1.4.0/updating-document.html">Libbson API Reference: Update Document</a></li>
<li><a href="http://mongoc.org/libmongoc/1.0.0/mongoc_insert_flags_t.html">MongoDB C Driver API Reference: Insert Flag</a></li>
<li><a href="http://mongoc.org/libmongoc/1.2.3/mongoc_update_flags_t.html">MongoDB C Driver API Reference: Update Flag</a></li>
<li><a href="http://mongoc.org/libmongoc/1.3.2/mongoc_remove_flags_t.html">MongoDB C Driver API Reference: Remove Flag</a></li>
</ul>


<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Server Side Swift: Perfect を使ってみよう！]]></title>
    <link href="http://grandbig.github.io/blog/2016/10/30/swift-perfect/"/>
    <updated>2016-10-30T22:48:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2016/10/30/swift-perfect</id>
    <content type="html"><![CDATA[<h3>Server Side SwiftライブラリのPerfect</h3>

<p>本日は以前書いたサーバサイドSwiftの続きを書きます！<br/>
と言いたかったところなのですが、Swift ExpressはSwift3.0やXcode8に対応しておらず、何もできなかったため、方向転換して最もSTAR数の多い<a href="https://github.com/PerfectlySoft/Perfect">PerfectlySoft/Perfect</a>を使うことにしました。</p>

<p>よくよく見るとMySQLだけでなくMongoDB接続用にもモジュールが用意されており、なかなか良さそうではないですか！！<br/>
とは言いつつも、そんなにすぐにMaster Of Perfectにはなれないので少しずつ見ていくことにします。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<!-- more -->


<h4>チュートリアルを触ってみる</h4>

<p>まずは何はともあれGitHubの <em>Getting Started</em> からやらないと話になりません。<br/>
手順は簡単です。</p>

<p>１．テンプレートプロジェクトをクローンする<br/>
<code>git clone https://github.com/PerfectlySoft/PerfectTemplate.git</code></p>

<p>２．ビルドを実行する<br/>
クローンした<code>PerfectTemplate</code>フォルダ内に入り、ビルドを実行しましょう。</p>

<p><code>
$ cd PerfectTemplate
$ swift build
</code></p>

<p>３．サーバを起動します<br/>
なんと後は下記コマンドでサーバを起動するだけです。</p>

<p><code>.build/debug/PerfectTemplate</code></p>

<p>正しく起動すれば、下記ログが出力されます。<br/>
<code>Starting HTTP server on 0.0.0.0:8181 with document root ./webroot</code><br/>
またログの指示通りChromeで<code>http://localhost:8181/</code>にアクセスすれば<code>Hello World</code>が拝めます。</p>

<h4>ルーティングの書き方について学ぶ</h4>

<p>では次に簡単なルーティングについて学んでいきましょう。<br/>
チュートリアルでは、下記GETリクエストのみ受け付けていました。</p>

<p>```javascript
// main.swift
var routes = Routes()
routes.add(method: .get, uri: &ldquo;/&rdquo;, handler: {</p>

<pre><code>request, response in
response.setHeader(.contentType, value: "text/html")
response.appendBody(string: "&lt;html&gt;&lt;title&gt;Hello, world!&lt;/title&gt;&lt;body&gt;Hello, world!&lt;/body&gt;&lt;/html&gt;")
response.completed()
</code></pre>

<p>})
```</p>

<p>最も単純なGETリクエストですね。<br/>
では、<code>ID: 100</code>のユーザ情報を取得するGETリクエストはどう受け付けるのでしょうか。</p>

<p>```javascript
// main.swift
var routes = Routes()
routes.add(method: .get, uri: &ldquo;/user/{id}&rdquo;, handler: {</p>

<pre><code>request, response in
response.setHeader(.contentType, value: "text/html")
response.appendBody(string: "&lt;html&gt;&lt;title&gt;Sample&lt;/title&gt;&lt;body&gt;You GET UserInfo with \(request.urlVariables)&lt;/body&gt;&lt;/html&gt;")
response.completed()
</code></pre>

<p>})
```</p>

<p>たったのこれだけです。<br/>
では、POSTリクエストの受け付けはどうでしょうか。</p>

<p>```javascript
// main.swift
var routes = Routes()
routes.add(method: .post, uri: &ldquo;/user&rdquo;, handler: {</p>

<pre><code>request, response in
response.appendBody(string: "&lt;html&gt;&lt;title&gt;Sample&lt;/title&gt;&lt;body&gt;You POSTed user data to catch your POST request.&lt;/body&gt;&lt;/html&gt;")
response.completed()
</code></pre>

<p>})
```</p>

<p>これも簡単ですね。<br/>
書き方に若干の違いはあれど、最早Node.jsとそんなに変わらん&hellip;</p>

<p>おまけで、POSTリクエストで届いたJSONStringをバラバラっと分解して返却してみました。<br/>
そのためにまずはJSONStringをデコードする処理を実装します。</p>

<p>```javascript
// decode.swift
import PerfectHTTPServer
import PerfectLib</p>

<p>func decode(postBody: String?) &ndash;> [String: Any]? {</p>

<pre><code>do {
    guard let decoded = try postBody?.jsonDecode() as? [String:Any] else {
        return [:]
    }
    print(decoded)
    return decoded
} catch {
    return [:]
}
</code></pre>

<p>}
```</p>

<p>これを下記のように利用します。</p>

<p>```javascript
// main.swift
var routes = Routes()
routes.add(method: .post, uri: &ldquo;/user&rdquo;, handler: {</p>

<pre><code>request, response in

var userInfo = ""
let decodedParam = decode(postBody: request.postBodyString)
for (key, value) in decodedParam! {
    switch key {
        case "name":
            userInfo = userInfo + "name is \(value as! String).\n"
        case "email":
            userInfo = userInfo + "email is \(value as! String)."
        default:
            break
    }
}
response.appendBody(string: "&lt;html&gt;&lt;body&gt;POST handler: \(userInfo)&lt;/body&gt;&lt;/html&gt;")
response.completed()
</code></pre>

<p>})
```</p>

<p>さて、実装できたのでクライアントからリクエストを投げてみます。</p>

<p><code>
// クライアントからPOSTリクエストを投げます
curl http://localhost:8181/user -X POST -H "Content-Type: application/json" -d '{"name":"Ichiro", "email": "xxx@gmail.com"}'
// 結果
&lt;html&gt;&lt;body&gt;POST handler: name is Ichiro.
email is xxx@gmail.com.&lt;/body&gt;&lt;/html&gt;xxxx:PerfectTemplate
</code></p>

<h3>まとめ</h3>

<p>さて今回は<code>Perfect</code>を使ったサーバサイドSwiftを見てみました。<br/>
まだまだ基本的なリクエストの受付しかみていませんが、既にいろいろなモジュールが用意されているようなので、継続的に見ていきたいと思います。<br/>
やっぱりライブラリを作るなら、最新の状況についていかないと見捨てられるな〜と思ってしまいました。<br/>
(今回で言うと、Swift3やXcode8とかですね。)</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Node.jsでrouterモジュールでルーティング！]]></title>
    <link href="http://grandbig.github.io/blog/2016/10/30/node-router/"/>
    <updated>2016-10-30T00:00:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2016/10/30/node-router</id>
    <content type="html"><![CDATA[<h3>Expressなしで簡単にルーティングしよう！</h3>

<p>さて、久しぶりにNode.jsについて書きます。<br/>
筆者が本格的にNode.jsを利用していたのは3〜4年前だったため、Expressをよく利用していました。<br/>
その後、Expressを利用するほどのリッチな機能を必要としない、簡易的なデモ用のサーバサイドの仕組みを作るのにバリバリ自作ルーティングをしていました。<br/>
しかし、ここにきてExpressを利用するでもなく、かと言って自作でルーティング処理を書くのも若干面倒だと感じるとき果たしてどうすれば良いのかふと気になりました。<br/>
「きっと今の世の中なら何らかのモジュールが出ているはず！」と思った筆者は早速探してみることに&hellip;</p>

<p>そこで見つけたのが<a href="https://github.com/pillarjs/router">router</a>です。<br/>
このモジュールを利用すれば、次のように簡単にルーティングを実装することができます。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<!-- more -->


<p>```javascript
// server.js
var http = require(&ldquo;http&rdquo;);
var Router = require(&ldquo;router&rdquo;);
var finalhandler = require(&lsquo;finalhandler&rsquo;);
var bodyParser   = require(&lsquo;body-parser&rsquo;);</p>

<p>function start(route) {</p>

<pre><code>var opts = { mergeParams: true }
var router = Router(opts);
var server = http.createServer(function onRequest(req, res) {
    router(req, res, finalhandler(req, res));
});

// GETリクエストのハンドリング
var user = Router(opts);
router.use('/users/:path', user);

user.get('/', function (req, res) {
    res.statusCode = 200
    res.setHeader('Content-Type', 'text/plain; charset=utf-8')
    res.end(req.params.path + '\n')
});

// POSTリクエストのハンドリング
var users = Router();
router.use('/users', users);
users.use(bodyParser.json());

users.post('/', function (req, res) {
    if (req.body.value) {
        res.statusCode = 200;
        res.setHeader('Content-Type', 'text/plain; charset=utf-8');
        res.end(req.body.value + '\n');
    } else {
        res.statusCode = 400;
        res.setHeader('Content-Type', 'text/plain; charset=utf-8');
        res.end('Invalid API Syntax\n');
    }
});

server.listen(8888);
console.log("server has started.");
</code></pre>

<p>}</p>

<p>exports.start = start;
```</p>

<p>因みに、 <code>server.js</code> はモジュールとして切り出しています。<br/>
実際には <code>app.js</code> で呼び出すようにしています。</p>

<p><code>javascript
// app.js
var server = require("./server");
server.start();
</code></p>

<p>ただ、今後たくさんのリクエストを捌くことを考えると、もう少しリクエスト内容ごとにファイルを分けた方が良いですよね&hellip;<br/>
と言うことで少々修正します。</p>

<p>```javascript
// server.js
var http = require(&ldquo;http&rdquo;);
var Router = require(&ldquo;router&rdquo;);
var finalhandler = require(&lsquo;finalhandler&rsquo;);
var bodyParser   = require(&lsquo;body-parser&rsquo;);
var users = require(&ldquo;./users&rdquo;);</p>

<p>/<em>*
 *  サーバ起動処理
 </em>/
function start() {</p>

<pre><code>var opts = { mergeParams: true };
var router = Router(opts);
var server = http.createServer(function onRequest(req, res) {
    router(req, res, finalhandler(req, res));
});

router.use(bodyParser.json());
router.use('/users/:path', users);  // GETリクエスト
router.use('/users', users);        // POST, PUT, DELETEリクエスト

server.listen(8888);
console.log("server has started.");
</code></pre>

<p>}</p>

<p>exports.start = start;</p>

<p>```</p>

<p>上記のように<code>server.js</code>はサーバ起動だけに絞りました。<br/>
そしてリクエストを受け付けたあとの処理は下記のように<code>users.js</code>に書きます。</p>

<p>```javascript
// users.js
var Router = require(&ldquo;router&rdquo;);
var opts = { mergeParams: true };
var router = Router(opts);</p>

<p>router.get(&ldquo;/&rdquo;, function(req, res) {</p>

<pre><code>res.statusCode = 200;
res.setHeader("Content-Type", "text/plain; charset=utf-8");
res.end(req.params.path + "\n");
</code></pre>

<p>});</p>

<p>router.post(&ldquo;/&rdquo;, function(req, res) {</p>

<pre><code>if (req.body.value) {
    res.statusCode = 200;
    res.setHeader('Content-Type', 'text/plain; charset=utf-8');
    res.end(req.body.value + '\n');
} else {
    res.statusCode = 400;
    res.setHeader('Content-Type', 'text/plain; charset=utf-8');
    res.end('Invalid API Syntax\n');
}
</code></pre>

<p>});</p>

<p>module.exports = router;</p>

<p>```</p>

<p>このようにまとめることで可読性高くなるので、ルーティングの意味も出てくるというものですね。<br/>
因みに、GETとPOSTリクエストを送れば下記のような結果が得られます。</p>

<p>```
// GETリクエスト
curl <a href="http://localhost:8888/users/20161029">http://localhost:8888/users/20161029</a>
// 結果
20161029</p>

<p>// POSTリクエスト
curl <a href="http://localhost:8888/users">http://localhost:8888/users</a> -X POST -H &ldquo;Content-Type: application/json&rdquo; -d &lsquo;{&ldquo;value&rdquo;:&ldquo;Sample&rdquo;}&rsquo;
// 結果
Sample
```</p>

<h3>Node.jsでデバッグ</h3>

<p>筆者はこれまで <code>node-inspector</code> を利用していたのですが、何とv6.3.0からデバッグ機能が標準装備されているらしいですね！<br/>
早速ですが使ってみました。</p>

<p>```
// Node.jsでデバッグ起動
node &mdash;inspect app.js
Debugger listening on port 9229.
Warning: This is an experimental feature and could change at any time.
To start debugging, open the following URL in Chrome:</p>

<pre><code>chrome-devtools://devtools/remote/serve_file/@60cd6e859b9f557d2312f5bf532f6aec5f284980/inspector.html?experiments=true&amp;v8only=true&amp;ws=localhost:9229/f1478fd8-33f2-4bca-8ab4-4ac9be3515cb
</code></pre>

<p>server has started.
Debugger attached.
```</p>

<p>出力される <code>chrome-devtools://devtools/remote/serve_file/@....</code> の部分をChromeのアドレスバーに貼りましょう！<br/>
<code>node-inspcetor</code> さながらのデバッグができるはずです。</p>

<p>因みに、起動時のオプションとして <code>--debug-brk</code> をつけると必ず1行目でデバッグが停止します。<br/>
一度停めたい場合はオプションを使いましょう。</p>

<h3>まとめ</h3>

<p>今回はNode.jsに触る機会があったため、どうすれば簡単にルーティングが実装できるのか調べてみました。<br/>
Expressを使っても良かったのですが、極力不要なモジュールを取り込みたくない気持ちがあったので割りと最低限にできて良かったなと思いました。<br/>
Node.jsは少しずつリハビリしながら思い出していくことにしようかな。<br/>
と言ったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift ExpressでAjax通信してみよう！]]></title>
    <link href="http://grandbig.github.io/blog/2016/07/31/swift-express-2/"/>
    <updated>2016-07-31T23:40:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2016/07/31/swift-express-2</id>
    <content type="html"><![CDATA[<h3>Swift ExpressでPOSTリクエスト投げてみよう！</h3>

<p>さて、本日は<a href="https://github.com/crossroadlabs/Express">Swift Express</a>の続きを試してみます。<br/>
<a href="http://grandbig.github.io/blog/2016/07/10/swift-express/">前回</a>はインストール方法とデフォルト画面の表示までを紹介しましたが、<br/>
今回はAjax通信によるPOSTリクエストを投げてみたいと思います。</p>

<h4>サーバサイドの対応</h4>

<p>まずは、サーバサイドの準備です。<br/>
<code>main.swift</code>を修正しましょう。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<p>```objective-c
import Express</p>

<p>let app = express()</p>

<p>app.views.register(StencilViewEngine())</p>

<!-- ここを追加 -->


<p>app.views.register(JsonView())</p>

<p>app.get(&ldquo;/assets/:file+&rdquo;, action: StaticAction(path: &ldquo;public&rdquo;, param:&ldquo;file&rdquo;))</p>

<p>app.get(&ldquo;/&rdquo;) { (request:Request<AnyContent>)&ndash;>Action<AnyContent> in</p>

<pre><code>return Action&lt;AnyContent&gt;.render("index", context: ["hello": "Hello,", "swift": "Swift", "express": "Express!"])
</code></pre>

<p>}</p>

<!-- ここを追加 -->


<p>app.post(&ldquo;/:param&rdquo;) { (request:Request<AnyContent>)&ndash;>Action<AnyContent> in</p>

<pre><code>let response = ["status": "ok", "description": "Post Request Succesfully"]
    return Action.render(JsonView.name, context: response)
</code></pre>

<p>}</p>

<p>app.listen(9999).onSuccess { server in</p>

<pre><code>print("Express was successfully launched on port", server.port)
</code></pre>

<p>}</p>

<p>app.run()
```</p>

<p><code>app.views.register(JsonView())</code>を追加することで、JSON形式のデータを返却できるようになります。<br/>
また、返却レスポンスは<code>dictionary</code>型で書けばOKなようです。</p>

<h4>クライアントサイドの対応</h4>

<p>続いて、クライアントサイドの準備です。<br/>
手っ取り早くjQuery使いましょう。<br/>
<a href="https://jquery.com/">こちらのページ</a>から最新のjQueryをダウンロードしてきます。</p>

<p>そして、<code>index.js</code>をさくっと作っちゃいましょう。</p>

<p>```javascript
$(function() {</p>

<pre><code>$("#touch").on("click", function() {
    // Ajax通信
    ajax();
});

function ajax() {
    $.ajax({
        type: "POST",
        url: "http://localhost:9999/1",
        dataType: "json"
    }).done(function(data) {
        alert(data.status + "\n" + data.description);
    }).fail(function(data) {
        alert("error!!");
    });
}
</code></pre>

<p>});
```</p>

<p>これらjsファイルを読み込みます。</p>

<p>```html
// index.stencil
<html></p>

<pre><code>&lt;head&gt;
    &lt;title&gt;{{hello}} {{swift}} {{express}}&lt;/title&gt;
    &lt;link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:700italic,700' rel='stylesheet' type='text/css'&gt;
    &lt;link href='http://grandbig.github.io/assets/css/main.css' rel='stylesheet' type='text/css'&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;img class="logo" src="http://grandbig.github.io/assets/logo.png"/&gt;
    &lt;h1&gt;{{hello}} &lt;i&gt;&lt;span class="swift"&gt;{{swift}}&lt;/span&gt; {{express}}&lt;/i&gt;&lt;/h1&gt;
    &lt;div id="touch"&gt;ここをタッチ！！&lt;/div&gt;

    &lt;script src="http://grandbig.github.io/assets/js/jquery-3.1.0.min.js"&gt;&lt;/script&gt;
    &lt;script src="http://grandbig.github.io/assets/js/index.js"&gt;&lt;/script&gt;
&lt;/body&gt;
</code></pre>

<p></html>
```</p>

<p>これだけで下図のようにPOSTリクエストが通りました。</p>

<p><img src="/images/swift-express-3.png" alt="POSTリクエスト" /></p>

<p>というところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift Expressを使ってみよう！]]></title>
    <link href="http://grandbig.github.io/blog/2016/07/10/swift-express/"/>
    <updated>2016-07-10T22:56:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2016/07/10/swift-express</id>
    <content type="html"><![CDATA[<h3>今注目のサーバーサイドSwift</h3>

<p>本日はサーバーサイドSwiftのWebフレームワークの1つである<a href="https://github.com/crossroadlabs/Express">Swift Express</a>を紹介したいと思います。<br/>
近年、AppleからSwiftのOSS化が発表されたことで一気に動き出したのがGitHub上でのWebフレームワーク作成合戦です。<br/>
筆者が知っているだけでも、</p>

<ul>
<li><a href="https://github.com/PerfectlySoft/Perfect">Perfect</a></li>
<li><a href="https://github.com/qutheory/vapor">Vapor</a></li>
<li><a href="https://github.com/IBM-Swift/Kitura-Starter-Bluemix">Kitura</a></li>
<li><a href="https://github.com/slimane-swift">Sliman</a></li>
</ul>


<p>などが上げられます。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<p>そんな中、筆者の目に止まったのが、 <strong>Swift Express</strong> でした。<br/>
本ブログでも度々 <strong>Node.js</strong> を触ったことがあると述べてきたように、筆者は <strong>Node.js</strong> でサーバサイド実装の経験があります。<br/>
その際に利用していたWebフレームワークに<a href="http://expressjs.com/">Express</a>というものがありました。<br/>
Expressは <strong>Node.js</strong> でいとも簡単にベースとなるサーバサイド実装を提供してくれます。</p>

<p>Swiftの経験はあるものの、サーバサイドSwiftの実装経験がない筆者にとっては『願ってもないWebフレームワークじゃないか！』ということで <strong>Swift Express</strong> に惹かれたのです。<br/>
さて、本日はそんな <strong>Swift Express</strong> を見ていきたいと思います。</p>

<h3>Swift Expressをインストールしよう</h3>

<p>まずは、Swift Expressをインストールしてみます。<br/>
<code>homebrew</code>でインストールします。</p>

<p>```javascript
// 手順(1)
brew tap crossroadlabs/tap</p>

<p>// 手順(2)
brew install swift-express
```</p>

<p>手順(1)を実行すると、下記のように結果が表示されます。</p>

<p><code>javascript
==&gt; Tapping crossroadlabs/tap
Cloning into '/usr/local/Library/Taps/crossroadlabs/homebrew-tap'...
remote: Counting objects: 8, done.
remote: Compressing objects: 100% (7/7), done.
remote: Total 8 (delta 0), reused 6 (delta 0), pack-reused 0
Unpacking objects: 100% (8/8), done.
Checking connectivity... done.
Tapped 2 formulae (34 files, 72.7K)
</code></p>

<p>続いて、手順(2)を実行すると、下記のように結果が表示されます。</p>

<p>```javascript
==> Installing swift-express from crossroadlabs/tap
==> Installing dependencies for crossroadlabs/tap/swift-express: openssl, cmake, libevent, libevhtp, carthage
==> Installing crossroadlabs/tap/swift-express dependency: openssl
==> Downloading <a href="https://homebrew.bintray.com/bottles/openssl-1.0.2h_1.el_capitan.bottle.tar.gz">https://homebrew.bintray.com/bottles/openssl-1.0.2h_1.el_capitan.bottle.tar.gz</a></p>

<h6>################################################################## 100.0%</h6>

<p>==> Pouring openssl-1.0.2h_1.el_capitan.bottle.tar.gz
==> Caveats
A CA file has been bootstrapped using certificates from the system
keychain. To add additional certificates, place .pem files in
  /usr/local/etc/openssl/certs</p>

<p>  and run</p>

<pre><code>/usr/local/opt/openssl/bin/c_rehash

This formula is keg-only, which means it was not symlinked into /usr/local.

Apple has deprecated use of OpenSSL in favor of its own TLS and crypto libraries

Generally there are no consequences of this for you. If you build your
own software and it requires this formula, you'll need to add to your
build variables:

    LDFLAGS:  -L/usr/local/opt/openssl/lib
    CPPFLAGS: -I/usr/local/opt/openssl/include
</code></pre>

<p>==> Summary
🍺  /usr/local/Cellar/openssl/1.0.2h_1: 1,691 files, 12M
==> Installing crossroadlabs/tap/swift-express dependency: cmake
==> Downloading <a href="https://homebrew.bintray.com/bottles/cmake-3.6.0.el_capitan.bottle.tar.gz">https://homebrew.bintray.com/bottles/cmake-3.6.0.el_capitan.bottle.tar.gz</a></p>

<h6>################################################################## 100.0%</h6>

<p>==> Pouring cmake-3.6.0.el_capitan.bottle.tar.gz
==> Caveats
Emacs Lisp files have been installed to:
  /usr/local/share/emacs/site-lisp/cmake
  ==> Summary
  🍺  /usr/local/Cellar/cmake/3.6.0: 2,028 files, 27.8M
  ==> Installing crossroadlabs/tap/swift-express dependency: libevent
  ==> Downloading <a href="https://homebrew.bintray.com/bottles/libevent-2.0.22.el_capitan.bottle.tar.gz">https://homebrew.bintray.com/bottles/libevent-2.0.22.el_capitan.bottle.tar.gz</a></p>

<h6>################################################################## 100.0%</h6>

<p>==> Pouring libevent-2.0.22.el_capitan.bottle.tar.gz
🍺  /usr/local/Cellar/libevent/2.0.22: 53 files, 1.6M
==> Installing crossroadlabs/tap/swift-express dependency: libevhtp
==> Downloading <a href="https://github.com/ellzey/libevhtp/archive/1.2.10.tar.gz">https://github.com/ellzey/libevhtp/archive/1.2.10.tar.gz</a>
==> Downloading from <a href="https://codeload.github.com/ellzey/libevhtp/tar.gz/1.2.10">https://codeload.github.com/ellzey/libevhtp/tar.gz/1.2.10</a></p>

<h6>################################################################## 100.0%</h6>

<p>Warning: SHA1 support is deprecated and will be removed in a future version.
Please switch this formula to SHA256.
==> cmake . -DEVHTP_DISABLE_REGEX:STRING=ON -DEVHTP_BUILD_SHARED:STRING=ON -DCMAKE_C_FLAGS_RELEASE=-DNDEBUG -DCMAKE_CXX_FLAGS_RELEASE=-DNDEBUG -DCMAKE_INSTALL_PREFIX=/usr/local/Cell
==> make install
🍺  /usr/local/Cellar/libevhtp/1.2.10: 9 files, 151.5K, built in 48 seconds
==> Installing crossroadlabs/tap/swift-express dependency: carthage
==> Downloading <a href="https://homebrew.bintray.com/bottles/carthage-0.17.2.el_capitan.bottle.tar.gz">https://homebrew.bintray.com/bottles/carthage-0.17.2.el_capitan.bottle.tar.gz</a></p>

<h6>################################################################## 100.0%</h6>

<p>==> Pouring carthage-0.17.2.el_capitan.bottle.tar.gz
🍺  /usr/local/Cellar/carthage/0.17.2: 45 files, 11.9M
==> Installing crossroadlabs/tap/swift-express
==> Cloning <a href="https://github.com/crossroadlabs/ExpressCommandLine.git">https://github.com/crossroadlabs/ExpressCommandLine.git</a>
Cloning into &lsquo;/Users/kato_takahiro/Library/Caches/Homebrew/swift-express&mdash;git&rsquo;&hellip;
remote: Counting objects: 67, done.
remote: Compressing objects: 100% (63/63), done.
remote: Total 67 (delta 21), reused 25 (delta 1), pack-reused 0
Unpacking objects: 100% (67/67), done.
Checking connectivity&hellip; done.
Note: checking out &lsquo;fae821f4d52c9dfb4e4c34ab0a4297ea700c9db1&rsquo;.</p>

<p>You are in &lsquo;detached HEAD&rsquo; state. You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by performing another checkout.</p>

<p>If you want to create a new branch to retain commits you create, you may
do so (now or later) by using -b with the checkout command again. Example:</p>

<pre><code>  git checkout -b &lt;new-branch-name&gt;

==&gt; Checking out tag 0.2.2
==&gt; carthage update --platform Mac --no-use-binaries --no-build
==&gt; rm -rf Carthage/Checkouts/Commandant/Carthage/Checkouts/Nimble Carthage/Checkouts/Commandant/Carthage/Checkouts/Quick
==&gt; carthage build --platform Mac
==&gt; xcodebuild SYMROOT=build
==&gt; Caveats
.app bundles were installed.
Run `brew linkapps swift-express` to symlink these to /Applications.
==&gt; Summary
🍺  /usr/local/Cellar/swift-express/0.2.2: 30 files, 7.3M, built in 3 minutes 5 seconds
</code></pre>

<p>```</p>

<p>さて、見過ごしがちですが、<br/>
最後の方に『<code>brew linkapps swift-express</code> to symlink these to /Applications.』と書かれているので、</p>

<p><code>brew linkapps swift-express</code>を実行しておきましょう。</p>

<p>ここまで来たら、<code>swift-express</code>を実行してください。</p>

<p>```javascript
Available commands:</p>

<p>bootstrap   download and build Express project dependencies
build       build Express project
help        Display general or command-specific help
init        Creates new Express application project
run         run Express project
update      update and build Express project dependencies
version     Display the current version of Swift Express Command Line
```</p>

<p>のようにコマンド種別が表示されたら、正しく <strong>Swift Express</strong> がインストールされた証拠です。</p>

<h3>Swift Expressのプロジェクトを作ろう！</h3>

<p>Swift Expressのインストールが完了したので、早速プロジェクト作成しましょう。</p>

<p>```javascript
// 手順(1)
swift-express init &lt;プロジェクト名></p>

<p>// 手順(2)
cd &lt;プロジェクト名></p>

<p>// 手順(3)
swift-express bootstrap
```</p>

<p>手順(1)を実行すると、下記の結果が表示されます。</p>

<p><code>javascript
Cloning into '/var/folders/hj/p9y9d00s3sb5nn_x04961z2m0000gn/T/swift-express-827699'...
remote: Counting objects: 124, done.
remote: Total 124 (delta 0), reused 0 (delta 0), pack-reused 124
Receiving objects: 100% (124/124), 79.66 KiB | 0 bytes/s, done.
Resolving deltas: 100% (33/33), done.
Checking connectivity... done.
Task: "init" done.
</code></p>

<p>続いて、手順(2)で作成したプロジェクトフォルダ配下に移動すると、</p>

<p><code>javascript
HelloExpress
  ┣━━ Cartfile
  ┣━━ HelloExpress.xcodeproj
  ┣━━ Info.plist
  ┣━━ Package.swift
  ┣━━ app
  ┃    ┗━━ main.swift
  ┣━━ dist
  ┣━━ public
  ┃    ┣━━ css
  ┃    ┃    ┗━━ main.css
  ┃    ┗━━ logo.png
  ┗━━ views
</code></p>

<p>といった形で構成されていることを確認できます。</p>

<p>最後に手順(3)を実行すると、下記の結果が表示されます。<br/>
(ここが最も時間のかかる工程になります。)</p>

<p>```javascript
<strong><em> No Cartfile.resolved found, updating dependencies
</em></strong> Cloning Express
<strong><em> Cloning Stencil
</em></strong> Cloning GRMustache.swift
<strong><em> Cloning CEVHTP
</em></strong> Cloning PathToRegex
<strong><em> Cloning Regex
</em></strong> Cloning TidyJSON
<strong><em> Cloning BrightFutures
</em></strong> Cloning PathKit
<strong><em> Cloning ExecutionContext
</em></strong> Cloning Result
<strong><em> Checking out CEVHTP at &ldquo;0.1.0&rdquo;
</em></strong> Checking out ExecutionContext at &ldquo;0.3.1&rdquo;
<strong><em> Checking out Result at &ldquo;1.0.3&rdquo;
</em></strong> Checking out GRMustache.swift at &ldquo;bf7d6031d7e0dd862519eaba2b36b2e11a0d25a9&rdquo;
<strong><em> Checking out Regex at &ldquo;0.5.2&rdquo;
</em></strong> Checking out PathToRegex at &ldquo;0.2.2&rdquo;
<strong><em> Checking out PathKit at &ldquo;0.6.1&rdquo;
</em></strong> Checking out BrightFutures at &ldquo;0.4.0&rdquo;
<strong><em> Checking out Stencil at &ldquo;0.5.3&rdquo;
</em></strong> Checking out Express at &ldquo;0.3.6&rdquo;
*** Checking out TidyJSON at &ldquo;1.1.0&rdquo;</p>

<p>&lt;省略></p>

<p>/Users/<strong><strong>**/</strong></strong>/HelloExpress/Carthage/Checkouts/Express/Express/Content.swift:39:5: warning: use of &lsquo;typealias&rsquo; to declare associated types is deprecated; use &lsquo;associatedtype&rsquo; instead
Task: &ldquo;bootstrap&rdquo; done.
```</p>

<p>これでプロジェクトの作成は完了です。</p>

<h3>プロジェクトを実行してみよう！</h3>

<p>先ほど作成したプロジェクトを実行してみたいと思います。</p>

<p>```javascript
// 手順(1)
swift-express build</p>

<p>// 手順(2)
swift-express run
```</p>

<p>早速、ビルドを実行するために手順(1)のコマンドを叩いてください。<br/>
すると、</p>

<p>```javascript
Building HelloExpress in Debug mode&hellip;</p>

<p>&lt;省略></p>

<p>=== BUILD TARGET HelloExpress OF PROJECT HelloExpress WITH CONFIGURATION Debug ===</p>

<p>&lt;省略></p>

<p><strong> BUILD SUCCEEDED </strong></p>

<p>Task: &ldquo;build&rdquo; done.
```</p>

<p>という結果が表示されます。<br/>
問題がなければ<code>BUILD SUCCEEDED</code>が表示されるはずです。</p>

<p>ビルドが成功したら、手順(2)を実行しましょう。<br/>
すると、</p>

<p><code>javascript
Running HelloExpress...
Express was successfully launched on port 9999
</code></p>

<p>のように表示されます。デフォルトでポート番号が <strong>9999</strong> になっていることがわかると思います。<br/>
<code>http://localhost:9999</code>にアクセスしてみると、</p>

<p><img src="/images/swift-express-1.png" alt="Swift Express TOPページ" /></p>

<p>という画面が得られます。</p>

<p>因みにですが、Xcodeからも<code>Build</code>＆<code>Run</code>はできます。</p>

<p><img src="/images/swift-express-2.png" alt="XcodeからBuild &amp; Run" /></p>

<h3>Swift Expressの中身を見てみよう！</h3>

<p>最後にざっくり中身のソースを見てみようと思います。<br/>
Swift Expressのメインソースである<code>main.swift</code>を見てみます。</p>

<p>```javascript
// app/main.swift</p>

<p>import Express</p>

<p>let app = express()</p>

<p>// (1)
app.views.register(StencilViewEngine())</p>

<p>// (2)
app.get(&ldquo;/assets/:file+&rdquo;, action: StaticAction(path: &ldquo;public&rdquo;, param:&ldquo;file&rdquo;))</p>

<p>// (3)
app.get(&ldquo;/&rdquo;) { (request:Request<AnyContent>)&ndash;>Action<AnyContent> in</p>

<pre><code>return Action&lt;AnyContent&gt;.render("index", context: ["hello": "Hello,", "swift": "Swift", "express": "Express!"])
</code></pre>

<p>}</p>

<p>// (4)
app.listen(9999).onSuccess { server in</p>

<pre><code>print("Express was successfully launched on port", server.port)
</code></pre>

<p>}</p>

<p>app.run()
```</p>

<p>これは <strong>Node.js</strong> 経験者としてはかなりExpressに酷似してるなと感じます。<br/>
順に追ってみていきます。</p>

<p>(1): 描画エンジンを設定しています。</p>

<p>Node.jsのExpressで言うところの、</p>

<p><code>javascript
app.set('views', path.join(__dirname, 'views'));
app.set('view engine', 'jade');
</code></p>

<p>に該当します。</p>

<p>(2): 静的ファイルの格納場所を設定しています。</p>

<p>Node.jsのExpressで言うところの、</p>

<p><code>javascript
app.use(express.static(path.join(__dirname, 'public')));
</code></p>

<p>に該当します。</p>

<p>(3): リクエストのアクションパスと処理を設定しています。</p>

<p>Node.jsのExpressで言うところの、</p>

<p>```javascript
// app.js
app.use(&lsquo;/&rsquo;, routes);</p>

<p>// route/index.js
router.get(&lsquo;/&rsquo;, function(req, res, next) {</p>

<pre><code>res.render('index', { title: 'Express' });
</code></pre>

<p>}
```</p>

<p>に該当します。</p>

<p>(4): ポート番号を設定しています。</p>

<p>Node.jsのExpressで言うところの、</p>

<p>```javascript
// bin/www
var port = normalizePort(process.env.PORT || &lsquo;3000&rsquo;);
app.set(&lsquo;port&rsquo;, port);</p>

<p>var server = http.createServer(app);</p>

<p>server.listen(port);</p>

<p>server.on(&lsquo;listening&rsquo;, onListening);</p>

<p>function onListening() {</p>

<pre><code>var addr = server.address();
var bind = typeof addr === 'string'
    ? 'pipe ' + addr
    : 'port ' + addr.port;
debug('Listening on ' + bind);
</code></pre>

<p>}
```</p>

<p>に該当します。</p>

<h3>まとめ</h3>

<p>さて如何でしたでしょうか？<br/>
これだけNode.jsのExpressに似ているのですから、<br/>
<strong>Swift Express</strong> はこれからサーバサイドSwiftを学んでいく上で強力なWebフレームワークとなるかもしれません。<br/>
新しくNode.jsを学ぶ人も将来的にサーバサイドSwiftを触る機会が出てくるかもしれませんので知っておいて損はないでしょう。<br/>
筆者もこれまら益々注目されるであろうサーバサイドSwiftの情報は追っていきたいと思います。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
</feed>
