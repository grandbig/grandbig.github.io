<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: rx | Takahiro Octopress Blog]]></title>
  <link href="http://grandbig.github.io/blog/categories/rx/atom.xml" rel="self"/>
  <link href="http://grandbig.github.io/"/>
  <updated>2017-04-11T23:27:50+09:00</updated>
  <id>http://grandbig.github.io/</id>
  <author>
    <name><![CDATA[Takahiro]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[RxSwiftを勉強してみよう！(3)]]></title>
    <link href="http://grandbig.github.io/blog/2016/08/30/rxswift-3/"/>
    <updated>2016-08-30T16:42:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2016/08/30/rxswift-3</id>
    <content type="html"><![CDATA[<h3>RxSwiftのメソッドを見てみよう</h3>

<p>前回に引き続きRxSwiftを勉強したいと思います。<br/>
今回は<a href="https://github.com/ReactiveX/RxSwift/blob/master/Documentation/API.md">GitHub: Reactive/RxSwift API一覧</a>からメインのメソッドを見ていきたいと思います。</p>

<h4>asObservable</h4>

<p>これは<code>ReactiveX</code>で定義されている<code>From</code>オペレータと同義です。<br/>
様々なオブジェクトを<code>Observable</code>型のデータに変換するためのオペレータです。</p>

<p>利用例は下記です。</p>

<p>```objective-c
let disposeBag = DisposeBag()   // 自動unsubscribeのために必要</p>

<p>let array: [Int] = [1, 2, 3, 4, 5]
let variable = Variable(array)
variable.asObservable.subscribe { (event) in</p>

<pre><code>print("Event is \(event)")
</code></pre>

<p>}.addDisposableTo(disposeBag)</p>

<p>variable.value = [6, 7, 8]</p>

<p>// 結果は下記です。
Event is Next([1, 2, 3, 4, 5])
Event is Next([6, 7, 8])
Event is Completed
```</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h4>create</h4>

<p>0から<code>Observable</code>型のデータを生成するためのオペレータです。</p>

<p>```objective-c
let disposeBag = DisposeBag()   // 自動unsubscribeのために必要</p>

<p>let source = Observable.create { (observer: AnyObserver<Int>) &ndash;> Disposable in</p>

<pre><code>observer.onNext(1)
observer.onCompleted()

return AnonymousDisposable {
    print("Disposed")
}
</code></pre>

<p>}</p>

<p>source.subscribeNext { (elem) in</p>

<pre><code>print("Event is \(elem)")
</code></pre>

<p>}.addDisposableTo(disposeBag)</p>

<p>// 結果は下記です
Event is 1
Disposed
```</p>

<h4>deferred</h4>

<p>Subscribeされたタイミングで<code>Observable</code>型のデータを生成するオペレータです。</p>

<p>```objective-c
let disposeBag = DisposeBag()   // 自動unsubscribeのために必要</p>

<p>let source = Observable.deferred { () &ndash;> Observable<Int> in</p>

<pre><code>return Observable.just(1)
</code></pre>

<p>}
source.subscribeNext { (elem) in</p>

<pre><code>print("Elem is \(elem)")
</code></pre>

<p>}.addDisposableTo(disposeBag)</p>

<p>// 結果は下記です
Event is 1
```</p>

<h4>empty</h4>

<p>空の(何の値も持たない)<code>Observable</code>型のデータを生成するオペレータです。<br/>
通常通り、終了処理は実行されます。</p>

<p>```objective-c
let disposeBag = DisposeBag()   // 自動unsubscribeのために必要</p>

<p>let source: Observable<Int> = Observable.empty()
source.subscribeNext { (elem) in</p>

<pre><code>print("Elem is \(elem)")
</code></pre>

<p>}.addDisposableTo(disposeBag)</p>

<p>// 結果は下記です。
// 空のため何も出力されません
```</p>

<h4>never</h4>

<p>空の(何の値も持たない)<code>Observable</code>型のデータを生成するオペレータです。<br/>
<code>empty</code>と異なるのは終了処理が実行されないことです。</p>

<p>```objective-c
let disposeBag = DisposeBag()   // 自動unsubscribeのために必要</p>

<p>let source: Observable<Int> = Observable.never()
source.subscribeNext { (elem) in</p>

<pre><code>print("Elem is \(elem)")
</code></pre>

<p>}.addDisposableTo(disposeBag)</p>

<p>// 結果は下記です。
// 空のため何も出力されません
```</p>

<h4>error</h4>

<p>空の(何の値も持たない)<code>Observable</code>型のデータを生成するオペレータです。<br/>
<code>empty</code>, <code>never</code>と異なり、エラーを持った終了処理を実行します。</p>

<p>```objective-c
let disposeBag = DisposeBag()   // 自動unsubscribeのために必要</p>

<p>let error = NSError(domain: &ldquo;test&rdquo;, code: -1, userInfo: nil)
let source: Observable<Int> = Observable.error(error)
source.subscribeError { (error) in</p>

<pre><code>print("Error is \(error)")
</code></pre>

<p>}.addDisposableTo(disposeBag)</p>

<p>// 結果は下記です。
Error is Error Domain=test Code=-1 &ldquo;(null)&rdquo;
```</p>

<h4>toObservable</h4>

<p>様々なオブジェクトを<code>Observable</code>型のデータに変換するためのオペレータです。<br/>
<code>asObservable</code>とは利用方法が異なります。</p>

<p>```objective-c
let disposeBag = DisposeBag()   // 自動unsubscribeのために必要</p>

<p>let array: [Int] = [1, 2, 3]
array.toObservable().subscribeNext { (elem) in</p>

<pre><code>print("Number is \(elem)")
</code></pre>

<p>}.addDisposableTo(disposeBag)</p>

<p>// 結果は下記です。
Number is 1
Number is 2
Number is 3
```</p>

<h4>interval</h4>

<p>一定期間あけて処理を実行するためのオペレータです。<br/>
<code>JavaScript</code>で言うところの<code>setTimeInterval</code>です。</p>

<p>```objective-c
let disposeBag = DisposeBag()   // 自動unsubscribeのために必要</p>

<p>let timer: Observable<Int> = Observable.interval(5.0, scheduler: MainScheduler.instance)
timer.subscribeNext { (count) in</p>

<pre><code>print("log output")
</code></pre>

<p>}.addDisposableTo(disposeBag)</p>

<p>// 結果は下記です。
// 5秒後に実行されます。
log output
```</p>

<h4>just</h4>

<p>引数に指定した特定の型を返却する<code>Observable</code>型のデータを生成するためのオペレータです。</p>

<p>```objective-c
let disposeBag = DisposeBag()   // 自動unsubscribeのために必要</p>

<p>let source = Observable.just(1)
source.subscribeNext { (elem) in</p>

<pre><code>print("Elem is \(elem)")
</code></pre>

<p>}.addDisposableTo(disposeBag)</p>

<p>// 結果は下記です。
Elem is 1
```</p>

<h4>of</h4>

<p>様々なオブジェクトを<code>Observable</code>型のデータに変換するためのオペレータです。<br/>
<code>asObservable</code>や<code>toObservable</code>とは利用方法が異なります。</p>

<p>```objective-c
let disposeBag = DisposeBag()   // 自動unsubscribeのために必要</p>

<p>let source = Observable.of(1)
source.subscribeNext { (elem) in</p>

<pre><code>print("Elem is \(elem)")
</code></pre>

<p>}.addDisposableTo(disposeBag)</p>

<p>// 結果は下記です。
Elem is 1
```</p>

<h4>range</h4>

<p>特定の範囲の<code>Int</code>型を持つ<code>Observable</code>型データを生成するオペレータです。</p>

<p>```objective-c
let disposeBag = DisposeBag()   // 自動unsubscribeのために必要</p>

<p>let source: Observable<Int> = Observable.range(start: 1, count: 3)
source.subscribeNext { (elem) in</p>

<pre><code>print("Elem is \(elem)")
</code></pre>

<p>}.addDisposableTo(disposeBag)</p>

<p>// 結果は下記です。
Elem is 1
Elem is 2
Elem is 3
```</p>

<h4>repeatElement</h4>

<p>指定した回数、処理を実行するときに利用する<code>Observable</code>型データを生成するオペレータです。<br/>
<code>take</code>メソッドを利用して回数を指定します。</p>

<p>```objective-c
let disposeBag = DisposeBag()   // 自動unsubscribeのために必要</p>

<p>let source = Observable.repeatElement(1).take(3)
source.subscribeNext { (elem) in</p>

<pre><code>print("Elem is \(elem)")
</code></pre>

<p>}.addDisposableTo(disposeBag)</p>

<p>// 結果は下記です。
Elem is 1
Elem is 1
Elem is 1
```</p>

<h4>timer</h4>

<p>一定時間経過後に処理を実行したい場合に利用するオペレータです。<br/>
<code>JavaScript</code>で言うところの<code>setTimeout</code>です。</p>

<p>```objective-c
let timer: Observable<Int> = Observable.timer(5.0, scheduler: MainScheduler.instance)
timer.subscribeNext { (count) in</p>

<pre><code>print("log output")
</code></pre>

<p>}.addDisposableTo(disposeBag)
```</p>

<h3>まとめ</h3>

<p>さて、今回は<code>Creating Observables</code>のみを取り上げさせて頂きましたが、いかがでしたでしょうか？<br/>
筆者もイマイチ使い方がわからなかったオペレータがたくさんあったので、多少なりとも使えそうな気がしてきました。<br/>
<code>Transforming Observables</code>, <code>Filtering Observables</code> &hellip;. と全て見ていけると良いのですが、結構数が多いですね。<br/>
時間があるときに続きを書きたいと思います。</p>

<p>と言ったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RxSwiftを勉強してみよう！(2)]]></title>
    <link href="http://grandbig.github.io/blog/2016/08/29/rxswift-2/"/>
    <updated>2016-08-29T22:40:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2016/08/29/rxswift-2</id>
    <content type="html"><![CDATA[<h3>RxSwiftの公式Exampleを覗いてみる(2)</h3>

<p>前回に引き続きRxSwiftの公式Exampleを見ていきたいと思います。<br/>
公式ソースは<a href="https://github.com/ReactiveX/RxSwift">GitHub: ReactiveX/RxSwift</a>からダウンロードできます。</p>

<h4>GeolocationExample</h4>

<p>位置情報を用いたときのRxの有効性が表現されているのでしょうか？<br/>
早速見ていきましょう。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<p>まずは、<code>CoreLocation</code>のコア部分をラップしている<code>GeolocationService</code>です。</p>

<p>```objective-c
import Foundation
import CoreLocation
import RxSwift
import RxCocoa</p>

<p>class GeolocationService {</p>

<pre><code>static let instance = GeolocationService()
// (1)
private (set) var authorized: Driver&lt;Bool&gt;
private (set) var location: Driver&lt;CLLocationCoordinate2D&gt;

private let locationManager = CLLocationManager()

private init() {
    locationManager.distanceFilter = kCLDistanceFilterNone
    locationManager.desiredAccuracy = kCLLocationAccuracyBestForNavigation

    // (2)
    authorized = Observable.deferred { [weak locationManager] in
        let status = CLLocationManager.authorizationStatus()
        guard let locationManager = locationManager else {
            // (3)
            return Observable.just(status)
        }
        return locationManager
            .rx_didChangeAuthorizationStatus
            .startWith(status) // (4)
        }
        .asDriver(onErrorJustReturn: CLAuthorizationStatus.NotDetermined) // (5)
        .map {
            switch $0 {
                case .AuthorizedAlways:
                    return true
                default:
                    return false
            }
        }
}
</code></pre>

<p>}
```</p>

<p>上記ソースでポイントとなる部分を見ていきます。</p>

<p>(1): <code>Driver</code><br/>
末尾に参考URLとして上げさせて頂いた記事に書かれているのですが、<br/>
<code>Driver</code>型で定義することで、エラー発生時の処理<code>asDriver</code>オペレータで続けて書くことができます。</p>

<p>(2): <code>deferred</code><br/>
ObserverがSubscribe(購読)されたタイミングで動的にObservableを生成します。<br/>
※ 因みに新規ObservableをSubscribeタイミングで毎回生成します。</p>

<p>(3): <code>just</code><br/>
引数に取った特定の型を返却するObservableを生成します。<br/>
この場合は<code>CLAuthorizationStatus</code>型のObservableです。</p>

<p>(4): <code>startWith</code><br/>
想定したemit対象値の前に何らかの値をemitしたい場合に利用します。<br/>
この場合、<code>rx_didChangeAuthoricationStatus</code>をemitする前にということでしょうか。<br/>
(これが恐らく、一番わかりやすい例です → <a href="http://www.introtorx.com/Content/v1.0.10621.0/12_CombiningSequences.html#StartWith">Introduction to Rx: startWith</a>)</p>

<p>(5): <code>asDriver</code><br/>
(1)で説明した<code>Driver</code>に関係するオペレータです。<br/>
エラーが発生した場合に<code>onErrorJustReturn</code>で指定した値を返却して処理を続けます。</p>

<p>続いて、<code>GeolocationService</code>を利用している<code>GeolocationViewController</code>です。</p>

<p>```objective-c
import Foundation
import UIKit
import RxSwift
import RxCocoa</p>

<p>// (6)
private extension UILabel {</p>

<pre><code>var rx_driveCoordinates: AnyObserver&lt;CLLocationCoordinate2D&gt; {
    return UIBindingObserver(UIElement: self) { label, location in
        label.text = "Lat: \(location.latitude)\nLon: \(location.longitude)"
    }.asObserver()
}
</code></pre>

<p>}</p>

<p>// (7)
private extension UIView {</p>

<pre><code>var rx_driveAuthorization: AnyObserver&lt;Bool&gt; {
    return UIBindingObserver(UIElement: self) { view, authorized in
        if authorized {
            view.hidden = true
            view.superview?.sendSubviewToBack(view)
        }
        else {
            view.hidden = false
            view.superview?.bringSubviewToFront(view)
        }
    }.asObserver()
}
</code></pre>

<p>}</p>

<p>class GeolocationViewController: ViewController {</p>

<pre><code>@IBOutlet weak private var noGeolocationView: UIView!
@IBOutlet weak private var button: UIButton!
@IBOutlet weak private var button2: UIButton!
@IBOutlet weak var label: UILabel!

override func viewDidLoad() {
    super.viewDidLoad()

    let geolocationService = GeolocationService.instance

    geolocationService.authorized
        .drive(noGeolocationView.rx_driveAuthorization) // (8)
        .addDisposableTo(disposeBag)

    geolocationService.location
        .drive(label.rx_driveCoordinates) // (8)
        .addDisposableTo(disposeBag)

    button.rx_tap
        .bindNext { [weak self] in
            self?.openAppPreferences()
        }
        .addDisposableTo(disposeBag)

    button2.rx_tap
        .bindNext { [weak self] in
            self?.openAppPreferences()
        }
        .addDisposableTo(disposeBag)
}

private func openAppPreferences() {
    UIApplication.sharedApplication().openURL(NSURL(string: UIApplicationOpenSettingsURLString)!)
}
</code></pre>

<p>}
```</p>

<p>(6): <code>rx_driveCoordinates</code><br/>
見ての通りここで<code>UILabel</code>の<code>extension</code>をしています。<br/>
<code>UILabel</code>の<code>text</code>内容を任意の値で返却するために作成しています。<br/>
(<code>asObserver</code>をつけることで<code>rx_driveCoordinates</code>という<code>AnyObserver</code>型の変数定義を実現しています。)</p>

<p>(7): <code>rx_driveAuthorization</code><br/>
同じく<code>UIView</code>の<code>extension</code>をしています。<br/>
<code>authorized</code>の値でViewの表示/非表示を切り替えています。</p>

<p>(8): <code>drive</code><br/>
ここで新たにSubscriptionを生成して、引数に取ったObserverに処理の実行を要請しています。</p>

<p>今回のExampleを見てみると下記のようなメリットが感じられます。</p>

<ul>
<li>Rxを利用することで非同期処理を直列的に書ける</li>
<li>エラーハンドリングを直列的に書けることで後処理も直列的に統一して見れる(<code>jQuery</code>の<code>ajax</code>メソッドの<code>always</code>的なイメージ)</li>
<li>処理の拡張がRxで用意されたメソッドで比較的に容易に書ける</li>
</ul>


<h3>Rxで把握しておきたいAPI一覧</h3>

<p>RxSwiftをインストールすると中にドキュメントが含まれています。<br/>
<a href="https://github.com/ReactiveX/RxSwift/blob/master/Documentation/API.md">API.md</a>を読むだけでもかなり理解が進むと思われます。</p>

<p>特に言語がSwiftであるが故に他のRxフレームワークとはメソッド名が異なる場合があります。<br/>
(<code>defer</code>でなく<code>deferred</code>、<code>repeat</code>でなく<code>repeatElement</code>など)</p>

<p>一度は目を通しておくと良いかもしれません。<br/>
と言いつつ、筆者も全然見れていませんが&hellip;</p>

<h3>まとめ</h3>

<p>さて、今回は公式Exampleの1つを見るだけに留まりましたが如何でしたでしょうか？<br/>
筆者としてはRxの使い方の理解がだいぶ進んだ気がしております。<br/>
引き続きRxに関する勉強は続けていきたいと思います。<br/>
と言ったところで本日はここまで。</p>

<p>参考:</p>

<ul>
<li><a href="http://qiita.com/yuzushioh/items/0a4483502c5c8569790a">RxSwift/RxCocoa Driver Unitについてまとめてみた。</a></li>
</ul>


<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RxSwiftを勉強してみよう！]]></title>
    <link href="http://grandbig.github.io/blog/2016/08/21/rxswift-1/"/>
    <updated>2016-08-21T18:09:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2016/08/21/rxswift-1</id>
    <content type="html"><![CDATA[<h3>RxSwiftとは</h3>

<p>Reactive Extensions(以下、Rx)のSwift版です。<br/>
と一言で言っても、「Rxとはなんぞや？？」となってしまうかと思います。<br/>
(多分に漏れず、筆者もそうです&hellip;)<br/>
そこで、いろいろと調べてみると、</p>

<ul>
<li>「非同期/イベント/時間に関する処理をLINQの形式で簡潔かつ宣言的に記述すること」ができるのが特徴</li>
<li>観測可能 (observable) なシーケンスと LINQ スタイルのクエリ演算子を使って、非同期なイベントベースのプログラムを合成するライブラリ</li>
</ul>


<p>なんて話が出てきます。<br/>
確かに非同期処理はソースコードが複雑になりやすいので、何となくRxは良さそうな気がしてきました。<br/>
今回はまず触って慣れてみようということで見ていきましょう。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h3>RxSwiftでUI</h3>

<p>まずはRxSwiftの書き方を覚えるためにUI関連から見てきましょう。</p>

<h4>サンプル画面</h4>

<p>下記のように画面を作成します。<br/>
<img src="/images/rxswift_1.png" alt="サンプル画面" /></p>

<h4>RxSwiftのインストール</h4>

<p>下記のように<code>Podfile</code>を作成します。</p>

<p>```objective-c
use_frameworks!</p>

<p>target &lsquo;RxSwiftSample&rsquo; do</p>

<pre><code>pod 'RxSwift',    '~&gt; 2.0'
pod 'RxCocoa',    '~&gt; 2.0'
</code></pre>

<p>end</p>

<p>target &lsquo;RxSwiftSampleTests&rsquo; do</p>

<pre><code>pod 'RxBlocking', '~&gt; 2.0'
pod 'RxTests',    '~&gt; 2.0'
</code></pre>

<p>end</p>

<p>target &lsquo;RxSwiftSampleUITests&rsquo; do</p>

<pre><code>pod 'RxBlocking', '~&gt; 2.0'
pod 'RxTests',    '~&gt; 2.0'
</code></pre>

<p>end
```</p>

<p>そして、<code>pod install</code>を実行します。</p>

<h4>RxSwiftを用いたUIアクションを実装</h4>

<p>下記のようにアクションを実装します。</p>

<p>```objective-c
// ViewController.swift
import UIKit
import RxSwift
import RxCocoa</p>

<p>class ViewController: UIViewController {</p>

<pre><code>// UI部品
@IBOutlet weak var sampleBtn: UIButton!
@IBOutlet weak var sampleTextField: UITextField!
@IBOutlet weak var sampleLabel: UILabel!

// 自動unsubscribeのために必要
let disposeBag = DisposeBag()

override func viewDidLoad() {
    super.viewDidLoad()

    // ボタンタップアクション
    self.sampleBtn.rx_tap.subscribeNext { [unowned self] _ in
        self.showAlert()
    }.addDisposableTo(disposeBag)

    // テキストフィールドの入力アクション
    self.sampleTextField.rx_text
        .map { "Your Text is \($0)" }
        .bindTo(self.sampleTextField.rx_text)
        .addDisposableTo(disposeBag)
}

&lt;省略&gt;

func showAlert() {
    let alert = UIAlertController(title: "Sample Alert", message: "Can you see a sample alert?", preferredStyle: .Alert)
    let ok = UIAlertAction(title: "OK", style: .Default) { (action) in
        // 特に何もしない
    }
    alert.addAction(ok)
    presentViewController(alert, animated: true, completion: nil)
}
</code></pre>

<p>}
```</p>

<p>上記のUIアクションはあまりにも単純な例であるため、恩恵を受けられている気はしないですね&hellip;<br/>
いつものようにXcodeでアクションを繋げているのと同じ気がする&hellip;</p>

<h3>RxSwiftの公式Exampleを覗いてみる</h3>

<p>先ほどの例ではイマイチ良さがわからなかったので、公式のExampleを覗いてみます。<br/>
公式のExampleは<a href="https://github.com/ReactiveX/RxSwift">GitHub: ReactiveX/RxSwift</a>からダウンロードできます。</p>

<h4>NumbersViewController</h4>

<p>最も簡単なExampleはこれになるかと思います。</p>

<p>```objective-c
import Foundation
import UIKit
import RxSwift
import RxCocoa</p>

<p>class NumbersViewController: ViewController {</p>

<pre><code>@IBOutlet weak var number1: UITextField!
@IBOutlet weak var number2: UITextField!
@IBOutlet weak var number3: UITextField!

@IBOutlet weak var result: UILabel!

override func viewDidLoad() {
    super.viewDidLoad()
    // 注目！！
    Observable.combineLatest(number1.rx_text, number2.rx_text, number3.rx_text) { textValue1, textValue2, textValue3 -&gt; Int in
        return (Int(textValue1) ?? 0) + (Int(textValue2) ?? 0) + (Int(textValue3) ?? 0)
    }
    .map { $0.description }
    .bindTo(result.rx_text)
    .addDisposableTo(disposeBag)
}
</code></pre>

<p>}
```</p>

<p>ここで注目したいのは<code>Observable.combineLatest</code>です。<br/>
Exampleではこれを利用して一気に3つの<code>UITextField</code>から値を取得して、合計値を計算しています。<br/>
<code>Obsertvable.combineLatest</code>は名前から察することができると思いますが、3つの<code>UITextField</code>のいずれかの値が変わったタイミングで合計値が再計算されます。</p>

<p>これだけでも少し便利な感じが伝わってきました。</p>

<h4>SimpleValidationViewController</h4>

<p>続いて着手しやすいExampleはこちらになりそうです。</p>

<p>```objective-c
import Foundation
import UIKit
import RxSwift
import RxCocoa</p>

<p>let minimalUsernameLength = 5
let minimalPasswordLength = 5</p>

<p>class SimpleValidationViewController : ViewController {</p>

<pre><code>@IBOutlet weak var usernameOutlet: UITextField!
@IBOutlet weak var usernameValidOutlet: UILabel!
@IBOutlet weak var passwordOutlet: UITextField!
@IBOutlet weak var passwordValidOutlet: UILabel!
@IBOutlet weak var doSomethingOutlet: UIButton!

override func viewDidLoad() {
    super.viewDidLoad()

    usernameValidOutlet.text = "Username has to be at least \(minimalUsernameLength) characters"
    passwordValidOutlet.text = "Password has to be at least \(minimalPasswordLength) characters"

    // 注目！！
    let usernameValid = usernameOutlet.rx_text
        .map { $0.characters.count &gt;= minimalUsernameLength }
        .shareReplay(1)

    let passwordValid = passwordOutlet.rx_text
        .map { $0.characters.count &gt;= minimalPasswordLength }
        .shareReplay(1)

    let everythingValid = Observable.combineLatest(usernameValid, passwordValid) { $0 &amp;&amp; $1 }
        .shareReplay(1)

    usernameValid
        .bindTo(passwordOutlet.rx_enabled)
        .addDisposableTo(disposeBag)

    usernameValid
        .bindTo(usernameValidOutlet.rx_hidden)
        .addDisposableTo(disposeBag)

    passwordValid
        .bindTo(passwordValidOutlet.rx_hidden)
        .addDisposableTo(disposeBag)

    everythingValid
        .bindTo(doSomethingOutlet.rx_enabled)
        .addDisposableTo(disposeBag)

    doSomethingOutlet.rx_tap
        .subscribeNext { [weak self] in self?.showAlert() }
        .addDisposableTo(disposeBag)
}

func showAlert() {
    let alertView = UIAlertView(
        title: "RxExample",
        message: "This is wonderful",
        delegate: nil,
        cancelButtonTitle: "OK"
    )

    alertView.show()
}
</code></pre>

<p>}
```</p>

<p>ここで注目したいのは<code>shareReplay(1)</code>という記述です。<br/>
このExampleでは、<br/>
<code>username</code>のバリデーションをクリアしていれば、<code>passwordOutlet.rx_enabled</code>と<code>usernameValidOutlet.rx_hidden</code>の2つを実行するように実装されています。</p>

<p>通常だと、<code>usernameValid</code>が2回実行されてしまうところを<code>shareReplay(1)</code>をつけることで、最適な回数だけ実行してくれます。<br/>
詳しくは、<a href="http://qiita.com/kazu0620/items/bde4a65e82a10bd33f88">hareReplayをちゃんと書いてお行儀良くストリームを購読しよう</a>を読むと良いでしょう。</p>

<p>ここまで来ると<code>RxSwift</code>の有効性を許容せざるを得ませんね。</p>

<h3>まとめ</h3>

<p>今回簡単に触っただけでも、Rxはかなり有効なものであると感じました。<br/>
非同期処理や互いに関連性を持つ複雑な処理を実装する際にはぜひRxを使ってみたいと思いました。</p>

<p>本当はもっとExampleを追っていきたいのですが、一旦ここまでとさせて頂きます。<br/>
(単なる時間切れなので、続きは必ず書きたいを思っています。)</p>

<p>ということで本日はここまで。</p>

<p>参考:</p>

<ul>
<li><a href="https://github.com/ReactiveX/RxSwift">GitHub: ReactiveX/RxSwift</a></li>
<li><a href="http://qiita.com/nakailand/items/8b54dc9b4b39b0809c57">RxSwiftの道標</a></li>
<li><a href="http://qiita.com/usamik26/items/2bbd0b8d304ab42b2279">RxSwift で UIKit を扱う基本</a></li>
<li><a href="http://okapies.hateblo.jp/entry/2015/03/04/031148">関数型プログラマのための Rx 入門（前編）</a></li>
</ul>


<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
</feed>
