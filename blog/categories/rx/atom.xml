<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: rx | Takahiro Octopress Blog]]></title>
  <link href="http://grandbig.github.io/blog/categories/rx/atom.xml" rel="self"/>
  <link href="http://grandbig.github.io/"/>
  <updated>2019-01-25T17:06:02+09:00</updated>
  <id>http://grandbig.github.io/</id>
  <author>
    <name><![CDATA[Takahiro]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[This is a feature to warn you that there is already a delegate の対応 ~ RxSwiftでUITableViewのリロード時にクラッシュする問題にぶつかった ~]]></title>
    <link href="http://grandbig.github.io/blog/2018/12/30/rx-uitableview-crash/"/>
    <updated>2018-12-30T04:11:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2018/12/30/rx-uitableview-crash</id>
    <content type="html"><![CDATA[<h3>はじめに</h3>

<p>今回は表題にあるクラッシュ問題についてのメモです。<br/>
単純な話だったけど、しばらくハマってました笑</p>

<p>取り組んでいた内容としてはシンプルで、</p>

<ul>
<li><code>RxSwift</code> を利用していた</li>
<li><code>RxDataSources</code> を利用しようとした</li>
<li><code>UITableView</code> の <code>Cell</code> 削除アクションを <code>Rx</code> っぽく書きたかった</li>
</ul>


<p>というものです。</p>

<p><code>UITableView</code> の初期描画はうまくいくものの、 <code>Cell</code> 削除アクションを実行するとクラッシュしていました。</p>

<p>では早速内容について見ていきましょう。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h3>クラッシュの内容</h3>

<p>どんなクラッシュが発生していたかというと</p>

<p><code>objective-c
This is a feature to warn you that there is already a delegate (or data source) set somewhere previously.
The action you are trying to perform will clear that delegate (data source) and that means that some of your features
that depend on that delegate (data source) being set will likely stop working.\n
</code></p>

<p>といったものが出ていました。</p>

<p>この内容でググってみると&hellip;</p>

<ul>
<li><a href="https://github.com/ReactiveX/RxSwift/issues/675">Maybe delegate was already set in <code>xib</code> or <code>storyboard</code> and now it&rsquo;s being overwritten in code.</a></li>
<li><a href="https://github.com/RxSwiftCommunity/RxDataSources/issues/185">How to change datasource and rebind to tableview</a></li>
<li><a href="https://github.com/ReactiveX/RxSwift/issues/706">Assertion failure in DelegateProxyType</a></li>
</ul>


<p>といった形でたびたび本家の <code>RxSwift</code> で意見交換されていました。</p>

<p>上記内で言われていることは、</p>

<p><code>
tableView.delegate = nil
tableView.dataSource = nil
</code></p>

<p>を書けば解決するよって話だったりしました。<br/>
筆者的には、 <code>xib</code> で <code>delegate</code> や <code>dataSource</code> の設定などしていなかったので、半信半疑ながら上記をコードに記載して試していました。</p>

<p>が解決されず&hellip;</p>

<h3>解決方法</h3>

<p>では、一体どうやって解決したかというと、<br/>
クラッシュの内容とは全く関係のない部分の話でした&hellip;</p>

<p>筆者は <code>MVVM</code> アーキテクチャでプロジェクトを構成しており、<br/>
下記のように <code>ViewModel</code> を定義していました。</p>

<p>```objective-c
// ViewModel.swift
import Foundation
import RxSwift
import RxCocoa</p>

<p>final class MainViewModel: Injectable {</p>

<pre><code>struct Dependency {
}

// MARK: - Properties
private let disposeBag = DisposeBag()
private var sectionModels: [SectionModel]!

// MARK: PublishRelays
let requestDeleteRecordStream = PublishRelay&lt;IndexPath&gt;()

// MARK: BehaviorRelays
var dataRelay = BehaviorRelay&lt;[SectionModel]&gt;(value: [])

// MARK: Initial method
init(with dependency: Dependency) {

    sectionModels = [SectionModel(items: [("test1", 1), ("test2", 2), ("test3", 3)])]

    Observable.deferred {() -&gt; Observable&lt;[SectionModel]&gt; in
        return Observable.just(self.sectionModels)
        }
        .bind(to: dataRelay)
        .disposed(by: disposeBag)

    requestDeleteRecordStream
        .subscribe(onNext: { [weak self] indexPath in
            guard let strongSelf = self, let sectionModel = strongSelf.sectionModels.first else { return }
            var items = sectionModel.items
            items.remove(at: indexPath.row)
            strongSelf.sectionModels = [SectionModel(items: items)]
            strongSelf.dataRelay.accept(strongSelf.sectionModels)
        })
        .disposed(by: disposeBag)
}
</code></pre>

<p>}
```</p>

<p>続いて、 <code>View</code> の方では下記のように、 <code>Cell</code> が削除された場合を捕捉するようにしていました。</p>

<p>```objective-c
// View
import UIKit
import RxSwift
import RxCocoa
import RxDataSources</p>

<p>class MainViewController: UIViewController, Injectable {</p>

<pre><code>typealias Dependency = MainViewModel

@IBOutlet private weak var tableView: UITableView!

private let disposeBag = DisposeBag()
private var dataSource: RxTableViewSectionedReloadDataSource&lt;SectionModel&gt;!
private let viewModel: MainViewModel

required init(with dependency: Dependency) {
    viewModel = dependency
    super.init(nibName: nil, bundle: nil)
}

@available(*, unavailable)
required init?(coder aDecoder: NSCoder) {
    fatalError("init(coder:) has not been implemented")
}

override func viewDidLoad() {
    super.viewDidLoad()

    // Do any additional setup after loading the view.
    tableView.register(CustomTableViewCell.self, forCellReuseIdentifier: "Cell")

    dataSource = RxTableViewSectionedReloadDataSource&lt;SectionModel&gt;(
        configureCell: { _, tableView, indexPath, item in
            let cell = tableView.dequeueReusableCell(withIdentifier: "Cell",
                                                     for: IndexPath(row: indexPath.row, section: 0))
            cell.textLabel?.text = item.0
            cell.accessoryType = .disclosureIndicator

            return cell
    }, canEditRowAtIndexPath: { _, _ in
        return true
    })

    //////// ↓問題はココ /////////////////////////////////////////////////////////////////////
    viewModel.dataRelay
        .subscribe(onNext: { [weak self] records in
            guard let strongSelf = self, let items = records.first?.items else { return }
            let data = [SectionModel(items: items)]
            Observable.just(data)
                .bind(to: strongSelf.tableView.rx.items(dataSource: strongSelf.dataSource))
                .disposed(by: strongSelf.disposeBag)
        }.disposed(by: strongSelf.disposeBag)
    })
    //////// ↑問題はココ /////////////////////////////////////////////////////////////////////

    tableView.rx.itemDeleted
        .subscribe(onNext: { [weak self] indexPath in
            guard let strongSelf = self else { return }
            Observable.just(indexPath)
                .bind(to: strongSelf.viewModel.requestDeleteRecordStream)
                .disposed(by: strongSelf.disposeBag)
        })
        .disposed(by: disposeBag)
}
</code></pre>

<p>}
```</p>

<p>上記の <strong>問題はココ</strong> と書かれているところが間違っていました。<br/>
<code>ViewModel</code> 側で既に <code>SectionModel</code> としてデータを作成しているので、<br/>
<code>ViewController</code> 側では単に <code>tableView.rx.items</code> に流せば良かったのです。</p>

<p>それを改めて <code>SectionModel</code> の形に整形し直そうとしてしまっていました。<br/>
そして再度 <code>Observable</code> を生成して <code>tableView.rx.items</code> に流し込んでいました。</p>

<p>この問題の部分を下記のように修正したところクラッシュすることがなくなりました。</p>

<p>```objective-c
viewModel.dataRelay</p>

<pre><code>.asObservable()
.bind(to: tableView.rx.items(dataSource: dataSource))
.disposed(by: disposeBag)
</code></pre>

<p>```</p>

<h3>まとめ</h3>

<p>クラッシュ内容にだいぶ惑わされましたが、<br/>
どうしてもわからない時は簡単なサンプルを作って試してみるのが良いなと改めて思いました。</p>

<p>ということで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RxDataSourcesを使ってみよう！]]></title>
    <link href="http://grandbig.github.io/blog/2018/12/28/rxdatasources/"/>
    <updated>2018-12-28T18:41:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2018/12/28/rxdatasources</id>
    <content type="html"><![CDATA[<h3>はじめに</h3>

<p>さて今回は <a href="https://github.com/RxSwiftCommunity/RxDataSources">RxDataSources</a> の使い方について見ていきたいと思います。</p>

<p><code>RxDataSources</code> を利用することで、<br/>
<code>Cell</code> の選択/移動/削除などの扱いが書きやすくなるとのことのようです。</p>

<p>では早速見ていきましょう。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h3>今回利用するライブラリをインストール</h3>

<p>まずは、今回の紹介サンプルで利用するライブラリのインストールから始めましょう。<br/>
<code>CocoaPods</code> を使いますので、下記のように <code>Podfile</code> を作成します。</p>

<p>```objective-c</p>

<h1>Podfile</h1>

<p>platform :ios, &ldquo;11.0&rdquo;
use_frameworks!</p>

<p>target &ldquo;RxDataSourcesSample&rdquo; do</p>

<pre><code>pod 'RxSwift',    '~&gt; 4.0'
</code></pre>

<p>  pod &lsquo;RxCocoa&rsquo;,    &lsquo;~> 4.0&rsquo;
  pod &lsquo;RxDataSources&rsquo;, &lsquo;~> 3.0&rsquo;
end</p>

<p>target &ldquo;RxDataSourcesSampleTests&rdquo; do</p>

<pre><code>pod 'RealmSwift'
pod 'RxBlocking', '~&gt; 4.0'
</code></pre>

<p>  pod &lsquo;RxTest&rsquo;,     &lsquo;~> 4.0&rsquo;
end</p>

<p>target &ldquo;RxDataSourcesSampleUITests&rdquo; do</p>

<pre><code>pod 'RealmSwift'
pod 'RxBlocking', '~&gt; 4.0'
</code></pre>

<p>  pod &lsquo;RxTest&rsquo;,     &lsquo;~> 4.0&rsquo;
end
```</p>

<h3>RxDataSourcesを利用したサンプル</h3>

<p>準備ができたので、実際に <code>ViewController</code> にサンプルを書いてみましょう。</p>

<h4>プロジェクト構成</h4>

<p>因みに、今回のプロジェクト構成は下記のようになっています。</p>

<p><code>objective-c
RxDataSourcesSample
  ├── Model
  │    └── SectionModel
  ├── AppDelegate.swift
  ├── ViewController.swift
  ├── Main.storyboard
  ...
</code></p>

<h4>SectionModelの実装</h4>

<p>Model配下に配置した <code>SectionModel</code> を実装します。<br/>
これは <code>RxDataSources</code> を利用するにあたって根幹をなす <code>Model</code> となるため非常に重要です。</p>

<p>```objective-c
// SectionModel.swift
import RxDataSources</p>

<p>struct SectionModel {</p>

<pre><code>var items: [Item]
</code></pre>

<p>}
extension SectionModel: SectionModelType {</p>

<pre><code>typealias Item = (String, Int)

init(original: SectionModel, items: [Item]) {
    self = original
    self.items = items
}
</code></pre>

<p>}
```</p>

<p>今回のサンプルでは <code>Header</code> は特にセットしないため、 <code>cell</code> 内に表示するデータを持つために <code>items</code> のみ定義します。<br/>
<code>SectionModel</code> は <code>struct</code> (構造体)で定義をし、<code>SectionModelType</code> を継承させます。</p>

<p><code>SectionModelType</code> の中身を覗いてみると非常にシンプルな作りになっています。</p>

<p>```objective-c
import Foundation</p>

<p>public protocol SectionModelType {</p>

<pre><code>associatedtype Item

var items: [Item] { get }

init(original: Self, items: [Item])
</code></pre>

<p>}
```</p>

<h3>Storyboardの実装</h3>

<p><code>Main.storyboard</code> は下図のように実装します。</p>

<p><img src="/images/rxdatasources.png" alt="Main.storyboardの実装" /></p>

<h3>ViewControllerの実装</h3>

<p>準備が整ったので <code>ViewController</code> を実装していきましょう。</p>

<p>```objective-c
import UIKit
import RxSwift
import RxCocoa
import RxDataSources</p>

<p>class ViewController: UIViewController {</p>

<pre><code>// MARK: - IBOutlets
@IBOutlet private weak var tableView: UITableView!

// MARK: - Properties
private let disposeBag = DisposeBag()

// dataSourceをRxDataSourcesを利用して定義する
private var dataSource: RxTableViewSectionedReloadDataSource&lt;SectionModel&gt;!

// cellに設定するデータを保持する
private var sectionModels: [SectionModel]!

// cellに表示するデータの変更を検知して、dataSourceに知らせる
private var dataRelay = BehaviorRelay&lt;[SectionModel]&gt;(value: [])

// MARK: - Lifecycle methods
override func viewDidLoad() {
    super.viewDidLoad()

    // Cellに設定するデータを格納
    sectionModels = [SectionModel(items: [("test1", 1), ("test2", 2), ("test3", 3)])]

    // RxDataSourcesを利用してCellを描画
    dataSource = RxTableViewSectionedReloadDataSource&lt;SectionModel&gt;(
        configureCell: { _, tableView, indexPath, item in
            // 引数名通り、与えられたデータを利用してcellを生成する
            let cell = tableView.dequeueReusableCell(withIdentifier: "Cell",
                                                     for: IndexPath(row: indexPath.row, section: 0))
            cell.textLabel?.text = item.0
            cell.accessoryType = .disclosureIndicator

            return cell
    }, canEditRowAtIndexPath: { _, _ in
        // この引数を設定しないと、Cellの削除アクションができない
        return true
    })

    // dataRelayの変更をキャッチしてdataSourceにデータを流す
    dataRelay.asObservable()
        .bind(to: tableView.rx.items(dataSource: dataSource))
        .disposed(by: disposeBag)

    // Cellを削除した場合にバインディングされる処理
    tableView.rx.itemDeleted
        .subscribe(onNext: { [weak self] indexPath in
            guard let strongSelf = self, let sectionModel = strongSelf.sectionModels.first else { return }
            var items = sectionModel.items
            items.remove(at: indexPath.row)

                            strongSelf.sectionModels = [SectionModel(items: items)]
            // dataRelayにデータを流し込む
            strongSelf.dataRelay.accept(strongSelf.sectionModels)
        })
        .disposed(by: disposeBag)

    // 初期表示用のデータフェッチ
    fetch()
}
</code></pre>

<p>}</p>

<p>// MARK: &ndash; Private methods
extension ViewController {</p>

<pre><code>// 初期表示用のデータフェッチする処理
private func fetch() {
    // sectionModelsを利用して
    Observable.just(sectionModels)
        .subscribe(onNext: { [weak self] _ in
            guard let strongSelf = self else { return }

            // dataRelayにデータを流し込む
            strongSelf.dataRelay.accept(strongSelf.sectionModels)
        })
        .disposed(by: disposeBag)
}
</code></pre>

<p>}
```</p>

<p>因みに <code>Cell</code> を削除した場合に <code>deleteRow</code> を実行する必要はありません。<br/>
理由は、 <code>RxTableViewSectionedReloadDataSource</code> を利用すると <code>reloadData</code> が実行されるようになっているためです。</p>

<p>```objective-c
// RxTableViewSectionedReloadDataSource.swift</p>

<h1>if os(iOS) || os(tvOS)</h1>

<p>import Foundation
import UIKit</p>

<h1>if !RX_NO_MODULE</h1>

<p>import RxSwift
import RxCocoa</p>

<h1>endif</h1>

<p>import Differentiator</p>

<p>open class RxTableViewSectionedReloadDataSource&lt;S: SectionModelType></p>

<pre><code>: TableViewSectionedDataSource&lt;S&gt;
, RxTableViewDataSourceType {
public typealias Element = [S]

open func tableView(_ tableView: UITableView, observedEvent: Event&lt;Element&gt;) {
    Binder(self) { dataSource, element in
        #if DEBUG
            self._dataSourceBound = true
        #endif
        dataSource.setSections(element)
        tableView.reloadData()  --&gt; reloadDataを実行するようになっている
    }.on(observedEvent)
}
</code></pre>

<p>}</p>

<h1>endif</h1>

<p>```</p>

<h3>MVVMで実装してみよう</h3>

<p>おまけとして、 <code>MVVM</code> での実装例も載せておきます。</p>

<h4>プロジェクト構成</h4>

<p>プロジェクト構成は下図の通りです。</p>

<p>```objective-c
RxDataSourcesSample
  ├── Protocol</p>

<pre><code>│    └── Injectable.swift
</code></pre>

<p>  ├── Model
  │    └── SectionModel</p>

<pre><code>├── ViewModel
</code></pre>

<p>  │    └── MainViewModel</p>

<pre><code>├── View
│    ├── Parts
│    │    ├── CustomTableViewCell.swift
│    │    └── CustomTableViewCell.xib
</code></pre>

<p>  │    ├── MainViewController.swift</p>

<pre><code>│    └── MainViewController.xib
</code></pre>

<p>  ├── AppDelegate.swift
  &hellip;
```</p>

<h4>Viewの実装</h4>

<p>今回、 <code>MVVM</code> で実装するに辺り、 <code>storyboard</code> から <code>xib</code> に変更しました。<br/>
下図の通り単純に <code>xib</code> で <code>UITableView</code> を載せているだけです。</p>

<p><img src="/images/rxdatasources_2.png" alt="xibにUITableViewを載せる" /></p>

<p>また、 <code>xib</code> で <code>UITableViewCell</code> を用意します。</p>

<p><img src="/images/rxdatasources_3.png" alt="xibでCustomTableViewCellを用意" /></p>

<p><code>MVVM</code> で構成するために、 <code>Injectable</code> を定義します。</p>

<p>```objective-c
// Injectable.swift
protocol Injectable {</p>

<pre><code>associatedtype Dependency
init(with dependency: Dependency)
</code></pre>

<p>}</p>

<p>extension Injectable where Dependency == Void {</p>

<pre><code>init() {
    self.init(with: ())
}
</code></pre>

<p>}
```</p>

<p>そして <code>MainViewController.swift</code> の実装です。<br/>
一部の処理を <code>ViewModel</code> に移行しているだけで、ほぼ変更はありません。</p>

<p>```objective-c
// MainViewController.swift</p>

<p>import UIKit
import RxSwift
import RxCocoa
import RxDataSources</p>

<p>// Injectableを継承
class MainViewController: UIViewController, Injectable {</p>

<pre><code>typealias Dependency = MainViewModel

@IBOutlet private weak var tableView: UITableView!

private let disposeBag = DisposeBag()
private var dataSource: RxTableViewSectionedReloadDataSource&lt;SectionModel&gt;!
private let viewModel: MainViewModel

    // 初期化時にViewModelを設定できるようにする
required init(with dependency: Dependency) {
    viewModel = dependency
    super.init(nibName: nil, bundle: nil)
}

@available(*, unavailable)
required init?(coder aDecoder: NSCoder) {
    fatalError("init(coder:) has not been implemented")
}

override func viewDidLoad() {
    super.viewDidLoad()

    // Do any additional setup after loading the view.
    tableView.register(CustomTableViewCell.self, forCellReuseIdentifier: "Cell")

    dataSource = RxTableViewSectionedReloadDataSource&lt;SectionModel&gt;(
        configureCell: { _, tableView, indexPath, item in
            let cell = tableView.dequeueReusableCell(withIdentifier: "Cell",
                                                     for: IndexPath(row: indexPath.row, section: 0))
            cell.textLabel?.text = item.0
            cell.accessoryType = .disclosureIndicator

            return cell
    }, canEditRowAtIndexPath: { _, _ in
        return true
    })

    viewModel.dataRelay.asObservable()
        .bind(to: tableView.rx.items(dataSource: dataSource))
        .disposed(by: disposeBag)

    tableView.rx.itemDeleted
        .subscribe(onNext: { [weak self] indexPath in
            guard let strongSelf = self else { return }

            // ViewModelにテーブルビューの行を削除操作を伝える
            Observable.just(indexPath)
                .bind(to: strongSelf.viewModel.requestDeleteRecordStream)
                .disposed(by: strongSelf.disposeBag)
        })
        .disposed(by: disposeBag)
}
</code></pre>

<p>}
```</p>

<h4>ViewModelの実装</h4>

<p>さて、 <code>ViewModel</code> の実装です。</p>

<p>```objective-c
// MainViewModel.swift
import Foundation
import RxSwift
import RxCocoa</p>

<p>// Injectableを継承
final class MainViewModel: Injectable {</p>

<pre><code>struct Dependency {
}

// MARK: - Properties
private let disposeBag = DisposeBag()
private var sectionModels: [SectionModel]!

// MARK: PublishRelays
let requestDeleteRecordStream = PublishRelay&lt;IndexPath&gt;()

// MARK: BehaviorRelays
var dataRelay = BehaviorRelay&lt;[SectionModel]&gt;(value: [])

// MARK: Initial method
init(with dependency: Dependency) {

    sectionModels = [SectionModel(items: [("test1", 1), ("test2", 2), ("test3", 3)])]

    // 画面初期描画時に初期設定のsectionModelsを渡す
    Observable.deferred {() -&gt; Observable&lt;[SectionModel]&gt; in
        return Observable.just(self.sectionModels)
        }
        .bind(to: dataRelay)    // dataRelayにデータを流し込む
        .disposed(by: disposeBag)

    requestDeleteRecordStream
        .subscribe(onNext: { [weak self] indexPath in
            guard let strongSelf = self, let sectionModel = strongSelf.sectionModels.first else { return }
            var items = sectionModel.items
            items.remove(at: indexPath.row)
            strongSelf.sectionModels = [SectionModel(items: items)]

            // dataRelayにデータを流し込む
            strongSelf.dataRelay.accept(strongSelf.sectionModels)
        })
        .disposed(by: disposeBag)
}
</code></pre>

<p>}
```</p>

<h3>まとめ</h3>

<p>さて如何でしたでしょうか？<br/>
書き方さえ慣れてしまえば案外簡単に利用できそうですよね。</p>

<p>ということで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[5年前に初めて個人開発したアプリを再構築している話]]></title>
    <link href="http://grandbig.github.io/blog/2018/12/12/personal-develop-footstepmeter/"/>
    <updated>2018-12-12T00:00:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2018/12/12/personal-develop-footstepmeter</id>
    <content type="html"><![CDATA[<h3>はじめに</h3>

<p>今年もやってきましたAdvent Calendarの季節！<br/>
こちらは<a href="https://qiita.com/advent-calendar/2018/private-developmen2">個人開発 #2 Advent Calendar 2018</a>の12日目の記事です。</p>

<p>今年は、5年前に初めて個人開発したアプリを再構築している話を思い出を交えながら書こうと思います。<br/>
とは言え、絶賛再構築中なので、恐らく本記事公開日までに作り終わらないと思うのですが、それも一興ということで大目に見て頂ければと思います。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h3>5年前になぜ個人開発をしようと思ったのか</h3>

<p>まずは筆者がなぜ個人開発を始めようと思ったのかについて話したいと思います。<br/>
当時の筆者の状況やスキルを思い出してみます。</p>

<h4>状況</h4>

<ul>
<li>社会人3年目</li>
<li>当然、役職も重い責任も何もないぺーぺー</li>
<li>プロジェクトを1〜2個経験(内の1つは大炎上を経験)</li>
</ul>


<h4>スキル</h4>

<ul>
<li><code>HTML5, CSS3, jQuery</code>を利用したWEBフロントエンドの開発</li>
<li><code>iOS, Android</code>アプリの開発</li>
<li><code>Node.js, MongoDB</code>を用いたサーバサイドの開発</li>
</ul>


<h4>状況とスキルを見た振り返り</h4>

<p>一見、スキルを見ると凄そうに見えるかもしれませんが、<br/>
<code>iOS, Android</code>アプリの中身は<code>WebView</code>を利用しており、ネイティブコードは位置情報の取得やプッシュ通知などのごく一部でした。</p>

<p>また、当時、非常に新しかった<code>Node.js</code>や<code>MongoDB</code>も訳が分からず利用しており、<br/>
その知識やスキル不足からプロジェクトを大炎上させてしまいました。</p>

<p>その時に学んだ重要なことは、</p>

<ul>
<li>メモリ消費を考えて、何でもかんでも <code>DB</code> からデータを引っ張ってくるのは辞めよう</li>
<li>CPU消費を考えて、大量データを永遠と<code>for</code>ループ回すのは辞めよう</li>
</ul>


<p>といったエンジニアとしては『当たり前 &amp; これができなかったらごめんなさいで済まされないレベル』の話でした。</p>

<h4>個人開発を始めた理由</h4>

<p>そんな状態の私がなぜ個人開発を始めたのかというと&hellip;</p>

<ol>
<li>技術的な強みを1つ持ちたかった</li>
<li>エンジニアとしての将来が不安で悶々としていた</li>
</ol>


<p>という2つが大きな理由です。</p>

<p>理由2を満たすために、手始めに技術ブログを開設したのですが、<br/>
『どうせなら理由1も満たしたい！』という想いから、<br/>
当時最も興味のあった <code>iOS</code> アプリの開発を勉強しながら始めることにしました。<br/>
※ <code>iOS</code> ネイティブアプリの開発ができるようになるというのが当面の目標でした。<br/>
( <code>WebView</code>ではなく、ネイティブアプリの開発です。 )</p>

<h3>足跡計について</h3>

<p>初めのうちは基本的なXcodeの使い方などを試してブログに書いたりしていたのですが、<br/>
折角なので、1つアプリを完成させて世にリリースしたいという想いが強くなりました。<br/>
そうして完成した個人開発の第一段階アプリが『<a href="https://itunes.apple.com/jp/app/%E8%B6%B3%E8%B7%A1%E8%A8%88/id725412788?mt=8">足跡計</a>』です。</p>

<h4>足跡計の機能</h4>

<p>このアプリには、次のような機能を持たせました。</p>

<ul>
<li>様々な精度で歩行ルートを記録可能</li>
<li>複数の歩行ルートを記録可能</li>
<li>歩行ルート履歴をいつでも閲覧可能</li>
<li>歩行ルート記録をメールで送信可能</li>
<li>不要になった歩行ルート記録は削除可能</li>
</ul>


<p>このアプリを開発しようと思った理由は、<br/>
当時、業務にて位置情報を扱ったアプリ内 <code>WebView</code> のアプリを開発・運用しており、<br/>
位置情報機能は私にとって非常に扱いやすかったためです。</p>

<p>【足跡計のスクリーンショット】<br/>
<img src="/images/personal_development_footprintmeter_1.png" alt="足跡計のスクリーンショット" /></p>

<h4>今回再構築をしようと思った理由</h4>

<p>さて、ここまでは5年前の個人でのアプリ開発に至るまでの話をしてきました。<br/>
ここからが本題で、今回、筆者は思い切って、足跡計アプリを再構築しようと考えました。</p>

<p>その理由は、</p>

<ol>
<li>iPhoneXの画面にアプリが対応できておらず、格好悪い(上下の黒帯の幅が長い)</li>
<li>ホームアイコンとアプリ画面の色合いを統一させたい</li>
<li><code>MVVM</code> アーキテクチャを用いたアプリ開発を試したい</li>
</ol>


<p>という3つの想いがあったためです。</p>

<p>特に『3』に関しては、<br/>
筆者が業務で昨年から今年の春先にかけて <code>Clean Swift</code> アーキテクチャでのiOSアプリ開発に挑戦し、改めてiOSアプリのアーキテクチャのあり方に悩んだことが元となっています。</p>

<p>具体的に悩んだ内容に関しては後日別途書こうと思いますが、<br/>
上記経緯より、現在最も頻繁に採用されているであろう <a href="https://github.com/ReactiveX/RxSwift">RxSwift</a> を用いた <code>MVVM</code> アーキテクチャ設計をきちんと勉強しておきたいと思わずにはいられなかったのです。</p>

<p>では、前段はここまでとして、ここから先は、</p>

<ul>
<li>どのように設計を変更したのか(プロジェクト構成の話)</li>
<li><code>RxSwift</code> を用いた <code>MVVM</code> アーキテクチャで構成されたメインロジックの説明</li>
<li>その上で躓いたこと / ハマったこと</li>
</ul>


<p>を中心に説明し、最後に今後の展望とリリース時期を説明して終了にしたいと思います。</p>

<h3>足跡計の再構築について</h3>

<p>では、再構築について一つずつ説明してきましょう。</p>

<h4>プロジェクト構成の変更</h4>

<p>まずはアーキテクチャの変更によって生じたプロジェクト構成の変更について説明します。<br/>
これまでは <code>MVC</code> アーキテクチャを採用していたため、下記のようなプロジェクト構成になっていました。</p>

<p><code>objective-c
// 再構築前のMVCアーキテクチャでのプロジェクト構成
footStepMeter
├── Enum
│    └── LocationAccuracy.swift
├── Model
│    ├── CustomAnnotation.swift
│    ├── Footprint.swift
│    ├── FootprintManager.swift
│    ├── Location.swift
│    └── UIImage+Extension.swift
├── View
│    └── PickerView.swift
├── Main.storyboard
├── AppDelegate.swift
├── ViewController.swift
├── SettingViewController.swift
...
</code></p>

<p>一応、フォルダ分けして責務を見やすくしようとした形跡がありますが、<br/>
下記観点が全然ダメだなと今振り返って思います。</p>

<ul>
<li><code>Model</code> の責務がカオスになりかけている

<ul>
<li><code>UIImage+Extension</code> は <code>Model</code> 配下でなくても良いはず</li>
</ul>
</li>
<li><code>ViewController</code> がフォルダ分けされておらず、ただ並んでいる

<ul>
<li>今後、画面が増えてきた時に <code>ViewController</code> も増えるので視認性が悪くなる</li>
</ul>
</li>
</ul>


<p>今回は、 <code>MVVM</code> アーキテクチャを採用し、プロジェクト構成も見直しています。</p>

<p><code>objective-c
footStepMeter
├── Enum
│    ├── AlertActionType.swift
│    ├── LocationAccuracy.swift
│    └── TabBarItemTag.swift
├── Model
│    ├── CustomAnnotation.swift
│    ├── Footprint.swift
│    └── RealmManager.swift
├── View
│    ├── Parts
│    │    ├── CustomTableViewCell
│    │    └── PickerView
│    ├── Map
│    │    ├── MapViewController.swift
│    │    └── MapViewController.xib
│    ├── Setting
│    ...
├── ViewModel
│    ├── MapViewModel.swift
│    ├── SettingViewModel.swift
│    ...
├── Protocol
│    └── Injectable.swift
├── Extensions
│    ├── UIImage+Extension.swift
│    ├── UIViewController+Rx.swift
│    ...
├── AppDelegate.swift
...
</code></p>

<p>変更点としては、</p>

<ul>
<li><code>MVVM</code> なので、 <code>View</code> / <code>Model</code> / <code>ViewModel</code> フォルダを作る</li>
<li><code>Extension</code> 系は <code>Extensions</code> フォルダを作ってまとめる</li>
<li>疎結合の肝となる <code>Protocol</code> も専用に <code>Protocol</code> フォルダを作る</li>
<li><code>Storyboard</code> を廃止し、 <code>xib</code> を採用</li>
</ul>


<p>となります。<br/>
設計思想的な面で変更している部分はあるものの、以前に比べれば視認性は上がったと思っています。<br/>
(もう少し改善の余地はあるなと思いつつ&hellip;)</p>

<h4>RxSwiftを用いたMVVMアーキテクチャでの構成</h4>

<p>続いて、 <code>RxSwift</code> を用いた <code>MVVM</code> アーキテクチャで具体的に何をどのように書いているのか紹介したいと思います。<br/>
全ては紹介しきれないため、メイン画面であるマップ画面を元に一部を説明したいと思います。</p>

<h5>マップ画面の機能</h5>

<p>具体的にスクショを交えながら、機能を紹介します。</p>

<p><img src="/images/personal_development_footprintmeter_2.png" alt="歩行ルートの保存開始機能" /></p>

<p><img src="/images/personal_development_footprintmeter_3.png" alt="歩行ルートの保存終了機能" /></p>

<p><img src="/images/personal_development_footprintmeter_4.png" alt="歩行ルートの表示/非表示切替機能" /></p>

<p>さて、ここからはソースコードベースで実装について説明したいと思います。</p>

<h5>View / Model / ViewModelそれぞれの責務</h5>

<p>先程スクショベースでお見せした機能をロジックベースで言語化すると、</p>

<ul>
<li>位置情報の取得許可の確認</li>
<li>位置情報の取得情報の確認</li>
<li>位置情報の計測を開始し、<code>Realm</code> にそのデータを保存する</li>
<li>位置情報の計測を停止する</li>
<li><code>Realm</code> から保存した位置情報を取得する</li>
</ul>


<p>のように言い換えられます。</p>

<p>では、 <code>View</code> / <code>Model</code> / <code>ViewModel</code> それぞれどんな責務を持たせれば良いのでしょうか。<br/>
下記にそれぞれの責務を簡単に書き出してみました。</p>

<ul>
<li><code>Model</code>

<ul>
<li>いわゆるビジネスロジックを担当する</li>
<li>例) API関連、ローカルDBを扱い関連など</li>
</ul>
</li>
<li><code>View</code>

<ul>
<li>ユーザアクションのキャッチ</li>
<li>画面の描画</li>
</ul>
</li>
<li><code>ViewModel</code>

<ul>
<li><code>View</code> と <code>Model</code> を繋ぐ</li>
<li><code>View</code> からの処理依頼を受けて、<code>Model</code>を介して必要な情報を取得し、<code>View</code>に特定の描画司令を出す</li>
</ul>
</li>
</ul>


<p>続いて、具体的に上記を実現する方法について説明します。</p>

<h5>Modelの説明</h5>

<p>まずは <code>Model</code> に関する実装から説明します。<br/>
本アプリの肝となる『計測した位置情報の <code>Realm</code> への保存』を実装するために、<br/>
<code>Realm</code> を管理する <code>RealmManager</code> を定義します。</p>

<p>また、 <code>Realm</code> に保存する形式を先に決める必要があるため、 <code>Footprint</code> という <code>Model</code> を作成します。</p>

<p>以下、 <code>Footprint</code> のソースコードです。<br/>
書式は <code>Realm</code> の使い方そのままなので詳細は省きます。</p>

<p>```objective-c
// Model/Footprint.swift
import RealmSwift</p>

<p>/// 足跡
class Footprint: Object {</p>

<pre><code>// ID
@objc dynamic var id: Int = 0
// 保存した歩行ルートのタイトル
@objc dynamic var title: String = ""
// 緯度
@objc dynamic var latitude: Double = 0.0
// 軽度
@objc dynamic var longitude: Double = 0.0
// 位置の精度
@objc dynamic var accuracy: Double = 0.0
// 歩行速度
@objc dynamic var speed: Double = 0.0
// 歩行方向
@objc dynamic var direction: Double = 0.0
// データの生成日時
@objc dynamic var created: Double = Date().timeIntervalSince1970

// プライマリーキーの設定
override static func primaryKey() -&gt; String? {
    return "id"
}

// インデックスの設定
override static func indexedProperties() -&gt; [String] {
    return ["title"]
}
</code></pre>

<p>}
```</p>

<p>続いて、 <code>RealmManager</code> のソースコードです。<br/>
まずは、 <code>protocol</code> として <code>RealmManagerClient</code> を定義します。<br/>
実際の <code>RealmManager</code> クラスは <code>RealmManagerClient protocol</code> を継承します。</p>

<p>こうすることで、テストを書く際にモックデータを返却することが容易になります。</p>

<p>```objective-c
// Model/RealmManager.swift
import Foundation
import CoreLocation
import RxSwift
import RealmSwift</p>

<p>protocol RealmManagerClient {</p>

<pre><code>// MARK: - Protocol Properties
var title: String { get set }

// MARK: - Protocol Methods
func setSaveTitle(_ title: String)
func createFootprint(location: CLLocation)
func fetchFootprints() -&gt; Observable&lt;Results&lt;Footprint&gt;?&gt;
func fetchFootprintsByTitle(_ text: String) -&gt; Observable&lt;Results&lt;Footprint&gt;?&gt;
func existsByTitle(_ text: String) -&gt; Observable&lt;Bool&gt;
func countFootprints() -&gt; Observable&lt;Int&gt;
func countFootprintsByTitle(_ text: String) -&gt; Observable&lt;Int&gt;
</code></pre>

<p>}
```</p>

<p>この <code>RealmManagerClient protocol</code> を継承して各メソッドの実処理を実装すると、下記のようになります。</p>

<p>```objective-c
// Model/RealmManager.swift
final class RealmManager: NSObject, RealmManagerClient {</p>

<pre><code>// MARK: - Properties
var title = String()

// MARK: - Initial Methods
override init() {
    super.init()
}

/// タイトルの保存処理
///
/// - Parameter title: 保存したいタイトル
func setSaveTitle(_ title: String) {
    self.title = title
}

// MARK: - CRUD

/// 位置情報のデータの保存処理
///
/// - Parameter location: 保存する位置情報
func createFootprint(location: CLLocation) {
    do {
        let realm = try Realm()
        let footprint = Footprint()
        let savedLastFootprint = fetchAllFootprints()?.last
        footprint.id = (savedLastFootprint != nil) ? ((savedLastFootprint?.id)! + 1) : 0
        footprint.title = self.title
        footprint.latitude = location.coordinate.latitude
        footprint.longitude = location.coordinate.longitude
        footprint.accuracy = location.horizontalAccuracy
        footprint.speed = location.speed
        footprint.direction = location.course

        // Realmへのオブジェクトの書き込み
        try realm.write {
            realm.create(Footprint.self, value: footprint, update: false)
        }
    } catch let error as NSError {
        print("Error: code - \(error.code), description - \(error.description)")
    }
}

/// 保存している全位置情報データを取得する処理
///
/// - Returns: 保存している全位置情報データ
func fetchFootprints() -&gt; Observable&lt;Results&lt;Footprint&gt;?&gt; {
    let footprints = fetchAllFootprints()
    return Observable.just(footprints)
}

/// 指定したタイトルで保存されている位置情報データを取得する処理
///
/// - Parameter text: タイトル
/// - Returns: 指定したタイトルで保存されている位置情報データ
func fetchFootprintsByTitle(_ text: String) -&gt; Observable&lt;Results&lt;Footprint&gt;?&gt; {
    do {
        let realm = try Realm()
        let footprints = realm.objects(Footprint.self).filter("title == '\(text)'")
        if footprints.count &gt; 0 {
            return Observable.just(footprints)
        }
        return Observable.just(nil)
    } catch _ as NSError {
        return Observable.just(nil)
    }
}

/// 指定したタイトルで保存されている位置情報データがあるか確認する処理
///
/// - Parameter text: タイトル
/// - Returns: 存在する場合はtrue, 存在しない場合はfalseを返却する
func existsByTitle(_ text: String) -&gt; Observable&lt;Bool&gt; {
    do {
        let realm = try Realm()
        let footprints = realm.objects(Footprint.self).filter("title == '\(text)'")
        if footprints.count &gt; 0 {
            return Observable.just(true)
        }
        return Observable.just(false)
    } catch _ as NSError {
        return Observable.just(false)
    }
}

/// 保存したい全位置情報の数を取得する処理
///
/// - Returns: 保存している位置情報の数
func countFootprints() -&gt; Observable&lt;Int&gt; {
    do {
        let realm = try Realm()
        return Observable.just(realm.objects(Footprint.self).count)
    } catch _ as NSError {
        return Observable.just(0)
    }
}

/// 指定したタイトルで保存されている位置情報の数
///
/// - Parameter text: タイトル
/// - Returns: 保存している位置情報の数
func countFootprintsByTitle(_ text: String) -&gt; Observable&lt;Int&gt; {
    do {
        let realm = try Realm()
        let footprints = realm.objects(Footprint.self).filter("title == '\(text)'")
        return Observable.just(footprints.count)
    } catch _ as NSError {
        return Observable.just(0)
    }
}

// MARK: - Private Methods

/// 保存している全位置情報データを取得する処理
///
/// - Returns: 位置情報データ
private func fetchAllFootprints() -&gt; Results&lt;Footprint&gt;? {
    do {
        let footprints = try Realm().objects(Footprint.self).sorted(byKeyPath: "id")
        return footprints
    } catch _ as NSError {
        return nil
    }
}
</code></pre>

<p>}
```</p>

<h5>protocol Injectableを用意することで依存関係の解決</h5>

<p>続いて、<code>ViewModel</code> や <code>View</code> の説明をする前に、<br/>
<code>ViewModel</code> と <code>View</code> の双方を疎結合にするための <code>protocol Injectable</code> を定義します。<br/>
※これは<a href="https://gihyo.jp/magazine/wdpress/archive/2018/vol106">WEB+DB PRESS V.106</a>で特集されていた手法をそのまま採用しています。</p>

<p>```objective-c
import UIKit</p>

<p>protocol Injectable {</p>

<pre><code>associatedtype Dependency
init(with dependency: Dependency)
</code></pre>

<p>}</p>

<p>extension Injectable where Dependency == Void {</p>

<pre><code>init() {
    self.init(with: ())
}
</code></pre>

<p>}
```</p>

<p>実際の効力は <code>ViewModel</code> や <code>View</code> のソースを見て頂けると伝わるかと思います。</p>

<h5>ViewModelの説明</h5>

<p>では、<code>ViewModel</code>について次は見ていきます。</p>

<p>先程言語化した</p>

<ul>
<li>位置情報の取得許可の確認</li>
<li>位置情報の取得情報の確認</li>
<li>位置情報の計測を開始し、<code>Realm</code> にそのデータを保存する</li>
<li>位置情報の計測を停止する</li>
<li><code>Realm</code> から保存した位置情報を取得する</li>
</ul>


<p>の5つを実装の内の幾つかを例に説明していきます。</p>

<p>繰り返しになりますが、 <code>ViewModel</code> ですので、以下を守ることを念頭に置くことが大事です。</p>

<ul>
<li><code>ViewModel</code> の責務

<ul>
<li><code>View</code> と <code>Model</code> を繋ぐ</li>
<li><code>View</code> からの処理依頼を受けて、<code>Model</code>を介して必要な情報を取得し、<code>View</code>に特定の描画司令を出す</li>
</ul>
</li>
</ul>


<p>まずは、 <code>ViewModel</code> の最低限の実装から先に説明します。</p>

<p>```objective-c
// MapViewModel.swift
import Foundation
import RxSwift
import RxCocoa
import CoreLocation
import RealmSwift</p>

<p>// 説明(1)
final class MapViewModel: Injectable {</p>

<pre><code>// 説明(2)
struct Dependency {
    let locationManager: CLLocationManager
    let realmManager: RealmManagerClient
}

// MARK: - Properties
private let disposeBag = DisposeBag()

// MARK: Initial method
// 説明(3)
init(with dependency: Dependency) {
    let locationManager = dependency.locationManager
    let realmManager = dependency.realmManager
    ...
}
</code></pre>

<p>}
```</p>

<p><strong>説明(1)</strong><br/>
<code>MapViewModel</code> クラスは <code>Injectable</code> プロトコルを継承するクラスとして定義します。</p>

<p><strong>説明(2)</strong><br/>
<code>Injectable</code> は <code>Generic Protocol</code> として定義されているため、
説明(1)の実装により、 <code>Dependency</code> を定義する必要が出てきます。<br/>
ここでは <code>struct</code> として、そのプロパティに</p>

<ul>
<li><code>CLLocationManager</code> 型の <code>locationManager</code></li>
<li><code>RealmManagerClient</code> 型の <code>realmManager</code></li>
</ul>


<p>を定義しています。</p>

<p>ミソなのが、 <code>RealmManager</code> ではなく <code>RealmManagerClient</code> としている点です。<br/>
<code>RealmManagerClient</code> は <code>protocol</code> なので、具体的な処理は書かれていません。<br/>
あくまでもインタフェースの提供のみです。</p>

<p>このため、テストを書く際に、レスポンスをモック化することが容易になるのです。<br/>
※ <code>CLLocationManager</code> はApple提供の純正品なので難しいですが&hellip;</p>

<p><strong>説明(3)</strong><br/>
<code>MapViewModel</code> の初期化メソッドの引数に <code>Dependency</code> 型の <code>dependency</code> を渡しています。<br/>
初期化時の引数として外部から渡せるようにすることで依存性を軽減しています。</p>

<p>説明(2)の実装を活かすために、外部から渡せるようにしたと言いかえることもできますね。</p>

<p>続いて、 <code>View</code> と <code>ViewModel</code> を繋ぐ <code>RxSwift</code> の実装部分を説明してきます。</p>

<p>5つの実装の内の</p>

<ul>
<li>位置情報の取得許可の確認</li>
<li>位置情報の取得情報の確認</li>
</ul>


<p>は下記の通りに実装しています。</p>

<p>```objective-c
// MapViewModel.swift
import Foundation
import RxSwift
import RxCocoa
import CoreLocation
import RealmSwift</p>

<p>final class MapViewModel: Injectable {</p>

<pre><code>struct Dependency {
    let locationManager: CLLocationManager
    let realmManager: RealmManagerClient
}

// MARK: - Properties
private let disposeBag = DisposeBag()

// MARK: Drivers
private (set) var authorized: Driver&lt;Bool&gt;
private (set) var location: Driver&lt;CLLocationCoordinate2D&gt;

// MARK: Initial method
init(with dependency: Dependency) {
    let locationManager = dependency.locationManager
    let realmManager = dependency.realmManager

    // Initialize stored properties
    // 位置情報の取得許可の確認
    authorized = Observable.deferred({() -&gt; Observable&lt;CLAuthorizationStatus&gt; in
        let status = CLLocationManager.authorizationStatus()
        return locationManager
            .rx.didChangeAuthorizationStatus
            .startWith(status)
    })
        .asDriver(onErrorJustReturn: CLAuthorizationStatus.notDetermined)
        .map {
            switch $0 {
            case .authorizedAlways:
                return true
            default:
                return false
            }
    }

    // 位置情報の取得情報の確認
    location = locationManager.rx.didUpdateLocations
        .asDriver(onErrorJustReturn: [])
        .flatMap {
            return $0.last.map(Driver.just) ?? Driver.empty()
        }
        .map {
            realmManager.createFootprint(location: $0)
            return $0.coordinate
    }

    // 位置情報の取得許可を要求
    locationManager.requestAlwaysAuthorization()
    // バックグラウンドでの位置情報取得を許可
    locationManager.allowsBackgroundLocationUpdates = true
    // バックグラウンドで位置情報取得がわかるように設定
    locationManager.showsBackgroundLocationIndicator = true
}
</code></pre>

<p>}
```</p>

<p>これは<a href="https://github.com/ReactiveX/RxSwift/blob/master/RxExample/RxExample/Services/GeolocationService.swift">RxSwiftの公式ExampleのGeolocationService</a>と同じ実装です。</p>

<p>詳細は<a href="http://grandbig.github.io/blog/2018/10/06/rx-delegate/">GeolocationSampleから学ぶdelegateのRx対応</a>でも説明しているので、ここでは概略だけにします。</p>

<ul>
<li>位置情報の補足等を <code>Rx</code> でできるように独自に実装する必要があります</li>
<li>これにより <code>didChangeAuthorizationStatus</code> と <code>didUpdateLocations</code> を <code>locationManager.rx.xxx</code> のように <code>Rx</code> 実装方式に則って書けるようになります</li>
<li>それぞれハンドリングした値を <code>authorized</code> と <code>location</code> に渡すことで <code>View</code> で検知できるようにします</li>
</ul>


<p>また、5つの実装の内の</p>

<ul>
<li>位置情報の計測を開始し、<code>Realm</code> にそのデータを保存する</li>
<li>位置情報の計測を停止する</li>
</ul>


<p>は下記の通りに実装しています。</p>

<p>```objective-c
// MapViewModel.swift
import Foundation
import RxSwift
import RxCocoa
import CoreLocation
import RealmSwift</p>

<p>final class MapViewModel: Injectable {</p>

<pre><code>...
// MARK: - Properties
private let disposeBag = DisposeBag()
private var dataTitle = String()
private var isUpdatingLocation = false

// 説明(4)
// MARK: PublishSubjects
private let startUpdatingLocationStream = PublishSubject&lt;(LocationAccuracy, String?)&gt;()
private let stopUpdatingLocationStream = PublishSubject&lt;Void&gt;()

// MARK: BehaviorRelays
private let errorStream = BehaviorRelay&lt;String?&gt;(value: nil)

// MARK: Initial method
init(with dependency: Dependency) {
    ...
    // Data Binding Handling
    // 説明(6)
    observeStartUpdatingLocation(locationManager: locationManager, realmManager: realmManager)
    observeStopUpdatingLocation(locationManager: locationManager)
}
</code></pre>

<p>}</p>

<p>// 説明(5)
// MARK: &ndash; Input
extension MapViewModel {</p>

<pre><code>var startUpdatingLocation: AnyObserver&lt;(LocationAccuracy, String?)&gt; {
    return startUpdatingLocationStream.asObserver()
}
var stopUpdatingLocation: AnyObserver&lt;Void&gt; {
    return stopUpdatingLocationStream.asObserver()
}
</code></pre>

<p>}</p>

<p>// MARK: &ndash; Output
extension MapViewModel {</p>

<pre><code>var error: Driver&lt;String?&gt; {
    return errorStream.asDriver()
}
</code></pre>

<p>}</p>

<p>// MARK: &ndash; Data Binding Handling
// 説明(6)
extension MapViewModel {</p>

<pre><code>/// startUpdatingLocationStreamにデータバインディングされてきた場合の処理
///
/// - Parameters:
///   - locationManager: 位置情報管理マネージャ
///   - realmManager: Realm管理マネージャ
func observeStartUpdatingLocation(locationManager: CLLocationManager, realmManager: RealmManagerClient) {

    startUpdatingLocationStream
        .subscribe { [weak self] event in
            guard let strongSelf = self, let element = event.element, let dataTitle = element.1 else { return }
            strongSelf.dataTitle = dataTitle
            let locationAccuracy = LocationAccuracy.toCLLocationAccuracy(element.0)
            // タイトルの設定
            realmManager.setSaveTitle(dataTitle)
            // 同名タイトルの既存データが存在するか確認
            realmManager.existsByTitle(dataTitle)
                .flatMapLatest({ isExist -&gt; Observable&lt;String?&gt; in
                    if isExist {
                        return Observable.just(R.string.mapView.alreadySameTitleErrorMessage())
                    }
                    // 位置情報の取得精度を設定
                    locationManager.desiredAccuracy = locationAccuracy
                    // 位置情報の計測を開始
                    locationManager.startUpdatingLocation()
                    strongSelf.isUpdatingLocation = true
                    return Observable.just(nil)
                })
                .asDriver(onErrorJustReturn: R.string.mapView.unExpectedErrorMessage())
                .drive(strongSelf.errorStream)
                .disposed(by: strongSelf.disposeBag)
        }
        .disposed(by: disposeBag)
}

/// stopUpdatingLocationStreamにデータバインディングされてきた場合の処理
///
/// - Parameter locationManager: 位置情報管理マネージャ
func observeStopUpdatingLocation(locationManager: CLLocationManager) {

    stopUpdatingLocationStream
        .subscribe { [weak self] _ in
            guard let strongSelf = self else { return }
            // 位置情報の計測を停止
            locationManager.stopUpdatingLocation()
            strongSelf.isUpdatingLocation = false
        }
        .disposed(by: disposeBag)
}
</code></pre>

<p>}
```</p>

<p><strong>説明(4)</strong><br/>
<code>View</code> からの位置情報の取得開始と停止イベント通知をキャッチした後に、 <code>ViewModel</code> 内の処理に導くために実装している部分になります。<br/>
開発当初に <code>Observable</code> であり <code>Observer</code> でもある <code>PublishSubject</code> を利用する必要があったため、 <code>PublishSubject</code> 型として宣言しています。<br/>
現段階では <code>Observer</code> で十分な気がします。<br/>
(今後の宿題と言うことで&hellip;)</p>

<p><strong>説明(5)</strong><br/>
<code>startUpdatingLocationStream</code> と <code>stopUpdatingLocationStream</code> を <code>PublishSubject</code> として定義したことで、必要となった実装です。<br/>
<code>Observable</code> であり <code>Observer</code> でもある <code>PublishSubject</code> は便利な反面、<code>public</code> なプロパティとしておくと、誤って外側から <code>Observable</code> な機能を利用される可能性があります。</p>

<p>これを防ぐために <code>AnyObserver</code> 型のプロパティを外部に公開し、<code>PublishSubject</code> 型プロパティは <code>private</code> として内部に閉ざしています。</p>

<p>因みに、 <code>Input</code> / <code>Output</code> と分けて書くことで視認性が高まるので、<br/>
<code>error</code> に至っては <code>BehaviorRelay</code> 関連にも関わらず、この書式を取っています。<br/>
※ <code>error</code> は <code>Output</code> 時のみの利用かつ、<code>ObservableType</code> 型の <code>BehaviorRelay</code> なので誤った利用がされる恐れはないため。</p>

<p><strong>説明(6)</strong><br/>
実際に <code>View</code> からの指示を受け取った後に実行している処理になります。<br/>
この中で、必要な情報を <code>Model</code> を介して取得することで <code>MVVM</code> というアーキテクチャが取れているわけです。<br/>
<code>ViewModel</code> の中で、 <code>View</code> の描画に必要な情報を整理して、必要な情報を <code>View</code> に渡しつつ、実行処理を指示しています。</p>

<h5>Viewの説明</h5>

<p><code>ViewModel</code> に続いて <code>View</code> を説明します。<br/>
繰り返しになりますが、 <code>View</code> の責務は、</p>

<ul>
<li><code>View</code>

<ul>
<li>ユーザアクションのキャッチ</li>
<li>画面の描画</li>
</ul>
</li>
</ul>


<p>になります。<br/>
まずは、 <code>View</code> の最低限の実装から説明します。</p>

<p>```objective-c
import UIKit
import MapKit
import RxSwift
import RxCocoa</p>

<p>// 説明(1)
final class MapViewController: UIViewController, Injectable {</p>

<pre><code>typealias Dependency = MapViewModel

// MARK: - IBOutlets
@IBOutlet private weak var mapView: MKMapView!
@IBOutlet private weak var tabBar: UITabBar!
@IBOutlet private weak var searchButton: UIButton!

// MARK: - Properties
// 説明(2)
private let viewModel: MapViewModel
private let disposeBag = DisposeBag()

// MARK: - Initial methods
// 説明(3)
required init(with dependency: Dependency) {
    viewModel = dependency
    super.init(nibName: nil, bundle: nil)
}

@available(*, unavailable)
required init?(coder aDecoder: NSCoder) {
    fatalError("init(coder:) has not been implemented")
}

// MARK: - Lifecycle methods
override func viewDidLoad() {
    super.viewDidLoad()
    ...
}
</code></pre>

<p>}
```</p>

<p><strong>説明(1)</strong><br/>
<code>ViewModel</code> と <code>View</code> を疎結合にするために、ここでも <code>Injectable</code> を利用します。<br/>
<code>MapViewController</code> を <code>Injectable</code> プロトコルを継承するクラスとして定義し、<br/>
<code>Dependency</code> を <code>MapViewModel</code> の別名として設定しています。</p>

<p><strong>説明(2)</strong><br/>
<code>ViewModel</code> からの指示を受け取れるように、 <code>MapViewModel</code> を宣言します。</p>

<p><strong>説明(3)</strong><br/>
<code>Injectable</code> プロトコルを継承するため、 <code>Dependency</code> を引数に持つ <code>init</code> メソッドが必要になります。<br/>
メソッド内で <code>viewModel</code> に <code>dependency</code> を与えていますが、<br/>
これは冒頭で説明した通り <code>Dependency</code> を <code>MapViewModel</code> の別名として設定しているため実現可能となります。</p>

<p>最低限の実装の次は「位置情報の計測を停止する」機能を元に、 <code>View</code> → <code>ViewModel</code> の実装を見てみます。</p>

<p>本アプリでは、<code>UITabBar</code>の「STOP」項目をタップすることで位置情報の計測停止処理を進めることができます。<br/>
よって、 <code>View</code> → <code>ViewModel</code> の部分は下記のように&hellip;</p>

<p>```objective-c
 // 説明(4)
 // Drive to ViewModel
 private func driveToViewModel() {</p>

<pre><code>tabBar.rx.didSelectItem
    .asDriver()
    .drive(onNext: { [weak self] item in
        guard let strongSelf = self else { return }
        strongSelf.didSelectTabBarItem(tag: item.tag)
        }, onCompleted: nil, onDisposed: nil)
    .disposed(by: disposeBag)
</code></pre>

<p> }</p>

<p>// 説明(5)
/// 各タブバーアイテムタップ時の処理
///
/// &ndash; Parameter tag: タブバーアイテムのタグ
private func didSelectTabBarItem(tag: Int) {</p>

<pre><code>guard let itemTag = TabBarItemTag(rawValue: tag) else { return }
switch itemTag {
case .start:
    startUpdatingLocationMode()
case .stop:
    stopUpdatingLocationMode()
case .footView:
    showOrHideFootprintMode()
case .settings:
    showSettingViewMode()
}
</code></pre>

<p>}</p>

<p>// 説明(6)
/// Stopモードに変更された場合に実行される処理
private func stopUpdatingLocationMode() {</p>

<pre><code>// 確認アラートを表示、タブバーの選択表示をnilにする(全て未選択状態にする)
let alert = UIAlertController(title: R.string.common.confirmTitle(),
                              message: R.string.mapView.stopUpdatingLocationMessage(),
                              preferredStyle: .alert)
self.promptFor(alert: alert)
    .subscribe({ [weak self] event in
        // アラートを消す
        alert.dismiss(animated: false, completion: nil)

        // アラートに表示されたOK/Cancelボタンのどちらをタップしたか確認
        guard let strongSelf = self, let alertActionType = event.element else { return }
        switch alertActionType {
        case .ok:
            // OKボタンをタップした場合
            // タブバーの全アイテムを未選択の状態にする
            strongSelf.tabBar.selectedItem = nil
            // ストップボタンをdisabledに変更
            strongSelf.activateStartButton()
            // 位置情報の取得停止をViewModelにバインディング
            Observable.just(Void())
                .bind(to: strongSelf.viewModel.stopUpdatingLocation)
                .disposed(by: strongSelf.disposeBag)
        case .cancel:
            // Cancelボタンをタップした場合
            // タブバーの選択状態をスタートボタンの選択状態に戻す
            let startTag = TabBarItemTag.start
            strongSelf.tabBar.selectedItem = strongSelf.tabBar.items?[startTag.rawValue]
        }
    })
    .disposed(by: disposeBag)
</code></pre>

<p>}
```</p>

<p><strong>説明(4)</strong><br/>
<code>RxCocoa</code> 内に <code>UITabBar+Rx.swift</code> があり、その中で <code>Rx</code> 的に扱えるように <code>didSelectItem</code> が定義されています。<br/>
ここでは、それを用いて、 <code>UITabBar</code> のタブ項目をタップしたら、 <code>didSelectTabBarItem</code> メソッドを呼び出すように処理を書いています。</p>

<p><strong>説明(5)</strong><br/>
ここは1つ1つの処理が長くなり過ぎないように、単にメソッド分けしているだけです。<br/>
<code>tag</code> の <code>0</code> 〜 <code>3</code> で判別して処理分けしているのですが、<br/>
直で数字で <code>switch</code> 文を利用したくないので <code>TabBarItemTag</code> を定義しています。</p>

<p>```objective-c
// TabBarItemTag.swift
enum TabBarItemTag: Int {</p>

<pre><code>case start = 0
case stop
case footView
case settings
</code></pre>

<p>}
```</p>

<p>単にこれだけですが、何をタップした時にどんな処理をするのかが、こちらの方がひと目でわかりますよね。</p>

<p><strong>説明(6)</strong><br/>
ここで具体的に「STOP」をタップされた場合の処理を書いています。<br/>
重要なのは、</p>

<p>```objective-c
// 位置情報の取得停止をViewModelにバインディング
Observable.just(Void())</p>

<pre><code>.bind(to: strongSelf.viewModel.stopUpdatingLocation)
.disposed(by: strongSelf.disposeBag)
</code></pre>

<p>```</p>

<p>の部分です。<br/>
「位置情報の計測を停止しますか？」という質問に「OK」と答えた際に実行される処理で、<br/>
<code>View</code> から <code>ViewModel</code> に指示が出ていることを伝えています。<br/>
(<code>Void</code>型のデータを <code>viewModel.stopUpdatingLocation</code> にバインディングしています。)</p>

<p>このような形で <code>View</code> と <code>ViewModel</code> は双方向データバインディングな関係を構築しています。</p>

<h4>今後の展望とリリース時期について</h4>

<p>ざっくりと <code>MVVM</code> で実装したソースコードを説明してきましたが、<br/>
冒頭でも述べた通り、まだアプリは完成しておりません&hellip;</p>

<p>そこで今後の展望ですが、下記2点となります。</p>

<ul>
<li><code>RxSwift</code> らしい書き方に修正する

<ul>
<li>学習しながら実装していた経緯もあり、無用に <code>PublishSubject</code> や <code>BehaviorRelay</code> を利用している箇所があります。</li>
<li>上記を <code>Driver</code> に置き換えることで視認性の向上に繋がると考えています。</li>
</ul>
</li>
<li>テストの拡充

<ul>
<li>正直、まだ十分にテストが書けていません&hellip;</li>
<li>折角、疎結合を意識しながら構築しているのでテストは書き切りたいと思っています。</li>
</ul>
</li>
</ul>


<p>それらを満たした上で、リリース時期は1月末を見込んでいます。<br/>
極力、早期なリリースを目指していきたいと思います。</p>

<h3>まとめ</h3>

<p>さて如何でしたでしょうか？<br/>
今回は5年前の個人開発アプリの再構築について紹介させて頂きました。</p>

<p>個人開発すると、業務で学んだ技術の復習になることもあるでしょうし、<br/>
新たな技術の学びにも繋がるかと思います。</p>

<p>筆者もめげずにこれからも新しい技術を学び続け、個人開発した結果をアウトプットしていきたいなと思います。<br/>
と言ったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RxSwiftを勉強してみよう！(4) ~ 成功処理と失敗処理の書き方 ~]]></title>
    <link href="http://grandbig.github.io/blog/2018/10/20/rxswift-4/"/>
    <updated>2018-10-20T13:20:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2018/10/20/rxswift-4</id>
    <content type="html"><![CDATA[<h3>はじめに</h3>

<p>本日は <code>RxSwift</code> で、『ある条件のときのみ <code>Observer</code> に伝える』方法について見ていきたいと思います。<br/>
これは例えば、</p>

<ul>
<li>処理が成功した場合のみ、何か次のアクションを実行させる</li>
<li>処理の成功/失敗で次のアクション内容を変更する</li>
</ul>


<p>場合に必要な書き方です。<br/>
では具体的に見ていきましょう。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h3>サンプルを元に書き方を学ぼう</h3>

<p>具体的なサンプルを見ながら書き方を学んでいきたいと思います。<br/>
今回のサンプルのアーキテクチャは <code>MVVM</code> を採用します。</p>

<p>各役割は</p>

<ul>
<li><code>Model</code> : ビジネスロジック</li>
<li><code>View</code> : ユーザ操作のキャッチと実描画処理</li>
<li><code>ViewModel</code> : プレゼンテーションロジック</li>
</ul>


<p>となります。<br/>
早速、サンプルを見ていきましょう。</p>

<h4>検索ボタンをタップした結果を表現する</h4>

<p>サンプルを例に考えます。</p>

<h5>サンプルの前提</h5>

<ul>
<li>検索ボタンをタップすると、レストラン検索APIを叩く</li>
<li>レストラン検索APIの取得が成功した場合、マップにレストランの場所を示すマーカを配置する</li>
<li>レストラン検索APIの取得が失敗した場合、エラーメッセージを表示する</li>
</ul>


<h5>Viewにユーザ操作のキャッチ部分を書く</h5>

<p>まずは、 <code>ViewController.swift</code> に「ユーザ操作のキャッチ」部分を書きます。<br/>
※必要のない処理は省略します。</p>

<p>```objective-c
// ViewController.swift
import UIKit
import RxSwift
import RxCocoa
import GoogleMaps</p>

<p>class ViewController: UIViewController, Injectable {</p>

<pre><code>...
// MARK: - IBOutlets
@IBOutlet weak private var mapView: GMSMapView!
@IBOutlet weak private var searchButton: UIButton!

// MARK: - Properties
private let viewModel: ViewModel
...

override func viewDidLoad() {
    super.viewDidLoad()
    ...
    bind()
}

func bind() {
  // ユーザの検索ボタンのタップ操作をキャッチ
  searchButton.rx.tap
      .bind(to: viewModel.searchButtonDidTap)
      .disposed(by: disposeBag)
}
...
</code></pre>

<p>}
```</p>

<h5>ViewModelにViewからのインプットをハンドリング&amp;レストラン検索APIを叩く</h5>

<p>続いて、上記で書いた <code>viewModel.searchButtonDidTap</code> を <code>ViewModel</code> に定義します。<br/>
<code>View</code> からユーザのタップ操作が伝えられた時に、レストラン検索APIを叩く処理も書きます。</p>

<p>```objective-c
// ViewModel.swift
import Foundation
import RxSwift
import RxCocoa
import GoogleMaps</p>

<p>final class ViewModel: Injectable {</p>

<pre><code>struct Dependency {
    let apiClient: GooglePlacesAPIClient
    let locationManager: LocationManagerClient
    let coordinate: CLLocationCoordinate2D
}
private let disposeBag = DisposeBag()
...

// MARK: PublishSubjects
private let searchButtonDidTapStream = PublishSubject&lt;Void&gt;()

// MARK: BehaviorSubjects
private let placesStream = BehaviorSubject&lt;Places&gt;(value: defaultPlaces)
private let errorStream = BehaviorSubject&lt;String&gt;(value: String())

init(with dependency: Dependency) {
    let apiClient = dependency.apiClient
    let locationManager = dependency.locationManager
    var coordinate = dependency.coordinate

    ...

    // 検索ボタンタップ時に、レストラン検索APIを叩く
    let state = searchButtonDidTapStream
        .flatMapLatest { _ -&gt; Observable&lt;Result&lt;Places&gt;&gt; in
            return apiClient.fetchRestaurants(coordinate: coordinate)
        }

    ...
}
</code></pre>

<p>}</p>

<p>// MARK: Input
extension ViewModel {</p>

<pre><code>var searchButtonDidTap: AnyObserver&lt;()&gt; {
    return searchButtonDidTapStream.asObserver()
}
</code></pre>

<p>}</p>

<p>// MARK: Output
extension ViewModel {</p>

<pre><code>var places: Observable&lt;Places&gt; {
    return placesStream.asObservable()
}

var error: Observable&lt;String&gt; {
    return errorStream.asObservable()
}
</code></pre>

<p>}
```</p>

<p>上記のように、 <code>View</code> からのインプットとして <code>searchButtonDidTap</code> プロパティを用意します。<br/>
インプットがあった場合に、 <code>searchButtonDidTapStream.asObserver()</code> することで、呼び出しを伝搬する仕組みになっています。<br/>
その中で <code>apiClient.fetchRestaurants(coordinate: coordinate)</code> を叩いています。</p>

<h5>ViewModelにレストラン検索APIの取得成功/失敗の処理を書く：パターン１</h5>

<p>この <code>apiClient.fetchRestaurants(coordinate: coordinate)</code> の結果次第で <code>View</code> に表示させる処理を変えたいと思います。<br/>
<code>GooglePlacesAPIClient</code> クラスの <code>fetchRestaurants</code> の戻り値の定義は以下とします。</p>

<p><code>objective-c
func fetchRestaurants(coordinate: CLLocationCoordinate2D) -&gt; Observable&lt;Result&lt;Places&gt;&gt;
</code></p>

<p>上記の <code>Result</code> と <code>Places</code> の定義は以下とします。</p>

<p>```objective-c
// Result.swift
enum Result<T> {</p>

<pre><code>case success(T)
case failure(error: Error)
</code></pre>

<p>}</p>

<p>// Places.swift
public struct Places: Codable {</p>

<pre><code>public var results: [Place]
public var status: String
public var htmlAttributions: [String]
</code></pre>

<p>}
```</p>

<p><code>Place</code> の定義の紹介は省略します。</p>

<p>準備ができたので、レストラン検索APIの取得成功/失敗の処理を見ていきましょう。</p>

<p>```objective-c
// ViewModel.swift
private static let defaultPlaces = Places(results: [], status: R.string.common.ok(), htmlAttributions: [])</p>

<p>&hellip;</p>

<p>// 検索ボタンタップ時
let state = searchButtonDidTapStream</p>

<pre><code>.flatMapLatest { _ -&gt; Observable&lt;Result&lt;Places&gt;&gt; in
    return apiClient.fetchRestaurants(coordinate: coordinate)
}
</code></pre>

<p>// 処理が成功した場合
state</p>

<pre><code>.flatMapLatest { result -&gt; Observable&lt;Places&gt; in
    switch result {
    case let .success(value):
        return Observable.just(value)
    default:
        return Observable.just(ViewModel.defaultPlaces)
    }
}
.bind(to: placesStream)
.disposed(by: disposeBag)
</code></pre>

<p>// 処理が失敗した場合
state</p>

<pre><code>.flatMapLatest { result -&gt; Observable&lt;String&gt; in
    switch result {
    case let .failure(error):
        return Observable.just(error.localizedDescription)
    default:
        return Observable.just(String())
    }
}
.bind(to: errorStream)
.disposed(by: disposeBag)
</code></pre>

<p>```</p>

<p>上記では、処理が成功した場合と失敗した場合の処理を書いています。<br/>
処理が成功した場合はアウトプットである <code>placesStream</code> を経由して <code>View</code> に描画指示を出しています。<br/>
処理が失敗した場合はアウトプットである <code>errorStream</code> を経由して <code>View</code> に描画指示を出しています。</p>

<h5>Viewに描画処理を書く</h5>

<p><code>ViewModel</code> から指示の渡った後に <code>View</code> で実際に描画する処理を書きます。</p>

<p>```objective-c
// ViewController.swift
private func bind() {
  &hellip;
  viewModel.places</p>

<pre><code>  .bind { [weak self] places in
      guard let strongSelf = self else { return }
      let results = places.results
      if results.count &gt; 0 {
          strongSelf.mapView.clear()
          results.forEach({ (place) in
              // マップにマーカを配置します
              strongSelf.putMarker(place: place)
          })
      }
  }
  .disposed(by: disposeBag)
</code></pre>

<p>  viewModel.error</p>

<pre><code>  .bind { [weak self] message in
      guard let strongSelf = self else { return }
      if message.count == 0 { return }
      // エラーメッセージをアラートに表示します
      strongSelf.showAlert(message: message, completion: {})
  }
  .disposed(by: disposeBag)
</code></pre>

<p>}
```</p>

<h5>ViewModelにレストラン検索APIの取得成功/失敗の処理を書く：パターン２</h5>

<p>パターン１で手法を一つ書きましたが、筆者的には</p>

<ul>
<li><code>View</code> に条件分岐などのロジックが必要になってしまう</li>
<li><code>ViewModel</code> で <code>bind</code> 先のオブジェクトの型は1つなので無駄な処理を書かざるを得ない

<ul>
<li>処理成功の場合の <code>return Observable.just(ViewModel.defaultPlaces)</code></li>
<li>処理失敗の場合の <code>return Observable.just(String())</code></li>
</ul>
</li>
</ul>


<p>というところが微妙だと感じています。</p>

<p>上記を踏まえて、もう１つ別の方法を書きます。</p>

<p>```objective-c
// ViewModel.swift
// 検索ボタンタップ時
searchButtonDidTapStream</p>

<pre><code>.flatMapLatest { _ -&gt; Observable&lt;Result&lt;Places&gt;&gt; in
    return apiClient.fetchRestaurants(coordinate: coordinate)
}.subscribe { [weak self] event in
    guard let strongSelf = self else { return }
    guard let element = event.element else { return }
    switch element {
    case let .success(result):
        Observable.just(result)
            .bind(to: strongSelf.placesStream)
            .disposed(by: strongSelf.disposeBag)
    case let .failure(error):
        Observable.just(error.localizedDescription)
            .bind(to: strongSelf.errorStream)
            .disposed(by: strongSelf.disposeBag)
    }
</code></pre>

<p>}.disposed(by: disposeBag)
```</p>

<p>これであれば、 <code>View</code> の方のロジックも下記のように多少減らすことができ、スッキリします。<br/>
( あっても困らない条件分岐ではありますけどね&hellip; )</p>

<p>```objective-c
// ViewController.swift
private func bind() {
  &hellip;
  viewModel.places</p>

<pre><code>  .bind { [weak self] places in
      guard let strongSelf = self else { return }
      let results = places.results
      strongSelf.mapView.clear()
      results.forEach({ (place) in
          // マップにマーカを配置します
          strongSelf.putMarker(place: place)
      })
  }
  .disposed(by: disposeBag)
</code></pre>

<p>  viewModel.error</p>

<pre><code>  .bind { [weak self] message in
      guard let strongSelf = self else { return }
      // エラーメッセージをアラートに表示します
      strongSelf.showAlert(message: message, completion: {})
  }
  .disposed(by: disposeBag)
</code></pre>

<p>}
```</p>

<h3>まとめ</h3>

<p>さて如何でしたでしょうか？<br/>
筆者的には、まだまだ全然 <code>RxSwift</code> の修行が足りないので、もっと良い書き方を学んでいきたいと思います。<br/>
と言ったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[カスタムDelegateのRx対応]]></title>
    <link href="http://grandbig.github.io/blog/2018/10/14/popuppickerview-rx/"/>
    <updated>2018-10-14T22:52:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2018/10/14/popuppickerview-rx</id>
    <content type="html"><![CDATA[<h3>はじめに</h3>

<p>先日、<a href="https://grandbig.github.io/blog/2018/10/06/rx-delegate/">GeolocationSampleから学ぶdelegateのRx対応</a>を紹介しました。<br/>
今回は<a href="https://grandbig.github.io/blog/2018/10/13/popuppickerview/">下からニュッと出るPickerを作ろう！</a>で作成した <code>PickerView</code> に実装されている <code>Delegate</code> を <code>Rx</code> 対応させたいと思います。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h3>PickerViewクラスの確認</h3>

<p>まずは、元となる <code>PickerView</code> クラスを提示します。</p>

<p>```objective-c
import Foundation
import UIKit</p>

<p>/// ピッカービュー
public class PickerView: UIView {</p>

<pre><code>// MARK: - IBOutlets
@IBOutlet weak var toolBar: UIToolbar!
@IBOutlet weak var picker: UIPickerView!

// MARK: - Static Properties
static private let screenWidth = UIScreen.main.bounds.size.width
static private let screenHeight = UIScreen.main.bounds.size.height
static private let defaultPickerHeight: CGFloat = 260.0
static private let duration = 0.2

// MARK: - Properties
public weak var delegate: PickerViewDelegate?
private var selectItems = [String]()
private var selectedRowIndex: Int = 0

// MARK: - Initial Methods
required init(frame: CGRect = CGRect(x: 0, y: screenHeight, width: screenWidth, height: defaultPickerHeight),
              selectItems: [String]) {
    var frame = frame
    if let safeAreaTopInsets = UIApplication.shared.keyWindow?.safeAreaInsets.top, safeAreaTopInsets &gt; CGFloat(0.0) {
        // iPhoneX , XS, XS MAX, XRの場合はUIPickerViewの高さを調整する
        frame = CGRect(x: 0, y: frame.origin.y, width: frame.size.width, height: (frame.size.height + 100.0))
    }
    super.init(frame: frame)
    self.selectItems = selectItems
    self.xibViewSet()
}

required init?(coder aDecoder: NSCoder) {
    super.init(coder: aDecoder)!
    self.xibViewSet()
}

internal func xibViewSet() {
    if let view = R.nib.pickerView.firstView(owner: self) {
        view.frame = self.bounds
        self.addSubview(view)

        picker.delegate = self
        picker.dataSource = self
        picker.showsSelectionIndicator = true
    }
}

// MARK: - Picker Move Function
// PickerViewを表示する
func showPickerView() {
    let pickerViewWidth = self.frame.size.width
    let pickerViewHeight = self.frame.size.height
    let pickerViewYPosition = PickerView.screenHeight - pickerViewHeight
    UIView.animate(withDuration: PickerView.duration) {
        self.frame = CGRect.init(x: 0, y: pickerViewYPosition, width: pickerViewWidth, height: pickerViewHeight)
    }
}

// PickerViewを非表示にする
func hiddenPickerView() {
    let pickerViewWidth = self.frame.size.width
    let pickerViewHeight = self.frame.size.height
    UIView.animate(withDuration: PickerView.duration) {
        self.frame = CGRect.init(x: 0, y: PickerView.screenHeight, width: pickerViewWidth, height: pickerViewHeight)
    }
}

// MARK: - IBActions
@IBAction func cancelSelection(_ sender: Any) {
    delegate?.closePickerView()
    hiddenPickerView()
}

@IBAction func doneSelection(_ sender: Any) {
    delegate?.selectedItem(index: selectedRowIndex, title: selectItems[selectedRowIndex])
    hiddenPickerView()
}
</code></pre>

<p>}</p>

<p>/// MARK: &ndash; UIPickerViewDelegate
extension PickerView: UIPickerViewDelegate {</p>

<pre><code>public func pickerView(_ pickerView: UIPickerView, titleForRow row: Int, forComponent component: Int) -&gt; String? {
    return selectItems[row]
}

public func pickerView(_ pickerView: UIPickerView, didSelectRow row: Int, inComponent component: Int) {
    selectedRowIndex = row
}
</code></pre>

<p>}</p>

<p>/// MARK: &ndash; UIPickerViewDataSource
extension PickerView: UIPickerViewDataSource {</p>

<pre><code>public func numberOfComponents(in pickerView: UIPickerView) -&gt; Int {
    return 1
}

public func pickerView(_ pickerView: UIPickerView, numberOfRowsInComponent component: Int) -&gt; Int {
    return selectItems.count
}
</code></pre>

<p>}</p>

<p>/// MARK: &ndash; PickerViewDelegate
@objc
public protocol PickerViewDelegate: class {</p>

<pre><code>func selectedItem(index: Int, title: String)
func closePickerView()
</code></pre>

<p>}
```</p>

<p>では早速 <code>Rx</code> 対応させていきましょう。</p>

<h3>DelegateProxyとDelegateProxyTypeへの対応</h3>

<p>基本的には、 <code>CLLocationManagerDelegate</code> と同じです。<br/>
<code>DelegateProxy</code> と <code>DelegateProxyType</code> を継承したクラスを実装します。</p>

<p>```objective-c
import Foundation
import RxSwift
import RxCocoa</p>

<p>// 説明(1)
extension PickerView: HasDelegate {</p>

<pre><code>public typealias Delegate = PickerViewDelegate
</code></pre>

<p>}</p>

<p>public class RxPickerViewDelegateProxy: DelegateProxy&lt;PickerView, PickerViewDelegate>,</p>

<pre><code>DelegateProxyType,
PickerViewDelegate {

public init(pickerView: PickerView) {
    super.init(parentObject: pickerView, delegateProxy: RxPickerViewDelegateProxy.self)
}

// 説明(2)
public static func registerKnownImplementations() {
    self.register { RxPickerViewDelegateProxy(pickerView: $0) }
}

// 説明(3)
internal lazy var selectedItemSubject = PublishSubject&lt;(Int, String)&gt;()
internal lazy var closePickerViewSubject = PublishSubject&lt;Void&gt;()

// 説明(4)
public func selectedItem(index: Int, title: String) {
    selectedItemSubject.onNext((index, title))
}

public func closePickerView() {
    closePickerViewSubject.onNext(Void())
}

// 説明(5)
deinit {
    self.selectedItemSubject.on(.completed)
    self.closePickerViewSubject.on(.completed)
}
</code></pre>

<p>}
```</p>

<p>細かく見ていきましょう。</p>

<h4>説明(1)</h4>

<p><code>currentDelegate</code> および <code>setCurrentDelegate</code> に対応する代わりに、 <code>HasDelegate</code> を継承させましょう。</p>

<h4>説明(2)</h4>

<p>自身で定義した <code>DelegateProxy</code> の継承クラスを登録するために、 <code>registerKnownImplementations</code> 内で <code>DelegateProxySubclass.register()</code> を実行します。</p>

<h4>説明(3)</h4>

<p><code>delegate</code> メソッドが呼び出されて処理が実行されたことを <code>Subscriber</code> に伝えるために、 <code>PublishSubject</code> 型のプロパティを用意します。</p>

<h4>説明(4)</h4>

<p><code>PickerViewDelegate</code> の <code>selectedItem(index:title:)</code> と <code>closePickerView()</code> メソッドは必須メソッドです。<br/>
<code>RxPickerViewDelegateProxy</code> はもちろん <code>PickerViewDelegate</code> も継承しますので、上記2つのメソッドを定義する必要があります。</p>

<p>これが呼び出されたタイミングで <code>Subscriber</code> に伝えるために、 <code>PublishSubject.onNext(element:)</code> を実行します。</p>

<h4>説明(5)</h4>

<p><code>deinit</code> が呼ばれるタイミングで、初期化したオブジェクトが破棄されるので、<br/>
<code>PublishSubject</code> からイベント送信完了を知らせるように実装しましょう。</p>

<h3>ReactiveへのPickerViewの適応</h3>

<p>これも <code>CLLocationManager</code> と適応方法は同じです。<br/>
まずは、全体像から&hellip;</p>

<p>```objective-c
// PickerView+Rx.swift
import Foundation
import RxSwift
import RxCocoa</p>

<p>extension Reactive where Base: PickerView {</p>

<pre><code>// 説明(1)
public var delegate: DelegateProxy&lt;PickerView, PickerViewDelegate&gt; {
    return RxPickerViewDelegateProxy.proxy(for: base)
}

// 説明(2)
public var selectedItem: Observable&lt;(Int, String)&gt; {
    return RxPickerViewDelegateProxy.proxy(for: base).selectedItemSubject.asObservable()
}

public var closePickerView: Observable&lt;Void&gt; {
    return RxPickerViewDelegateProxy.proxy(for: base).closePickerViewSubject.asObservable()
}
</code></pre>

<p>}
```</p>

<p>1つずつ説明します。</p>

<h4>説明(1)</h4>

<p><code>delegate</code> を <code>DelegateProxy</code> 型として定義します。<br/>
<code>DelegateProxy</code> の取得は <code>DelegateProxyType</code> プロトコルの <code>proxy</code> メソッドを利用します。</p>

<h4>説明(2)</h4>

<p>各 <code>delegate</code> メソッドが実行されたことを補足(監視)するために <code>Observable</code> 型の <code>selectedItem</code> と <code>closePickerView</code> を用意します。</p>

<h3>利用方法</h3>

<p>では、早速利用してみましょう。</p>

<p>```objective-c
// ViewController.swift</p>

<p>private let disposeBag = DisposeBag()</p>

<p>private func bind() {
  pickerView?.rx.selectedItem</p>

<pre><code>  .asObservable()
  .subscribe({ [weak self] event in
      // Subscriberとして補足した情報を取得
      guard let strongSelf = self else { return }
      guard let index = event.element?.0 else { return }
      guard let title = event.element?.1 else { return }

      Observable.just(index, title)
          // ViewModelにsampleActionが定義されているとします
          .bind(to: strongSelf.viewModel.sampleAction)
          .disposed(by: strongSelf.disposeBag)
          })
          .disposed(by: disposeBag)
</code></pre>

<p>}
```</p>

<p>上記のような形で <code>ViewController</code> にて <code>Subscriber</code> としてアクションを補足し、 <code>ViewModel</code> に伝えることができるでしょう。</p>

<h3>まとめ</h3>

<p>さて、如何でしたでしょうか？<br/>
1つ1つの意味を理解することはもちろん大切ですが、<br/>
何だか型にはまって書き方を覚えれば、自身で <code>Rx</code> 対応が簡単にできる気がしてきますね。</p>

<p><code>Rx</code> の癖が強いが故に、慣れれば利用しやすいということなのでしょう。<br/>
と言ったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
</feed>
