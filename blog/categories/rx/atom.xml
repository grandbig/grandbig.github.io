<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: rx | Takahiro Octopress Blog]]></title>
  <link href="http://grandbig.github.io/blog/categories/rx/atom.xml" rel="self"/>
  <link href="http://grandbig.github.io/"/>
  <updated>2018-10-13T13:27:38+09:00</updated>
  <id>http://grandbig.github.io/</id>
  <author>
    <name><![CDATA[Takahiro]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[GeolocationSampleから学ぶdelegateのRx対応]]></title>
    <link href="http://grandbig.github.io/blog/2018/10/06/rx-delegate/"/>
    <updated>2018-10-06T11:16:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2018/10/06/rx-delegate</id>
    <content type="html"><![CDATA[<h3>はじめに</h3>

<p><code>RxSwift</code> を利用して <code>MVVM</code> アーキテクチャでアプリを開発することがあるでしょう。<br/>
その際に、ボタンタップやネットワーク通信であれば、何もやらずとも <code>RxSwift</code> が対応してくれていたり、 <code>RxSwift</code> に対応しているライブラリがあったりします。</p>

<p>しかし、デフォルトでは <code>RxSwift</code> に対応していない場合も当然あります。<br/>
ではそんなとき、どのようにして対応すれば良いでしょうか。</p>

<p>今日は、 <code>delegate</code> の <code>Rx</code> 対応について公式サンプルの <code>GeolocationSample</code> を元に説明してみたいと思います。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h3>delegateのRx対応方法</h3>

<p>早速具体的に方法を見ていきましょう。<br/>
今回は公式サンプルの <code>GeolocationSample</code> を元に、 <code>CLLocationManagerDelegate</code> を <code>Rx</code> に対応させる方法を説明します。</p>

<h4>DelegateProxyとDelegateProxyTypeへの対応</h4>

<p><code>delegate</code> の <code>Rx</code> 対応でまず必要なことは</p>

<ul>
<li><code>DelegateProxy</code> クラスを継承するクラスを作成すること</li>
<li><code>DelegateProxyType</code> プロトコルを継承するクラスを作成すること</li>
</ul>


<p>です。<br/>
ここでは上記2つの条件を満たした <code>RxCLLocationManagerDelegateProxy</code> クラスを作ることとします。</p>

<h5>DelegateProxyの説明</h5>

<p><code>DelegateProxy.swift</code> を見てみると、下記のように定義されています。</p>

<p>```objective-c
// DelegateProxy.swift</p>

<p>/// Base class for <code>DelegateProxyType</code> protocol.
///
/// This implementation is not thread safe and can be used only from one thread (Main thread).
open class DelegateProxy&lt;P: AnyObject, D>: _RXDelegateProxy {</p>

<pre><code>public typealias ParentObject = P
public typealias Delegate = D
...
</code></pre>

<p>}
```</p>

<p>この <code>DelegateProxy</code> は <code>DelegateProxyType</code> プロトコルのベースクラスと説明されています。<br/>
<code>DelegateProxy</code> はジェネリッククラスであり、2つのパラメータ <code>P</code> と <code>D</code> を持ちます。</p>

<p>ここで、 <code>P</code> と <code>D</code> について説明します。</p>

<ul>
<li><code>D</code> :<br/>
<code>Rx</code> に対応させたい <code>delegate</code> を指定します<br/>
<code>D</code> は <code>Delegate</code> の頭文字と思われます</li>
<li><code>P</code> :<br/>
<code>delegate</code> である <code>D</code> をプロパティとして持つオブジェクトを指定します<br/>
<code>P</code> は <code>ParentObject</code> の頭文字と思われます</li>
</ul>


<p>今回の場合は、<br/>
<code>DelegateProxy&lt;CLLocationManager, CLLocationManagerDelegate&gt;</code> になります。</p>

<h5>DelegateProxyTypeの説明</h5>

<p><code>DelegateProxyType.swift</code> の中身を見てみると、下記のように説明されています。</p>

<p>```objective-c
// DelegateProxyType.swift</p>

<p>/**
<code>DelegateProxyType</code> protocol enables using both normal delegates and Rx observable sequences with
views that can have only one delegate/datasource registered.
&hellip;</p>

<p>*/
```</p>

<p>意訳すると、<br/>
<code>DelegateProxyType</code> は <code>delegate</code> と <code>Rx</code> との紐付けを実現するプロトコル<br/>
であることを指しています。</p>

<p>方式は図示化されていますので、見てみると何となく理解できると思います。<br/>
図では <code>UIScrollViewDelegate</code> を例に説明されています。</p>

<p>```objective-c
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+
|                                           |                         <br/>
| UIView subclass (UIScrollView)            |                         <br/>
|                                           |
+&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+</p>

<pre><code>        |                                                           
        | Delegate                                                  
        |                                                           
        |                                                           
</code></pre>

<p>+&mdash;&mdash;&mdash;&mdash;&mdash;-v&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+                         <br/>
|                                           |                         <br/>
| Delegate proxy : DelegateProxyType        +&mdash;&mdash;&ndash;+&mdash;&mdash;>  Observable<T1>
|                , UIScrollViewDelegate     |     |
+&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+     +&mdash;&mdash;>  Observable<T2></p>

<pre><code>        |                                     |                     
        |                                     +----&gt;  Observable&lt;T3&gt;
        |                                     |                     
        | forwards events                     |
        | to custom delegate                  |
        |                                     v                     
</code></pre>

<p>+&mdash;&mdash;&mdash;&mdash;&mdash;-v&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+                         <br/>
|                                           |                         <br/>
| Custom delegate (UIScrollViewDelegate)    |                         <br/>
|                                           |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+ <br/>
```</p>

<p>また <code>DelegateProxyType</code> は以下3つの <code>static</code> メソッドを定義しているため、<br/>
<code>DelegateProxyType</code> を継承すると、必ずこの3つのメソッドを持つ必要があります。</p>

<ul>
<li><code>registerKnownImplementations</code><br/>
このメソッドの中で必ず <code>DelegateProxySubclass.register()</code> を実行します。<br/>
これをすることで自身で定義した <code>DelegateProxy</code> の継承クラスを登録することができます。</li>
<li><code>currentDelegate</code><br/>
<code>ParentObject</code> の持つ <code>delegate</code> を返却する処理を書きます。</li>
<li><code>setCurrentDelegate</code><br/>
<code>ParentObject</code> に持つべき <code>delegate</code> を設定する処理を書きます。</li>
</ul>


<p>特に特殊なことをしない場合は、<br/>
<code>delegate</code> をプロパティとして持つオブジェクトである <code>ParentObject</code>に<br/>
<code>HasDelegate</code> プロトコルを継承させます。 　</p>

<p>```objective-c
extension CLLocationManager: HasDelegate {</p>

<pre><code>public typealias Delegate = CLLocationManagerDelegate
</code></pre>

<p>}
```</p>

<p>これにより、 <code>currentDelegate</code> と <code>setCurrentDelegate</code> を省略することができます。</p>

<h5>対応したコードを書いてみる</h5>

<p>基本的な説明は以上として、実際にコードに起こしてみましょう。<br/>
まずは結果から。</p>

<p>```objective-c
import RxSwift      // ここは必須
import RxCocoa      // ここは必須
import CoreLocation //  CLLocationManagerDelegateはCoreLocation内に定義されています</p>

<p>// currentDelegateとsetCurrentDelegateの役割を担います
extension CLLocationManager: HasDelegate {</p>

<pre><code>public typealias Delegate = CLLocationManagerDelegate
</code></pre>

<p>}</p>

<p>// DelegateProxy, DelegateProxyType, CLLocationManagerDelegateを継承
// DelegateをRxに対応させるために、元となるDelegateも継承が必須です
public class RxCLLocationManagerDelegateProxy: DelegateProxy&lt;CLLocationManager, CLLocationManagerDelegate>,</p>

<pre><code>DelegateProxyType,
CLLocationManagerDelegate {

// 初期化処理
public init(locationManager: CLLocationManager) {
    super.init(parentObject: locationManager, delegateProxy: RxCLLocationManagerDelegateProxy.self)
}

// 必須のstaticメソッド
public static func registerKnownImplementations() {
    // 説明(1)
    self.register { (locationManager) -&gt; RxCLLocationManagerDelegateProxy in
        RxCLLocationManagerDelegateProxy(locationManager: locationManager)
    }
}

// 説明(2)
internal lazy var didUpdateLocationsSubject = PublishSubject&lt;[CLLocation]&gt;()
internal lazy var didFailWithErrorSubject = PublishSubject&lt;Error&gt;()

// 説明(3)
public func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
    _forwardToDelegate?.locationManager(manager, didUpdateLocations: locations)
    didUpdateLocationsSubject.onNext(locations)
}

public func locationManager(_ manager: CLLocationManager, didFailWithError error: Error) {
    _forwardToDelegate?.locationManager(manager, didFailWithError: error)
    didFailWithErrorSubject.onNext(error)
}

// 説明(4)
deinit {
    self.didUpdateLocationsSubject.on(.completed)
    self.didFailWithErrorSubject.on(.completed)
}
</code></pre>

<p>}
```</p>

<p>上記ソースコードを一部補足説明します。</p>

<h6>説明(1)</h6>

<p><code>registerKnownImplementations</code> で説明した通り <code>register</code> メソッドを実行しています。<br/>
<code>register</code> メソッドは、</p>

<p>```objective-c
/// Store DelegateProxy subclass to factory.
/// When make &lsquo;Rx<em>DelegateProxy&rsquo; subclass, call &lsquo;Rx</em>DelegateProxySubclass.register(for:_)&rsquo; 1 time, or use it in DelegateProxyFactory
/// &lsquo;Rx*DelegateProxy&rsquo; can have one subclass implementation per concrete ParentObject type.
/// Should call it from concrete DelegateProxy type, not generic.
public static func register<Parent>(make: @escaping (Parent) &ndash;> Self) {</p>

<pre><code>self.factory.extend(make: make)
</code></pre>

<p>}
```</p>

<p>と定義されています。</p>

<p>クロージャの引数に <code>ParentObject</code> を必要とし、<br/>
そのクラス自身を戻り値を必要としているため、<br/>
<code>ParentObject</code> として <code>locationManager</code> を渡し、<br/>
それを元に初期化した <code>RxCLLocationManagerDelegateProxy</code> オブジェクトを戻り値として渡しています。</p>

<p>ここは説明のため省略書きしませんでしたが、</p>

<p>```objective-c
public static func registerKnownImplementations() {</p>

<pre><code>self.register { RxCLLocationManagerDelegateProxy(locationManager: $0) }
</code></pre>

<p>}
```</p>

<p>とも当然書けます。</p>

<h6>説明(2)</h6>

<p><code>PublishSubject</code> 型のプロパティを2つ定義しています。</p>

<p><code>objective-c
internal lazy var didUpdateLocationsSubject = PublishSubject&lt;[CLLocation]&gt;()
internal lazy var didFailWithErrorSubject = PublishSubject&lt;Error&gt;()
</code></p>

<p>これは説明(3)にも関わるのですが、<br/>
<code>delegate</code> メソッドが呼び出されて処理が実行されたことを <code>Subscriber</code> に伝えるために定義が必要となります。</p>

<h6>説明(3)</h6>

<p><code>delegate</code> メソッドを <code>Rx</code> で対応するための方法が、まさにココで直接的に書かれています。</p>

<p>```objective-c
public func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {</p>

<pre><code>_forwardToDelegate?.locationManager(manager, didUpdateLocations: locations)
didUpdateLocationsSubject.onNext(locations)
</code></pre>

<p>}
```</p>

<p>今回は、 <code>didUpdateLocations</code> で取得した <code>locations</code> の情報を <code>Rx</code> 連携させるために、上記のように記述しています。<br/>
先程説明した <code>PublishSubject</code> が <code>Subscriber</code> にメソッドの実行タイミングでデータを伝える方法ですが、<br/>
<code>didUpdateLocationsSubject.onNext(locations)</code> で実行しています。</p>

<p><code>_forwardToDelegate?.locationManager(manager, didUpdateLocations: locations)</code> はメモリ観点から<br/>
<code>delegate</code> を引き続き利用していることを伝えるために利用しているように見えます。</p>

<h6>説明(4)</h6>

<p>最後に <code>deinit</code> 内で実行している処理ですが、<br/>
<code>deinit</code> が呼ばれるということは初期化したオブジェクトが破棄される時なので、イベントが送られることはないはずです。<br/>
よって <code>PublishSubject</code> からイベント送信完了を知らせるように実装しましょう。</p>

<h4>ReactiveへのCLLocationManagerの適応</h4>

<p>事前準備が整ったため、実際に <code>CLLocationManager</code> を <code>Rx</code> 適応させてみます。</p>

<p><code>RxSwift</code> では下記のように書くことで拡張できる仕組みを用意しています。</p>

<p>```objective-c
// CLLocationManager+Rx.swift
import CoreLocation
import RxSwift
import RxCocoa</p>

<p>extension Reactive where Base: CLLocationManager {</p>

<pre><code>...
</code></pre>

<p>}
```</p>

<p>これが可能な理由は <code>Reactive.swift</code> を見てみると良いでしょう。</p>

<p>```objective-c
public struct Reactive<Base> {</p>

<pre><code>/// Base object to extend.
public let base: Base

/// Creates extensions with base object.
///
/// - parameter base: Base object.
public init(_ base: Base) {
    self.base = base
}
</code></pre>

<p>}
```</p>

<p>そして、拡張した後にやることは下記です。</p>

<ul>
<li><code>delegate</code> のラッパーを生成する</li>
<li>各 <code>delegate</code> メソッドに対応したラッパープロパティを生成する</li>
<li>キャストメソッドを用意する</li>
</ul>


<p>1つずつ説明していきましょう。</p>

<h5>delegateのラッパーを生成する</h5>

<p>このラッパーは <code>delegate</code> を <code>DelegateProxy</code> 型として定義します。<br/>
この <code>delegate</code> はもちろん <code>readOnly</code> で値の取得のみできるものとします。<br/>
<code>DelegateProxy</code> の取得は <code>DelegateProxyType</code> プロトコルの <code>proxy</code> メソッドを利用します。</p>

<p><code>``objective-c
/**
Reactive wrapper for</code>delegate`.</p>

<p>For more information take a look at <code>DelegateProxyType</code> protocol documentation.
*/
public var delegate: DelegateProxy&lt;CLLocationManager, CLLocationManagerDelegate> {</p>

<pre><code>return RxCLLocationManagerDelegateProxy.proxy(for: base)
</code></pre>

<p>}
```</p>

<h5>各delegateメソッドに対応したラッパープロパティを生成する</h5>

<p><code>RxCLLocationManagerDelegateProxy</code> で <code>didUpdateLocations</code> と <code>didFailWithError</code> の <code>delegate</code> メソッドに対応しました。<br/>
これらのメソッドに対応したラッパープロパティは以下のように実装します。</p>

<p>```objective-c
// MARK: Responding to Location Events</p>

<p>/<em>*
 Reactive wrapper for <code>delegate</code> message.
 </em>/
 public var didUpdateLocations: Observable&lt;[CLLocation]> {</p>

<pre><code>return RxCLLocationManagerDelegateProxy.proxy(for: base).didUpdateLocationsSubject.asObservable()
</code></pre>

<p>}</p>

<p>/<em>*
 Reactive wrapper for <code>delegate</code> message.
 </em>/
public var didFailWithError: Observable<Error> {</p>

<pre><code>return RxCLLocationManagerDelegateProxy.proxy(for: base).didFailWithErrorSubject.asObservable()
</code></pre>

<p>}
```</p>

<p>これらも <code>readOnly</code> で値のみを <code>Observable</code> 型で取得できるように定義しています。</p>

<h5>キャストメソッドを用意する</h5>

<p>キャストメソッドを用意する理由は、<br/>
あるメソッドの処理の完了タイミングで何らかの処理を実行させたい<br/>
<code>methodInvoked</code> を利用するときに必要になります。</p>

<p>処理は下記の通りです。<br/>
<code>Optional</code> 型の場合とそうでない場合が必要になる可能性がありますので、2種類用意しています。</p>

<p>```objective-c
fileprivate func castOrThrow<T>(_ resultType: T.Type, _ object: Any) throws &ndash;> T {</p>

<pre><code>guard let returnValue = object as? T else {
    throw RxCocoaError.castingError(object: object, targetType: resultType)
}

return returnValue
</code></pre>

<p>}</p>

<p>fileprivate func castOptionalOrThrow<T>(_ resultType: T.Type, _ object: Any) throws &ndash;> T? {</p>

<pre><code>if NSNull().isEqual(object) {
    return nil
}

guard let returnValue = object as? T else {
    throw RxCocoaError.castingError(object: object, targetType: resultType)
}

return returnValue
</code></pre>

<p>}
```</p>

<p>今回の場合、端末の位置情報を利用するので、 <code>CLLocationManagerDelegate</code> の <code>didChangeAuthorization</code> のハンドリングが必須になります。<br/>
この <code>delegate</code> メソッドは定期的に繰り返し利用する必要はありません。<br/>
状態が変わって、その情報を必要となったタイミングでだけ利用できれば良いのです。<br/>
よって <code>methodInvoked</code> を利用してプロパティを定義します。</p>

<p>```objective-c
// MARK: Responding to Authorization Changes</p>

<p>/<em>*
 Reactive wrapper for <code>delegate</code> message.
 </em>/
public var didChangeAuthorizationStatus: Observable<CLAuthorizationStatus> {</p>

<pre><code>return delegate.methodInvoked(#selector(CLLocationManagerDelegate.locationManager(_:didChangeAuthorization:)))
    .map { a in
        let number = try castOrThrow(NSNumber.self, a[1])
        return CLAuthorizationStatus(rawValue: Int32(number.intValue)) ?? .notDetermined
}
</code></pre>

<p>}
```</p>

<p>以上で必要な対応は全て完了です。</p>

<h3>Rxに対応したdelegateの使い方</h3>

<p>自作した <code>Rx</code> 対応後の <code>delegate</code> を利用する例も見ていきましょう。</p>

<h4>処理ロジックの実装</h4>

<p>公式サンプルでは処理ロジックに相当する <code>GeolocationService.swift</code> を下記のように実装しています。</p>

<p>```objective-c
// GeolocationService.swift
import CoreLocation
import RxSwift
import RxCocoa</p>

<p>class GeolocationService {</p>

<pre><code>static let instance = GeolocationService()
// 説明(1)
private (set) var authorized: Driver&lt;Bool&gt;
private (set) var location: Driver&lt;CLLocationCoordinate2D&gt;

private let locationManager = CLLocationManager()

private init() {

    locationManager.distanceFilter = kCLDistanceFilterNone
    locationManager.desiredAccuracy = kCLLocationAccuracyBestForNavigation

    // 説明(2)
    authorized = Observable.deferred { [weak locationManager] in
            let status = CLLocationManager.authorizationStatus()
            guard let locationManager = locationManager else {
                return Observable.just(status)
            }
            return locationManager
                .rx.didChangeAuthorizationStatus
                .startWith(status)
        }
        .asDriver(onErrorJustReturn: CLAuthorizationStatus.notDetermined)
        .map {
            switch $0 {
            case .authorizedAlways:
                return true
            default:
                return false
            }
        }

    // 説明(3)
    location = locationManager.rx.didUpdateLocations
        .asDriver(onErrorJustReturn: [])
        .flatMap {
            return $0.last.map(Driver.just) ?? Driver.empty()
        }
        .map { $0.coordinate }

    locationManager.requestAlwaysAuthorization()
    locationManager.startUpdatingLocation()
}
</code></pre>

<p>}
```</p>

<p>1つずつ説明していきましょう。</p>

<h5>説明(1)</h5>

<p>今回のサンプルは、</p>

<ul>
<li>位置情報の利用を許可したら、画面が切り替わる</li>
<li>取得した最新の位置情報を画面に表示する</li>
</ul>


<p>という、データ結果を画面に直接反映させる処理が含まれています。<br/>
よって、</p>

<p><code>objective-c
private (set) var authorized: Driver&lt;Bool&gt;
private (set) var location: Driver&lt;CLLocationCoordinate2D&gt;
</code></p>

<p>のように <code>Driver</code> として定義しています。</p>

<h5>説明(2)</h5>

<p><code>authorized</code> は <code>delegate</code> メソッドである <code>didChangeAuthorization</code> が呼び出されたタイミングで値が変更される必要があります。 <br/>
今回は、<br/>
<code>Subscribe</code> するまでは <code>Observable</code> を生成せずに、 <code>Subscribe</code> されたタイミングで <code>Observable</code> を返す <code>Observable</code> を生成する<br/>
<code>deferred</code> メソッドを利用しています。</p>

<p>```objective-c
authorized = Observable.deferred { [weak locationManager] in</p>

<pre><code>    let status = CLLocationManager.authorizationStatus()
    guard let locationManager = locationManager else {
        return Observable.just(status)
    }
    // didChangeAuthorizationStatusからauthorizedの値を取得
    return locationManager
        .rx.didChangeAuthorizationStatus
        .startWith(status)
}
// エラーが発生した場合は .notDetermined で返却する
.asDriver(onErrorJustReturn: CLAuthorizationStatus.notDetermined)
.map {
    // .authorizedAlwaysの場合のみauthorizedにtrueを格納する
    switch $0 {
    case .authorizedAlways:
        return true
    default:
        return false
    }
}
</code></pre>

<p>```</p>

<h5>説明(3)</h5>

<p>最新の位置情報を取得したタイミングで通知します。</p>

<p>```objective-c
location = locationManager.rx.didUpdateLocations</p>

<pre><code>// エラーが発生した場合は、空配列で返却する
.asDriver(onErrorJustReturn: [])
// 位置情報が格納されている場合はその値を、位置情報がない場合は空を返却する
.flatMap {
    return $0.last.map(Driver.just) ?? Driver.empty()
}
// CLLocationCoordinate2Dの値を返却する
.map { $0.coordinate }
</code></pre>

<p>```</p>

<h4>Viewロジックの実装</h4>

<p>サンプルでは下記のように実装しています。</p>

<p>```objective-c
// GeolocationViewController.swift
import UIKit
import CoreLocation
import RxSwift
import RxCocoa</p>

<p>// 説明(1)
private extension Reactive where Base: UILabel {</p>

<pre><code>var coordinates: Binder&lt;CLLocationCoordinate2D&gt; {
    return Binder(base) { label, location in
        label.text = "Lat: \(location.latitude)\nLon: \(location.longitude)"
    }
}
</code></pre>

<p>}</p>

<p>class GeolocationViewController: ViewController {</p>

<pre><code>@IBOutlet weak private var noGeolocationView: UIView!
@IBOutlet weak private var button: UIButton!
@IBOutlet weak private var button2: UIButton!
@IBOutlet weak var label: UILabel!

override func viewDidLoad() {
    super.viewDidLoad()

    view.addSubview(noGeolocationView)

    let geolocationService = GeolocationService.instance

    // 説明(2)
    geolocationService.authorized
        .drive(noGeolocationView.rx.isHidden)
        .disposed(by: disposeBag)

    // 説明(3)
    geolocationService.location
        .drive(label.rx.coordinates)
        .disposed(by: disposeBag)
    ...
}
...
</code></pre>

<p>}
```</p>

<p>1つずつ説明していきましょう。</p>

<h5>説明(1)</h5>

<p>画面に位置情報を表示するために <code>UILabel</code> を独自に <code>Rx</code> に対応させています。<br/>
これは <code>CLLocationManager</code> を拡張した方法と同じですね。</p>

<h5>説明(2)</h5>

<p><code>authorized</code> が <code>true</code> の場合に <code>noGeolocationView</code> を非表示にするよう実装しています。</p>

<h5>説明(3)</h5>

<p>取得できた最新の位置情報を説明(1)で拡張した機能を利用して <code>UILabel</code> に表示するようにしています。</p>

<p>以上で <code>Rx</code> に対応させた <code>delegate</code> を利用することができました。</p>

<h3>まとめ</h3>

<p>さて、如何でしたでしょうか。<br/>
形式に沿って実装をすることで簡単に拡張することはできますが、<br/>
実装1つ1つを理解することでより深く <code>RxSwift</code> を現場で活用できるかと思います。</p>

<p>まだまだ筆者も理解が乏しいところがあるので、もっと深く勉強を続けていきたいと思います。<br/>
ということで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RxSwiftを勉強してみよう！(3)]]></title>
    <link href="http://grandbig.github.io/blog/2016/08/30/rxswift-3/"/>
    <updated>2016-08-30T16:42:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2016/08/30/rxswift-3</id>
    <content type="html"><![CDATA[<h3>RxSwiftのメソッドを見てみよう</h3>

<p>前回に引き続きRxSwiftを勉強したいと思います。<br/>
今回は<a href="https://github.com/ReactiveX/RxSwift/blob/master/Documentation/API.md">GitHub: Reactive/RxSwift API一覧</a>からメインのメソッドを見ていきたいと思います。</p>

<h4>asObservable</h4>

<p>これは<code>ReactiveX</code>で定義されている<code>From</code>オペレータと同義です。<br/>
様々なオブジェクトを<code>Observable</code>型のデータに変換するためのオペレータです。</p>

<p>利用例は下記です。</p>

<p>```objective-c
let disposeBag = DisposeBag()   // 自動unsubscribeのために必要</p>

<p>let array: [Int] = [1, 2, 3, 4, 5]
let variable = Variable(array)
variable.asObservable.subscribe { (event) in</p>

<pre><code>print("Event is \(event)")
</code></pre>

<p>}.addDisposableTo(disposeBag)</p>

<p>variable.value = [6, 7, 8]</p>

<p>// 結果は下記です。
Event is Next([1, 2, 3, 4, 5])
Event is Next([6, 7, 8])
Event is Completed
```</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h4>create</h4>

<p>0から<code>Observable</code>型のデータを生成するためのオペレータです。</p>

<p>```objective-c
let disposeBag = DisposeBag()   // 自動unsubscribeのために必要</p>

<p>let source = Observable.create { (observer: AnyObserver<Int>) &ndash;> Disposable in</p>

<pre><code>observer.onNext(1)
observer.onCompleted()

return AnonymousDisposable {
    print("Disposed")
}
</code></pre>

<p>}</p>

<p>source.subscribeNext { (elem) in</p>

<pre><code>print("Event is \(elem)")
</code></pre>

<p>}.addDisposableTo(disposeBag)</p>

<p>// 結果は下記です
Event is 1
Disposed
```</p>

<h4>deferred</h4>

<p>Subscribeされたタイミングで<code>Observable</code>型のデータを生成するオペレータです。</p>

<p>```objective-c
let disposeBag = DisposeBag()   // 自動unsubscribeのために必要</p>

<p>let source = Observable.deferred { () &ndash;> Observable<Int> in</p>

<pre><code>return Observable.just(1)
</code></pre>

<p>}
source.subscribeNext { (elem) in</p>

<pre><code>print("Elem is \(elem)")
</code></pre>

<p>}.addDisposableTo(disposeBag)</p>

<p>// 結果は下記です
Event is 1
```</p>

<h4>empty</h4>

<p>空の(何の値も持たない)<code>Observable</code>型のデータを生成するオペレータです。<br/>
通常通り、終了処理は実行されます。</p>

<p>```objective-c
let disposeBag = DisposeBag()   // 自動unsubscribeのために必要</p>

<p>let source: Observable<Int> = Observable.empty()
source.subscribeNext { (elem) in</p>

<pre><code>print("Elem is \(elem)")
</code></pre>

<p>}.addDisposableTo(disposeBag)</p>

<p>// 結果は下記です。
// 空のため何も出力されません
```</p>

<h4>never</h4>

<p>空の(何の値も持たない)<code>Observable</code>型のデータを生成するオペレータです。<br/>
<code>empty</code>と異なるのは終了処理が実行されないことです。</p>

<p>```objective-c
let disposeBag = DisposeBag()   // 自動unsubscribeのために必要</p>

<p>let source: Observable<Int> = Observable.never()
source.subscribeNext { (elem) in</p>

<pre><code>print("Elem is \(elem)")
</code></pre>

<p>}.addDisposableTo(disposeBag)</p>

<p>// 結果は下記です。
// 空のため何も出力されません
```</p>

<h4>error</h4>

<p>空の(何の値も持たない)<code>Observable</code>型のデータを生成するオペレータです。<br/>
<code>empty</code>, <code>never</code>と異なり、エラーを持った終了処理を実行します。</p>

<p>```objective-c
let disposeBag = DisposeBag()   // 自動unsubscribeのために必要</p>

<p>let error = NSError(domain: &ldquo;test&rdquo;, code: -1, userInfo: nil)
let source: Observable<Int> = Observable.error(error)
source.subscribeError { (error) in</p>

<pre><code>print("Error is \(error)")
</code></pre>

<p>}.addDisposableTo(disposeBag)</p>

<p>// 結果は下記です。
Error is Error Domain=test Code=-1 &ldquo;(null)&rdquo;
```</p>

<h4>toObservable</h4>

<p>様々なオブジェクトを<code>Observable</code>型のデータに変換するためのオペレータです。<br/>
<code>asObservable</code>とは利用方法が異なります。</p>

<p>```objective-c
let disposeBag = DisposeBag()   // 自動unsubscribeのために必要</p>

<p>let array: [Int] = [1, 2, 3]
array.toObservable().subscribeNext { (elem) in</p>

<pre><code>print("Number is \(elem)")
</code></pre>

<p>}.addDisposableTo(disposeBag)</p>

<p>// 結果は下記です。
Number is 1
Number is 2
Number is 3
```</p>

<h4>interval</h4>

<p>一定期間あけて処理を実行するためのオペレータです。<br/>
<code>JavaScript</code>で言うところの<code>setTimeInterval</code>です。</p>

<p>```objective-c
let disposeBag = DisposeBag()   // 自動unsubscribeのために必要</p>

<p>let timer: Observable<Int> = Observable.interval(5.0, scheduler: MainScheduler.instance)
timer.subscribeNext { (count) in</p>

<pre><code>print("log output")
</code></pre>

<p>}.addDisposableTo(disposeBag)</p>

<p>// 結果は下記です。
// 5秒後に実行されます。
log output
```</p>

<h4>just</h4>

<p>引数に指定した特定の型を返却する<code>Observable</code>型のデータを生成するためのオペレータです。</p>

<p>```objective-c
let disposeBag = DisposeBag()   // 自動unsubscribeのために必要</p>

<p>let source = Observable.just(1)
source.subscribeNext { (elem) in</p>

<pre><code>print("Elem is \(elem)")
</code></pre>

<p>}.addDisposableTo(disposeBag)</p>

<p>// 結果は下記です。
Elem is 1
```</p>

<h4>of</h4>

<p>様々なオブジェクトを<code>Observable</code>型のデータに変換するためのオペレータです。<br/>
<code>asObservable</code>や<code>toObservable</code>とは利用方法が異なります。</p>

<p>```objective-c
let disposeBag = DisposeBag()   // 自動unsubscribeのために必要</p>

<p>let source = Observable.of(1)
source.subscribeNext { (elem) in</p>

<pre><code>print("Elem is \(elem)")
</code></pre>

<p>}.addDisposableTo(disposeBag)</p>

<p>// 結果は下記です。
Elem is 1
```</p>

<h4>range</h4>

<p>特定の範囲の<code>Int</code>型を持つ<code>Observable</code>型データを生成するオペレータです。</p>

<p>```objective-c
let disposeBag = DisposeBag()   // 自動unsubscribeのために必要</p>

<p>let source: Observable<Int> = Observable.range(start: 1, count: 3)
source.subscribeNext { (elem) in</p>

<pre><code>print("Elem is \(elem)")
</code></pre>

<p>}.addDisposableTo(disposeBag)</p>

<p>// 結果は下記です。
Elem is 1
Elem is 2
Elem is 3
```</p>

<h4>repeatElement</h4>

<p>指定した回数、処理を実行するときに利用する<code>Observable</code>型データを生成するオペレータです。<br/>
<code>take</code>メソッドを利用して回数を指定します。</p>

<p>```objective-c
let disposeBag = DisposeBag()   // 自動unsubscribeのために必要</p>

<p>let source = Observable.repeatElement(1).take(3)
source.subscribeNext { (elem) in</p>

<pre><code>print("Elem is \(elem)")
</code></pre>

<p>}.addDisposableTo(disposeBag)</p>

<p>// 結果は下記です。
Elem is 1
Elem is 1
Elem is 1
```</p>

<h4>timer</h4>

<p>一定時間経過後に処理を実行したい場合に利用するオペレータです。<br/>
<code>JavaScript</code>で言うところの<code>setTimeout</code>です。</p>

<p>```objective-c
let timer: Observable<Int> = Observable.timer(5.0, scheduler: MainScheduler.instance)
timer.subscribeNext { (count) in</p>

<pre><code>print("log output")
</code></pre>

<p>}.addDisposableTo(disposeBag)
```</p>

<h3>まとめ</h3>

<p>さて、今回は<code>Creating Observables</code>のみを取り上げさせて頂きましたが、いかがでしたでしょうか？<br/>
筆者もイマイチ使い方がわからなかったオペレータがたくさんあったので、多少なりとも使えそうな気がしてきました。<br/>
<code>Transforming Observables</code>, <code>Filtering Observables</code> &hellip;. と全て見ていけると良いのですが、結構数が多いですね。<br/>
時間があるときに続きを書きたいと思います。</p>

<p>と言ったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RxSwiftを勉強してみよう！(2)]]></title>
    <link href="http://grandbig.github.io/blog/2016/08/29/rxswift-2/"/>
    <updated>2016-08-29T22:40:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2016/08/29/rxswift-2</id>
    <content type="html"><![CDATA[<h3>RxSwiftの公式Exampleを覗いてみる(2)</h3>

<p>前回に引き続きRxSwiftの公式Exampleを見ていきたいと思います。<br/>
公式ソースは<a href="https://github.com/ReactiveX/RxSwift">GitHub: ReactiveX/RxSwift</a>からダウンロードできます。</p>

<h4>GeolocationExample</h4>

<p>位置情報を用いたときのRxの有効性が表現されているのでしょうか？<br/>
早速見ていきましょう。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<p>まずは、<code>CoreLocation</code>のコア部分をラップしている<code>GeolocationService</code>です。</p>

<p>```objective-c
import Foundation
import CoreLocation
import RxSwift
import RxCocoa</p>

<p>class GeolocationService {</p>

<pre><code>static let instance = GeolocationService()
// (1)
private (set) var authorized: Driver&lt;Bool&gt;
private (set) var location: Driver&lt;CLLocationCoordinate2D&gt;

private let locationManager = CLLocationManager()

private init() {
    locationManager.distanceFilter = kCLDistanceFilterNone
    locationManager.desiredAccuracy = kCLLocationAccuracyBestForNavigation

    // (2)
    authorized = Observable.deferred { [weak locationManager] in
        let status = CLLocationManager.authorizationStatus()
        guard let locationManager = locationManager else {
            // (3)
            return Observable.just(status)
        }
        return locationManager
            .rx_didChangeAuthorizationStatus
            .startWith(status) // (4)
        }
        .asDriver(onErrorJustReturn: CLAuthorizationStatus.NotDetermined) // (5)
        .map {
            switch $0 {
                case .AuthorizedAlways:
                    return true
                default:
                    return false
            }
        }
}
</code></pre>

<p>}
```</p>

<p>上記ソースでポイントとなる部分を見ていきます。</p>

<p>(1): <code>Driver</code><br/>
末尾に参考URLとして上げさせて頂いた記事に書かれているのですが、<br/>
<code>Driver</code>型で定義することで、エラー発生時の処理<code>asDriver</code>オペレータで続けて書くことができます。</p>

<p>(2): <code>deferred</code><br/>
ObserverがSubscribe(購読)されたタイミングで動的にObservableを生成します。<br/>
※ 因みに新規ObservableをSubscribeタイミングで毎回生成します。</p>

<p>(3): <code>just</code><br/>
引数に取った特定の型を返却するObservableを生成します。<br/>
この場合は<code>CLAuthorizationStatus</code>型のObservableです。</p>

<p>(4): <code>startWith</code><br/>
想定したemit対象値の前に何らかの値をemitしたい場合に利用します。<br/>
この場合、<code>rx_didChangeAuthoricationStatus</code>をemitする前にということでしょうか。<br/>
(これが恐らく、一番わかりやすい例です → <a href="http://www.introtorx.com/Content/v1.0.10621.0/12_CombiningSequences.html#StartWith">Introduction to Rx: startWith</a>)</p>

<p>(5): <code>asDriver</code><br/>
(1)で説明した<code>Driver</code>に関係するオペレータです。<br/>
エラーが発生した場合に<code>onErrorJustReturn</code>で指定した値を返却して処理を続けます。</p>

<p>続いて、<code>GeolocationService</code>を利用している<code>GeolocationViewController</code>です。</p>

<p>```objective-c
import Foundation
import UIKit
import RxSwift
import RxCocoa</p>

<p>// (6)
private extension UILabel {</p>

<pre><code>var rx_driveCoordinates: AnyObserver&lt;CLLocationCoordinate2D&gt; {
    return UIBindingObserver(UIElement: self) { label, location in
        label.text = "Lat: \(location.latitude)\nLon: \(location.longitude)"
    }.asObserver()
}
</code></pre>

<p>}</p>

<p>// (7)
private extension UIView {</p>

<pre><code>var rx_driveAuthorization: AnyObserver&lt;Bool&gt; {
    return UIBindingObserver(UIElement: self) { view, authorized in
        if authorized {
            view.hidden = true
            view.superview?.sendSubviewToBack(view)
        }
        else {
            view.hidden = false
            view.superview?.bringSubviewToFront(view)
        }
    }.asObserver()
}
</code></pre>

<p>}</p>

<p>class GeolocationViewController: ViewController {</p>

<pre><code>@IBOutlet weak private var noGeolocationView: UIView!
@IBOutlet weak private var button: UIButton!
@IBOutlet weak private var button2: UIButton!
@IBOutlet weak var label: UILabel!

override func viewDidLoad() {
    super.viewDidLoad()

    let geolocationService = GeolocationService.instance

    geolocationService.authorized
        .drive(noGeolocationView.rx_driveAuthorization) // (8)
        .addDisposableTo(disposeBag)

    geolocationService.location
        .drive(label.rx_driveCoordinates) // (8)
        .addDisposableTo(disposeBag)

    button.rx_tap
        .bindNext { [weak self] in
            self?.openAppPreferences()
        }
        .addDisposableTo(disposeBag)

    button2.rx_tap
        .bindNext { [weak self] in
            self?.openAppPreferences()
        }
        .addDisposableTo(disposeBag)
}

private func openAppPreferences() {
    UIApplication.sharedApplication().openURL(NSURL(string: UIApplicationOpenSettingsURLString)!)
}
</code></pre>

<p>}
```</p>

<p>(6): <code>rx_driveCoordinates</code><br/>
見ての通りここで<code>UILabel</code>の<code>extension</code>をしています。<br/>
<code>UILabel</code>の<code>text</code>内容を任意の値で返却するために作成しています。<br/>
(<code>asObserver</code>をつけることで<code>rx_driveCoordinates</code>という<code>AnyObserver</code>型の変数定義を実現しています。)</p>

<p>(7): <code>rx_driveAuthorization</code><br/>
同じく<code>UIView</code>の<code>extension</code>をしています。<br/>
<code>authorized</code>の値でViewの表示/非表示を切り替えています。</p>

<p>(8): <code>drive</code><br/>
ここで新たにSubscriptionを生成して、引数に取ったObserverに処理の実行を要請しています。</p>

<p>今回のExampleを見てみると下記のようなメリットが感じられます。</p>

<ul>
<li>Rxを利用することで非同期処理を直列的に書ける</li>
<li>エラーハンドリングを直列的に書けることで後処理も直列的に統一して見れる(<code>jQuery</code>の<code>ajax</code>メソッドの<code>always</code>的なイメージ)</li>
<li>処理の拡張がRxで用意されたメソッドで比較的に容易に書ける</li>
</ul>


<h3>Rxで把握しておきたいAPI一覧</h3>

<p>RxSwiftをインストールすると中にドキュメントが含まれています。<br/>
<a href="https://github.com/ReactiveX/RxSwift/blob/master/Documentation/API.md">API.md</a>を読むだけでもかなり理解が進むと思われます。</p>

<p>特に言語がSwiftであるが故に他のRxフレームワークとはメソッド名が異なる場合があります。<br/>
(<code>defer</code>でなく<code>deferred</code>、<code>repeat</code>でなく<code>repeatElement</code>など)</p>

<p>一度は目を通しておくと良いかもしれません。<br/>
と言いつつ、筆者も全然見れていませんが&hellip;</p>

<h3>まとめ</h3>

<p>さて、今回は公式Exampleの1つを見るだけに留まりましたが如何でしたでしょうか？<br/>
筆者としてはRxの使い方の理解がだいぶ進んだ気がしております。<br/>
引き続きRxに関する勉強は続けていきたいと思います。<br/>
と言ったところで本日はここまで。</p>

<p>参考:</p>

<ul>
<li><a href="http://qiita.com/yuzushioh/items/0a4483502c5c8569790a">RxSwift/RxCocoa Driver Unitについてまとめてみた。</a></li>
</ul>


<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RxSwiftを勉強してみよう！]]></title>
    <link href="http://grandbig.github.io/blog/2016/08/21/rxswift-1/"/>
    <updated>2016-08-21T18:09:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2016/08/21/rxswift-1</id>
    <content type="html"><![CDATA[<h3>RxSwiftとは</h3>

<p>Reactive Extensions(以下、Rx)のSwift版です。<br/>
と一言で言っても、「Rxとはなんぞや？？」となってしまうかと思います。<br/>
(多分に漏れず、筆者もそうです&hellip;)<br/>
そこで、いろいろと調べてみると、</p>

<ul>
<li>「非同期/イベント/時間に関する処理をLINQの形式で簡潔かつ宣言的に記述すること」ができるのが特徴</li>
<li>観測可能 (observable) なシーケンスと LINQ スタイルのクエリ演算子を使って、非同期なイベントベースのプログラムを合成するライブラリ</li>
</ul>


<p>なんて話が出てきます。<br/>
確かに非同期処理はソースコードが複雑になりやすいので、何となくRxは良さそうな気がしてきました。<br/>
今回はまず触って慣れてみようということで見ていきましょう。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h3>RxSwiftでUI</h3>

<p>まずはRxSwiftの書き方を覚えるためにUI関連から見てきましょう。</p>

<h4>サンプル画面</h4>

<p>下記のように画面を作成します。<br/>
<img src="/images/rxswift_1.png" alt="サンプル画面" /></p>

<h4>RxSwiftのインストール</h4>

<p>下記のように<code>Podfile</code>を作成します。</p>

<p>```objective-c
use_frameworks!</p>

<p>target &lsquo;RxSwiftSample&rsquo; do</p>

<pre><code>pod 'RxSwift',    '~&gt; 2.0'
pod 'RxCocoa',    '~&gt; 2.0'
</code></pre>

<p>end</p>

<p>target &lsquo;RxSwiftSampleTests&rsquo; do</p>

<pre><code>pod 'RxBlocking', '~&gt; 2.0'
pod 'RxTests',    '~&gt; 2.0'
</code></pre>

<p>end</p>

<p>target &lsquo;RxSwiftSampleUITests&rsquo; do</p>

<pre><code>pod 'RxBlocking', '~&gt; 2.0'
pod 'RxTests',    '~&gt; 2.0'
</code></pre>

<p>end
```</p>

<p>そして、<code>pod install</code>を実行します。</p>

<h4>RxSwiftを用いたUIアクションを実装</h4>

<p>下記のようにアクションを実装します。</p>

<p>```objective-c
// ViewController.swift
import UIKit
import RxSwift
import RxCocoa</p>

<p>class ViewController: UIViewController {</p>

<pre><code>// UI部品
@IBOutlet weak var sampleBtn: UIButton!
@IBOutlet weak var sampleTextField: UITextField!
@IBOutlet weak var sampleLabel: UILabel!

// 自動unsubscribeのために必要
let disposeBag = DisposeBag()

override func viewDidLoad() {
    super.viewDidLoad()

    // ボタンタップアクション
    self.sampleBtn.rx_tap.subscribeNext { [unowned self] _ in
        self.showAlert()
    }.addDisposableTo(disposeBag)

    // テキストフィールドの入力アクション
    self.sampleTextField.rx_text
        .map { "Your Text is \($0)" }
        .bindTo(self.sampleTextField.rx_text)
        .addDisposableTo(disposeBag)
}

&lt;省略&gt;

func showAlert() {
    let alert = UIAlertController(title: "Sample Alert", message: "Can you see a sample alert?", preferredStyle: .Alert)
    let ok = UIAlertAction(title: "OK", style: .Default) { (action) in
        // 特に何もしない
    }
    alert.addAction(ok)
    presentViewController(alert, animated: true, completion: nil)
}
</code></pre>

<p>}
```</p>

<p>上記のUIアクションはあまりにも単純な例であるため、恩恵を受けられている気はしないですね&hellip;<br/>
いつものようにXcodeでアクションを繋げているのと同じ気がする&hellip;</p>

<h3>RxSwiftの公式Exampleを覗いてみる</h3>

<p>先ほどの例ではイマイチ良さがわからなかったので、公式のExampleを覗いてみます。<br/>
公式のExampleは<a href="https://github.com/ReactiveX/RxSwift">GitHub: ReactiveX/RxSwift</a>からダウンロードできます。</p>

<h4>NumbersViewController</h4>

<p>最も簡単なExampleはこれになるかと思います。</p>

<p>```objective-c
import Foundation
import UIKit
import RxSwift
import RxCocoa</p>

<p>class NumbersViewController: ViewController {</p>

<pre><code>@IBOutlet weak var number1: UITextField!
@IBOutlet weak var number2: UITextField!
@IBOutlet weak var number3: UITextField!

@IBOutlet weak var result: UILabel!

override func viewDidLoad() {
    super.viewDidLoad()
    // 注目！！
    Observable.combineLatest(number1.rx_text, number2.rx_text, number3.rx_text) { textValue1, textValue2, textValue3 -&gt; Int in
        return (Int(textValue1) ?? 0) + (Int(textValue2) ?? 0) + (Int(textValue3) ?? 0)
    }
    .map { $0.description }
    .bindTo(result.rx_text)
    .addDisposableTo(disposeBag)
}
</code></pre>

<p>}
```</p>

<p>ここで注目したいのは<code>Observable.combineLatest</code>です。<br/>
Exampleではこれを利用して一気に3つの<code>UITextField</code>から値を取得して、合計値を計算しています。<br/>
<code>Obsertvable.combineLatest</code>は名前から察することができると思いますが、3つの<code>UITextField</code>のいずれかの値が変わったタイミングで合計値が再計算されます。</p>

<p>これだけでも少し便利な感じが伝わってきました。</p>

<h4>SimpleValidationViewController</h4>

<p>続いて着手しやすいExampleはこちらになりそうです。</p>

<p>```objective-c
import Foundation
import UIKit
import RxSwift
import RxCocoa</p>

<p>let minimalUsernameLength = 5
let minimalPasswordLength = 5</p>

<p>class SimpleValidationViewController : ViewController {</p>

<pre><code>@IBOutlet weak var usernameOutlet: UITextField!
@IBOutlet weak var usernameValidOutlet: UILabel!
@IBOutlet weak var passwordOutlet: UITextField!
@IBOutlet weak var passwordValidOutlet: UILabel!
@IBOutlet weak var doSomethingOutlet: UIButton!

override func viewDidLoad() {
    super.viewDidLoad()

    usernameValidOutlet.text = "Username has to be at least \(minimalUsernameLength) characters"
    passwordValidOutlet.text = "Password has to be at least \(minimalPasswordLength) characters"

    // 注目！！
    let usernameValid = usernameOutlet.rx_text
        .map { $0.characters.count &gt;= minimalUsernameLength }
        .shareReplay(1)

    let passwordValid = passwordOutlet.rx_text
        .map { $0.characters.count &gt;= minimalPasswordLength }
        .shareReplay(1)

    let everythingValid = Observable.combineLatest(usernameValid, passwordValid) { $0 &amp;&amp; $1 }
        .shareReplay(1)

    usernameValid
        .bindTo(passwordOutlet.rx_enabled)
        .addDisposableTo(disposeBag)

    usernameValid
        .bindTo(usernameValidOutlet.rx_hidden)
        .addDisposableTo(disposeBag)

    passwordValid
        .bindTo(passwordValidOutlet.rx_hidden)
        .addDisposableTo(disposeBag)

    everythingValid
        .bindTo(doSomethingOutlet.rx_enabled)
        .addDisposableTo(disposeBag)

    doSomethingOutlet.rx_tap
        .subscribeNext { [weak self] in self?.showAlert() }
        .addDisposableTo(disposeBag)
}

func showAlert() {
    let alertView = UIAlertView(
        title: "RxExample",
        message: "This is wonderful",
        delegate: nil,
        cancelButtonTitle: "OK"
    )

    alertView.show()
}
</code></pre>

<p>}
```</p>

<p>ここで注目したいのは<code>shareReplay(1)</code>という記述です。<br/>
このExampleでは、<br/>
<code>username</code>のバリデーションをクリアしていれば、<code>passwordOutlet.rx_enabled</code>と<code>usernameValidOutlet.rx_hidden</code>の2つを実行するように実装されています。</p>

<p>通常だと、<code>usernameValid</code>が2回実行されてしまうところを<code>shareReplay(1)</code>をつけることで、最適な回数だけ実行してくれます。<br/>
詳しくは、<a href="http://qiita.com/kazu0620/items/bde4a65e82a10bd33f88">shareReplayをちゃんと書いてお行儀良くストリームを購読しよう</a>を読むと良いでしょう。</p>

<p>ここまで来ると<code>RxSwift</code>の有効性を許容せざるを得ませんね。</p>

<h3>まとめ</h3>

<p>今回簡単に触っただけでも、Rxはかなり有効なものであると感じました。<br/>
非同期処理や互いに関連性を持つ複雑な処理を実装する際にはぜひRxを使ってみたいと思いました。</p>

<p>本当はもっとExampleを追っていきたいのですが、一旦ここまでとさせて頂きます。<br/>
(単なる時間切れなので、続きは必ず書きたいを思っています。)</p>

<p>ということで本日はここまで。</p>

<p>参考:</p>

<ul>
<li><a href="https://github.com/ReactiveX/RxSwift">GitHub: ReactiveX/RxSwift</a></li>
<li><a href="http://qiita.com/nakailand/items/8b54dc9b4b39b0809c57">RxSwiftの道標</a></li>
<li><a href="http://qiita.com/usamik26/items/2bbd0b8d304ab42b2279">RxSwift で UIKit を扱う基本</a></li>
<li><a href="http://okapies.hateblo.jp/entry/2015/03/04/031148">関数型プログラマのための Rx 入門（前編）</a></li>
</ul>


<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
</feed>
