<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: rx | Takahiro Octopress Blog]]></title>
  <link href="http://grandbig.github.io/blog/categories/rx/atom.xml" rel="self"/>
  <link href="http://grandbig.github.io/"/>
  <updated>2018-10-20T14:43:39+09:00</updated>
  <id>http://grandbig.github.io/</id>
  <author>
    <name><![CDATA[Takahiro]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[RxSwiftを勉強してみよう！(4) ~ 成功処理と失敗処理の書き方 ~]]></title>
    <link href="http://grandbig.github.io/blog/2018/10/20/rxswift-4/"/>
    <updated>2018-10-20T13:20:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2018/10/20/rxswift-4</id>
    <content type="html"><![CDATA[<h3>はじめに</h3>

<p>本日は <code>RxSwift</code> で、『ある条件のときのみ <code>Observer</code> に伝える』方法について見ていきたいと思います。<br/>
これは例えば、</p>

<ul>
<li>処理が成功した場合のみ、何か次のアクションを実行させる</li>
<li>処理の成功/失敗で次のアクション内容を変更する</li>
</ul>


<p>場合に必要な書き方です。<br/>
では具体的に見ていきましょう。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h3>サンプルを元に書き方を学ぼう</h3>

<p>具体的なサンプルを見ながら書き方を学んでいきたいと思います。<br/>
今回のサンプルのアーキテクチャは <code>MVVM</code> を採用します。</p>

<p>各役割は</p>

<ul>
<li><code>Model</code> : ビジネスロジック</li>
<li><code>View</code> : ユーザ操作のキャッチと実描画処理</li>
<li><code>ViewModel</code> : プレゼンテーションロジック</li>
</ul>


<p>となります。<br/>
早速、サンプルを見ていきましょう。</p>

<h4>検索ボタンをタップした結果を表現する</h4>

<p>サンプルを例に考えます。</p>

<h5>サンプルの前提</h5>

<ul>
<li>検索ボタンをタップすると、レストラン検索APIを叩く</li>
<li>レストラン検索APIの取得が成功した場合、マップにレストランの場所を示すマーカを配置する</li>
<li>レストラン検索APIの取得が失敗した場合、エラーメッセージを表示する</li>
</ul>


<h5>Viewにユーザ操作のキャッチ部分を書く</h5>

<p>まずは、 <code>ViewController.swift</code> に「ユーザ操作のキャッチ」部分を書きます。<br/>
※必要のない処理は省略します。</p>

<p>```objective-c
// ViewController.swift
import UIKit
import RxSwift
import RxCocoa
import GoogleMaps</p>

<p>class ViewController: UIViewController, Injectable {</p>

<pre><code>...
// MARK: - IBOutlets
@IBOutlet weak private var mapView: GMSMapView!
@IBOutlet weak private var searchButton: UIButton!

// MARK: - Properties
private let viewModel: ViewModel
...

override func viewDidLoad() {
    super.viewDidLoad()
    ...
    bind()
}

func bind() {
  // ユーザの検索ボタンのタップ操作をキャッチ
  searchButton.rx.tap
      .bind(to: viewModel.searchButtonDidTap)
      .disposed(by: disposeBag)
}
...
</code></pre>

<p>}
```</p>

<h5>ViewModelにViewからのインプットをハンドリング&amp;レストラン検索APIを叩く</h5>

<p>続いて、上記で書いた <code>viewModel.searchButtonDidTap</code> を <code>ViewModel</code> に定義します。<br/>
<code>View</code> からユーザのタップ操作が伝えられた時に、レストラン検索APIを叩く処理も書きます。</p>

<p>```objective-c
// ViewModel.swift
import Foundation
import RxSwift
import RxCocoa
import GoogleMaps</p>

<p>final class ViewModel: Injectable {</p>

<pre><code>struct Dependency {
    let apiClient: GooglePlacesAPIClient
    let locationManager: LocationManagerClient
    let coordinate: CLLocationCoordinate2D
}
private let disposeBag = DisposeBag()
...

// MARK: PublishSubjects
private let searchButtonDidTapStream = PublishSubject&lt;Void&gt;()

// MARK: BehaviorSubjects
private let placesStream = BehaviorSubject&lt;Places&gt;(value: defaultPlaces)
private let errorStream = BehaviorSubject&lt;String&gt;(value: String())

init(with dependency: Dependency) {
    let apiClient = dependency.apiClient
    let locationManager = dependency.locationManager
    var coordinate = dependency.coordinate

    ...

    // 検索ボタンタップ時に、レストラン検索APIを叩く
    let state = searchButtonDidTapStream
        .flatMapLatest { _ -&gt; Observable&lt;Result&lt;Places&gt;&gt; in
            return apiClient.fetchRestaurants(coordinate: coordinate)
        }

    ...
}
</code></pre>

<p>}</p>

<p>// MARK: Input
extension ViewModel {</p>

<pre><code>var searchButtonDidTap: AnyObserver&lt;()&gt; {
    return searchButtonDidTapStream.asObserver()
}
</code></pre>

<p>}</p>

<p>// MARK: Output
extension ViewModel {</p>

<pre><code>var places: Observable&lt;Places&gt; {
    return placesStream.asObservable()
}

var error: Observable&lt;String&gt; {
    return errorStream.asObservable()
}
</code></pre>

<p>}
```</p>

<p>上記のように、 <code>View</code> からのインプットとして <code>searchButtonDidTap</code> プロパティを用意します。<br/>
インプットがあった場合に、 <code>searchButtonDidTapStream.asObserver()</code> することで、呼び出しを伝搬する仕組みになっています。<br/>
その中で <code>apiClient.fetchRestaurants(coordinate: coordinate)</code> を叩いています。</p>

<h5>ViewModelにレストラン検索APIの取得成功/失敗の処理を書く：パターン１</h5>

<p>この <code>apiClient.fetchRestaurants(coordinate: coordinate)</code> の結果次第で <code>View</code> に表示させる処理を変えたいと思います。<br/>
<code>GooglePlacesAPIClient</code> クラスの <code>fetchRestaurants</code> の戻り値の定義は以下とします。</p>

<p><code>objective-c
func fetchRestaurants(coordinate: CLLocationCoordinate2D) -&gt; Observable&lt;Result&lt;Places&gt;&gt;
</code></p>

<p>上記の <code>Result</code> と <code>Places</code> の定義は以下とします。</p>

<p>```objective-c
// Result.swift
enum Result<T> {</p>

<pre><code>case success(T)
case failure(error: Error)
</code></pre>

<p>}</p>

<p>// Places.swift
public struct Places: Codable {</p>

<pre><code>public var results: [Place]
public var status: String
public var htmlAttributions: [String]
</code></pre>

<p>}
```</p>

<p><code>Place</code> の定義の紹介は省略します。</p>

<p>準備ができたので、レストラン検索APIの取得成功/失敗の処理を見ていきましょう。</p>

<p>```objective-c
// ViewModel.swift
private static let defaultPlaces = Places(results: [], status: R.string.common.ok(), htmlAttributions: [])</p>

<p>&hellip;</p>

<p>// 検索ボタンタップ時
let state = searchButtonDidTapStream</p>

<pre><code>.flatMapLatest { _ -&gt; Observable&lt;Result&lt;Places&gt;&gt; in
    return apiClient.fetchRestaurants(coordinate: coordinate)
}
</code></pre>

<p>// 処理が成功した場合
state</p>

<pre><code>.flatMapLatest { result -&gt; Observable&lt;Places&gt; in
    switch result {
    case let .success(value):
        return Observable.just(value)
    default:
        return Observable.just(ViewModel.defaultPlaces)
    }
}
.bind(to: placesStream)
.disposed(by: disposeBag)
</code></pre>

<p>// 処理が失敗した場合
state</p>

<pre><code>.flatMapLatest { result -&gt; Observable&lt;String&gt; in
    switch result {
    case let .failure(error):
        return Observable.just(error.localizedDescription)
    default:
        return Observable.just(String())
    }
}
.bind(to: errorStream)
.disposed(by: disposeBag)
</code></pre>

<p>```</p>

<p>上記では、処理が成功した場合と失敗した場合の処理を書いています。<br/>
処理が成功した場合はアウトプットである <code>placesStream</code> を経由して <code>View</code> に描画指示を出しています。<br/>
処理が失敗した場合はアウトプットである <code>errorStream</code> を経由して <code>View</code> に描画指示を出しています。</p>

<h5>Viewに描画処理を書く</h5>

<p><code>ViewModel</code> から指示の渡った後に <code>View</code> で実際に描画する処理を書きます。</p>

<p>```objective-c
// ViewController.swift
private func bind() {
  &hellip;
  viewModel.places</p>

<pre><code>  .bind { [weak self] places in
      guard let strongSelf = self else { return }
      let results = places.results
      if results.count &gt; 0 {
          strongSelf.mapView.clear()
          results.forEach({ (place) in
              // マップにマーカを配置します
              strongSelf.putMarker(place: place)
          })
      }
  }
  .disposed(by: disposeBag)
</code></pre>

<p>  viewModel.error</p>

<pre><code>  .bind { [weak self] message in
      guard let strongSelf = self else { return }
      if message.count == 0 { return }
      // エラーメッセージをアラートに表示します
      strongSelf.showAlert(message: message, completion: {})
  }
  .disposed(by: disposeBag)
</code></pre>

<p>}
```</p>

<h5>ViewModelにレストラン検索APIの取得成功/失敗の処理を書く：パターン２</h5>

<p>パターン１で手法を一つ書きましたが、筆者的には</p>

<ul>
<li><code>View</code> に条件分岐などのロジックが必要になってしまう</li>
<li><code>ViewModel</code> で <code>bind</code> 先のオブジェクトの型は1つなので無駄な処理を書かざるを得ない

<ul>
<li>処理成功の場合の <code>return Observable.just(ViewModel.defaultPlaces)</code></li>
<li>処理失敗の場合の <code>return Observable.just(String())</code></li>
</ul>
</li>
</ul>


<p>というところが微妙だと感じています。</p>

<p>上記を踏まえて、もう１つ別の方法を書きます。</p>

<p>```objective-c
// ViewModel.swift
// 検索ボタンタップ時
searchButtonDidTapStream</p>

<pre><code>.flatMapLatest { _ -&gt; Observable&lt;Result&lt;Places&gt;&gt; in
    return apiClient.fetchRestaurants(coordinate: coordinate)
}.subscribe { [weak self] event in
    guard let strongSelf = self else { return }
    guard let element = event.element else { return }
    switch element {
    case let .success(result):
        Observable.just(result)
            .bind(to: strongSelf.placesStream)
            .disposed(by: strongSelf.disposeBag)
    case let .failure(error):
        Observable.just(error.localizedDescription)
            .bind(to: strongSelf.errorStream)
            .disposed(by: strongSelf.disposeBag)
    }
</code></pre>

<p>}.disposed(by: disposeBag)
```</p>

<p>これであれば、 <code>View</code> の方のロジックも下記のように多少減らすことができ、スッキリします。<br/>
( あっても困らない条件分岐ではありますけどね&hellip; )</p>

<p>```objective-c
// ViewController.swift
private func bind() {
  &hellip;
  viewModel.places</p>

<pre><code>  .bind { [weak self] places in
      guard let strongSelf = self else { return }
      let results = places.results
      strongSelf.mapView.clear()
      results.forEach({ (place) in
          // マップにマーカを配置します
          strongSelf.putMarker(place: place)
      })
  }
  .disposed(by: disposeBag)
</code></pre>

<p>  viewModel.error</p>

<pre><code>  .bind { [weak self] message in
      guard let strongSelf = self else { return }
      // エラーメッセージをアラートに表示します
      strongSelf.showAlert(message: message, completion: {})
  }
  .disposed(by: disposeBag)
</code></pre>

<p>}
```</p>

<h3>まとめ</h3>

<p>さて如何でしたでしょうか？<br/>
筆者的には、まだまだ全然 <code>RxSwift</code> の修行が足りないので、もっと良い書き方を学んでいきたいと思います。<br/>
と言ったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[カスタムDelegateのRx対応]]></title>
    <link href="http://grandbig.github.io/blog/2018/10/14/popuppickerview-rx/"/>
    <updated>2018-10-14T22:52:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2018/10/14/popuppickerview-rx</id>
    <content type="html"><![CDATA[<h3>はじめに</h3>

<p>先日、<a href="https://grandbig.github.io/blog/2018/10/06/rx-delegate/">GeolocationSampleから学ぶdelegateのRx対応</a>を紹介しました。<br/>
今回は<a href="https://grandbig.github.io/blog/2018/10/13/popuppickerview/">下からニュッと出るPickerを作ろう！</a>で作成した <code>PickerView</code> に実装されている <code>Delegate</code> を <code>Rx</code> 対応させたいと思います。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h3>PickerViewクラスの確認</h3>

<p>まずは、元となる <code>PickerView</code> クラスを提示します。</p>

<p>```objective-c
import Foundation
import UIKit</p>

<p>/// ピッカービュー
public class PickerView: UIView {</p>

<pre><code>// MARK: - IBOutlets
@IBOutlet weak var toolBar: UIToolbar!
@IBOutlet weak var picker: UIPickerView!

// MARK: - Static Properties
static private let screenWidth = UIScreen.main.bounds.size.width
static private let screenHeight = UIScreen.main.bounds.size.height
static private let defaultPickerHeight: CGFloat = 260.0
static private let duration = 0.2

// MARK: - Properties
public weak var delegate: PickerViewDelegate?
private var selectItems = [String]()
private var selectedRowIndex: Int = 0

// MARK: - Initial Methods
required init(frame: CGRect = CGRect(x: 0, y: screenHeight, width: screenWidth, height: defaultPickerHeight),
              selectItems: [String]) {
    var frame = frame
    if let safeAreaTopInsets = UIApplication.shared.keyWindow?.safeAreaInsets.top, safeAreaTopInsets &gt; CGFloat(0.0) {
        // iPhoneX , XS, XS MAX, XRの場合はUIPickerViewの高さを調整する
        frame = CGRect(x: 0, y: frame.origin.y, width: frame.size.width, height: (frame.size.height + 100.0))
    }
    super.init(frame: frame)
    self.selectItems = selectItems
    self.xibViewSet()
}

required init?(coder aDecoder: NSCoder) {
    super.init(coder: aDecoder)!
    self.xibViewSet()
}

internal func xibViewSet() {
    if let view = R.nib.pickerView.firstView(owner: self) {
        view.frame = self.bounds
        self.addSubview(view)

        picker.delegate = self
        picker.dataSource = self
        picker.showsSelectionIndicator = true
    }
}

// MARK: - Picker Move Function
// PickerViewを表示する
func showPickerView() {
    let pickerViewWidth = self.frame.size.width
    let pickerViewHeight = self.frame.size.height
    let pickerViewYPosition = PickerView.screenHeight - pickerViewHeight
    UIView.animate(withDuration: PickerView.duration) {
        self.frame = CGRect.init(x: 0, y: pickerViewYPosition, width: pickerViewWidth, height: pickerViewHeight)
    }
}

// PickerViewを非表示にする
func hiddenPickerView() {
    let pickerViewWidth = self.frame.size.width
    let pickerViewHeight = self.frame.size.height
    UIView.animate(withDuration: PickerView.duration) {
        self.frame = CGRect.init(x: 0, y: PickerView.screenHeight, width: pickerViewWidth, height: pickerViewHeight)
    }
}

// MARK: - IBActions
@IBAction func cancelSelection(_ sender: Any) {
    delegate?.closePickerView()
    hiddenPickerView()
}

@IBAction func doneSelection(_ sender: Any) {
    delegate?.selectedItem(index: selectedRowIndex, title: selectItems[selectedRowIndex])
    hiddenPickerView()
}
</code></pre>

<p>}</p>

<p>/// MARK: &ndash; UIPickerViewDelegate
extension PickerView: UIPickerViewDelegate {</p>

<pre><code>public func pickerView(_ pickerView: UIPickerView, titleForRow row: Int, forComponent component: Int) -&gt; String? {
    return selectItems[row]
}

public func pickerView(_ pickerView: UIPickerView, didSelectRow row: Int, inComponent component: Int) {
    selectedRowIndex = row
}
</code></pre>

<p>}</p>

<p>/// MARK: &ndash; UIPickerViewDataSource
extension PickerView: UIPickerViewDataSource {</p>

<pre><code>public func numberOfComponents(in pickerView: UIPickerView) -&gt; Int {
    return 1
}

public func pickerView(_ pickerView: UIPickerView, numberOfRowsInComponent component: Int) -&gt; Int {
    return selectItems.count
}
</code></pre>

<p>}</p>

<p>/// MARK: &ndash; PickerViewDelegate
@objc
public protocol PickerViewDelegate: class {</p>

<pre><code>func selectedItem(index: Int, title: String)
func closePickerView()
</code></pre>

<p>}
```</p>

<p>では早速 <code>Rx</code> 対応させていきましょう。</p>

<h3>DelegateProxyとDelegateProxyTypeへの対応</h3>

<p>基本的には、 <code>CLLocationManagerDelegate</code> と同じです。<br/>
<code>DelegateProxy</code> と <code>DelegateProxyType</code> を継承したクラスを実装します。</p>

<p>```objective-c
import Foundation
import RxSwift
import RxCocoa</p>

<p>// 説明(1)
extension PickerView: HasDelegate {</p>

<pre><code>public typealias Delegate = PickerViewDelegate
</code></pre>

<p>}</p>

<p>public class RxPickerViewDelegateProxy: DelegateProxy&lt;PickerView, PickerViewDelegate>,</p>

<pre><code>DelegateProxyType,
PickerViewDelegate {

public init(pickerView: PickerView) {
    super.init(parentObject: pickerView, delegateProxy: RxPickerViewDelegateProxy.self)
}

// 説明(2)
public static func registerKnownImplementations() {
    self.register { RxPickerViewDelegateProxy(pickerView: $0) }
}

// 説明(3)
internal lazy var selectedItemSubject = PublishSubject&lt;(Int, String)&gt;()
internal lazy var closePickerViewSubject = PublishSubject&lt;Void&gt;()

// 説明(4)
public func selectedItem(index: Int, title: String) {
    selectedItemSubject.onNext((index, title))
}

public func closePickerView() {
    closePickerViewSubject.onNext(Void())
}

// 説明(5)
deinit {
    self.selectedItemSubject.on(.completed)
    self.closePickerViewSubject.on(.completed)
}
</code></pre>

<p>}
```</p>

<p>細かく見ていきましょう。</p>

<h4>説明(1)</h4>

<p><code>currentDelegate</code> および <code>setCurrentDelegate</code> に対応する代わりに、 <code>HasDelegate</code> を継承させましょう。</p>

<h4>説明(2)</h4>

<p>自身で定義した <code>DelegateProxy</code> の継承クラスを登録するために、 <code>registerKnownImplementations</code> 内で <code>DelegateProxySubclass.register()</code> を実行します。</p>

<h4>説明(3)</h4>

<p><code>delegate</code> メソッドが呼び出されて処理が実行されたことを <code>Subscriber</code> に伝えるために、 <code>PublishSubject</code> 型のプロパティを用意します。</p>

<h4>説明(4)</h4>

<p><code>PickerViewDelegate</code> の <code>selectedItem(index:title:)</code> と <code>closePickerView()</code> メソッドは必須メソッドです。<br/>
<code>RxPickerViewDelegateProxy</code> はもちろん <code>PickerViewDelegate</code> も継承しますので、上記2つのメソッドを定義する必要があります。</p>

<p>これが呼び出されたタイミングで <code>Subscriber</code> に伝えるために、 <code>PublishSubject.onNext(element:)</code> を実行します。</p>

<h4>説明(5)</h4>

<p><code>deinit</code> が呼ばれるタイミングで、初期化したオブジェクトが破棄されるので、<br/>
<code>PublishSubject</code> からイベント送信完了を知らせるように実装しましょう。</p>

<h3>ReactiveへのPickerViewの適応</h3>

<p>これも <code>CLLocationManager</code> と適応方法は同じです。<br/>
まずは、全体像から&hellip;</p>

<p>```objective-c
// PickerView+Rx.swift
import Foundation
import RxSwift
import RxCocoa</p>

<p>extension Reactive where Base: PickerView {</p>

<pre><code>// 説明(1)
public var delegate: DelegateProxy&lt;PickerView, PickerViewDelegate&gt; {
    return RxPickerViewDelegateProxy.proxy(for: base)
}

// 説明(2)
public var selectedItem: Observable&lt;(Int, String)&gt; {
    return RxPickerViewDelegateProxy.proxy(for: base).selectedItemSubject.asObservable()
}

public var closePickerView: Observable&lt;Void&gt; {
    return RxPickerViewDelegateProxy.proxy(for: base).closePickerViewSubject.asObservable()
}
</code></pre>

<p>}
```</p>

<p>1つずつ説明します。</p>

<h4>説明(1)</h4>

<p><code>delegate</code> を <code>DelegateProxy</code> 型として定義します。<br/>
<code>DelegateProxy</code> の取得は <code>DelegateProxyType</code> プロトコルの <code>proxy</code> メソッドを利用します。</p>

<h4>説明(2)</h4>

<p>各 <code>delegate</code> メソッドが実行されたことを補足(監視)するために <code>Observable</code> 型の <code>selectedItem</code> と <code>closePickerView</code> を用意します。</p>

<h3>利用方法</h3>

<p>では、早速利用してみましょう。</p>

<p>```objective-c
// ViewController.swift</p>

<p>private let disposeBag = DisposeBag()</p>

<p>private func bind() {
  pickerView?.rx.selectedItem</p>

<pre><code>  .asObservable()
  .subscribe({ [weak self] event in
      // Subscriberとして補足した情報を取得
      guard let strongSelf = self else { return }
      guard let index = event.element?.0 else { return }
      guard let title = event.element?.1 else { return }

      Observable.just(index, title)
          // ViewModelにsampleActionが定義されているとします
          .bind(to: strongSelf.viewModel.sampleAction)
          .disposed(by: strongSelf.disposeBag)
          })
          .disposed(by: disposeBag)
</code></pre>

<p>}
```</p>

<p>上記のような形で <code>ViewController</code> にて <code>Subscriber</code> としてアクションを補足し、 <code>ViewModel</code> に伝えることができるでしょう。</p>

<h3>まとめ</h3>

<p>さて、如何でしたでしょうか？<br/>
1つ1つの意味を理解することはもちろん大切ですが、<br/>
何だか型にはまって書き方を覚えれば、自身で <code>Rx</code> 対応が簡単にできる気がしてきますね。</p>

<p><code>Rx</code> の癖が強いが故に、慣れれば利用しやすいということなのでしょう。<br/>
と言ったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GeolocationSampleから学ぶdelegateのRx対応]]></title>
    <link href="http://grandbig.github.io/blog/2018/10/06/rx-delegate/"/>
    <updated>2018-10-06T11:16:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2018/10/06/rx-delegate</id>
    <content type="html"><![CDATA[<h3>はじめに</h3>

<p><code>RxSwift</code> を利用して <code>MVVM</code> アーキテクチャでアプリを開発することがあるでしょう。<br/>
その際に、ボタンタップやネットワーク通信であれば、何もやらずとも <code>RxSwift</code> が対応してくれていたり、 <code>RxSwift</code> に対応しているライブラリがあったりします。</p>

<p>しかし、デフォルトでは <code>RxSwift</code> に対応していない場合も当然あります。<br/>
ではそんなとき、どのようにして対応すれば良いでしょうか。</p>

<p>今日は、 <code>delegate</code> の <code>Rx</code> 対応について公式サンプルの <code>GeolocationSample</code> を元に説明してみたいと思います。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h3>delegateのRx対応方法</h3>

<p>早速具体的に方法を見ていきましょう。<br/>
今回は公式サンプルの <code>GeolocationSample</code> を元に、 <code>CLLocationManagerDelegate</code> を <code>Rx</code> に対応させる方法を説明します。</p>

<h4>DelegateProxyとDelegateProxyTypeへの対応</h4>

<p><code>delegate</code> の <code>Rx</code> 対応でまず必要なことは</p>

<ul>
<li><code>DelegateProxy</code> クラスを継承するクラスを作成すること</li>
<li><code>DelegateProxyType</code> プロトコルを継承するクラスを作成すること</li>
</ul>


<p>です。<br/>
ここでは上記2つの条件を満たした <code>RxCLLocationManagerDelegateProxy</code> クラスを作ることとします。</p>

<h5>DelegateProxyの説明</h5>

<p><code>DelegateProxy.swift</code> を見てみると、下記のように定義されています。</p>

<p>```objective-c
// DelegateProxy.swift</p>

<p>/// Base class for <code>DelegateProxyType</code> protocol.
///
/// This implementation is not thread safe and can be used only from one thread (Main thread).
open class DelegateProxy&lt;P: AnyObject, D>: _RXDelegateProxy {</p>

<pre><code>public typealias ParentObject = P
public typealias Delegate = D
...
</code></pre>

<p>}
```</p>

<p>この <code>DelegateProxy</code> は <code>DelegateProxyType</code> プロトコルのベースクラスと説明されています。<br/>
<code>DelegateProxy</code> はジェネリッククラスであり、2つのパラメータ <code>P</code> と <code>D</code> を持ちます。</p>

<p>ここで、 <code>P</code> と <code>D</code> について説明します。</p>

<ul>
<li><code>D</code> :<br/>
<code>Rx</code> に対応させたい <code>delegate</code> を指定します<br/>
<code>D</code> は <code>Delegate</code> の頭文字と思われます</li>
<li><code>P</code> :<br/>
<code>delegate</code> である <code>D</code> をプロパティとして持つオブジェクトを指定します<br/>
<code>P</code> は <code>ParentObject</code> の頭文字と思われます</li>
</ul>


<p>今回の場合は、<br/>
<code>DelegateProxy&lt;CLLocationManager, CLLocationManagerDelegate&gt;</code> になります。</p>

<h5>DelegateProxyTypeの説明</h5>

<p><code>DelegateProxyType.swift</code> の中身を見てみると、下記のように説明されています。</p>

<p>```objective-c
// DelegateProxyType.swift</p>

<p>/**
<code>DelegateProxyType</code> protocol enables using both normal delegates and Rx observable sequences with
views that can have only one delegate/datasource registered.
&hellip;</p>

<p>*/
```</p>

<p>意訳すると、<br/>
<code>DelegateProxyType</code> は <code>delegate</code> と <code>Rx</code> との紐付けを実現するプロトコル<br/>
であることを指しています。</p>

<p>方式は図示化されていますので、見てみると何となく理解できると思います。<br/>
図では <code>UIScrollViewDelegate</code> を例に説明されています。</p>

<p>```objective-c
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+
|                                           |                         <br/>
| UIView subclass (UIScrollView)            |                         <br/>
|                                           |
+&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+</p>

<pre><code>        |                                                           
        | Delegate                                                  
        |                                                           
        |                                                           
</code></pre>

<p>+&mdash;&mdash;&mdash;&mdash;&mdash;-v&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+                         <br/>
|                                           |                         <br/>
| Delegate proxy : DelegateProxyType        +&mdash;&mdash;&ndash;+&mdash;&mdash;>  Observable<T1>
|                , UIScrollViewDelegate     |     |
+&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+     +&mdash;&mdash;>  Observable<T2></p>

<pre><code>        |                                     |                     
        |                                     +----&gt;  Observable&lt;T3&gt;
        |                                     |                     
        | forwards events                     |
        | to custom delegate                  |
        |                                     v                     
</code></pre>

<p>+&mdash;&mdash;&mdash;&mdash;&mdash;-v&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+                         <br/>
|                                           |                         <br/>
| Custom delegate (UIScrollViewDelegate)    |                         <br/>
|                                           |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+ <br/>
```</p>

<p>また <code>DelegateProxyType</code> は以下3つの <code>static</code> メソッドを定義しているため、<br/>
<code>DelegateProxyType</code> を継承すると、必ずこの3つのメソッドを持つ必要があります。</p>

<ul>
<li><code>registerKnownImplementations</code><br/>
このメソッドの中で必ず <code>DelegateProxySubclass.register()</code> を実行します。<br/>
これをすることで自身で定義した <code>DelegateProxy</code> の継承クラスを登録することができます。</li>
<li><code>currentDelegate</code><br/>
<code>ParentObject</code> の持つ <code>delegate</code> を返却する処理を書きます。</li>
<li><code>setCurrentDelegate</code><br/>
<code>ParentObject</code> に持つべき <code>delegate</code> を設定する処理を書きます。</li>
</ul>


<p>特に特殊なことをしない場合は、<br/>
<code>delegate</code> をプロパティとして持つオブジェクトである <code>ParentObject</code>に<br/>
<code>HasDelegate</code> プロトコルを継承させます。 　</p>

<p>```objective-c
extension CLLocationManager: HasDelegate {</p>

<pre><code>public typealias Delegate = CLLocationManagerDelegate
</code></pre>

<p>}
```</p>

<p>これにより、 <code>currentDelegate</code> と <code>setCurrentDelegate</code> を省略することができます。</p>

<h5>対応したコードを書いてみる</h5>

<p>基本的な説明は以上として、実際にコードに起こしてみましょう。<br/>
まずは結果から。</p>

<p>```objective-c
import RxSwift      // ここは必須
import RxCocoa      // ここは必須
import CoreLocation //  CLLocationManagerDelegateはCoreLocation内に定義されています</p>

<p>// currentDelegateとsetCurrentDelegateの役割を担います
extension CLLocationManager: HasDelegate {</p>

<pre><code>public typealias Delegate = CLLocationManagerDelegate
</code></pre>

<p>}</p>

<p>// DelegateProxy, DelegateProxyType, CLLocationManagerDelegateを継承
// DelegateをRxに対応させるために、元となるDelegateも継承が必須です
public class RxCLLocationManagerDelegateProxy: DelegateProxy&lt;CLLocationManager, CLLocationManagerDelegate>,</p>

<pre><code>DelegateProxyType,
CLLocationManagerDelegate {

// 初期化処理
public init(locationManager: CLLocationManager) {
    super.init(parentObject: locationManager, delegateProxy: RxCLLocationManagerDelegateProxy.self)
}

// 必須のstaticメソッド
public static func registerKnownImplementations() {
    // 説明(1)
    self.register { (locationManager) -&gt; RxCLLocationManagerDelegateProxy in
        RxCLLocationManagerDelegateProxy(locationManager: locationManager)
    }
}

// 説明(2)
internal lazy var didUpdateLocationsSubject = PublishSubject&lt;[CLLocation]&gt;()
internal lazy var didFailWithErrorSubject = PublishSubject&lt;Error&gt;()

// 説明(3)
public func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
    _forwardToDelegate?.locationManager(manager, didUpdateLocations: locations)
    didUpdateLocationsSubject.onNext(locations)
}

public func locationManager(_ manager: CLLocationManager, didFailWithError error: Error) {
    _forwardToDelegate?.locationManager(manager, didFailWithError: error)
    didFailWithErrorSubject.onNext(error)
}

// 説明(4)
deinit {
    self.didUpdateLocationsSubject.on(.completed)
    self.didFailWithErrorSubject.on(.completed)
}
</code></pre>

<p>}
```</p>

<p>上記ソースコードを一部補足説明します。</p>

<h6>説明(1)</h6>

<p><code>registerKnownImplementations</code> で説明した通り <code>register</code> メソッドを実行しています。<br/>
<code>register</code> メソッドは、</p>

<p>```objective-c
/// Store DelegateProxy subclass to factory.
/// When make &lsquo;Rx<em>DelegateProxy&rsquo; subclass, call &lsquo;Rx</em>DelegateProxySubclass.register(for:_)&rsquo; 1 time, or use it in DelegateProxyFactory
/// &lsquo;Rx*DelegateProxy&rsquo; can have one subclass implementation per concrete ParentObject type.
/// Should call it from concrete DelegateProxy type, not generic.
public static func register<Parent>(make: @escaping (Parent) &ndash;> Self) {</p>

<pre><code>self.factory.extend(make: make)
</code></pre>

<p>}
```</p>

<p>と定義されています。</p>

<p>クロージャの引数に <code>ParentObject</code> を必要とし、<br/>
そのクラス自身を戻り値を必要としているため、<br/>
<code>ParentObject</code> として <code>locationManager</code> を渡し、<br/>
それを元に初期化した <code>RxCLLocationManagerDelegateProxy</code> オブジェクトを戻り値として渡しています。</p>

<p>ここは説明のため省略書きしませんでしたが、</p>

<p>```objective-c
public static func registerKnownImplementations() {</p>

<pre><code>self.register { RxCLLocationManagerDelegateProxy(locationManager: $0) }
</code></pre>

<p>}
```</p>

<p>とも当然書けます。</p>

<h6>説明(2)</h6>

<p><code>PublishSubject</code> 型のプロパティを2つ定義しています。</p>

<p><code>objective-c
internal lazy var didUpdateLocationsSubject = PublishSubject&lt;[CLLocation]&gt;()
internal lazy var didFailWithErrorSubject = PublishSubject&lt;Error&gt;()
</code></p>

<p>これは説明(3)にも関わるのですが、<br/>
<code>delegate</code> メソッドが呼び出されて処理が実行されたことを <code>Subscriber</code> に伝えるために定義が必要となります。</p>

<h6>説明(3)</h6>

<p><code>delegate</code> メソッドを <code>Rx</code> で対応するための方法が、まさにココで直接的に書かれています。</p>

<p>```objective-c
public func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {</p>

<pre><code>_forwardToDelegate?.locationManager(manager, didUpdateLocations: locations)
didUpdateLocationsSubject.onNext(locations)
</code></pre>

<p>}
```</p>

<p>今回は、 <code>didUpdateLocations</code> で取得した <code>locations</code> の情報を <code>Rx</code> 連携させるために、上記のように記述しています。<br/>
先程説明した <code>PublishSubject</code> が <code>Subscriber</code> にメソッドの実行タイミングでデータを伝える方法ですが、<br/>
<code>didUpdateLocationsSubject.onNext(locations)</code> で実行しています。</p>

<p><code>_forwardToDelegate?.locationManager(manager, didUpdateLocations: locations)</code> はメモリ観点から<br/>
<code>delegate</code> を引き続き利用していることを伝えるために利用しているように見えます。</p>

<h6>説明(4)</h6>

<p>最後に <code>deinit</code> 内で実行している処理ですが、<br/>
<code>deinit</code> が呼ばれるということは初期化したオブジェクトが破棄される時なので、イベントが送られることはないはずです。<br/>
よって <code>PublishSubject</code> からイベント送信完了を知らせるように実装しましょう。</p>

<h4>ReactiveへのCLLocationManagerの適応</h4>

<p>事前準備が整ったため、実際に <code>CLLocationManager</code> を <code>Rx</code> 適応させてみます。</p>

<p><code>RxSwift</code> では下記のように書くことで拡張できる仕組みを用意しています。</p>

<p>```objective-c
// CLLocationManager+Rx.swift
import CoreLocation
import RxSwift
import RxCocoa</p>

<p>extension Reactive where Base: CLLocationManager {</p>

<pre><code>...
</code></pre>

<p>}
```</p>

<p>これが可能な理由は <code>Reactive.swift</code> を見てみると良いでしょう。</p>

<p>```objective-c
public struct Reactive<Base> {</p>

<pre><code>/// Base object to extend.
public let base: Base

/// Creates extensions with base object.
///
/// - parameter base: Base object.
public init(_ base: Base) {
    self.base = base
}
</code></pre>

<p>}
```</p>

<p>そして、拡張した後にやることは下記です。</p>

<ul>
<li><code>delegate</code> のラッパーを生成する</li>
<li>各 <code>delegate</code> メソッドに対応したラッパープロパティを生成する</li>
<li>キャストメソッドを用意する</li>
</ul>


<p>1つずつ説明していきましょう。</p>

<h5>delegateのラッパーを生成する</h5>

<p>このラッパーは <code>delegate</code> を <code>DelegateProxy</code> 型として定義します。<br/>
この <code>delegate</code> はもちろん <code>readOnly</code> で値の取得のみできるものとします。<br/>
<code>DelegateProxy</code> の取得は <code>DelegateProxyType</code> プロトコルの <code>proxy</code> メソッドを利用します。</p>

<p><code>``objective-c
/**
Reactive wrapper for</code>delegate`.</p>

<p>For more information take a look at <code>DelegateProxyType</code> protocol documentation.
*/
public var delegate: DelegateProxy&lt;CLLocationManager, CLLocationManagerDelegate> {</p>

<pre><code>return RxCLLocationManagerDelegateProxy.proxy(for: base)
</code></pre>

<p>}
```</p>

<h5>各delegateメソッドに対応したラッパープロパティを生成する</h5>

<p><code>RxCLLocationManagerDelegateProxy</code> で <code>didUpdateLocations</code> と <code>didFailWithError</code> の <code>delegate</code> メソッドに対応しました。<br/>
これらのメソッドに対応したラッパープロパティは以下のように実装します。</p>

<p>```objective-c
// MARK: Responding to Location Events</p>

<p>/<em>*
 Reactive wrapper for <code>delegate</code> message.
 </em>/
 public var didUpdateLocations: Observable&lt;[CLLocation]> {</p>

<pre><code>return RxCLLocationManagerDelegateProxy.proxy(for: base).didUpdateLocationsSubject.asObservable()
</code></pre>

<p>}</p>

<p>/<em>*
 Reactive wrapper for <code>delegate</code> message.
 </em>/
public var didFailWithError: Observable<Error> {</p>

<pre><code>return RxCLLocationManagerDelegateProxy.proxy(for: base).didFailWithErrorSubject.asObservable()
</code></pre>

<p>}
```</p>

<p>これらも <code>readOnly</code> で値のみを <code>Observable</code> 型で取得できるように定義しています。</p>

<h5>キャストメソッドを用意する</h5>

<p>キャストメソッドを用意する理由は、<br/>
あるメソッドの処理の完了タイミングで何らかの処理を実行させたい<br/>
<code>methodInvoked</code> を利用するときに必要になります。</p>

<p>処理は下記の通りです。<br/>
<code>Optional</code> 型の場合とそうでない場合が必要になる可能性がありますので、2種類用意しています。</p>

<p>```objective-c
fileprivate func castOrThrow<T>(_ resultType: T.Type, _ object: Any) throws &ndash;> T {</p>

<pre><code>guard let returnValue = object as? T else {
    throw RxCocoaError.castingError(object: object, targetType: resultType)
}

return returnValue
</code></pre>

<p>}</p>

<p>fileprivate func castOptionalOrThrow<T>(_ resultType: T.Type, _ object: Any) throws &ndash;> T? {</p>

<pre><code>if NSNull().isEqual(object) {
    return nil
}

guard let returnValue = object as? T else {
    throw RxCocoaError.castingError(object: object, targetType: resultType)
}

return returnValue
</code></pre>

<p>}
```</p>

<p>今回の場合、端末の位置情報を利用するので、 <code>CLLocationManagerDelegate</code> の <code>didChangeAuthorization</code> のハンドリングが必須になります。<br/>
この <code>delegate</code> メソッドは定期的に繰り返し利用する必要はありません。<br/>
状態が変わって、その情報を必要となったタイミングでだけ利用できれば良いのです。<br/>
よって <code>methodInvoked</code> を利用してプロパティを定義します。</p>

<p>```objective-c
// MARK: Responding to Authorization Changes</p>

<p>/<em>*
 Reactive wrapper for <code>delegate</code> message.
 </em>/
public var didChangeAuthorizationStatus: Observable<CLAuthorizationStatus> {</p>

<pre><code>return delegate.methodInvoked(#selector(CLLocationManagerDelegate.locationManager(_:didChangeAuthorization:)))
    .map { a in
        let number = try castOrThrow(NSNumber.self, a[1])
        return CLAuthorizationStatus(rawValue: Int32(number.intValue)) ?? .notDetermined
}
</code></pre>

<p>}
```</p>

<p>以上で必要な対応は全て完了です。</p>

<h3>Rxに対応したdelegateの使い方</h3>

<p>自作した <code>Rx</code> 対応後の <code>delegate</code> を利用する例も見ていきましょう。</p>

<h4>処理ロジックの実装</h4>

<p>公式サンプルでは処理ロジックに相当する <code>GeolocationService.swift</code> を下記のように実装しています。</p>

<p>```objective-c
// GeolocationService.swift
import CoreLocation
import RxSwift
import RxCocoa</p>

<p>class GeolocationService {</p>

<pre><code>static let instance = GeolocationService()
// 説明(1)
private (set) var authorized: Driver&lt;Bool&gt;
private (set) var location: Driver&lt;CLLocationCoordinate2D&gt;

private let locationManager = CLLocationManager()

private init() {

    locationManager.distanceFilter = kCLDistanceFilterNone
    locationManager.desiredAccuracy = kCLLocationAccuracyBestForNavigation

    // 説明(2)
    authorized = Observable.deferred { [weak locationManager] in
            let status = CLLocationManager.authorizationStatus()
            guard let locationManager = locationManager else {
                return Observable.just(status)
            }
            return locationManager
                .rx.didChangeAuthorizationStatus
                .startWith(status)
        }
        .asDriver(onErrorJustReturn: CLAuthorizationStatus.notDetermined)
        .map {
            switch $0 {
            case .authorizedAlways:
                return true
            default:
                return false
            }
        }

    // 説明(3)
    location = locationManager.rx.didUpdateLocations
        .asDriver(onErrorJustReturn: [])
        .flatMap {
            return $0.last.map(Driver.just) ?? Driver.empty()
        }
        .map { $0.coordinate }

    locationManager.requestAlwaysAuthorization()
    locationManager.startUpdatingLocation()
}
</code></pre>

<p>}
```</p>

<p>1つずつ説明していきましょう。</p>

<h5>説明(1)</h5>

<p>今回のサンプルは、</p>

<ul>
<li>位置情報の利用を許可したら、画面が切り替わる</li>
<li>取得した最新の位置情報を画面に表示する</li>
</ul>


<p>という、データ結果を画面に直接反映させる処理が含まれています。<br/>
よって、</p>

<p><code>objective-c
private (set) var authorized: Driver&lt;Bool&gt;
private (set) var location: Driver&lt;CLLocationCoordinate2D&gt;
</code></p>

<p>のように <code>Driver</code> として定義しています。</p>

<h5>説明(2)</h5>

<p><code>authorized</code> は <code>delegate</code> メソッドである <code>didChangeAuthorization</code> が呼び出されたタイミングで値が変更される必要があります。 <br/>
今回は、<br/>
<code>Subscribe</code> するまでは <code>Observable</code> を生成せずに、 <code>Subscribe</code> されたタイミングで <code>Observable</code> を返す <code>Observable</code> を生成する<br/>
<code>deferred</code> メソッドを利用しています。</p>

<p>```objective-c
authorized = Observable.deferred { [weak locationManager] in</p>

<pre><code>    let status = CLLocationManager.authorizationStatus()
    guard let locationManager = locationManager else {
        return Observable.just(status)
    }
    // didChangeAuthorizationStatusからauthorizedの値を取得
    return locationManager
        .rx.didChangeAuthorizationStatus
        .startWith(status)
}
// エラーが発生した場合は .notDetermined で返却する
.asDriver(onErrorJustReturn: CLAuthorizationStatus.notDetermined)
.map {
    // .authorizedAlwaysの場合のみauthorizedにtrueを格納する
    switch $0 {
    case .authorizedAlways:
        return true
    default:
        return false
    }
}
</code></pre>

<p>```</p>

<h5>説明(3)</h5>

<p>最新の位置情報を取得したタイミングで通知します。</p>

<p>```objective-c
location = locationManager.rx.didUpdateLocations</p>

<pre><code>// エラーが発生した場合は、空配列で返却する
.asDriver(onErrorJustReturn: [])
// 位置情報が格納されている場合はその値を、位置情報がない場合は空を返却する
.flatMap {
    return $0.last.map(Driver.just) ?? Driver.empty()
}
// CLLocationCoordinate2Dの値を返却する
.map { $0.coordinate }
</code></pre>

<p>```</p>

<h4>Viewロジックの実装</h4>

<p>サンプルでは下記のように実装しています。</p>

<p>```objective-c
// GeolocationViewController.swift
import UIKit
import CoreLocation
import RxSwift
import RxCocoa</p>

<p>// 説明(1)
private extension Reactive where Base: UILabel {</p>

<pre><code>var coordinates: Binder&lt;CLLocationCoordinate2D&gt; {
    return Binder(base) { label, location in
        label.text = "Lat: \(location.latitude)\nLon: \(location.longitude)"
    }
}
</code></pre>

<p>}</p>

<p>class GeolocationViewController: ViewController {</p>

<pre><code>@IBOutlet weak private var noGeolocationView: UIView!
@IBOutlet weak private var button: UIButton!
@IBOutlet weak private var button2: UIButton!
@IBOutlet weak var label: UILabel!

override func viewDidLoad() {
    super.viewDidLoad()

    view.addSubview(noGeolocationView)

    let geolocationService = GeolocationService.instance

    // 説明(2)
    geolocationService.authorized
        .drive(noGeolocationView.rx.isHidden)
        .disposed(by: disposeBag)

    // 説明(3)
    geolocationService.location
        .drive(label.rx.coordinates)
        .disposed(by: disposeBag)
    ...
}
...
</code></pre>

<p>}
```</p>

<p>1つずつ説明していきましょう。</p>

<h5>説明(1)</h5>

<p>画面に位置情報を表示するために <code>UILabel</code> を独自に <code>Rx</code> に対応させています。<br/>
これは <code>CLLocationManager</code> を拡張した方法と同じですね。</p>

<h5>説明(2)</h5>

<p><code>authorized</code> が <code>true</code> の場合に <code>noGeolocationView</code> を非表示にするよう実装しています。</p>

<h5>説明(3)</h5>

<p>取得できた最新の位置情報を説明(1)で拡張した機能を利用して <code>UILabel</code> に表示するようにしています。</p>

<p>以上で <code>Rx</code> に対応させた <code>delegate</code> を利用することができました。</p>

<h3>まとめ</h3>

<p>さて、如何でしたでしょうか。<br/>
形式に沿って実装をすることで簡単に拡張することはできますが、<br/>
実装1つ1つを理解することでより深く <code>RxSwift</code> を現場で活用できるかと思います。</p>

<p>まだまだ筆者も理解が乏しいところがあるので、もっと深く勉強を続けていきたいと思います。<br/>
ということで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RxSwiftを勉強してみよう！(3)]]></title>
    <link href="http://grandbig.github.io/blog/2016/08/30/rxswift-3/"/>
    <updated>2016-08-30T16:42:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2016/08/30/rxswift-3</id>
    <content type="html"><![CDATA[<h3>RxSwiftのメソッドを見てみよう</h3>

<p>前回に引き続きRxSwiftを勉強したいと思います。<br/>
今回は<a href="https://github.com/ReactiveX/RxSwift/blob/master/Documentation/API.md">GitHub: Reactive/RxSwift API一覧</a>からメインのメソッドを見ていきたいと思います。</p>

<h4>asObservable</h4>

<p>これは<code>ReactiveX</code>で定義されている<code>From</code>オペレータと同義です。<br/>
様々なオブジェクトを<code>Observable</code>型のデータに変換するためのオペレータです。</p>

<p>利用例は下記です。</p>

<p>```objective-c
let disposeBag = DisposeBag()   // 自動unsubscribeのために必要</p>

<p>let array: [Int] = [1, 2, 3, 4, 5]
let variable = Variable(array)
variable.asObservable.subscribe { (event) in</p>

<pre><code>print("Event is \(event)")
</code></pre>

<p>}.addDisposableTo(disposeBag)</p>

<p>variable.value = [6, 7, 8]</p>

<p>// 結果は下記です。
Event is Next([1, 2, 3, 4, 5])
Event is Next([6, 7, 8])
Event is Completed
```</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h4>create</h4>

<p>0から<code>Observable</code>型のデータを生成するためのオペレータです。</p>

<p>```objective-c
let disposeBag = DisposeBag()   // 自動unsubscribeのために必要</p>

<p>let source = Observable.create { (observer: AnyObserver<Int>) &ndash;> Disposable in</p>

<pre><code>observer.onNext(1)
observer.onCompleted()

return AnonymousDisposable {
    print("Disposed")
}
</code></pre>

<p>}</p>

<p>source.subscribeNext { (elem) in</p>

<pre><code>print("Event is \(elem)")
</code></pre>

<p>}.addDisposableTo(disposeBag)</p>

<p>// 結果は下記です
Event is 1
Disposed
```</p>

<h4>deferred</h4>

<p>Subscribeされたタイミングで<code>Observable</code>型のデータを生成するオペレータです。</p>

<p>```objective-c
let disposeBag = DisposeBag()   // 自動unsubscribeのために必要</p>

<p>let source = Observable.deferred { () &ndash;> Observable<Int> in</p>

<pre><code>return Observable.just(1)
</code></pre>

<p>}
source.subscribeNext { (elem) in</p>

<pre><code>print("Elem is \(elem)")
</code></pre>

<p>}.addDisposableTo(disposeBag)</p>

<p>// 結果は下記です
Event is 1
```</p>

<h4>empty</h4>

<p>空の(何の値も持たない)<code>Observable</code>型のデータを生成するオペレータです。<br/>
通常通り、終了処理は実行されます。</p>

<p>```objective-c
let disposeBag = DisposeBag()   // 自動unsubscribeのために必要</p>

<p>let source: Observable<Int> = Observable.empty()
source.subscribeNext { (elem) in</p>

<pre><code>print("Elem is \(elem)")
</code></pre>

<p>}.addDisposableTo(disposeBag)</p>

<p>// 結果は下記です。
// 空のため何も出力されません
```</p>

<h4>never</h4>

<p>空の(何の値も持たない)<code>Observable</code>型のデータを生成するオペレータです。<br/>
<code>empty</code>と異なるのは終了処理が実行されないことです。</p>

<p>```objective-c
let disposeBag = DisposeBag()   // 自動unsubscribeのために必要</p>

<p>let source: Observable<Int> = Observable.never()
source.subscribeNext { (elem) in</p>

<pre><code>print("Elem is \(elem)")
</code></pre>

<p>}.addDisposableTo(disposeBag)</p>

<p>// 結果は下記です。
// 空のため何も出力されません
```</p>

<h4>error</h4>

<p>空の(何の値も持たない)<code>Observable</code>型のデータを生成するオペレータです。<br/>
<code>empty</code>, <code>never</code>と異なり、エラーを持った終了処理を実行します。</p>

<p>```objective-c
let disposeBag = DisposeBag()   // 自動unsubscribeのために必要</p>

<p>let error = NSError(domain: &ldquo;test&rdquo;, code: -1, userInfo: nil)
let source: Observable<Int> = Observable.error(error)
source.subscribeError { (error) in</p>

<pre><code>print("Error is \(error)")
</code></pre>

<p>}.addDisposableTo(disposeBag)</p>

<p>// 結果は下記です。
Error is Error Domain=test Code=-1 &ldquo;(null)&rdquo;
```</p>

<h4>toObservable</h4>

<p>様々なオブジェクトを<code>Observable</code>型のデータに変換するためのオペレータです。<br/>
<code>asObservable</code>とは利用方法が異なります。</p>

<p>```objective-c
let disposeBag = DisposeBag()   // 自動unsubscribeのために必要</p>

<p>let array: [Int] = [1, 2, 3]
array.toObservable().subscribeNext { (elem) in</p>

<pre><code>print("Number is \(elem)")
</code></pre>

<p>}.addDisposableTo(disposeBag)</p>

<p>// 結果は下記です。
Number is 1
Number is 2
Number is 3
```</p>

<h4>interval</h4>

<p>一定期間あけて処理を実行するためのオペレータです。<br/>
<code>JavaScript</code>で言うところの<code>setTimeInterval</code>です。</p>

<p>```objective-c
let disposeBag = DisposeBag()   // 自動unsubscribeのために必要</p>

<p>let timer: Observable<Int> = Observable.interval(5.0, scheduler: MainScheduler.instance)
timer.subscribeNext { (count) in</p>

<pre><code>print("log output")
</code></pre>

<p>}.addDisposableTo(disposeBag)</p>

<p>// 結果は下記です。
// 5秒後に実行されます。
log output
```</p>

<h4>just</h4>

<p>引数に指定した特定の型を返却する<code>Observable</code>型のデータを生成するためのオペレータです。</p>

<p>```objective-c
let disposeBag = DisposeBag()   // 自動unsubscribeのために必要</p>

<p>let source = Observable.just(1)
source.subscribeNext { (elem) in</p>

<pre><code>print("Elem is \(elem)")
</code></pre>

<p>}.addDisposableTo(disposeBag)</p>

<p>// 結果は下記です。
Elem is 1
```</p>

<h4>of</h4>

<p>様々なオブジェクトを<code>Observable</code>型のデータに変換するためのオペレータです。<br/>
<code>asObservable</code>や<code>toObservable</code>とは利用方法が異なります。</p>

<p>```objective-c
let disposeBag = DisposeBag()   // 自動unsubscribeのために必要</p>

<p>let source = Observable.of(1)
source.subscribeNext { (elem) in</p>

<pre><code>print("Elem is \(elem)")
</code></pre>

<p>}.addDisposableTo(disposeBag)</p>

<p>// 結果は下記です。
Elem is 1
```</p>

<h4>range</h4>

<p>特定の範囲の<code>Int</code>型を持つ<code>Observable</code>型データを生成するオペレータです。</p>

<p>```objective-c
let disposeBag = DisposeBag()   // 自動unsubscribeのために必要</p>

<p>let source: Observable<Int> = Observable.range(start: 1, count: 3)
source.subscribeNext { (elem) in</p>

<pre><code>print("Elem is \(elem)")
</code></pre>

<p>}.addDisposableTo(disposeBag)</p>

<p>// 結果は下記です。
Elem is 1
Elem is 2
Elem is 3
```</p>

<h4>repeatElement</h4>

<p>指定した回数、処理を実行するときに利用する<code>Observable</code>型データを生成するオペレータです。<br/>
<code>take</code>メソッドを利用して回数を指定します。</p>

<p>```objective-c
let disposeBag = DisposeBag()   // 自動unsubscribeのために必要</p>

<p>let source = Observable.repeatElement(1).take(3)
source.subscribeNext { (elem) in</p>

<pre><code>print("Elem is \(elem)")
</code></pre>

<p>}.addDisposableTo(disposeBag)</p>

<p>// 結果は下記です。
Elem is 1
Elem is 1
Elem is 1
```</p>

<h4>timer</h4>

<p>一定時間経過後に処理を実行したい場合に利用するオペレータです。<br/>
<code>JavaScript</code>で言うところの<code>setTimeout</code>です。</p>

<p>```objective-c
let timer: Observable<Int> = Observable.timer(5.0, scheduler: MainScheduler.instance)
timer.subscribeNext { (count) in</p>

<pre><code>print("log output")
</code></pre>

<p>}.addDisposableTo(disposeBag)
```</p>

<h3>まとめ</h3>

<p>さて、今回は<code>Creating Observables</code>のみを取り上げさせて頂きましたが、いかがでしたでしょうか？<br/>
筆者もイマイチ使い方がわからなかったオペレータがたくさんあったので、多少なりとも使えそうな気がしてきました。<br/>
<code>Transforming Observables</code>, <code>Filtering Observables</code> &hellip;. と全て見ていけると良いのですが、結構数が多いですね。<br/>
時間があるときに続きを書きたいと思います。</p>

<p>と言ったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RxSwiftを勉強してみよう！(2)]]></title>
    <link href="http://grandbig.github.io/blog/2016/08/29/rxswift-2/"/>
    <updated>2016-08-29T22:40:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2016/08/29/rxswift-2</id>
    <content type="html"><![CDATA[<h3>RxSwiftの公式Exampleを覗いてみる(2)</h3>

<p>前回に引き続きRxSwiftの公式Exampleを見ていきたいと思います。<br/>
公式ソースは<a href="https://github.com/ReactiveX/RxSwift">GitHub: ReactiveX/RxSwift</a>からダウンロードできます。</p>

<h4>GeolocationExample</h4>

<p>位置情報を用いたときのRxの有効性が表現されているのでしょうか？<br/>
早速見ていきましょう。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<p>まずは、<code>CoreLocation</code>のコア部分をラップしている<code>GeolocationService</code>です。</p>

<p>```objective-c
import Foundation
import CoreLocation
import RxSwift
import RxCocoa</p>

<p>class GeolocationService {</p>

<pre><code>static let instance = GeolocationService()
// (1)
private (set) var authorized: Driver&lt;Bool&gt;
private (set) var location: Driver&lt;CLLocationCoordinate2D&gt;

private let locationManager = CLLocationManager()

private init() {
    locationManager.distanceFilter = kCLDistanceFilterNone
    locationManager.desiredAccuracy = kCLLocationAccuracyBestForNavigation

    // (2)
    authorized = Observable.deferred { [weak locationManager] in
        let status = CLLocationManager.authorizationStatus()
        guard let locationManager = locationManager else {
            // (3)
            return Observable.just(status)
        }
        return locationManager
            .rx_didChangeAuthorizationStatus
            .startWith(status) // (4)
        }
        .asDriver(onErrorJustReturn: CLAuthorizationStatus.NotDetermined) // (5)
        .map {
            switch $0 {
                case .AuthorizedAlways:
                    return true
                default:
                    return false
            }
        }
}
</code></pre>

<p>}
```</p>

<p>上記ソースでポイントとなる部分を見ていきます。</p>

<p>(1): <code>Driver</code><br/>
末尾に参考URLとして上げさせて頂いた記事に書かれているのですが、<br/>
<code>Driver</code>型で定義することで、エラー発生時の処理<code>asDriver</code>オペレータで続けて書くことができます。</p>

<p>(2): <code>deferred</code><br/>
ObserverがSubscribe(購読)されたタイミングで動的にObservableを生成します。<br/>
※ 因みに新規ObservableをSubscribeタイミングで毎回生成します。</p>

<p>(3): <code>just</code><br/>
引数に取った特定の型を返却するObservableを生成します。<br/>
この場合は<code>CLAuthorizationStatus</code>型のObservableです。</p>

<p>(4): <code>startWith</code><br/>
想定したemit対象値の前に何らかの値をemitしたい場合に利用します。<br/>
この場合、<code>rx_didChangeAuthoricationStatus</code>をemitする前にということでしょうか。<br/>
(これが恐らく、一番わかりやすい例です → <a href="http://www.introtorx.com/Content/v1.0.10621.0/12_CombiningSequences.html#StartWith">Introduction to Rx: startWith</a>)</p>

<p>(5): <code>asDriver</code><br/>
(1)で説明した<code>Driver</code>に関係するオペレータです。<br/>
エラーが発生した場合に<code>onErrorJustReturn</code>で指定した値を返却して処理を続けます。</p>

<p>続いて、<code>GeolocationService</code>を利用している<code>GeolocationViewController</code>です。</p>

<p>```objective-c
import Foundation
import UIKit
import RxSwift
import RxCocoa</p>

<p>// (6)
private extension UILabel {</p>

<pre><code>var rx_driveCoordinates: AnyObserver&lt;CLLocationCoordinate2D&gt; {
    return UIBindingObserver(UIElement: self) { label, location in
        label.text = "Lat: \(location.latitude)\nLon: \(location.longitude)"
    }.asObserver()
}
</code></pre>

<p>}</p>

<p>// (7)
private extension UIView {</p>

<pre><code>var rx_driveAuthorization: AnyObserver&lt;Bool&gt; {
    return UIBindingObserver(UIElement: self) { view, authorized in
        if authorized {
            view.hidden = true
            view.superview?.sendSubviewToBack(view)
        }
        else {
            view.hidden = false
            view.superview?.bringSubviewToFront(view)
        }
    }.asObserver()
}
</code></pre>

<p>}</p>

<p>class GeolocationViewController: ViewController {</p>

<pre><code>@IBOutlet weak private var noGeolocationView: UIView!
@IBOutlet weak private var button: UIButton!
@IBOutlet weak private var button2: UIButton!
@IBOutlet weak var label: UILabel!

override func viewDidLoad() {
    super.viewDidLoad()

    let geolocationService = GeolocationService.instance

    geolocationService.authorized
        .drive(noGeolocationView.rx_driveAuthorization) // (8)
        .addDisposableTo(disposeBag)

    geolocationService.location
        .drive(label.rx_driveCoordinates) // (8)
        .addDisposableTo(disposeBag)

    button.rx_tap
        .bindNext { [weak self] in
            self?.openAppPreferences()
        }
        .addDisposableTo(disposeBag)

    button2.rx_tap
        .bindNext { [weak self] in
            self?.openAppPreferences()
        }
        .addDisposableTo(disposeBag)
}

private func openAppPreferences() {
    UIApplication.sharedApplication().openURL(NSURL(string: UIApplicationOpenSettingsURLString)!)
}
</code></pre>

<p>}
```</p>

<p>(6): <code>rx_driveCoordinates</code><br/>
見ての通りここで<code>UILabel</code>の<code>extension</code>をしています。<br/>
<code>UILabel</code>の<code>text</code>内容を任意の値で返却するために作成しています。<br/>
(<code>asObserver</code>をつけることで<code>rx_driveCoordinates</code>という<code>AnyObserver</code>型の変数定義を実現しています。)</p>

<p>(7): <code>rx_driveAuthorization</code><br/>
同じく<code>UIView</code>の<code>extension</code>をしています。<br/>
<code>authorized</code>の値でViewの表示/非表示を切り替えています。</p>

<p>(8): <code>drive</code><br/>
ここで新たにSubscriptionを生成して、引数に取ったObserverに処理の実行を要請しています。</p>

<p>今回のExampleを見てみると下記のようなメリットが感じられます。</p>

<ul>
<li>Rxを利用することで非同期処理を直列的に書ける</li>
<li>エラーハンドリングを直列的に書けることで後処理も直列的に統一して見れる(<code>jQuery</code>の<code>ajax</code>メソッドの<code>always</code>的なイメージ)</li>
<li>処理の拡張がRxで用意されたメソッドで比較的に容易に書ける</li>
</ul>


<h3>Rxで把握しておきたいAPI一覧</h3>

<p>RxSwiftをインストールすると中にドキュメントが含まれています。<br/>
<a href="https://github.com/ReactiveX/RxSwift/blob/master/Documentation/API.md">API.md</a>を読むだけでもかなり理解が進むと思われます。</p>

<p>特に言語がSwiftであるが故に他のRxフレームワークとはメソッド名が異なる場合があります。<br/>
(<code>defer</code>でなく<code>deferred</code>、<code>repeat</code>でなく<code>repeatElement</code>など)</p>

<p>一度は目を通しておくと良いかもしれません。<br/>
と言いつつ、筆者も全然見れていませんが&hellip;</p>

<h3>まとめ</h3>

<p>さて、今回は公式Exampleの1つを見るだけに留まりましたが如何でしたでしょうか？<br/>
筆者としてはRxの使い方の理解がだいぶ進んだ気がしております。<br/>
引き続きRxに関する勉強は続けていきたいと思います。<br/>
と言ったところで本日はここまで。</p>

<p>参考:</p>

<ul>
<li><a href="http://qiita.com/yuzushioh/items/0a4483502c5c8569790a">RxSwift/RxCocoa Driver Unitについてまとめてみた。</a></li>
</ul>


<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
</feed>
