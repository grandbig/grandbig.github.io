<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: docker | Takahiro Octopress Blog]]></title>
  <link href="http://grandbig.github.io/blog/categories/docker/atom.xml" rel="self"/>
  <link href="http://grandbig.github.io/"/>
  <updated>2017-02-26T19:08:35+09:00</updated>
  <id>http://grandbig.github.io/</id>
  <author>
    <name><![CDATA[Takahiro]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Dockerコンテナ内のUbuntuでRedis設定を試してみよう！]]></title>
    <link href="http://grandbig.github.io/blog/2017/02/25/docker-for-mac-4/"/>
    <updated>2017-02-25T22:36:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2017/02/25/docker-for-mac-4</id>
    <content type="html"><![CDATA[<h3>はじめに</h3>

<p>今回はDockerコンテナ内のUbuntuに<a href="https://redis.io/">Redis</a>をインストールしてみたいと思います。<br/>
基本的な操作だけでなく、デフォルトの設定とそれらの意味についても見ていきます。</p>

<h3>UbuntuへのRedisのインストール</h3>

<p>まずはインストールをしないと始まりません。<br/>
その方法について見ていきます。<br/>
今回扱う環境は以下の通りです。</p>

<ul>
<li>Ubuntu: 14.04.5 LTS</li>
<li>Redis: 2.8.4</li>
</ul>


<p>バージョン的に最新ではない部分もあるのですが、Dockerコンテナ内のサーバを構築する上で利用したバージョンで進めます。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<p>インストールは実に簡単です。<br/>
<code>apt-get</code>を利用するのみです。</p>

<p><code>javascript
$ apt-get install redis-server
Reading package lists... Done
Building dependency tree       
Reading state information... Done
...
Setting up redis-server (2:2.8.4-2) ...
Starting redis-server: redis-server.
Processing triggers for libc-bin (2.19-0ubuntu6.9) ...
Processing triggers for ureadahead (0.100.0-16) ...
</code></p>

<p>上記のログで<code>Starting redis-server: redis-server.</code>として出力されている通り、インストールが完了すると、Redisを起動してくれます。<br/>
念のため確認してみますが、</p>

<p><code>javascript
$ ps aux | grep redis
redis     8833  0.0  0.1  37000  3348 ?        Ssl  13:25   0:00 /usr/bin/redis-server 127.0.0.1:6379       
root      8843  0.0  0.0   8868   784 ?        S+   13:26   0:00 grep --color=auto redis
</code></p>

<p>ご覧の通り起動しています。</p>

<h3>Redisの基本コマンド</h3>

<p>Redisの基本コマンドは以下の通りです。</p>

<ul>
<li><code>keys *</code>: 現時点で保存されているkey全てを表示</li>
<li><code>set key value</code>: keyとvalueの格納</li>
<li><code>get key</code>: 指定したkeyのvalueを取得</li>
<li><code>del key</code>: 指定したkeyのvalueを削除</li>
<li><code>flushdb</code>: 現時点で保存されているkey全てを削除</li>
</ul>


<p>実際に使ってみましょう。</p>

<p><code>javascript
$ redis-cli
127.0.0.1:6379&gt; keys *
(empty list or set)
127.0.0.1:6379&gt; set user takahiro
OK
127.0.0.1:6379&gt; set device iphone
OK
127.0.0.1:6379&gt; keys *
1) "user"
2) "device"
127.0.0.1:6379&gt; get user
"takahiro"
127.0.0.1:6379&gt; get device
"iphone"
127.0.0.1:6379&gt; del device
(integer) 1
127.0.0.1:6379&gt; keys *
1) "user"
127.0.0.1:6379&gt; flushdb
OK
127.0.0.1:6379&gt; keys *
(empty list or set)
</code></p>

<h3>Redisのデフォルト設定</h3>

<p>続いて、Redisの設定を見ていきます。<br/>
インストール後、<code>redis.conf</code>ファイルが<code>/etc/redis/</code>配下に作成されます。<br/>
デフォルトでこのファイルの中身には多くのことが書かれています。<br/>
1つずつ見ていきましょう。</p>

<h4>単位指定について</h4>

<p>まずはメモリ単位関連の説明です。</p>

<p>```javascript</p>

<h1>Redis configuration file example</h1>

<h1>Note on units: when memory size is needed, it is possible to specify</h1>

<h1>it in the usual form of 1k 5GB 4M and so forth:</h1>

<p>#</p>

<h1>1k => 1000 bytes</h1>

<h1>1kb => 1024 bytes</h1>

<h1>1m => 1000000 bytes</h1>

<h1>1mb => 1024*1024 bytes</h1>

<h1>1g => 1000000000 bytes</h1>

<h1>1gb => 1024<em>1024</em>1024 bytes</h1>

<p>#</p>

<h1>units are case insensitive so 1GB 1Gb 1gB are all the same.</h1>

<p>```</p>

<p>もう上記のままですね。<br/>
<code>1k</code>か<code>1kb</code>なのか微妙に書き方を気をつけないと想定外の容量指定になるので気をつけましょう。<br/>
ただし、<code>1GB</code> / <code>1Gb</code> / <code>1gB</code>は微妙に書き方が異なりますが指定容量は同じです。</p>

<h4>includeによる設定ファイルの分割について</h4>

<p>Apacheなどでもよくある通り<code>include</code>を利用することもできます。</p>

<p>```javascript</p>

<h6>############################ INCLUDES</h6>

<h1>Include one or more other config files here.  This is useful if you</h1>

<h1>have a standard template that goes to all Redis server but also need</h1>

<h1>to customize a few per-server settings.  Include files can include</h1>

<h1>other files, so use this wisely.</h1>

<p>#</p>

<h1>Notice option &ldquo;include&rdquo; won‘t be rewritten by command &ldquo;CONFIG REWRITE&rdquo;</h1>

<h1>from admin or Redis Sentinel. Since Redis always uses the last processed</h1>

<h1>line as value of a configuration directive, you‘d better put includes</h1>

<h1>at the beginning of this file to avoid overwriting config change at runtime.</h1>

<p>#</p>

<h1>If instead you are interested in using includes to override configuration</h1>

<h1>options, it is better to use include as the last line.</h1>

<p>#</p>

<h1>include /path/to/local.conf</h1>

<h1>include /path/to/other.conf</h1>

<p>```</p>

<p>サーバごとに設定を分けたいとか、第三者が見やすいように設定単位でファイルを分けたいとか様々な用途で便利に利用できるはずです。<br/>
<code>include</code>したファイルに定義した内容で<code>redis.conf</code>の定義内容を書き換えるのであれば、<code>redis.conf</code>の一番最後に<code>include</code>を書いた方が良いでしょう。<br/>
(逆に、書き換えたくないのであれば、<code>redis.conf</code>の初めに書きましょう。)</p>

<h4>一般設定について</h4>

<p>さて、最も基本となる設定です。<br/>
少々、長いので細かめに分割してみていきましょう。</p>

<h5>デーモン化の有無</h5>

<p>デーモン化の有無は下記で設定します。</p>

<p>```javascript</p>

<h1>By default Redis does not run as a daemon. Use &lsquo;yes&rsquo; if you need it.</h1>

<h1>Note that Redis will write a pid file in /var/run/redis.pid when daemonized.</h1>

<p>daemonize yes
```</p>

<p>デフォルト設定ではデーモン起動はしないようになっています。<br/>
* yes: デーモン起動する<br/>
* no: デーモン起動しない</p>

<p>PIDファイルはデフォルトで<code>/var/run/redis.pid</code>に出力します。</p>

<h5>PIDファイルの指定</h5>

<p>デフォルトとは異なる場所にPIDファイルを出力したい場合に指定します。</p>

<p>```javascript</p>

<h1>When running daemonized, Redis writes a pid file in /var/run/redis.pid by</h1>

<h1>default. You can specify a custom pid file location here.</h1>

<p>pidfile /var/run/redis/redis-server.pid
```</p>

<h5>ボート番号の指定</h5>

<p>Redisを起動する際のポート番号を指定します。</p>

<p>```javascript</p>

<h1>Accept connections on the specified port, default is 6379.</h1>

<h1>If port 0 is specified Redis will not listen on a TCP socket.</h1>

<p>port 6379
```</p>

<ul>
<li>デフォルトポート番号: 6379</li>
<li>0指定: TCPソケット通信を受け付けない</li>
</ul>


<h5>IPアドレスの指定</h5>

<p>Redisを起動する際の接続するIPアドレスを指定します。</p>

<p>```javascript</p>

<h1>By default Redis listens for connections from all the network interfaces</h1>

<h1>available on the server. It is possible to listen to just one or multiple</h1>

<h1>interfaces using the &ldquo;bind&rdquo; configuration directive, followed by one or</h1>

<h1>more IP addresses.</h1>

<p>#</p>

<h1>Examples:</h1>

<p>#</p>

<h1>bind 192.168.1.100 10.0.0.1</h1>

<p>bind 127.0.0.1
```</p>

<p>複数のIPアドレスを指定する場合は半角スペースを挟んで連続して書きましょう。</p>

<h5>Unixドメインソケット通信の設定</h5>

<p>TCP通信だけでなく、Unixドメインソケット通信を受け付ける場合に設定します。</p>

<p>```javascript</p>

<h1>Specify the path for the unix socket that will be used to listen for</h1>

<h1>incoming connections. There is no default, so Redis will not listen</h1>

<h1>on a unix socket when not specified.</h1>

<p>#</p>

<h1>unixsocket /var/run/redis/redis.sock</h1>

<h1>unixsocketperm 755</h1>

<p>```</p>

<ul>
<li>デフォルトではコメントアウトされている

<ul>
<li>同一サーバ内での受付はTCPより良いという話も&hellip;!?</li>
</ul>
</li>
<li><code>unixsocket</code>: <code>socket</code>ファイルのパス指定</li>
<li><code>unixsocketperm</code>: <code>socket</code>ファイルへのアクセス権</li>
</ul>


<h5>タイムアウトの設定</h5>

<p>クライアントからの接続タイムアウト設定です。</p>

<p>```javascript</p>

<h1>Close the connection after a client is idle for N seconds (0 to disable)</h1>

<p>timeout 0
```</p>

<p>0を設定すると、タイムアウトは無効になります。</p>

<h5>TCP KeepAlive設定</h5>

<p>TCP通信の生存確認に関する設定です。</p>

<p>```javascript</p>

<h1>TCP keepalive.</h1>

<p>#</p>

<h1>If non-zero, use SO_KEEPALIVE to send TCP ACKs to clients in absence</h1>

<h1>of communication. This is useful for two reasons:</h1>

<p>#</p>

<h1>1) Detect dead peers.</h1>

<h1>2) Take the connection alive from the point of view of network</h1>

<h1>equipment in the middle.</h1>

<p>#</p>

<h1>On Linux, the specified value (in seconds) is the period used to send ACKs.</h1>

<h1>Note that to close the connection the double of the time is needed.</h1>

<h1>On other kernels the period depends on the kernel configuration.</h1>

<p>#</p>

<h1>A reasonable value for this option is 60 seconds.</h1>

<p>tcp-keepalive 0
```</p>

<ul>
<li>有効にすることで、通信断(Dead Peer)状態を防いだり、コネクションの接続生存を確認することができます</li>
<li>適切な値として <code>60秒</code> が推奨されています</li>
</ul>


<h5>ログレベルの設定</h5>

<p>ログの出力量を調整するために設定します。</p>

<p>```javascript</p>

<h1>Specify the server verbosity level.</h1>

<h1>This can be one of:</h1>

<h1>debug (a lot of information, useful for development/testing)</h1>

<h1>verbose (many rarely useful info, but not a mess like the debug level)</h1>

<h1>notice (moderately verbose, what you want in production probably)</h1>

<h1>warning (only very important / critical messages are logged)</h1>

<p>loglevel notice
```</p>

<ul>
<li><code>debug</code>: 開発やテスト用に利用。大量のログを出力します</li>
<li><code>verbose</code>: <code>debug</code>よりは少ないものの多くのログを出力します</li>
<li><code>notice</code>: 商用に適した設定です</li>
<li><code>warning</code>: 重要またはクリティカルなメッセージのみログに出します</li>
</ul>


<h5>ログファイルの出力先の指定</h5>

<p>ログファイルの出力先のパスを指定します。</p>

<p>```javascript</p>

<h1>Specify the log file name. Also the empty string can be used to force</h1>

<h1>Redis to log on the standard output. Note that if you use standard</h1>

<h1>output for logging but daemonize, logs will be sent to /dev/null</h1>

<p>logfile /var/log/redis/redis-server.log
```</p>

<h5>システムログの設定</h5>

<p>システムログに関する設定です。</p>

<p>```javascript</p>

<h1>To enable logging to the system logger, just set &lsquo;syslog-enabled&rsquo; to yes,</h1>

<h1>and optionally update the other syslog parameters to suit your needs.</h1>

<h1>syslog-enabled no</h1>

<h1>Specify the syslog identity.</h1>

<h1>syslog-ident redis</h1>

<h1>Specify the syslog facility. Must be USER or between LOCAL0-LOCAL7.</h1>

<h1>syslog-facility local0</h1>

<p>```</p>

<ul>
<li><code>syslog-enabled</code>: システムログのロギングの有無を設定します</li>
<li><code>syslog-ident</code>: システムログの識別子の設定をします</li>
<li><code>syslog-facility</code>: システムログの分類を設定します

<ul>
<li><code>user</code>: ユーザプロセスのメッセージを記録するために設定します</li>
<li><code>local0 〜 7</code>: セキュリティやネットワークなど細かく設定できます</li>
</ul>
</li>
</ul>


<p><code>local0 〜 7</code>については<a href="https://www.furukawa.co.jp/fitelnet/f/man/100/command-config/global_config/syslog_facility.htm#facility">syslog facility</a>が参考になりそうです。</p>

<h5>データベースの設定</h5>

<p>使用するデータベース番号を指定します。<br/>
デフォルトで<code>16</code>が指定されていることで利用可能なデータベース番号は<code>0 〜 15</code>となっています。<br/>
特に何もしなければ<code>DB 0</code>を利用します。<br/>
<code>SELECT</code>文を利用することでデータベースを指定して使うこともできます。</p>

<p>```javascript</p>

<h1>Set the number of databases. The default database is DB 0, you can select</h1>

<h1>a different one on a per-connection basis using SELECT <dbid> where</h1>

<h1>dbid is a number between 0 and &lsquo;databases&rsquo;-1</h1>

<p>databases 16
```</p>

<h4>スナップショット(バックアップ)設定</h4>

<p>こちらもかなり重要な設定となります。<br/>
利用用途にもよりますが、サービス上、消えてしまってはまずいデータを扱うのであれば堅牢な仕組みになるように設定を考える必要があります。</p>

<h5>ディスク保存の頻度設定</h5>

<p><code>key</code>の変更数と保存までに時間を設定します。<br/>
これにより、ある程度自由に堅牢性を設定することが可能です。</p>

<p>```javascript
#</p>

<h1>Save the DB on disk:</h1>

<p>#</p>

<h1>save <seconds> <changes></h1>

<p>#</p>

<h1>Will save the DB if both the given number of seconds and the given</h1>

<h1>number of write operations against the DB occurred.</h1>

<p>#</p>

<h1>In the example below the behaviour will be to save:</h1>

<h1>after 900 sec (15 min) if at least 1 key changed</h1>

<h1>after 300 sec (5 min) if at least 10 keys changed</h1>

<h1>after 60 sec if at least 10000 keys changed</h1>

<p>#</p>

<h1>Note: you can disable saving at all commenting all the &ldquo;save&rdquo; lines.</h1>

<p>#</p>

<h1>It is also possible to remove all the previously configured save</h1>

<h1>points by adding a save directive with a single empty string argument</h1>

<h1>like in the following example:</h1>

<p>#</p>

<h1>save &ldquo;&rdquo;</h1>

<p>save 900 1
save 300 10
save 60 10000
```</p>

<p>上記デフォルト設定の意味は下記です。<br/>
* <code>save 900 1</code>: 1個の<code>key</code>が変更されたら、15分後にディスクにその状態を保存<br/>
* <code>sabe 300 10</code>: 10個の<code>key</code>が変更されたら、5分後にディスクにその状態を保存<br/>
* <code>save 60 10000</code>: 10000個の<code>key</code>が変更されたら、1分後にディスクにその状態を保存</p>

<p>もしディスク保存したくなければ(インメモリでの利用のみであれば)<code>save ""</code>を指定しましょう。</p>

<h5>エラー発生時の保存挙動の設定</h5>

<p>これはエラーが発生したときにディスク保存をどうするかを決める設定です。</p>

<p>```javascript</p>

<h1>By default Redis will stop accepting writes if RDB snapshots are enabled</h1>

<h1>(at least one save point) and the latest background save failed.</h1>

<h1>This will make the user aware (in a hard way) that data is not persisting</h1>

<h1>on disk properly, otherwise chances are that no one will notice and some</h1>

<h1>disaster will happen.</h1>

<p>#</p>

<h1>If the background saving process will start working again Redis will</h1>

<h1>automatically allow writes again.</h1>

<p>#</p>

<h1>However if you have setup your proper monitoring of the Redis server</h1>

<h1>and persistence, you may want to disable this feature so that Redis will</h1>

<h1>continue to work as usual even if there are problems with disk,</h1>

<h1>permissions, and so forth.</h1>

<p>stop-writes-on-bgsave-error yes
```</p>

<ul>
<li>yes: 保存を止めます</li>
<li>no: 書き込みを続けます</li>
</ul>


<h5>Dump時の圧縮設定</h5>

<p>データをDumpする際に<code>LZF</code>圧縮をかけるか否かを設定できます。</p>

<p>```javascript</p>

<h1>Compress string objects using LZF when dump .rdb databases?</h1>

<h1>For default that‘s set to &lsquo;yes&rsquo; as it‘s almost always a win.</h1>

<h1>If you want to save some CPU in the saving child set it to &lsquo;no&rsquo; but</h1>

<h1>the dataset will likely be bigger if you have compressible values or keys.</h1>

<p>rdbcompression yes
```</p>

<ul>
<li>yes: 圧縮します(CPU負荷が上がる一方で小容量)</li>
<li>no: 圧縮しません(CPU負荷が下がる一方で大容量)</li>
</ul>


<h5>Checksum設定</h5>

<p>これはデータの整合性を検証するための設定です。</p>

<p>```javascript</p>

<h1>Since version 5 of RDB a CRC64 checksum is placed at the end of the file.</h1>

<h1>This makes the format more resistant to corruption but there is a performance</h1>

<h1>hit to pay (around 10%) when saving and loading RDB files, so you can disable it</h1>

<h1>for maximum performances.</h1>

<p>#</p>

<h1>RDB files created with checksum disabled have a checksum of zero that will</h1>

<h1>tell the loading code to skip the check.</h1>

<p>rdbchecksum yes
```</p>

<p>データ保存時にRDBファイルの読み込みを行うため、10%の性能劣化が発生するが、堅牢なデータを担保したいのであれば設定して損はないでしょう。</p>

<h5>Dumpファイル名の設定</h5>

<p>Dumpしたファイルの名称を指定します。</p>

<p>```javascript</p>

<h1>The filename where to dump the DB</h1>

<p>dbfilename dump.rdb
```</p>

<h5>Dumpファイルの保存場所の設定</h5>

<p>どこにDumpファイルを配置するかの設定です。</p>

<p>```javascript</p>

<h1>The working directory.</h1>

<p>#</p>

<h1>The DB will be written inside this directory, with the filename specified</h1>

<h1>above using the &lsquo;dbfilename&rsquo; configuration directive.</h1>

<p>#</p>

<h1>The Append Only File will also be created inside this directory.</h1>

<p>#</p>

<h1>Note that you must specify a directory here, not a file name.</h1>

<p>dir /var/lib/redis
```</p>

<h4>レプリケーション設定</h4>

<p>障害発生時に利用するレプリケーションの設定についてもデフォルトで説明書きがなされています。</p>

<h5>スレーブ設定</h5>

<p>スレーブのコピー元となるマスターを指定します。</p>

<p>```javascript</p>

<h1>Master-Slave replication. Use slaveof to make a Redis instance a copy of</h1>

<h1>another Redis server. Note that the configuration is local to the slave</h1>

<h1>so for example it is possible to configure the slave to save the DB with a</h1>

<h1>different interval, or to listen to another port, and so on.</h1>

<p>#</p>

<h1>slaveof <masterip> <masterport></h1>

<p>```</p>

<p>スレーブ側のRedisに設定を記載します。<br/>
マスター側とDB保存間隔の設定や接続時のポート番号が異なっていたとしても何ら問題はありません。</p>

<h5>マスターのパスワード設定</h5>

<p>マスター側がパスワード認証を必要している場合、スレーブ側でマスターのパスワードを設定していないとリクエスト要求が通りません。</p>

<p>```javascript</p>

<h1>If the master is password protected (using the &ldquo;requirepass&rdquo; configuration</h1>

<h1>directive below) it is possible to tell the slave to authenticate before</h1>

<h1>starting the replication synchronization process, otherwise the master will</h1>

<h1>refuse the slave request.</h1>

<p>#</p>

<h1>masterauth &lt;master-password></h1>

<p>```</p>

<h5>マスターとの同期が最新でない場合のスレーブ挙動の設定</h5>

<p>スレーブがマスターと同期が取れなくなることは長く運用を続けていく上で必ず発生しうるものです。<br/>
その際にスレーブがどのような振る舞いをすべきか設定しておきましょう。</p>

<p>```javascript</p>

<h1>When a slave loses its connection with the master, or when the replication</h1>

<h1>is still in progress, the slave can act in two different ways:</h1>

<p>#</p>

<h1>1) if slave-serve-stale-data is set to &lsquo;yes&rsquo; (the default) the slave will</h1>

<h1>still reply to client requests, possibly with out of date data, or the</h1>

<h1>data set may just be empty if this is the first synchronization.</h1>

<p>#</p>

<h1>2) if slave-serve-stale-data is set to &lsquo;no&rsquo; the slave will reply with</h1>

<h1>an error &ldquo;SYNC with master in progress&rdquo; to all the kind of commands</h1>

<h1>but to INFO and SLAVEOF.</h1>

<p>#
slave-serve-stale-data yes
```</p>

<ul>
<li><code>yes</code>: 最後に同期が取れた際の最新データを返却</li>
<li><code>no</code>: 最新の同期が取れていないためエラーを返却</li>
</ul>


<h5>スレーブの書き込み権限の設定</h5>

<p>特別な理由がない限り、<code>yes</code>で良さそうな設定です。<br/>
スレーブは基本的にマスターに障害が発生した場合に利用する想定なので、直接書き込み権限をつける必要はないでしょう。</p>

<p>```javascript</p>

<h1>You can configure a slave instance to accept writes or not. Writing against</h1>

<h1>a slave instance may be useful to store some ephemeral data (because data</h1>

<h1>written on a slave will be easily deleted after resync with the master) but</h1>

<h1>may also cause problems if clients are writing to it because of a</h1>

<h1>misconfiguration.</h1>

<p>#</p>

<h1>Since Redis 2.6 by default slaves are read-only.</h1>

<p>#</p>

<h1>Note: read only slaves are not designed to be exposed to untrusted clients</h1>

<h1>on the internet. It‘s just a protection layer against misuse of the instance.</h1>

<h1>Still a read only slave exports by default all the administrative commands</h1>

<h1>such as CONFIG, DEBUG, and so forth. To a limited extent you can improve</h1>

<h1>security of read only slaves using &lsquo;rename-command&rsquo; to shadow all the</h1>

<h1>administrative / dangerous commands.</h1>

<p>slave-read-only yes
```</p>

<p>注意すべきこととしては、<code>slave-read-only</code>を<code>yes</code>に設定したとしても、<code>CONFIG</code>コマンドなどで設定値を変更することができてしまいます。<br/>
もし、それを防止したいのであれば、<code>rename-command</code>を利用することで予めコマンド名を第三者からはわからないもに変えておきましょう。</p>

<h5>マスターへのヘルスチェック設定</h5>

<p>スレーブがマスターの生存を確認するために流し込む<code>ping</code>の時間の間隔設定です。</p>

<p>```javascript</p>

<h1>Slaves send PINGs to server in a predefined interval. It‘s possible to change</h1>

<h1>this interval with the repl_ping_slave_period option. The default value is 10</h1>

<h1>seconds.</h1>

<p>#</p>

<h1>repl-ping-slave-period 10</h1>

<p>```</p>

<h5>レプリケーションのタイムアウト設定</h5>

<p>マスタースレーブ間で同期を取る際などにリクエスト/レスポンスが発生します。<br/>
その際のタイムアウト設定となります。</p>

<p>```javascript</p>

<h1>The following option sets the replication timeout for:</h1>

<p>#</p>

<h1>1) Bulk transfer I/O during SYNC, from the point of view of slave.</h1>

<h1>2) Master timeout from the point of view of slaves (data, pings).</h1>

<h1>3) Slave timeout from the point of view of masters (REPLCONF ACK pings).</h1>

<p>#</p>

<h1>It is important to make sure that this value is greater than the value</h1>

<h1>specified for repl-ping-slave-period otherwise a timeout will be detected</h1>

<h1>every time there is low traffic between the master and the slave.</h1>

<p>#</p>

<h1>repl-timeout 60</h1>

<p>```</p>

<p>注意点としては、<code>repl-ping-slave-period</code>よりも大きな設定をしないと毎回<code>ping</code>でタイムアウトすることになります。</p>

<h5>TCPの遅延に関する設定</h5>

<p>TCP通信時の帯域幅の占有可否と遅延の許容可否の優先度を決めます。</p>

<p>```javascript</p>

<h1>Disable TCP_NODELAY on the slave socket after SYNC?</h1>

<p>#</p>

<h1>If you select &ldquo;yes&rdquo; Redis will use a smaller number of TCP packets and</h1>

<h1>less bandwidth to send data to slaves. But this can add a delay for</h1>

<h1>the data to appear on the slave side, up to 40 milliseconds with</h1>

<h1>Linux kernels using a default configuration.</h1>

<p>#</p>

<h1>If you select &ldquo;no&rdquo; the delay for data to appear on the slave side will</h1>

<h1>be reduced but more bandwidth will be used for replication.</h1>

<p>#</p>

<h1>By default we optimize for low latency, but in very high traffic conditions</h1>

<h1>or when the master and slaves are many hops away, turning this to &ldquo;yes&rdquo; may</h1>

<h1>be a good idea.</h1>

<p>repl-disable-tcp-nodelay no
```</p>

<ul>
<li><code>yes</code>: TCP通信時のパケット数を小さく抑えることで、帯域幅の占有率を下げることができます。一方で遅延は増加します。</li>
<li><code>no</code>: TCP通信時に帯域幅を広く使うことで遅延を減少させます。</li>
</ul>


<h5>スレーブのバックアップログサイズの設定</h5>

<p>マスターからスレーブへの接続が切断されてしまっている間に保存しておく差分の最大サイズです。</p>

<p>```javascript</p>

<h1>Set the replication backlog size. The backlog is a buffer that accumulates</h1>

<h1>slave data when slaves are disconnected for some time, so that when a slave</h1>

<h1>wants to reconnect again, often a full resync is not needed, but a partial</h1>

<h1>resync is enough, just passing the portion of data the slave missed while</h1>

<h1>disconnected.</h1>

<p>#</p>

<h1>The biggest the replication backlog, the longer the time the slave can be</h1>

<h1>disconnected and later be able to perform a partial resynchronization.</h1>

<p>#</p>

<h1>The backlog is only allocated once there is at least a slave connected.</h1>

<p>#</p>

<h1>repl-backlog-size 1mb</h1>

<p>```</p>

<h5>バックログファイルの維持許容時間の設定</h5>

<p>スレーブが切断されている間にバックアップのためのログ保存を行う一方で、そのバックログファイルを解放する設定も可能です。</p>

<p>```javascript</p>

<h1>After a master has no longer connected slaves for some time, the backlog</h1>

<h1>will be freed. The following option configures the amount of seconds that</h1>

<h1>need to elapse, starting from the time the last slave disconnected, for</h1>

<h1>the backlog buffer to be freed.</h1>

<p>#</p>

<h1>A value of 0 means to never release the backlog.</h1>

<p>#</p>

<h1>repl-backlog-ttl 3600</h1>

<p>```</p>

<p>上記設定でコメントアウトを外せば、1時間はバックアップログファイルを維持します。<br/>
<code>0</code>を設定した場合、ファイルの解放は実施しません。</p>

<h5>スレーブの優先度設定</h5>

<p>マスターが何らかの障害により動作できなくなった場合にスレーブがマスターに昇格することになります。<br/>
もし、スレーブが複数台存在していたら、どれをマスターに昇格させるべきか選ぶ必要があります。<br/>
その際に参考とする値となっています。(実際には <code>Redis Sentinel</code> が参考にする値)</p>

<p>```javascript</p>

<h1>The slave priority is an integer number published by Redis in the INFO output.</h1>

<h1>It is used by Redis Sentinel in order to select a slave to promote into a</h1>

<h1>master if the master is no longer working correctly.</h1>

<p>#</p>

<h1>A slave with a low priority number is considered better for promotion, so</h1>

<h1>for instance if there are three slaves with priority 10, 100, 25 Sentinel will</h1>

<h1>pick the one with priority 10, that is the lowest.</h1>

<p>#</p>

<h1>However a special priority of 0 marks the slave as not able to perform the</h1>

<h1>role of master, so a slave with priority of 0 will never be selected by</h1>

<h1>Redis Sentinel for promotion.</h1>

<p>#</p>

<h1>By default the priority is 100.</h1>

<p>slave-priority 100
```</p>

<h5>マスターへの書き込み権限の設定</h5>

<p>Redis2.8系から導入された設定です。<br/>
『マスターに最低 N スレーブが接続している場合にかぎり、書き込み要求を受け付ける設定』です。</p>

<p>```javascript</p>

<h1>It is possible for a master to stop accepting writes if there are less than</h1>

<h1>N slaves connected, having a lag less or equal than M seconds.</h1>

<p>#</p>

<h1>The N slaves need to be in &ldquo;online&rdquo; state.</h1>

<p>#</p>

<h1>The lag in seconds, that must be &lt;= the specified value, is calculated from</h1>

<h1>the last ping received from the slave, that is usually sent every second.</h1>

<p>#</p>

<h1>This option does not GUARANTEES that N replicas will accept the write, but</h1>

<h1>will limit the window of exposure for lost writes in case not enough slaves</h1>

<h1>are available, to the specified number of seconds.</h1>

<p>#</p>

<h1>For example to require at least 3 slaves with a lag &lt;= 10 seconds use:</h1>

<p>#</p>

<h1>min-slaves-to-write 3</h1>

<h1>min-slaves-max-lag 10</h1>

<p>#</p>

<h1>Setting one or the other to 0 disables the feature.</h1>

<p>#</p>

<h1>By default min-slaves-to-write is set to 0 (feature disabled) and</h1>

<h1>min-slaves-max-lag is set to 10.</h1>

<p>```</p>

<ul>
<li><code>min-slaves-to-write</code>: 書き込むために必要な最少接続スレーブ数の設定</li>
<li><code>min-slaves-max-lag</code>: 書き込むために必要な最大タイムラグの設定</li>
</ul>


<h4>セキュリティ関連の設定</h4>

<p>セキュリティ面で設定が必要な場合に活用します。</p>

<h5>認証パスワードの設定</h5>

<p>クライアントからコマンドを叩かれる前にパスワードを要求することでセキュリティを高めます。<br/>
クライアントからRedisに対して直接コマンドを叩くケースがある場合は設定しておきましょう。</p>

<p>```javascript</p>

<h1>Require clients to issue AUTH <PASSWORD> before processing any other</h1>

<h1>commands.  This might be useful in environments in which you do not trust</h1>

<h1>others with access to the host running redis-server.</h1>

<p>#</p>

<h1>This should stay commented out for backward compatibility and because most</h1>

<h1>people do not need auth (e.g. they run their own servers).</h1>

<p>#</p>

<h1>Warning: since Redis is pretty fast an outside user can try up to</h1>

<h1>150k passwords per second against a good box. This means that you should</h1>

<h1>use a very strong password otherwise it will be very easy to break.</h1>

<p>#</p>

<h1>requirepass foobared</h1>

<p>```</p>

<h5>コマンド名の変更</h5>

<p><code>slave-read-only</code>で少し触れましたが、<code>CONFIG</code>コマンドを直接クライアントから叩かれたりすると困るかもしれません。<br/>
そういったケースが想定される場合は設定しておきましょう。</p>

<p>```javascript</p>

<h1>Command renaming.</h1>

<p>#</p>

<h1>It is possible to change the name of dangerous commands in a shared</h1>

<h1>environment. For instance the CONFIG command may be renamed into something</h1>

<h1>hard to guess so that it will still be available for internal-use tools</h1>

<h1>but not available for general clients.</h1>

<p>#</p>

<h1>Example:</h1>

<p>#</p>

<h1>rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52</h1>

<p>#</p>

<h1>It is also possible to completely kill a command by renaming it into</h1>

<h1>an empty string:</h1>

<p>#</p>

<h1>rename-command CONFIG &ldquo;&rdquo;</h1>

<p>#</p>

<h1>Please note that changing the name of commands that are logged into the</h1>

<h1>AOF file or transmitted to slaves may cause problems.</h1>

<p>```</p>

<h4>リソース制限に関する設定</h4>

<p>サーバはリソースが限られているため、利用ケースに合わせてリソース制限を適切に設定することが必要です。</p>

<h5>最大同時接続クライアント数の設定</h5>

<p>デフォルト<code>10000</code>ですが、実際にはRedis Serverの予約数である<code>32</code>がそこから引かれます。<br/>
もし、設定した同時接続数を超えた場合はエラーを返却します。</p>

<p>```javascript</p>

<h1>Set the max number of connected clients at the same time. By default</h1>

<h1>this limit is set to 10000 clients, however if the Redis server is not</h1>

<h1>able to configure the process file limit to allow for the specified limit</h1>

<h1>the max number of allowed clients is set to the current file limit</h1>

<h1>minus 32 (as Redis reserves a few file descriptors for internal uses).</h1>

<p>#</p>

<h1>Once the limit is reached Redis will close all the new connections sending</h1>

<h1>an error &lsquo;max number of clients reached&rsquo;.</h1>

<p>#</p>

<h1>maxclients 10000</h1>

<p>```</p>

<h5>利用するメモリ上限の設定</h5>

<p>指定した分までメモリを利用します。<br/>
デフォルトはコメントアウトされているため、システム上限までメモリを利用できます。<br/>
上限までメモリを利用した場合の挙動については<code>maxmemory-policy</code>で指定します。</p>

<p>```javascript</p>

<h1>Don‘t use more memory than the specified amount of bytes.</h1>

<h1>When the memory limit is reached Redis will try to remove keys</h1>

<h1>according to the eviction policy selected (see maxmemory-policy).</h1>

<p>#</p>

<h1>If Redis can‘t remove keys according to the policy, or if the policy is</h1>

<h1>set to &lsquo;noeviction&rsquo;, Redis will start to reply with errors to commands</h1>

<h1>that would use more memory, like SET, LPUSH, and so on, and will continue</h1>

<h1>to reply to read-only commands like GET.</h1>

<p>#</p>

<h1>This option is usually useful when using Redis as an LRU cache, or to set</h1>

<h1>a hard memory limit for an instance (using the &lsquo;noeviction&rsquo; policy).</h1>

<p>#</p>

<h1>WARNING: If you have slaves attached to an instance with maxmemory on,</h1>

<h1>the size of the output buffers needed to feed the slaves are subtracted</h1>

<h1>from the used memory count, so that network problems / resyncs will</h1>

<h1>not trigger a loop where keys are evicted, and in turn the output</h1>

<h1>buffer of slaves is full with DELs of keys evicted triggering the deletion</h1>

<h1>of more keys, and so forth until the database is completely emptied.</h1>

<p>#</p>

<h1>In short&hellip; if you have slaves attached it is suggested that you set a lower</h1>

<h1>limit for maxmemory so that there is some free RAM on the system for slave</h1>

<h1>output buffers (but this is not needed if the policy is &lsquo;noeviction&rsquo;).</h1>

<p>#</p>

<h1>maxmemory <bytes></h1>

<p>```</p>

<h5>許容メモリ利用上限に達した場合の挙動の設定</h5>

<p>幾つか用意されたポリシーの中から挙動を選択します。</p>

<p>```javascript</p>

<h1>MAXMEMORY POLICY: how Redis will select what to remove when maxmemory</h1>

<h1>is reached. You can select among five behaviors:</h1>

<p>#</p>

<h1>volatile-lru &ndash;> remove the key with an expire set using an LRU algorithm</h1>

<h1>allkeys-lru &ndash;> remove any key accordingly to the LRU algorithm</h1>

<h1>volatile-random &ndash;> remove a random key with an expire set</h1>

<h1>allkeys-random &ndash;> remove a random key, any key</h1>

<h1>volatile-ttl &ndash;> remove the key with the nearest expire time (minor TTL)</h1>

<h1>noeviction &ndash;> don‘t expire at all, just return an error on write operations</h1>

<p>#</p>

<h1>Note: with any of the above policies, Redis will return an error on write</h1>

<h1>operations, when there are not suitable keys for eviction.</h1>

<p>#</p>

<h1>At the date of writing this commands are: set setnx setex append</h1>

<h1>incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd</h1>

<h1>sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby</h1>

<h1>zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby</h1>

<h1>getset mset msetnx exec sort</h1>

<p>#</p>

<h1>The default is:</h1>

<p>#</p>

<h1>maxmemory-policy volatile-lru</h1>

<p>```</p>

<ul>
<li><code>volatile-lru</code>: LRUアルゴリズムに基づき、期限切れ<code>key</code>を削除</li>
<li><code>allkeys-lru</code>: LRUアルゴリズムに基づき、期限に関係なく<code>key</code>を削除</li>
<li><code>volatile-random</code>: 期限切れ<code>key</code>をランダム削除</li>
<li><code>allkeys-random</code>: 全ての<code>key</code>を対象にランダム削除</li>
<li><code>volatile-ttl</code>: 期限切れの中でも最も古い<code>key</code>から順に削除</li>
<li><code>noeviction</code>: <code>key</code>に期限切れが存在しないため、上限以上の書き込みに対してはエラーを返却する</li>
</ul>


<p>LRUアルゴリズムについては<a href="https://ja.wikipedia.org/wiki/Least_Recently_Used">Least Recently Used &ndash; Wikipedia</a>を読みましょう。</p>

<h5>近似LRUアルゴリズムの精緻設定</h5>

<p>先程LRUアルゴリズムを利用する設定があることに触れましたが、Redisではメモリ消費を抑えるために正確なLRUアルゴリズムを採用してはいません。<br/>
代替手段で近似的LRUアルゴリズムを実現しているのですが、その精緻をサンプラーの数を設定することで自由度高く決めることができます。</p>

<p>```javascript</p>

<h1>LRU and minimal TTL algorithms are not precise algorithms but approximated</h1>

<h1>algorithms (in order to save memory), so you can select as well the sample</h1>

<h1>size to check. For instance for default Redis will check three keys and</h1>

<h1>pick the one that was used less recently, you can change the sample size</h1>

<h1>using the following configuration directive.</h1>

<p>#</p>

<h1>maxmemory-samples 3</h1>

<p>```</p>

<h4>AOFに関する設定</h4>

<p>AOFとは<code>Append Only File</code>の略語で追記専用ファイルを利用することによるデータ永続化を目指す設定です。</p>

<h5>AOFの利用設定</h5>

<p>AOFの利用可否を設定します。もちろん<code>yes</code>にすればAOFが利用できます。</p>

<p>```javascript</p>

<h1>By default Redis asynchronously dumps the dataset on disk. This mode is</h1>

<h1>good enough in many applications, but an issue with the Redis process or</h1>

<h1>a power outage may result into a few minutes of writes lost (depending on</h1>

<h1>the configured save points).</h1>

<p>#</p>

<h1>The Append Only File is an alternative persistence mode that provides</h1>

<h1>much better durability. For instance using the default data fsync policy</h1>

<h1>(see later in the config file) Redis can lose just one second of writes in a</h1>

<h1>dramatic event like a server power outage, or a single write if something</h1>

<h1>wrong with the Redis process itself happens, but the operating system is</h1>

<h1>still running correctly.</h1>

<p>#</p>

<h1>AOF and RDB persistence can be enabled at the same time without problems.</h1>

<h1>If the AOF is enabled on startup Redis will load the AOF, that is the file</h1>

<h1>with the better durability guarantees.</h1>

<p>#</p>

<h1>Please check <a href="http://redis.io/topics/persistence">http://redis.io/topics/persistence</a> for more information.</h1>

<p>appendonly no
```</p>

<h5>AOFファイル名の設定</h5>

<p>ファイル名を設定します。</p>

<p>```javascript</p>

<h1>The name of the append only file (default: &ldquo;appendonly.aof&rdquo;)</h1>

<p>appendfilename &ldquo;appendonly.aof&rdquo;
```</p>

<h5>AOFへの同期タイミングの設定</h5>

<p>Redisには3つのモードが存在します。</p>

<ul>
<li><code>no</code>: <code>fsync</code>を利用せずOSに全てを任せます。高速です。</li>
<li><code>always</code>: 追記専用ログへの書き込み発生する際に必ず<code>fsync</code>を実行します。遅いですが安全です。</li>
<li><code>everysec</code>: 毎秒ごとに<code>fsync</code>を実行します。</li>
</ul>


<p>```javascript</p>

<h1>The fsync() call tells the Operating System to actually write data on disk</h1>

<h1>instead to wait for more data in the output buffer. Some OS will really flush</h1>

<h1>data on disk, some other OS will just try to do it ASAP.</h1>

<p>#</p>

<h1>Redis supports three different modes:</h1>

<p>#</p>

<h1>no: don‘t fsync, just let the OS flush the data when it wants. Faster.</h1>

<h1>always: fsync after every write to the append only log . Slow, Safest.</h1>

<h1>everysec: fsync only one time every second. Compromise.</h1>

<p>#</p>

<h1>The default is &ldquo;everysec&rdquo;, as that‘s usually the right compromise between</h1>

<h1>speed and data safety. It‘s up to you to understand if you can relax this to</h1>

<h1>&ldquo;no&rdquo; that will let the operating system flush the output buffer when</h1>

<h1>it wants, for better performances (but if you can live with the idea of</h1>

<h1>some data loss consider the default persistence mode that‘s snapshotting),</h1>

<h1>or on the contrary, use &ldquo;always&rdquo; that‘s very slow but a bit safer than</h1>

<h1>everysec.</h1>

<p>#</p>

<h1>More details please check the following article:</h1>

<h1><a href="http://antirez.com/post/redis-persistence-demystified.html">http://antirez.com/post/redis-persistence-demystified.html</a></h1>

<p>#</p>

<h1>If unsure, use &ldquo;everysec&rdquo;.</h1>

<h1>appendfsync always</h1>

<p>appendfsync everysec</p>

<h1>appendfsync no</h1>

<p>```</p>

<p>デフォルトは<code>everysec</code>が設定されています。</p>

<h5>ディスクI/O遅延に対する設定</h5>

<p><code>save</code>プロセスがディスクに対して大量のI/Oを発生させていた場合、<code>fsync</code>呼び出し時にRedisが長時間ブロックする可能性があります。<br/>
バックグラウンドプロセスで<code>save</code>が動いている場合は<code>fsync</code>を止めるように設定することで、この問題を回避することができます。<br/>
(<code>no-appendfsync-on-rewrite</code>は文字通りそういった意味ですね。)</p>

<p>```javascript</p>

<h1>When the AOF fsync policy is set to always or everysec, and a background</h1>

<h1>saving process (a background save or AOF log background rewriting) is</h1>

<h1>performing a lot of I/O against the disk, in some Linux configurations</h1>

<h1>Redis may block too long on the fsync() call. Note that there is no fix for</h1>

<h1>this currently, as even performing fsync in a different thread will block</h1>

<h1>our synchronous write(2) call.</h1>

<p>#</p>

<h1>In order to mitigate this problem it‘s possible to use the following option</h1>

<h1>that will prevent fsync() from being called in the main process while a</h1>

<h1>BGSAVE or BGREWRITEAOF is in progress.</h1>

<p>#</p>

<h1>This means that while another child is saving, the durability of Redis is</h1>

<h1>the same as &ldquo;appendfsync none&rdquo;. In practical terms, this means that it is</h1>

<h1>possible to lose up to 30 seconds of log in the worst scenario (with the</h1>

<h1>default Linux settings).</h1>

<p>#</p>

<h1>If you have latency problems turn this to &ldquo;yes&rdquo;. Otherwise leave it as</h1>

<h1>&ldquo;no&rdquo; that is the safest pick from the point of view of durability.</h1>

<p>no-appendfsync-on-rewrite no
```</p>

<ul>
<li><code>yes</code>: バックグランドプロセスで<code>save</code>が動いていたら<code>fsync</code>しない</li>
<li><code>no</code>: 上記縛りを設定しない</li>
</ul>


<h5>AOFのログファイル自動書き換え設定</h5>

<p>AOFファイルサイズが肥大したときに対処するための基準を設定します。</p>

<p>```javascript</p>

<h1>Automatic rewrite of the append only file.</h1>

<h1>Redis is able to automatically rewrite the log file implicitly calling</h1>

<h1>BGREWRITEAOF when the AOF log size grows by the specified percentage.</h1>

<p>#</p>

<h1>This is how it works: Redis remembers the size of the AOF file after the</h1>

<h1>latest rewrite (if no rewrite has happened since the restart, the size of</h1>

<h1>the AOF at startup is used).</h1>

<p>#</p>

<h1>This base size is compared to the current size. If the current size is</h1>

<h1>bigger than the specified percentage, the rewrite is triggered. Also</h1>

<h1>you need to specify a minimal size for the AOF file to be rewritten, this</h1>

<h1>is useful to avoid rewriting the AOF file even if the percentage increase</h1>

<h1>is reached but it is still pretty small.</h1>

<p>#</p>

<h1>Specify a percentage of zero in order to disable the automatic AOF</h1>

<h1>rewrite feature.</h1>

<p>auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb
```</p>

<ul>
<li><code>auto-aof-rewrite-percentage</code>: 書き換えを発生させるファイルサイズの基準</li>
<li><code>auto-aof-rewrite-min-size</code>: ここで指定したファイルサイズ以内であれば書き換えを実行しません</li>
</ul>


<h4>LUAスクリプトに関する設定</h4>

<p>LUAスクリプトを実行する場合に必要な設定です。<br/>
と言っても最大実行時間しかありません。</p>

<p>```javascript</p>

<h1>Max execution time of a Lua script in milliseconds.</h1>

<p>#</p>

<h1>If the maximum execution time is reached Redis will log that a script is</h1>

<h1>still in execution after the maximum allowed time and will start to</h1>

<h1>reply to queries with an error.</h1>

<p>#</p>

<h1>When a long running script exceed the maximum execution time only the</h1>

<h1>SCRIPT KILL and SHUTDOWN NOSAVE commands are available. The first can be</h1>

<h1>used to stop a script that did not yet called write commands. The second</h1>

<h1>is the only way to shut down the server in the case a write commands was</h1>

<h1>already issue by the script but the user don‘t want to wait for the natural</h1>

<h1>termination of the script.</h1>

<p>#</p>

<h1>Set it to 0 or a negative value for unlimited execution without warnings.</h1>

<p>lua-time-limit 5000
```</p>

<h4>スローログの設定</h4>

<p>サービスレベルに耐えられないスロークエリを事前に検出するための設定です。<br/>
サービスレベル上、許容できないスロークエリの閾値を指定することで、その閾値を超えたクエリをログファイルに記録します。</p>

<p>```javascript</p>

<h1>The Redis Slow Log is a system to log queries that exceeded a specified</h1>

<h1>execution time. The execution time does not include the I/O operations</h1>

<h1>like talking with the client, sending the reply and so forth,</h1>

<h1>but just the time needed to actually execute the command (this is the only</h1>

<h1>stage of command execution where the thread is blocked and can not serve</h1>

<h1>other requests in the meantime).</h1>

<p>#</p>

<h1>You can configure the slow log with two parameters: one tells Redis</h1>

<h1>what is the execution time, in microseconds, to exceed in order for the</h1>

<h1>command to get logged, and the other parameter is the length of the</h1>

<h1>slow log. When a new command is logged the oldest one is removed from the</h1>

<h1>queue of logged commands.</h1>

<h1>The following time is expressed in microseconds, so 1000000 is equivalent</h1>

<h1>to one second. Note that a negative number disables the slow log, while</h1>

<h1>a value of zero forces the logging of every command.</h1>

<p>slowlog-log-slower-than 10000</p>

<h1>There is no limit to this length. Just be aware that it will consume memory.</h1>

<h1>You can reclaim memory used by the slow log with SLOWLOG RESET.</h1>

<p>slowlog-max-len 128
```</p>

<ul>
<li><code>slowlog-log-slower-than</code>: スロークエリとみなす実行時間の閾値。マイクロ秒です。</li>
<li><code>slowlog-max-len</code>: スロークエリログとして記録する容量の閾値。超えると古い順に削除します。</li>
</ul>


<h4>イベント通知設定</h4>

<p>Pub/Sub利用時に設定するようです。<br/>
Redisが通知するイベントは幾つかあるのですが、全て1文字で表現されており、<code>notify-keyspace-events</code>に指定することで通知イベントを決定します。</p>

<p>```javascript</p>

<h1>Redis can notify Pub/Sub clients about events happening in the key space.</h1>

<h1>This feature is documented at <a href="http://redis.io/topics/keyspace-events">http://redis.io/topics/keyspace-events</a></h1>

<p>#</p>

<h1>For instance if keyspace events notification is enabled, and a client</h1>

<h1>performs a DEL operation on key &ldquo;foo&rdquo; stored in the Database 0, two</h1>

<h1>messages will be published via Pub/Sub:</h1>

<p>#</p>

<h1>PUBLISH <strong>keyspace@0</strong>:foo del</h1>

<h1>PUBLISH <strong>keyevent@0</strong>:del foo</h1>

<p>#</p>

<h1>It is possible to select the events that Redis will notify among a set</h1>

<h1>of classes. Every class is identified by a single character:</h1>

<p>#</p>

<h1>K     Keyspace events, published with <strong>keyspace@<db></strong> prefix.</h1>

<h1>E     Keyevent events, published with <strong>keyevent@<db></strong> prefix.</h1>

<h1>g     Generic commands (non-type specific) like DEL, EXPIRE, RENAME, &hellip;</h1>

<h1>$     String commands</h1>

<h1>l     List commands</h1>

<h1>s     Set commands</h1>

<h1>h     Hash commands</h1>

<h1>z     Sorted set commands</h1>

<h1>x     Expired events (events generated every time a key expires)</h1>

<h1>e     Evicted events (events generated when a key is evicted for maxmemory)</h1>

<h1>A     Alias for g$lshzxe, so that the &ldquo;AKE&rdquo; string means all the events.</h1>

<p>#</p>

<h1>The &ldquo;notify-keyspace-events&rdquo; takes as argument a string that is composed</h1>

<h1>by zero or multiple characters. The empty string means that notifications</h1>

<h1>are disabled at all.</h1>

<p>#</p>

<h1>Example: to enable list and generic events, from the point of view of the</h1>

<h1>event name, use:</h1>

<p>#</p>

<h1>notify-keyspace-events Elg</h1>

<p>#</p>

<h1>Example 2: to get the stream of the expired keys subscribing to channel</h1>

<h1>name <strong>keyevent@0</strong>:expired use:</h1>

<p>#</p>

<h1>notify-keyspace-events Ex</h1>

<p>#</p>

<h1>By default all notifications are disabled because most users don‘t need</h1>

<h1>this feature and the feature has some overhead. Note that if you don‘t</h1>

<h1>specify at least one of K or E, no events will be delivered.</h1>

<p>notify-keyspace-events &ldquo;&rdquo;
```</p>

<ul>
<li><code>AKE</code>: これを設定することで全ての通知タイプに対応します。</li>
<li><code>空文字</code>: これを設定することで全ての通知を無効にします。</li>
</ul>


<h4>高度な設定</h4>

<p>この辺りが意識して触れるようになったらRedis上級者と見なせるのではないでしょうか。</p>

<h5>Hash型データのメモリ効率設定</h5>

<p>CPUとメモリのトレードオフにはなるのですが、「要素数の上限」と「1要素あたりの上限サイズ」の2つの閾値以内に収まる場合に、非常にメモリ効率の良い方法でエンコードされます。<br/>
これによりメモリが最大10分の1、平均でも5分の1に抑えられます。</p>

<p>```javascript</p>

<h1>Hashes are encoded using a memory efficient data structure when they have a</h1>

<h1>small number of entries, and the biggest entry does not exceed a given</h1>

<h1>threshold. These thresholds can be configured using the following directives.</h1>

<p>hash-max-ziplist-entries 512
hash-max-ziplist-value 64
```</p>

<ul>
<li><code>hash-max-ziplist-entries</code>: 要素数の上限</li>
<li><code>hash-max-ziplist-value</code>: 1要素あたりの上限サイズ</li>
</ul>


<h5>List型データのメモリ効率設定</h5>

<p>List型データに対する設定です。(各々の意味はHash型と同じです。)</p>

<p>```javascript</p>

<h1>Similarly to hashes, small lists are also encoded in a special way in order</h1>

<h1>to save a lot of space. The special representation is only used when</h1>

<h1>you are under the following limits:</h1>

<p>list-max-ziplist-entries 512
list-max-ziplist-value 64
```</p>

<h5>Set型データのメモリ効率設定</h5>

<p>Set型データに対する設定です。<br/>
Set型のみ圧縮方式が<code>ziplist</code>ではなく<code>intset</code>であるためか設定項目数が異なります。</p>

<p>```javascript</p>

<h1>Sets have a special encoding in just one case: when a set is composed</h1>

<h1>of just strings that happens to be integers in radix 10 in the range</h1>

<h1>of 64 bit signed integers.</h1>

<h1>The following configuration setting sets the limit in the size of the</h1>

<h1>set in order to use this special memory saving encoding.</h1>

<p>set-max-intset-entries 512
```</p>

<h5>ZSet型データのメモリ効率設定</h5>

<p>ZSet型データに対する設定です。(各々の意味はHash型と同じです。)</p>

<p>```javascript</p>

<h1>Similarly to hashes and lists, sorted sets are also specially encoded in</h1>

<h1>order to save a lot of space. This encoding is only used when the length and</h1>

<h1>elements of a sorted set are below the following limits:</h1>

<p>zset-max-ziplist-entries 128
zset-max-ziplist-value 64
```</p>

<h5>再ハッシュ設定</h5>

<p>これは、『100ミリ秒ごとに1ミリ秒のCPU時間を使用して、Redisのメインのハッシュテーブル(トップレベルのキーと値を保持している)の再ハッシュ化を行う』設定です。<br/>
<code>yes</code>にすることでメモリが効率的に利用されるようになる一方で最大2ミリ秒間の遅延が発生する可能性があります。<br/>
この2ミリ秒間の遅延を許容できない場合は<code>no</code>に設定を変更しましょう。</p>

<p>```javascript</p>

<h1>Active rehashing uses 1 millisecond every 100 milliseconds of CPU time in</h1>

<h1>order to help rehashing the main Redis hash table (the one mapping top-level</h1>

<h1>keys to values). The hash table implementation Redis uses (see dict.c)</h1>

<h1>performs a lazy rehashing: the more operation you run into a hash table</h1>

<h1>that is rehashing, the more rehashing &ldquo;steps&rdquo; are performed, so if the</h1>

<h1>server is idle the rehashing is never complete and some more memory is used</h1>

<h1>by the hash table.</h1>

<p>#</p>

<h1>The default is to use this millisecond 10 times every second in order to</h1>

<h1>active rehashing the main dictionaries, freeing memory when possible.</h1>

<p>#</p>

<h1>If unsure:</h1>

<h1>use &ldquo;activerehashing no&rdquo; if you have hard latency requirements and it is</h1>

<h1>not a good thing in your environment that Redis can reply form time to time</h1>

<h1>to queries with 2 milliseconds delay.</h1>

<p>#</p>

<h1>use &ldquo;activerehashing yes&rdquo; if you don‘t have such hard requirements but</h1>

<h1>want to free memory asap when possible.</h1>

<p>activerehashing yes
```</p>

<p>2ミリ秒の遅延も許せないサービスってあるんだろうか&hellip;と思いつつも。</p>

<h5>クライアントの出力バッファ制限の設定</h5>

<p>指定した値以上に出力バッファが到達するとクライアントとの接続を強制的に切断します。<br/>
出力バッファが制限値に到達し続けるということは、想定した出力バッファサイズと処理速度を見誤っている可能性があるということです。</p>

<p>```javascript</p>

<h1>The client output buffer limits can be used to force disconnection of clients</h1>

<h1>that are not reading data from the server fast enough for some reason (a</h1>

<h1>common reason is that a Pub/Sub client can‘t consume messages as fast as the</h1>

<h1>publisher can produce them).</h1>

<p>#</p>

<h1>The limit can be set differently for the three different classes of clients:</h1>

<p>#</p>

<h1>normal &ndash;> normal clients</h1>

<h1>slave  &ndash;> slave clients and MONITOR clients</h1>

<h1>pubsub &ndash;> clients subscribed to at least one pubsub channel or pattern</h1>

<p>#</p>

<h1>The syntax of every client-output-buffer-limit directive is the following:</h1>

<p>#</p>

<h1>client-output-buffer-limit <class> <hard limit> <soft limit> <soft seconds></h1>

<p>#</p>

<h1>A client is immediately disconnected once the hard limit is reached, or if</h1>

<h1>the soft limit is reached and remains reached for the specified number of</h1>

<h1>seconds (continuously).</h1>

<h1>So for instance if the hard limit is 32 megabytes and the soft limit is</h1>

<h1>16 megabytes / 10 seconds, the client will get disconnected immediately</h1>

<h1>if the size of the output buffers reach 32 megabytes, but will also get</h1>

<h1>disconnected if the client reaches 16 megabytes and continuously overcomes</h1>

<h1>the limit for 10 seconds.</h1>

<p>#</p>

<h1>By default normal clients are not limited because they don‘t receive data</h1>

<h1>without asking (in a push way), but just after a request, so only</h1>

<h1>asynchronous clients may create a scenario where data is requested faster</h1>

<h1>than it can read.</h1>

<p>#</p>

<h1>Instead there is a default limit for pubsub and slave clients, since</h1>

<h1>subscribers and slaves receive data in a push fashion.</h1>

<p>#</p>

<h1>Both the hard or the soft limit can be disabled by setting them to zero.</h1>

<p>client-output-buffer-limit normal 0 0 0
client-output-buffer-limit slave 256mb 64mb 60
client-output-buffer-limit pubsub 32mb 8mb 60
```</p>

<ul>
<li><code>client-output-buffer-limit normal 0 0 0</code>

<ul>
<li>通常クライアントに対する設定</li>
<li>hard limit / soft limit を0設定して無効化している</li>
</ul>
</li>
<li><code>client-output-buffer-limit slave 256mb 64mb 60</code>

<ul>
<li>スレーブクライアントに対する設定</li>
<li>hard limitが256mbなので、256MBに到達した時点で即時切断します</li>
<li>soft limitが64mb, soft secondsが60なので、出力バッファが60秒間64MBに到達し続けた場合に切断します</li>
<li>ここはレプリケーション設定にも関わってくるため設定値は考えてつける必要があります</li>
</ul>
</li>
<li><code>client-output-buffer-limit pubsub 32mb 8mb 60</code>

<ul>
<li>Pub/Sub(購読)クライアントに対する設定</li>
<li>hard limitが32mbなので、32MBに到達した時点で即時切断します</li>
<li>soft limitが8mb, soft secondsが60なので、出力バッファが60秒間8MBに到達し続けた場合に切断します</li>
</ul>
</li>
</ul>


<h5>バックグラウンド処理の頻度に関する設定</h5>

<p>Redisはバックグランドタスクとして、タイムアウトしたクライアントとのコネクションの切断 / 期限切れキーの削除などを実施しています。<br/>
その頻度を<code>hz</code>の値によって決めています。<br/>
基本的に推奨値は<code>10</code>なので変更することは少ないと思われます。<br/>
低レイテンシを厳しく求められる環境でのみ<code>100</code>を設定しても良いでしょう。</p>

<p>```javascript</p>

<h1>Redis calls an internal function to perform many background tasks, like</h1>

<h1>closing connections of clients in timeout, purging expired keys that are</h1>

<h1>never requested, and so forth.</h1>

<p>#</p>

<h1>Not all tasks are performed with the same frequency, but Redis checks for</h1>

<h1>tasks to perform accordingly to the specified &ldquo;hz&rdquo; value.</h1>

<p>#</p>

<h1>By default &ldquo;hz&rdquo; is set to 10. Raising the value will use more CPU when</h1>

<h1>Redis is idle, but at the same time will make Redis more responsive when</h1>

<h1>there are many keys expiring at the same time, and timeouts may be</h1>

<h1>handled with more precision.</h1>

<p>#</p>

<h1>The range is between 1 and 500, however a value over 100 is usually not</h1>

<h1>a good idea. Most users should use the default of 10 and raise this up to</h1>

<h1>100 only in environments where very low latency is required.</h1>

<p>hz 10
```</p>

<h5>AOF書き換え時のfsyncの設定</h5>

<p><code>yes</code>を設定することで、32MBごとにfsyncを実行するようになります。<br/>
これによりファイルをディスクに書き込む際に、大きな遅延スパイクが発生するのを避けることができます。</p>

<p>```javascript</p>

<h1>When a child rewrites the AOF file, if the following option is enabled</h1>

<h1>the file will be fsync-ed every 32 MB of data generated. This is useful</h1>

<h1>in order to commit the file to the disk more incrementally and avoid</h1>

<h1>big latency spikes.</h1>

<p>aof-rewrite-incremental-fsync yes
```</p>

<h3>まとめ</h3>

<p>細かな設定の棚卸しをしてみたものの、かなりしんどかったです&hellip;<br/>
運用してみないと想像がつかない設定も多く、この辺りは本当に実務でしか経験を養えないのだと痛感しました。<br/>
しかし、各々の意味を理解しておくことは決して無駄ではないと思うので、勉強になったかなと思います。<br/>
と言ったところで本日はここまで。</p>

<h3>参考</h3>

<ul>
<li><a href="http://redis-documentasion-japanese.readthedocs.io/ja/latest/topics/replication.html">Redis Documentation レプリケーション</a></li>
<li><a href="http://redis-documentasion-japanese.readthedocs.io/ja/latest/topics/lru-cache.html">Redis Documentation LRUキャッシュ</a></li>
<li><a href="http://redis-documentasion-japanese.readthedocs.io/ja/latest/topics/notifications.html">Redis Documentation キー・スペース通知</a></li>
<li><a href="http://redis-documentasion-japanese.readthedocs.io/ja/latest/topics/memory-optimization.html">Redis Documentation メモリ最適化</a></li>
<li><a href="http://t-cyrill.hatenablog.jp/entry/2016/12/11/224604">真剣にRedisを使ってみようという気持ちになったのでRedisについて知っていることを書く</a></li>
<li><a href="http://qiita.com/eccyan/items/e8cc56948a00d6aad0aa">Redis のメモリが足りなくなった時にどうやってチューニングしたか</a></li>
<li><a href="http://mocobeta-backup.tumblr.com/post/84793291682/redis-set">Redisのメモリ使用量削減</a></li>
<li><a href="http://tech.guitarrapc.com/entry/2013/08/02/210858">EC2など 高負荷クラウド環境における Redis のチューニングについて</a></li>
<li><a href="http://redis.shibu.jp/admin/config.html">redis 2.0.3 documentation</a></li>
</ul>


<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dockerコンテナ内のUbuntuでApache設定を試してみよう！]]></title>
    <link href="http://grandbig.github.io/blog/2017/02/19/docker-for-mac-3/"/>
    <updated>2017-02-19T23:45:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2017/02/19/docker-for-mac-3</id>
    <content type="html"><![CDATA[<h3>はじめに</h3>

<p>前回の<a href="http://grandbig.github.io/blog/2017/02/19/docker-for-mac-2/">DockerにWebサーバーを立てよう！</a>に引き続きDocker内Apacheで遊んでみます。<br/>
前回はUbuntuへのApacheインストールから起動まで見てきました。<br/>
実際の現場でApacheを利用する際は様々な設定を施す必要があります。<br/>
本記事ではその一端を少しでも学ぼうということで書いていきます。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h3>DocumentRootの設定</h3>

<p>Apacheでは設定ファイルで静的ファイルのルートパスを設定することができます。<br/>
デフォルトでは<code>/var/www/html</code>になっています。<br/>
これは、<code>/etc/apache2/sites-enabled/000-default.conf</code>で次のように定義されています。</p>

<p>```javascript
<VirtualHost *:80>
  # The ServerName directive sets the request scheme, hostname and port that
  # the server uses to identify itself. This is used when creating
  # redirection URLs. In the context of virtual hosts, the ServerName
  # specifies what hostname must appear in the request’s Host: header to
  # match this virtual host. For the default virtual host (this file) this
  # value is not decisive as it is used as a last resort host regardless.
  # However, you must set it for any further virtual host explicitly.
  #ServerName www.example.com</p>

<p>  ServerAdmin webmaster@localhost
  DocumentRoot /var/www/html</p>

<p>  # Available loglevels: trace8, &hellip;, trace1, debug, info, notice, warn,
  # error, crit, alert, emerg.
  # It is also possible to configure the loglevel for particular
  # modules, e.g.
  #LogLevel info ssl:warn</p>

<p>  ErrorLog ${APACHE_LOG_DIR}/error.log
  CustomLog ${APACHE_LOG_DIR}/access.log combined</p>

<p>  # For most configuration files from conf-available/, which are
  # enabled or disabled at a global level, it is possible to
  # include a line for only one particular virtual host. For example the
  # following line enables the CGI configuration for this host only
  # after it has been globally disabled with &ldquo;a2disconf&rdquo;.
  #Include conf-available/serve-cgi-bin.conf
</VirtualHost></p>

<h1>vim: syntax=apache ts=4 sw=4 sts=4 sr noet</h1>

<p>```</p>

<p>必要があれば書き換えて使いましょう。</p>

<h3>リバースプロキシ設定</h3>

<p>リバースプロキシとは、</p>

<ul>
<li>クライアントからのアクセスをキャッチして、特定のサーバへ送るプロキシサーバ</li>
<li>セキュリティや負荷分散などのために利用される</li>
</ul>


<p>ものです。<br/>
詳しくは<a href="https://ja.wikipedia.org/wiki/%E3%83%AA%E3%83%90%E3%83%BC%E3%82%B9%E3%83%97%E3%83%AD%E3%82%AD%E3%82%B7">リバースプロキシ &ndash; wiki</a>を見てください。</p>

<p>設定はいたって簡単です。<br/>
まずは、モジュールの有効化をするために下記コマンドを打ちましょう。</p>

<p>```javascript
// プロキシモジュールの有効化
$ a2enmod proxy proxy_http
Enabling module proxy.
Considering dependency proxy for proxy_<a href="http:">http:</a>
Module proxy already enabled
Enabling module proxy_http.
To activate the new configuration, you need to run:
  service apache2 restart</p>

<p>// Apacheを再起動
$ /etc/init.d/apache2 restart
```</p>

<p>続いて、設定ファイルを更新します。</p>

<p>```javascript
<IfModule mod_proxy.c></p>

<p>  # If you want to use apache2 as a forward proxy, uncomment the
  # &lsquo;ProxyRequests On&rsquo; line and the <Proxy *> block below.
  # WARNING: Be careful to restrict access inside the <Proxy *> block.
  # Open proxy servers are dangerous both to your network and to the
  # Internet at large.
  #
  # If you only want to use apache2 as a reverse proxy/gateway in
  # front of some web application server, you DON’T need
  ProxyRequests Off</p>

<p>  <Proxy *>
  #   AddDefaultCharset off
  #   Require all denied
  #   #Require local</p>

<pre><code>Require all granted
</code></pre>

<p>  </Proxy>
  ProxyPass /hoge/ <a href="http://localhost:80/hoge.html">http://localhost:80/hoge.html</a>
  ProxyPassReverse /hoge/ <a href="http://localhost:80/hoge.html">http://localhost:80/hoge.html</a></p>

<p>  # Enable/disable the handling of HTTP/1.1 &ldquo;Via:&rdquo; headers.
  # (&ldquo;Full&rdquo; adds the server version; &ldquo;Block&rdquo; removes all outgoing Via: headers)
  # Set to one of: Off | On | Full | Block
  #ProxyVia Off
</IfModule></p>

<h1>vim: syntax=apache ts=4 sw=4 sts=4 sr noet</h1>

<p>```</p>

<p>上記の設定について説明します。</p>

<ul>
<li><code>ProxyRequests Off</code>: フォワードプロキシをOFFにする設定です</li>
<li><code>&lt;Proxy *&gt; 〜 &lt;/Proxy&gt;</code>: アクセスパスに対するアクセス権限範囲を設定します</li>
<li><code>ProxyPass 元のアクセス要求パス 転送パス</code>: クライアントからのアクセス要求を転送します</li>
<li><code>ProxyPassReverse 元のアクセス要求パス 転送パス</code>: Apache に HTTP リダイレクト応答の Location, Content-Location, URI ヘッダの調整を担います</li>
</ul>


<p>筆者自身、フォワードプロキシという単語を意識して使ったことがなかったのですが、ごくごく普通に使われているものなんですよね&hellip;<br/>
Apache公式ページの下記記述を見るとよくわかります。</p>

<blockquote><p>ファイアウォールによって 制限されている内部のクライアントにインターネットへのアクセスを 提供するもの</p></blockquote>

<p>どうも<code>ProxyPassReverse</code>は理解するのが厄介だったようで多くの方が記事にしてくれていました。</p>

<ul>
<li><a href="http://dev.classmethod.jp/server-side/server/introduction_mod_proxy/">mod_proxy再入門 – ProxyPassとProxyPassReverse</a></li>
<li><a href="http://d.hatena.ne.jp/a666666/20090211/1234348004">やっとわかった、リバースプロキシの設定の意味</a></li>
</ul>


<p>上記設定をしたので下記にアクセスしてみます。<br/>
<code>http://localhost:15600/hoge/</code><br/>
結果は下記の通りです。</p>

<p><img src="/images/docker_reverse_proxy.png" alt="リバースプロキシした画面を表示" /></p>

<p>このために用意した<code>hoge.html</code>が表示されました。</p>

<h3>RewriteRuleの設定</h3>

<p><code>Rewrite</code>はクライアントからのリクエストを内部変換してリダイレクトするような機能です。<br/>
今回は些か簡単な例を扱ったためリバースプロキシとの違いがわかりにくかったかもしれません。<br/>
あくまでも<code>Rewrite</code>はパスの読み替えであるため、物理的に別のサーバに接続を促すようなリバースプロキシならではの設定はできません。</p>

<p>まずはモジュールを有効化させます。</p>

<p>```javascript
$ a2enmod rewrite
Enabling module rewrite.
To activate the new configuration, you need to run:
  service apache2 restart</p>

<p>// Apacheを再起動
$ /etc/init.d/apache2 restart
```</p>

<p>続いて、静的ファイルパスへのアクセス制限を変更します。</p>

<p><code>javascript
// /etc/apache2/apache2.conf
&lt;Directory /var/www/&gt;
  Options Indexes FollowSymLinks
  AllowOverride All
  Require all granted
&lt;/Directory&gt;
</code></p>

<p>デフォルトでは上記が<code>AllowOverride None</code>だったのを<code>AllowOverride All</code>に変更しています。<br/>
さらに、<code>.htaccess</code>ファイルを作成して書き換えルールを記載します。<br/>
<code>.htaccess</code>を利用する設定は<code>apache2.conf</code>にデフォルトで記載されています。</p>

<p>```javascript
// /etc/apache2/apache2.conf</p>

<h1>AccessFileName: The name of the file to look for in each directory</h1>

<h1>for additional configuration directives.  See also the AllowOverride</h1>

<h1>directive.</h1>

<p>#
AccessFileName .htaccess
```</p>

<p>そして実際の<code>RewriteRule</code>の記載です。</p>

<p><code>javascript
// /var/www/html/.htaccess
&lt;IfModule mod_rewrite.c&gt;
RewriteEngine On
RewriteRule ^fuga/(.*)$ /bar/$1
&lt;/IfModule&gt;
</code></p>

<p>サンプル用に、<code>/var/www/html</code>配下に<code>bar</code>フォルダを作成し、その配下に<code>index.html</code>を作成しました。<br/>
上記設定をしたので下記にアクセスしてみます。<br/>
<code>http://localhost:15600/fuga/</code><br/>
結果は下記の通りです。</p>

<p><img src="/images/docker_rewrite.png" alt="RewriteRule適用" /></p>

<h3>ErrorDocumentの設定</h3>

<p>エラー発生時にカスタムエラーページを表示したいときなどに利用します。<br/>
具体的には、</p>

<p>```javascript
// /etc/apache2/site-enabled/000-default.conf
<VirtualHost *:80>
  &hellip;
  ErrorLog ${APACHE_LOG_DIR}/error.log
  CustomLog ${APACHE_LOG_DIR}/access.log combined</p>

<p>  // 以下、ErrorDocumentの設定
  ErrorDocument 404 error_404.html
  ErrorDocument 500 error_500.html
  &hellip;
</VirtualHost>
```</p>

<p>のように設定が可能です。<br/>
Ubuntuの場合、<code>/etc/apache2/conf-enabled/localized-error-pages.conf</code>に<code>ErrorDocument</code>の構文が全てコメントアウトの状態で記載があるため、本格的にやるならきちんとファイルを分けた方が良さそうです。</p>

<h3>まとめ</h3>

<p>さて今回はApacheの設定を少し見ることができました。<br/>
WEBサーバとはどんなものなのか、わかったようでわかっていなかったことが見えてきた気がします。<br/>
引き続き勉強を続けていきたいものです。<br/>
と言ったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dockerコンテナ内のUbuntuにWebサーバーを立てよう！]]></title>
    <link href="http://grandbig.github.io/blog/2017/02/19/docker-for-mac-2/"/>
    <updated>2017-02-19T15:05:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2017/02/19/docker-for-mac-2</id>
    <content type="html"><![CDATA[<h3>はじめに</h3>

<p>さて、今回は前回(<a href="http://grandbig.github.io/blog/2017/02/13/docker-for-mac-1/">Docker for Macをインストールしよう！</a>)構築したDocker内のUbuntuサーバの中で遊んでみます。<br/>
まずは、基本となるWebサーバを立てるところから始めたいと思います。</p>

<p>今回は最も有名であろう(Nginxも人気ですが&hellip;) <strong>Apache</strong> を利用したWebサーバの構築をしてみます。<br/>
限りなく常識に近いと思うものの、一応概要だけ紹介すると、Apacheとは下記の通りです。</p>

<ul>
<li>正式名所は「 <strong>Apache HTTP Server</strong> 」</li>
<li>Webサーバソフトウェア</li>
<li>Apache Licenseで無償で提供</li>
<li>2.2系と2.4系があるがモダンなのは <strong>2.4系</strong></li>
</ul>


<p>というところで早速見ていきましょう。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h3>Host Macからアクセスするためのポートフォワード設定</h3>

<p>これからApacheをインストールするわけですが、その前にDockerコンテナにポートフォワード設定をしてみましょう。<br/>
Docker for Macなら簡単にできます。</p>

<p>１．該当コンテナの設定を見ましょう</p>

<p><img src="/images/docker_port_forward_1.png" alt="設定を見る" /></p>

<p>２．Port設定を見ましょう</p>

<p><img src="/images/docker_port_forward_2.png" alt="Port設定を見る" /></p>

<p>３．ポートフォワードの設定を追加する</p>

<p><img src="/images/docker_port_forward_3.png" alt="ポートフォワードの設定を追加" /></p>

<p>上記では、<code>http://localhost:15600/</code>でMacからアクセスできるようにしています。<br/>
<code>localhost</code>でなく、具体的にIPアドレスを指定しても良いようですが、今回は特に必要ないのでこれでいきます。</p>

<h3>Apacheのインストール</h3>

<p>まずは当然のことながらインストール作業から始めます。<br/>
DockerのUbuntuコンテナを起動した後にログインして、下記コマンドを叩きましょう。</p>

<p>ログインはDockerアプリに含まれている <strong>Kitematic</strong> からもできますし、コマンドでもできます。</p>

<p>```javascript
// docker コンテナにログイン
$ docker exec -it &lt;&lt;コンテナ名>> bash</p>

<p>// apt-getのアップデート
$ apt-get update
// Apacheのインストール
$ apt-get install apache2
```</p>

<p>なぜ初めに<code>apt-get update</code>をやっているかと言うと、これをやらずに突き進もうとした際に下記エラーが発生したためです。</p>

<p>```javascript</p>

<h1>apt-get install apache2</h1>

<p>Reading package lists&hellip; Done
Building dependency tree     <br/>
Reading state information&hellip; Done
E: Unable to locate package apache2
```</p>

<p>きちんとApacheのインストールが完了したか確認するためにバージョンを見てみましょう。</p>

<p>```javascript
// バージョン確認方法(1)
$ apachectl -v
Server version: Apache/2.4.18 (Ubuntu)
Server built:   2016-07-14T12:32:26</p>

<p>// バージョン確認方法(2)
$ apache2 -v
Server version: Apache/2.4.18 (Ubuntu)
Server built:   2016-07-14T12:32:26
```</p>

<h3>Apacheの起動確認</h3>

<p>インストール後はデフォルトで起動していると思いますが、念のため確認しておきましょう。</p>

<p><code>javascript
$ /etc/init.d/apache2 status
 * apache2 is running
</code></p>

<p>因みに、初期状態では<code>start</code>や<code>restart</code>コマンドを実行したときに下記警告が表示されます。</p>

<p><code>javascript
$ /etc/init.d/apache2 restart
 * Restarting Apache httpd web server apache2                                                                                                                                                           AH00558: apache2: Could not reliably determine the server’s fully qualified domain name, using XX.XX.XX.XX. Set the 'ServerName' directive globally to suppress this message
</code></p>

<p>これを回避するためには設定ファイルに<code>ServerName</code>を定義する必要があります。<br/>
(警告は出るものの、起動には何ら問題はありません。)</p>

<p>下記のように設定ファイルを開きます。</p>

<p><code>javascript
// 設定ファイルを開く
$ vi /etc/apache2/apache2.conf
</code></p>

<p>続いて、<code>ServerName</code>を適当な場所に定義してやりましょう。</p>

<p>```javascript
// /etc/apache2/apache2.conf
// 省略</p>

<h1>Include list of ports to listen on</h1>

<p>Include ports.conf</p>

<p>ServerName xxx.com
// 省略
```</p>

<p>これにより、エラーなく起動や再起動できることを確認できるはずです。</p>

<p><code>javascript
$ /etc/init.d/apache2 restart
 * Restarting Apache httpd web server apache2  
</code></p>

<p>これでApacheが起動していることが確認できたので、GETリクエストを投げてアクセスしてみましょう。<br/>
Ubuntu用のApacheデフォルトページが返却されるはずです。</p>

<p>```javascript
$ curl <a href="http://127.0.0.1/">http://127.0.0.1/</a></p>

<p>&lt;!DOCTYPE html PUBLIC &ldquo;&ndash;//W3C//DTD XHTML 1.0 Transitional//EN&rdquo; &ldquo;<a href="http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd</a>&rdquo;>
<html xmlns="http://www.w3.org/1999/xhtml">
  &hellip;
</html>
```</p>

<h3>Webページにアクセス</h3>

<p>冒頭でポートフォワード設定をしたので、Apacheが起動しているのであれば、Macからページを見れるはずです！<br/>
早速見てみましょう。<br/>
設定した<code>http://localhost:15600/</code>でアクセスすると下記のようにページが表示されます。</p>

<p><img src="/images/docker_apache_1.png" alt="DockerコンテナのWEBページ" /></p>

<h3>便利コマンド利用するためにモジュールをインストール</h3>

<p>Webサーバを構築する上で、あまりにもまっさらなUbuntuだったため幾つか必要なものをインストールする必要がありました。<br/>
その紹介もおまけ程度に書いておきます。</p>

<h4>lessのインストール</h4>

<p>毎回<code>cat</code>コマンドで中身を見る必要性がないこともあると思います。<br/>
流石に<code>less</code>くらいはインストールしておきます。</p>

<p>```javascript
// lessのインストール
$ apt-get install less</p>

<p>// lessのバージョン確認
$ less &mdash;help
```</p>

<h4>lessコマンドで色をつける</h4>

<p>ついでに<code>less</code>コマンドで色を付けて見やすくする方法を書いておきます。</p>

<p><code>javascript
// source-highlightのインストール
$ apt-get install source-highlight
</code></p>

<p>Dockerコンテナ内の環境変数は<code>.dockerenv</code>ファイル内に書きます。</p>

<p>```javascript
// .dockerenvに下記を追加</p>

<h1>Source-hilight with less</h1>

<p>export LESSOPEN=&ldquo;| /usr/share/source-highlight/src-hilite-lesspipe.sh %s&rdquo;
export LESS=&lsquo;-R&rsquo;
```</p>

<p>結果を反映させるために、下記コマンドを叩きましょう。</p>

<p><code>javascript
$ source ~/.dockerenv
</code></p>

<h4>vi/vimのインストール</h4>

<p>ファイルを作成する際に必ず必要になります。</p>

<p>```javascript
// vimのインストール
$ apt-get install vim</p>

<p>// vimのバージョン確認
$ vim -v
// viのバージョン確認
$ vi -v
```</p>

<h4>curlのインストール</h4>

<p><code>curl</code>は試しにHTTPリクエストを投げてみたいことがあると思ったのでインストールしてみました。</p>

<p>```javascript
// curlのインストール
$ apt-get install curl</p>

<p>// curlのバージョン確認
$ curl -V
curl 7.47.0 (x86_64-pc-linux-gnu) libcurl/7.47.0 GnuTLS/3.4.10 zlib/1.2.8 libidn/1.32 librtmp/2.3
Protocols: dict file ftp ftps gopher http https imap imaps ldap ldaps pop3 pop3s rtmp rtsp smb smbs smtp smtps telnet tftp
Features: AsynchDNS IDN IPv6 Largefile GSS-API Kerberos SPNEGO NTLM NTLM_WB SSL libz TLS-SRP UnixSockets
```</p>

<h3>まとめ</h3>

<p>さて一先ず本記事の目的は達成できました。<br/>
が、Apacheのあまりにも簡単な基礎部分しか見ていません。<br/>
引き続き、最低限の設定を見ていきたいと思っています。</p>

<p>と言ったところで本日はここまで。</p>

<h3>参考</h3>

<p>以下、ページを参考にさせて頂きました。</p>

<ul>
<li><a href="http://www.nemotos.net/?p=1100">Ubuntuでlessを使って構文をカラー表示する方法</a></li>
<li><a href="http://qiita.com/maemori/items/e7318b088b9e4bf22310">docker-machineコマンド</a></li>
<li><a href="https://docs.docker.com/kitematic/userguide/">Kitematic user guide</a></li>
</ul>


<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Docker for Macをインストールしよう！]]></title>
    <link href="http://grandbig.github.io/blog/2017/02/13/docker-for-mac-1/"/>
    <updated>2017-02-13T00:06:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2017/02/13/docker-for-mac-1</id>
    <content type="html"><![CDATA[<h3>はじめに</h3>

<p>本日は <strong>Docker for Mac</strong> についてメモ程度に学んだことを書き残しておきたいと思います。<br/>
<code>Docker for Mac</code>とはMacアプリとしてインストールできるDockerです。<br/>
今までは、MacでDockerを利用するために<code>Docker Toolbox</code>と<code>Virtual Box</code>をインストールする必要がありましたが、<code>Docker for Mac</code>の登場により、いろいろとやってくれそうな感があります。<br/>
(筆者もDocker自体にそんなに詳しいわけではないので、1つずつ見ていきたいと思います。)</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h3>Docker for Macのインストール</h3>

<p>簡単かと思いきや、なぜか詰まることもあるので書きます。<br/>
インストールは<a href="https://docs.docker.com/docker-for-mac/">Docker公式ページ</a>から可能です。<br/>
公式ページを見ると、 <strong>Download Docker for Mac</strong> という文字が見つかります。<br/>
<code>Stable channel</code>と<code>Beta channel</code>の2つがあるのですが、筆者は最終的に<code>Beta channel</code>をインストールしました。<br/>
なぜなら、<code>Stable channel</code>では<code>docker run hello-world</code>が実行エラーになったためです&hellip;</p>

<p><img src="/images/docker_1.png" alt="Docker for Mac Betaのダウンロード" /></p>

<p>インストールが完了すると、macのツールバーにDockerのマークが出現します。</p>

<p><img src="/images/docker_2.png" alt="ツールバーにDockerマーク" /></p>

<p>Dockerが正しくインストールされたので下記コマンドでバージョンを確認してみましょう。</p>

<p>```javascript
$ docker &mdash;version
Docker version 1.13.1, build 092cba3</p>

<p>$ docker-compose &mdash;version
docker-compose version 1.11.1, build 7c5d5e4</p>

<p>$ docker-machine &mdash;version
docker-machine version 0.9.0, build 15fd4c7
```</p>

<p>続いて、Dockerが期待通りに動くことを確認するために下記コマンドを叩いてみましょう。<br/>
まずはDockerのバージョン確認です。</p>

<p>```javascript
$ docker version
Client:
 Version:      1.13.1
 API version:  1.26
 Go version:   go1.7.5
 Git commit:   092cba3
 Built:        Wed Feb  8 08:47:51 2017
 OS/Arch:      darwin/amd64</p>

<p>Server:
 Version:      1.13.1
 API version:  1.26 (minimum version 1.12)
 Go version:   go1.7.5
 Git commit:   092cba3
 Built:        Wed Feb  8 08:47:51 2017
 OS/Arch:      linux/amd64
 Experimental: true
```</p>

<p><code>Client</code>と<code>Server</code>の両方のバージョンが確認できるようです。<br/>
(中身があまり変わらないように見えるけど&hellip;)</p>

<p>続いて、ローカルに存在するDockerコンテナの確認です。</p>

<p><code>javascript
$ docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
</code></p>

<p>何もないと当然ですが、上記のように何も表示されません。<br/>
最も初歩であろう<code>hello-world</code>コマンドです。</p>

<p>```javascript
$ docker run hello-world
Unable to find image &lsquo;hello-world:latest&rsquo; locally
latest: Pulling from library/hello-world
78445dd45222: Pull complete
Digest: sha256:c5515758d4c5e1e838e9cd307f6c6a0d620b5e07e6f927b07d05f6d12a1ac8d7
Status: Downloaded newer image for hello-world:latest</p>

<p>Hello from Docker!
This message shows that your installation appears to be working correctly.</p>

<p>To generate this message, Docker took the following steps:
 1. The Docker client contacted the Docker daemon.
 2. The Docker daemon pulled the &ldquo;hello-world&rdquo; image from the Docker Hub.
 3. The Docker daemon created a new container from that image which runs the</p>

<pre><code>executable that produces the output you are currently reading.
</code></pre>

<ol>
<li>The Docker daemon streamed that output to the Docker client, which sent it
to your terminal.</li>
</ol>


<p>To try something more ambitious, you can run an Ubuntu container with:
 $ docker run -it ubuntu bash</p>

<p>Share images, automate workflows, and more with a free Docker ID:
 <a href="https://cloud.docker.com/">https://cloud.docker.com/</a></p>

<p>For more examples and ideas, visit:
 <a href="https://docs.docker.com/engine/userguide/">https://docs.docker.com/engine/userguide/</a>
```</p>

<p>ローカルに存在しないとダウンロードを始めます。<br/>
冒頭に述べた<code>Stable channel</code>では、ここで全くダウンロードができませんでした。<br/>
何はともあれ、これで <strong>Docker for Mac</strong> のインストール完了です。</p>

<h3>Docker for Macを使ってUbuntuをインストールしてみよう</h3>

<p>先程インストールした<code>hello-world</code>の結果の中に<code>To try something more ambitious, you can run an Ubuntu container with:</code>とありました。<br/>
興味本位ですが、コマンド叩いてみましょう。</p>

<p><code>javascript
$ docker run -it ubuntu bash
Unable to find image 'ubuntu:latest' locally
latest: Pulling from library/ubuntu
8aec416115fd: Pull complete
695f074e24e3: Pull complete
946d6c48c2a7: Pull complete
bc7277e579f0: Pull complete
2508cbcde94b: Pull complete
Digest: sha256:71cd81252a3563a03ad8daee81047b62ab5d892ebbfbf71cf53415f29c130950
Status: Downloaded newer image for ubuntu:latest
root@3e95790a60cb:/#
</code></p>

<p>これで<code>Ubuntu</code>がインストールできたようです。<br/>
しかも<code>Ubuntu</code>の中に入れてますね！</p>

<p>本当に<code>Ubuntu</code>インストールできたか確かめるためにもコマンドを叩いてみましょう。</p>

<p>```javascript
root@3e95790a60cb:/# cat /etc/lsb-release
DISTRIB_ID=Ubuntu
DISTRIB_RELEASE=16.04
DISTRIB_CODENAME=xenial
DISTRIB_DESCRIPTION=&ldquo;Ubuntu 16.04.1 LTS&rdquo;</p>

<p>root@3e95790a60cb:/# arch
x86_64</p>

<p>root@3e95790a60cb:/# uname -a
Linux 3e95790a60cb 4.9.8-moby #1 SMP Wed Feb 8 09:59:13 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux
```</p>

<p>バッチリですね！！<br/>
(正直な話、<code>uname -a</code>とか数年ぶりに叩いた気がして懐かしい&hellip;笑)</p>

<p>これで後はもう様々な便利なものをインストールして楽しめそうですね。</p>

<h3>Kitematicの紹介</h3>

<p>メニューバーのDockerマークをクリックすると、Docker for Macのメニュー項目が表示されます。<br/>
その中に<code>Kitematic</code>という聞きなれないものがあると思います。<br/>
こちらをインストールするとターミナルからコマンドを叩かずとも、GUIからクリック操作で様々なことが可能になります。</p>

<p><img src="/images/docker_3.png" alt="Dockerのメニュー" /></p>

<p>起動してログインすると(初めはアカウントがないと思うので作成しましょう。)、下記のような画面が表示されます。</p>

<p><img src="/images/docker_4.png" alt="Kitematic" /></p>

<p>最早、見るだけで心躍りますよね！？<br/>
様々なものをインストールして楽しめそうな気しかしません！</p>

<p>因みに、下記のようにコンテナの起動などが可能です。</p>

<p><img src="/images/docker_5.png" alt="KitematicでDockerコンテナ起動" /></p>

<h3>まとめ</h3>

<p>さて、今回は珍しく基盤よりなDockerで遊んでみました。<br/>
この付近の知識はあって困ることはないですし、Dockerかなり一般的になってきているので引き続きブログの題材として取り上げていきたいと思います。<br/>
と言ったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
</feed>
