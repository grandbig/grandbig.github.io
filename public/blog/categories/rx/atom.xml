<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: rx | Takahiro Octopress Blog]]></title>
  <link href="http://grandbig.github.io/blog/categories/rx/atom.xml" rel="self"/>
  <link href="http://grandbig.github.io/"/>
  <updated>2018-12-22T00:30:08+09:00</updated>
  <id>http://grandbig.github.io/</id>
  <author>
    <name><![CDATA[Takahiro]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[5年前に初めて個人開発したアプリを再構築している話]]></title>
    <link href="http://grandbig.github.io/blog/2018/12/12/personal-develop-footstepmeter/"/>
    <updated>2018-12-12T00:00:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2018/12/12/personal-develop-footstepmeter</id>
    <content type="html"><![CDATA[<h3>はじめに</h3>

<p>今年もやってきましたAdvent Calendarの季節！<br/>
こちらは<a href="https://qiita.com/advent-calendar/2018/private-developmen2">個人開発 #2 Advent Calendar 2018</a>の12日目の記事です。</p>

<p>今年は、5年前に初めて個人開発したアプリを再構築している話を思い出を交えながら書こうと思います。<br/>
とは言え、絶賛再構築中なので、恐らく本記事公開日までに作り終わらないと思うのですが、それも一興ということで大目に見て頂ければと思います。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h3>5年前になぜ個人開発をしようと思ったのか</h3>

<p>まずは筆者がなぜ個人開発を始めようと思ったのかについて話したいと思います。<br/>
当時の筆者の状況やスキルを思い出してみます。</p>

<h4>状況</h4>

<ul>
<li>社会人3年目</li>
<li>当然、役職も重い責任も何もないぺーぺー</li>
<li>プロジェクトを1〜2個経験(内の1つは大炎上を経験)</li>
</ul>


<h4>スキル</h4>

<ul>
<li><code>HTML5, CSS3, jQuery</code>を利用したWEBフロントエンドの開発</li>
<li><code>iOS, Android</code>アプリの開発</li>
<li><code>Node.js, MongoDB</code>を用いたサーバサイドの開発</li>
</ul>


<h4>状況とスキルを見た振り返り</h4>

<p>一見、スキルを見ると凄そうに見えるかもしれませんが、<br/>
<code>iOS, Android</code>アプリの中身は<code>WebView</code>を利用しており、ネイティブコードは位置情報の取得やプッシュ通知などのごく一部でした。</p>

<p>また、当時、非常に新しかった<code>Node.js</code>や<code>MongoDB</code>も訳が分からず利用しており、<br/>
その知識やスキル不足からプロジェクトを大炎上させてしまいました。</p>

<p>その時に学んだ重要なことは、</p>

<ul>
<li>メモリ消費を考えて、何でもかんでも <code>DB</code> からデータを引っ張ってくるのは辞めよう</li>
<li>CPU消費を考えて、大量データを永遠と<code>for</code>ループ回すのは辞めよう</li>
</ul>


<p>といったエンジニアとしては『当たり前 &amp; これができなかったらごめんなさいで済まされないレベル』の話でした。</p>

<h4>個人開発を始めた理由</h4>

<p>そんな状態の私がなぜ個人開発を始めたのかというと&hellip;</p>

<ol>
<li>技術的な強みを1つ持ちたかった</li>
<li>エンジニアとしての将来が不安で悶々としていた</li>
</ol>


<p>という2つが大きな理由です。</p>

<p>理由2を満たすために、手始めに技術ブログを開設したのですが、<br/>
『どうせなら理由1も満たしたい！』という想いから、<br/>
当時最も興味のあった <code>iOS</code> アプリの開発を勉強しながら始めることにしました。<br/>
※ <code>iOS</code> ネイティブアプリの開発ができるようになるというのが当面の目標でした。<br/>
( <code>WebView</code>ではなく、ネイティブアプリの開発です。 )</p>

<h3>足跡計について</h3>

<p>初めのうちは基本的なXcodeの使い方などを試してブログに書いたりしていたのですが、<br/>
折角なので、1つアプリを完成させて世にリリースしたいという想いが強くなりました。<br/>
そうして完成した個人開発の第一段階アプリが『<a href="https://itunes.apple.com/jp/app/%E8%B6%B3%E8%B7%A1%E8%A8%88/id725412788?mt=8">足跡計</a>』です。</p>

<h4>足跡計の機能</h4>

<p>このアプリには、次のような機能を持たせました。</p>

<ul>
<li>様々な精度で歩行ルートを記録可能</li>
<li>複数の歩行ルートを記録可能</li>
<li>歩行ルート履歴をいつでも閲覧可能</li>
<li>歩行ルート記録をメールで送信可能</li>
<li>不要になった歩行ルート記録は削除可能</li>
</ul>


<p>このアプリを開発しようと思った理由は、<br/>
当時、業務にて位置情報を扱ったアプリ内 <code>WebView</code> のアプリを開発・運用しており、<br/>
位置情報機能は私にとって非常に扱いやすかったためです。</p>

<p>【足跡計のスクリーンショット】<br/>
<img src="/images/personal_development_footprintmeter_1.png" alt="足跡計のスクリーンショット" /></p>

<h4>今回再構築をしようと思った理由</h4>

<p>さて、ここまでは5年前の個人でのアプリ開発に至るまでの話をしてきました。<br/>
ここからが本題で、今回、筆者は思い切って、足跡計アプリを再構築しようと考えました。</p>

<p>その理由は、</p>

<ol>
<li>iPhoneXの画面にアプリが対応できておらず、格好悪い(上下の黒帯の幅が長い)</li>
<li>ホームアイコンとアプリ画面の色合いを統一させたい</li>
<li><code>MVVM</code> アーキテクチャを用いたアプリ開発を試したい</li>
</ol>


<p>という3つの想いがあったためです。</p>

<p>特に『3』に関しては、<br/>
筆者が業務で昨年から今年の春先にかけて <code>Clean Swift</code> アーキテクチャでのiOSアプリ開発に挑戦し、改めてiOSアプリのアーキテクチャのあり方に悩んだことが元となっています。</p>

<p>具体的に悩んだ内容に関しては後日別途書こうと思いますが、<br/>
上記経緯より、現在最も頻繁に採用されているであろう <a href="https://github.com/ReactiveX/RxSwift">RxSwift</a> を用いた <code>MVVM</code> アーキテクチャ設計をきちんと勉強しておきたいと思わずにはいられなかったのです。</p>

<p>では、前段はここまでとして、ここから先は、</p>

<ul>
<li>どのように設計を変更したのか(プロジェクト構成の話)</li>
<li><code>RxSwift</code> を用いた <code>MVVM</code> アーキテクチャで構成されたメインロジックの説明</li>
<li>その上で躓いたこと / ハマったこと</li>
</ul>


<p>を中心に説明し、最後に今後の展望とリリース時期を説明して終了にしたいと思います。</p>

<h3>足跡計の再構築について</h3>

<p>では、再構築について一つずつ説明してきましょう。</p>

<h4>プロジェクト構成の変更</h4>

<p>まずはアーキテクチャの変更によって生じたプロジェクト構成の変更について説明します。<br/>
これまでは <code>MVC</code> アーキテクチャを採用していたため、下記のようなプロジェクト構成になっていました。</p>

<p><code>objective-c
// 再構築前のMVCアーキテクチャでのプロジェクト構成
footStepMeter
├── Enum
│    └── LocationAccuracy.swift
├── Model
│    ├── CustomAnnotation.swift
│    ├── Footprint.swift
│    ├── FootprintManager.swift
│    ├── Location.swift
│    └── UIImage+Extension.swift
├── View
│    └── PickerView.swift
├── Main.storyboard
├── AppDelegate.swift
├── ViewController.swift
├── SettingViewController.swift
...
</code></p>

<p>一応、フォルダ分けして責務を見やすくしようとした形跡がありますが、<br/>
下記観点が全然ダメだなと今振り返って思います。</p>

<ul>
<li><code>Model</code> の責務がカオスになりかけている

<ul>
<li><code>UIImage+Extension</code> は <code>Model</code> 配下でなくても良いはず</li>
</ul>
</li>
<li><code>ViewController</code> がフォルダ分けされておらず、ただ並んでいる

<ul>
<li>今後、画面が増えてきた時に <code>ViewController</code> も増えるので視認性が悪くなる</li>
</ul>
</li>
</ul>


<p>今回は、 <code>MVVM</code> アーキテクチャを採用し、プロジェクト構成も見直しています。</p>

<p><code>objective-c
footStepMeter
├── Enum
│    ├── AlertActionType.swift
│    ├── LocationAccuracy.swift
│    └── TabBarItemTag.swift
├── Model
│    ├── CustomAnnotation.swift
│    ├── Footprint.swift
│    └── RealmManager.swift
├── View
│    ├── Parts
│    │    ├── CustomTableViewCell
│    │    └── PickerView
│    ├── Map
│    │    ├── MapViewController.swift
│    │    └── MapViewController.xib
│    ├── Setting
│    ...
├── ViewModel
│    ├── MapViewModel.swift
│    ├── SettingViewModel.swift
│    ...
├── Protocol
│    └── Injectable.swift
├── Extensions
│    ├── UIImage+Extension.swift
│    ├── UIViewController+Rx.swift
│    ...
├── AppDelegate.swift
...
</code></p>

<p>変更点としては、</p>

<ul>
<li><code>MVVM</code> なので、 <code>View</code> / <code>Model</code> / <code>ViewModel</code> フォルダを作る</li>
<li><code>Extension</code> 系は <code>Extensions</code> フォルダを作ってまとめる</li>
<li>疎結合の肝となる <code>Protocol</code> も専用に <code>Protocol</code> フォルダを作る</li>
<li><code>Storyboard</code> を廃止し、 <code>xib</code> を採用</li>
</ul>


<p>となります。<br/>
設計思想的な面で変更している部分はあるものの、以前に比べれば視認性は上がったと思っています。<br/>
(もう少し改善の余地はあるなと思いつつ&hellip;)</p>

<h4>RxSwiftを用いたMVVMアーキテクチャでの構成</h4>

<p>続いて、 <code>RxSwift</code> を用いた <code>MVVM</code> アーキテクチャで具体的に何をどのように書いているのか紹介したいと思います。<br/>
全ては紹介しきれないため、メイン画面であるマップ画面を元に一部を説明したいと思います。</p>

<h5>マップ画面の機能</h5>

<p>具体的にスクショを交えながら、機能を紹介します。</p>

<p><img src="/images/personal_development_footprintmeter_2.png" alt="歩行ルートの保存開始機能" /></p>

<p><img src="/images/personal_development_footprintmeter_3.png" alt="歩行ルートの保存終了機能" /></p>

<p><img src="/images/personal_development_footprintmeter_4.png" alt="歩行ルートの表示/非表示切替機能" /></p>

<p>さて、ここからはソースコードベースで実装について説明したいと思います。</p>

<h5>View / Model / ViewModelそれぞれの責務</h5>

<p>先程スクショベースでお見せした機能をロジックベースで言語化すると、</p>

<ul>
<li>位置情報の取得許可の確認</li>
<li>位置情報の取得情報の確認</li>
<li>位置情報の計測を開始し、<code>Realm</code> にそのデータを保存する</li>
<li>位置情報の計測を停止する</li>
<li><code>Realm</code> から保存した位置情報を取得する</li>
</ul>


<p>のように言い換えられます。</p>

<p>では、 <code>View</code> / <code>Model</code> / <code>ViewModel</code> それぞれどんな責務を持たせれば良いのでしょうか。<br/>
下記にそれぞれの責務を簡単に書き出してみました。</p>

<ul>
<li><code>Model</code>

<ul>
<li>いわゆるビジネスロジックを担当する</li>
<li>例) API関連、ローカルDBを扱い関連など</li>
</ul>
</li>
<li><code>View</code>

<ul>
<li>ユーザアクションのキャッチ</li>
<li>画面の描画</li>
</ul>
</li>
<li><code>ViewModel</code>

<ul>
<li><code>View</code> と <code>Model</code> を繋ぐ</li>
<li><code>View</code> からの処理依頼を受けて、<code>Model</code>を介して必要な情報を取得し、<code>View</code>に特定の描画司令を出す</li>
</ul>
</li>
</ul>


<p>続いて、具体的に上記を実現する方法について説明します。</p>

<h5>Modelの説明</h5>

<p>まずは <code>Model</code> に関する実装から説明します。<br/>
本アプリの肝となる『計測した位置情報の <code>Realm</code> への保存』を実装するために、<br/>
<code>Realm</code> を管理する <code>RealmManager</code> を定義します。</p>

<p>また、 <code>Realm</code> に保存する形式を先に決める必要があるため、 <code>Footprint</code> という <code>Model</code> を作成します。</p>

<p>以下、 <code>Footprint</code> のソースコードです。<br/>
書式は <code>Realm</code> の使い方そのままなので詳細は省きます。</p>

<p>```objective-c
// Model/Footprint.swift
import RealmSwift</p>

<p>/// 足跡
class Footprint: Object {</p>

<pre><code>// ID
@objc dynamic var id: Int = 0
// 保存した歩行ルートのタイトル
@objc dynamic var title: String = ""
// 緯度
@objc dynamic var latitude: Double = 0.0
// 軽度
@objc dynamic var longitude: Double = 0.0
// 位置の精度
@objc dynamic var accuracy: Double = 0.0
// 歩行速度
@objc dynamic var speed: Double = 0.0
// 歩行方向
@objc dynamic var direction: Double = 0.0
// データの生成日時
@objc dynamic var created: Double = Date().timeIntervalSince1970

// プライマリーキーの設定
override static func primaryKey() -&gt; String? {
    return "id"
}

// インデックスの設定
override static func indexedProperties() -&gt; [String] {
    return ["title"]
}
</code></pre>

<p>}
```</p>

<p>続いて、 <code>RealmManager</code> のソースコードです。<br/>
まずは、 <code>protocol</code> として <code>RealmManagerClient</code> を定義します。<br/>
実際の <code>RealmManager</code> クラスは <code>RealmManagerClient protocol</code> を継承します。</p>

<p>こうすることで、テストを書く際にモックデータを返却することが容易になります。</p>

<p>```objective-c
// Model/RealmManager.swift
import Foundation
import CoreLocation
import RxSwift
import RealmSwift</p>

<p>protocol RealmManagerClient {</p>

<pre><code>// MARK: - Protocol Properties
var title: String { get set }

// MARK: - Protocol Methods
func setSaveTitle(_ title: String)
func createFootprint(location: CLLocation)
func fetchFootprints() -&gt; Observable&lt;Results&lt;Footprint&gt;?&gt;
func fetchFootprintsByTitle(_ text: String) -&gt; Observable&lt;Results&lt;Footprint&gt;?&gt;
func existsByTitle(_ text: String) -&gt; Observable&lt;Bool&gt;
func countFootprints() -&gt; Observable&lt;Int&gt;
func countFootprintsByTitle(_ text: String) -&gt; Observable&lt;Int&gt;
</code></pre>

<p>}
```</p>

<p>この <code>RealmManagerClient protocol</code> を継承して各メソッドの実処理を実装すると、下記のようになります。</p>

<p>```objective-c
// Model/RealmManager.swift
final class RealmManager: NSObject, RealmManagerClient {</p>

<pre><code>// MARK: - Properties
var title = String()

// MARK: - Initial Methods
override init() {
    super.init()
}

/// タイトルの保存処理
///
/// - Parameter title: 保存したいタイトル
func setSaveTitle(_ title: String) {
    self.title = title
}

// MARK: - CRUD

/// 位置情報のデータの保存処理
///
/// - Parameter location: 保存する位置情報
func createFootprint(location: CLLocation) {
    do {
        let realm = try Realm()
        let footprint = Footprint()
        let savedLastFootprint = fetchAllFootprints()?.last
        footprint.id = (savedLastFootprint != nil) ? ((savedLastFootprint?.id)! + 1) : 0
        footprint.title = self.title
        footprint.latitude = location.coordinate.latitude
        footprint.longitude = location.coordinate.longitude
        footprint.accuracy = location.horizontalAccuracy
        footprint.speed = location.speed
        footprint.direction = location.course

        // Realmへのオブジェクトの書き込み
        try realm.write {
            realm.create(Footprint.self, value: footprint, update: false)
        }
    } catch let error as NSError {
        print("Error: code - \(error.code), description - \(error.description)")
    }
}

/// 保存している全位置情報データを取得する処理
///
/// - Returns: 保存している全位置情報データ
func fetchFootprints() -&gt; Observable&lt;Results&lt;Footprint&gt;?&gt; {
    let footprints = fetchAllFootprints()
    return Observable.just(footprints)
}

/// 指定したタイトルで保存されている位置情報データを取得する処理
///
/// - Parameter text: タイトル
/// - Returns: 指定したタイトルで保存されている位置情報データ
func fetchFootprintsByTitle(_ text: String) -&gt; Observable&lt;Results&lt;Footprint&gt;?&gt; {
    do {
        let realm = try Realm()
        let footprints = realm.objects(Footprint.self).filter("title == '\(text)'")
        if footprints.count &gt; 0 {
            return Observable.just(footprints)
        }
        return Observable.just(nil)
    } catch _ as NSError {
        return Observable.just(nil)
    }
}

/// 指定したタイトルで保存されている位置情報データがあるか確認する処理
///
/// - Parameter text: タイトル
/// - Returns: 存在する場合はtrue, 存在しない場合はfalseを返却する
func existsByTitle(_ text: String) -&gt; Observable&lt;Bool&gt; {
    do {
        let realm = try Realm()
        let footprints = realm.objects(Footprint.self).filter("title == '\(text)'")
        if footprints.count &gt; 0 {
            return Observable.just(true)
        }
        return Observable.just(false)
    } catch _ as NSError {
        return Observable.just(false)
    }
}

/// 保存したい全位置情報の数を取得する処理
///
/// - Returns: 保存している位置情報の数
func countFootprints() -&gt; Observable&lt;Int&gt; {
    do {
        let realm = try Realm()
        return Observable.just(realm.objects(Footprint.self).count)
    } catch _ as NSError {
        return Observable.just(0)
    }
}

/// 指定したタイトルで保存されている位置情報の数
///
/// - Parameter text: タイトル
/// - Returns: 保存している位置情報の数
func countFootprintsByTitle(_ text: String) -&gt; Observable&lt;Int&gt; {
    do {
        let realm = try Realm()
        let footprints = realm.objects(Footprint.self).filter("title == '\(text)'")
        return Observable.just(footprints.count)
    } catch _ as NSError {
        return Observable.just(0)
    }
}

// MARK: - Private Methods

/// 保存している全位置情報データを取得する処理
///
/// - Returns: 位置情報データ
private func fetchAllFootprints() -&gt; Results&lt;Footprint&gt;? {
    do {
        let footprints = try Realm().objects(Footprint.self).sorted(byKeyPath: "id")
        return footprints
    } catch _ as NSError {
        return nil
    }
}
</code></pre>

<p>}
```</p>

<h5>protocol Injectableを用意することで依存関係の解決</h5>

<p>続いて、<code>ViewModel</code> や <code>View</code> の説明をする前に、<br/>
<code>ViewModel</code> と <code>View</code> の双方を疎結合にするための <code>protocol Injectable</code> を定義します。<br/>
※これは<a href="https://gihyo.jp/magazine/wdpress/archive/2018/vol106">WEB+DB PRESS V.106</a>で特集されていた手法をそのまま採用しています。</p>

<p>```objective-c
import UIKit</p>

<p>protocol Injectable {</p>

<pre><code>associatedtype Dependency
init(with dependency: Dependency)
</code></pre>

<p>}</p>

<p>extension Injectable where Dependency == Void {</p>

<pre><code>init() {
    self.init(with: ())
}
</code></pre>

<p>}
```</p>

<p>実際の効力は <code>ViewModel</code> や <code>View</code> のソースを見て頂けると伝わるかと思います。</p>

<h5>ViewModelの説明</h5>

<p>では、<code>ViewModel</code>について次は見ていきます。</p>

<p>先程言語化した</p>

<ul>
<li>位置情報の取得許可の確認</li>
<li>位置情報の取得情報の確認</li>
<li>位置情報の計測を開始し、<code>Realm</code> にそのデータを保存する</li>
<li>位置情報の計測を停止する</li>
<li><code>Realm</code> から保存した位置情報を取得する</li>
</ul>


<p>の5つを実装の内の幾つかを例に説明していきます。</p>

<p>繰り返しになりますが、 <code>ViewModel</code> ですので、以下を守ることを念頭に置くことが大事です。</p>

<ul>
<li><code>ViewModel</code> の責務

<ul>
<li><code>View</code> と <code>Model</code> を繋ぐ</li>
<li><code>View</code> からの処理依頼を受けて、<code>Model</code>を介して必要な情報を取得し、<code>View</code>に特定の描画司令を出す</li>
</ul>
</li>
</ul>


<p>まずは、 <code>ViewModel</code> の最低限の実装から先に説明します。</p>

<p>```objective-c
// MapViewModel.swift
import Foundation
import RxSwift
import RxCocoa
import CoreLocation
import RealmSwift</p>

<p>// 説明(1)
final class MapViewModel: Injectable {</p>

<pre><code>// 説明(2)
struct Dependency {
    let locationManager: CLLocationManager
    let realmManager: RealmManagerClient
}

// MARK: - Properties
private let disposeBag = DisposeBag()

// MARK: Initial method
// 説明(3)
init(with dependency: Dependency) {
    let locationManager = dependency.locationManager
    let realmManager = dependency.realmManager
    ...
}
</code></pre>

<p>}
```</p>

<p><strong>説明(1)</strong><br/>
<code>MapViewModel</code> クラスは <code>Injectable</code> プロトコルを継承するクラスとして定義します。</p>

<p><strong>説明(2)</strong><br/>
<code>Injectable</code> は <code>Generic Protocol</code> として定義されているため、
説明(1)の実装により、 <code>Dependency</code> を定義する必要が出てきます。<br/>
ここでは <code>struct</code> として、そのプロパティに</p>

<ul>
<li><code>CLLocationManager</code> 型の <code>locationManager</code></li>
<li><code>RealmManagerClient</code> 型の <code>realmManager</code></li>
</ul>


<p>を定義しています。</p>

<p>ミソなのが、 <code>RealmManager</code> ではなく <code>RealmManagerClient</code> としている点です。<br/>
<code>RealmManagerClient</code> は <code>protocol</code> なので、具体的な処理は書かれていません。<br/>
あくまでもインタフェースの提供のみです。</p>

<p>このため、テストを書く際に、レスポンスをモック化することが容易になるのです。<br/>
※ <code>CLLocationManager</code> はApple提供の純正品なので難しいですが&hellip;</p>

<p><strong>説明(3)</strong><br/>
<code>MapViewModel</code> の初期化メソッドの引数に <code>Dependency</code> 型の <code>dependency</code> を渡しています。<br/>
初期化時の引数として外部から渡せるようにすることで依存性を軽減しています。</p>

<p>説明(2)の実装を活かすために、外部から渡せるようにしたと言いかえることもできますね。</p>

<p>続いて、 <code>View</code> と <code>ViewModel</code> を繋ぐ <code>RxSwift</code> の実装部分を説明してきます。</p>

<p>5つの実装の内の</p>

<ul>
<li>位置情報の取得許可の確認</li>
<li>位置情報の取得情報の確認</li>
</ul>


<p>は下記の通りに実装しています。</p>

<p>```objective-c
// MapViewModel.swift
import Foundation
import RxSwift
import RxCocoa
import CoreLocation
import RealmSwift</p>

<p>final class MapViewModel: Injectable {</p>

<pre><code>struct Dependency {
    let locationManager: CLLocationManager
    let realmManager: RealmManagerClient
}

// MARK: - Properties
private let disposeBag = DisposeBag()

// MARK: Drivers
private (set) var authorized: Driver&lt;Bool&gt;
private (set) var location: Driver&lt;CLLocationCoordinate2D&gt;

// MARK: Initial method
init(with dependency: Dependency) {
    let locationManager = dependency.locationManager
    let realmManager = dependency.realmManager

    // Initialize stored properties
    // 位置情報の取得許可の確認
    authorized = Observable.deferred({() -&gt; Observable&lt;CLAuthorizationStatus&gt; in
        let status = CLLocationManager.authorizationStatus()
        return locationManager
            .rx.didChangeAuthorizationStatus
            .startWith(status)
    })
        .asDriver(onErrorJustReturn: CLAuthorizationStatus.notDetermined)
        .map {
            switch $0 {
            case .authorizedAlways:
                return true
            default:
                return false
            }
    }

    // 位置情報の取得情報の確認
    location = locationManager.rx.didUpdateLocations
        .asDriver(onErrorJustReturn: [])
        .flatMap {
            return $0.last.map(Driver.just) ?? Driver.empty()
        }
        .map {
            realmManager.createFootprint(location: $0)
            return $0.coordinate
    }

    // 位置情報の取得許可を要求
    locationManager.requestAlwaysAuthorization()
    // バックグラウンドでの位置情報取得を許可
    locationManager.allowsBackgroundLocationUpdates = true
    // バックグラウンドで位置情報取得がわかるように設定
    locationManager.showsBackgroundLocationIndicator = true
}
</code></pre>

<p>}
```</p>

<p>これは<a href="https://github.com/ReactiveX/RxSwift/blob/master/RxExample/RxExample/Services/GeolocationService.swift">RxSwiftの公式ExampleのGeolocationService</a>と同じ実装です。</p>

<p>詳細は<a href="http://grandbig.github.io/blog/2018/10/06/rx-delegate/">GeolocationSampleから学ぶdelegateのRx対応</a>でも説明しているので、ここでは概略だけにします。</p>

<ul>
<li>位置情報の補足等を <code>Rx</code> でできるように独自に実装する必要があります</li>
<li>これにより <code>didChangeAuthorizationStatus</code> と <code>didUpdateLocations</code> を <code>locationManager.rx.xxx</code> のように <code>Rx</code> 実装方式に則って書けるようになります</li>
<li>それぞれハンドリングした値を <code>authorized</code> と <code>location</code> に渡すことで <code>View</code> で検知できるようにします</li>
</ul>


<p>また、5つの実装の内の</p>

<ul>
<li>位置情報の計測を開始し、<code>Realm</code> にそのデータを保存する</li>
<li>位置情報の計測を停止する</li>
</ul>


<p>は下記の通りに実装しています。</p>

<p>```objective-c
// MapViewModel.swift
import Foundation
import RxSwift
import RxCocoa
import CoreLocation
import RealmSwift</p>

<p>final class MapViewModel: Injectable {</p>

<pre><code>...
// MARK: - Properties
private let disposeBag = DisposeBag()
private var dataTitle = String()
private var isUpdatingLocation = false

// 説明(4)
// MARK: PublishSubjects
private let startUpdatingLocationStream = PublishSubject&lt;(LocationAccuracy, String?)&gt;()
private let stopUpdatingLocationStream = PublishSubject&lt;Void&gt;()

// MARK: BehaviorRelays
private let errorStream = BehaviorRelay&lt;String?&gt;(value: nil)

// MARK: Initial method
init(with dependency: Dependency) {
    ...
    // Data Binding Handling
    // 説明(6)
    observeStartUpdatingLocation(locationManager: locationManager, realmManager: realmManager)
    observeStopUpdatingLocation(locationManager: locationManager)
}
</code></pre>

<p>}</p>

<p>// 説明(5)
// MARK: &ndash; Input
extension MapViewModel {</p>

<pre><code>var startUpdatingLocation: AnyObserver&lt;(LocationAccuracy, String?)&gt; {
    return startUpdatingLocationStream.asObserver()
}
var stopUpdatingLocation: AnyObserver&lt;Void&gt; {
    return stopUpdatingLocationStream.asObserver()
}
</code></pre>

<p>}</p>

<p>// MARK: &ndash; Output
extension MapViewModel {</p>

<pre><code>var error: Driver&lt;String?&gt; {
    return errorStream.asDriver()
}
</code></pre>

<p>}</p>

<p>// MARK: &ndash; Data Binding Handling
// 説明(6)
extension MapViewModel {</p>

<pre><code>/// startUpdatingLocationStreamにデータバインディングされてきた場合の処理
///
/// - Parameters:
///   - locationManager: 位置情報管理マネージャ
///   - realmManager: Realm管理マネージャ
func observeStartUpdatingLocation(locationManager: CLLocationManager, realmManager: RealmManagerClient) {

    startUpdatingLocationStream
        .subscribe { [weak self] event in
            guard let strongSelf = self, let element = event.element, let dataTitle = element.1 else { return }
            strongSelf.dataTitle = dataTitle
            let locationAccuracy = LocationAccuracy.toCLLocationAccuracy(element.0)
            // タイトルの設定
            realmManager.setSaveTitle(dataTitle)
            // 同名タイトルの既存データが存在するか確認
            realmManager.existsByTitle(dataTitle)
                .flatMapLatest({ isExist -&gt; Observable&lt;String?&gt; in
                    if isExist {
                        return Observable.just(R.string.mapView.alreadySameTitleErrorMessage())
                    }
                    // 位置情報の取得精度を設定
                    locationManager.desiredAccuracy = locationAccuracy
                    // 位置情報の計測を開始
                    locationManager.startUpdatingLocation()
                    strongSelf.isUpdatingLocation = true
                    return Observable.just(nil)
                })
                .asDriver(onErrorJustReturn: R.string.mapView.unExpectedErrorMessage())
                .drive(strongSelf.errorStream)
                .disposed(by: strongSelf.disposeBag)
        }
        .disposed(by: disposeBag)
}

/// stopUpdatingLocationStreamにデータバインディングされてきた場合の処理
///
/// - Parameter locationManager: 位置情報管理マネージャ
func observeStopUpdatingLocation(locationManager: CLLocationManager) {

    stopUpdatingLocationStream
        .subscribe { [weak self] _ in
            guard let strongSelf = self else { return }
            // 位置情報の計測を停止
            locationManager.stopUpdatingLocation()
            strongSelf.isUpdatingLocation = false
        }
        .disposed(by: disposeBag)
}
</code></pre>

<p>}
```</p>

<p><strong>説明(4)</strong><br/>
<code>View</code> からの位置情報の取得開始と停止イベント通知をキャッチした後に、 <code>ViewModel</code> 内の処理に導くために実装している部分になります。<br/>
開発当初に <code>Observable</code> であり <code>Observer</code> でもある <code>PublishSubject</code> を利用する必要があったため、 <code>PublishSubject</code> 型として宣言しています。<br/>
現段階では <code>Observer</code> で十分な気がします。<br/>
(今後の宿題と言うことで&hellip;)</p>

<p><strong>説明(5)</strong><br/>
<code>startUpdatingLocationStream</code> と <code>stopUpdatingLocationStream</code> を <code>PublishSubject</code> として定義したことで、必要となった実装です。<br/>
<code>Observable</code> であり <code>Observer</code> でもある <code>PublishSubject</code> は便利な反面、<code>public</code> なプロパティとしておくと、誤って外側から <code>Observable</code> な機能を利用される可能性があります。</p>

<p>これを防ぐために <code>AnyObserver</code> 型のプロパティを外部に公開し、<code>PublishSubject</code> 型プロパティは <code>private</code> として内部に閉ざしています。</p>

<p>因みに、 <code>Input</code> / <code>Output</code> と分けて書くことで視認性が高まるので、<br/>
<code>error</code> に至っては <code>BehaviorRelay</code> 関連にも関わらず、この書式を取っています。<br/>
※ <code>error</code> は <code>Output</code> 時のみの利用かつ、<code>ObservableType</code> 型の <code>BehaviorRelay</code> なので誤った利用がされる恐れはないため。</p>

<p><strong>説明(6)</strong><br/>
実際に <code>View</code> からの指示を受け取った後に実行している処理になります。<br/>
この中で、必要な情報を <code>Model</code> を介して取得することで <code>MVVM</code> というアーキテクチャが取れているわけです。<br/>
<code>ViewModel</code> の中で、 <code>View</code> の描画に必要な情報を整理して、必要な情報を <code>View</code> に渡しつつ、実行処理を指示しています。</p>

<h5>Viewの説明</h5>

<p><code>ViewModel</code> に続いて <code>View</code> を説明します。<br/>
繰り返しになりますが、 <code>View</code> の責務は、</p>

<ul>
<li><code>View</code>

<ul>
<li>ユーザアクションのキャッチ</li>
<li>画面の描画</li>
</ul>
</li>
</ul>


<p>になります。<br/>
まずは、 <code>View</code> の最低限の実装から説明します。</p>

<p>```objective-c
import UIKit
import MapKit
import RxSwift
import RxCocoa</p>

<p>// 説明(1)
final class MapViewController: UIViewController, Injectable {</p>

<pre><code>typealias Dependency = MapViewModel

// MARK: - IBOutlets
@IBOutlet private weak var mapView: MKMapView!
@IBOutlet private weak var tabBar: UITabBar!
@IBOutlet private weak var searchButton: UIButton!

// MARK: - Properties
// 説明(2)
private let viewModel: MapViewModel
private let disposeBag = DisposeBag()

// MARK: - Initial methods
// 説明(3)
required init(with dependency: Dependency) {
    viewModel = dependency
    super.init(nibName: nil, bundle: nil)
}

@available(*, unavailable)
required init?(coder aDecoder: NSCoder) {
    fatalError("init(coder:) has not been implemented")
}

// MARK: - Lifecycle methods
override func viewDidLoad() {
    super.viewDidLoad()
    ...
}
</code></pre>

<p>}
```</p>

<p><strong>説明(1)</strong><br/>
<code>ViewModel</code> と <code>View</code> を疎結合にするために、ここでも <code>Injectable</code> を利用します。<br/>
<code>MapViewController</code> を <code>Injectable</code> プロトコルを継承するクラスとして定義し、<br/>
<code>Dependency</code> を <code>MapViewModel</code> の別名として設定しています。</p>

<p><strong>説明(2)</strong><br/>
<code>ViewModel</code> からの指示を受け取れるように、 <code>MapViewModel</code> を宣言します。</p>

<p><strong>説明(3)</strong><br/>
<code>Injectable</code> プロトコルを継承するため、 <code>Dependency</code> を引数に持つ <code>init</code> メソッドが必要になります。<br/>
メソッド内で <code>viewModel</code> に <code>dependency</code> を与えていますが、<br/>
これは冒頭で説明した通り <code>Dependency</code> を <code>MapViewModel</code> の別名として設定しているため実現可能となります。</p>

<p>最低限の実装の次は「位置情報の計測を停止する」機能を元に、 <code>View</code> → <code>ViewModel</code> の実装を見てみます。</p>

<p>本アプリでは、<code>UITabBar</code>の「STOP」項目をタップすることで位置情報の計測停止処理を進めることができます。<br/>
よって、 <code>View</code> → <code>ViewModel</code> の部分は下記のように&hellip;</p>

<p>```objective-c
 // 説明(4)
 // Drive to ViewModel
 private func driveToViewModel() {</p>

<pre><code>tabBar.rx.didSelectItem
    .asDriver()
    .drive(onNext: { [weak self] item in
        guard let strongSelf = self else { return }
        strongSelf.didSelectTabBarItem(tag: item.tag)
        }, onCompleted: nil, onDisposed: nil)
    .disposed(by: disposeBag)
</code></pre>

<p> }</p>

<p>// 説明(5)
/// 各タブバーアイテムタップ時の処理
///
/// &ndash; Parameter tag: タブバーアイテムのタグ
private func didSelectTabBarItem(tag: Int) {</p>

<pre><code>guard let itemTag = TabBarItemTag(rawValue: tag) else { return }
switch itemTag {
case .start:
    startUpdatingLocationMode()
case .stop:
    stopUpdatingLocationMode()
case .footView:
    showOrHideFootprintMode()
case .settings:
    showSettingViewMode()
}
</code></pre>

<p>}</p>

<p>// 説明(6)
/// Stopモードに変更された場合に実行される処理
private func stopUpdatingLocationMode() {</p>

<pre><code>// 確認アラートを表示、タブバーの選択表示をnilにする(全て未選択状態にする)
let alert = UIAlertController(title: R.string.common.confirmTitle(),
                              message: R.string.mapView.stopUpdatingLocationMessage(),
                              preferredStyle: .alert)
self.promptFor(alert: alert)
    .subscribe({ [weak self] event in
        // アラートを消す
        alert.dismiss(animated: false, completion: nil)

        // アラートに表示されたOK/Cancelボタンのどちらをタップしたか確認
        guard let strongSelf = self, let alertActionType = event.element else { return }
        switch alertActionType {
        case .ok:
            // OKボタンをタップした場合
            // タブバーの全アイテムを未選択の状態にする
            strongSelf.tabBar.selectedItem = nil
            // ストップボタンをdisabledに変更
            strongSelf.activateStartButton()
            // 位置情報の取得停止をViewModelにバインディング
            Observable.just(Void())
                .bind(to: strongSelf.viewModel.stopUpdatingLocation)
                .disposed(by: strongSelf.disposeBag)
        case .cancel:
            // Cancelボタンをタップした場合
            // タブバーの選択状態をスタートボタンの選択状態に戻す
            let startTag = TabBarItemTag.start
            strongSelf.tabBar.selectedItem = strongSelf.tabBar.items?[startTag.rawValue]
        }
    })
    .disposed(by: disposeBag)
</code></pre>

<p>}
```</p>

<p><strong>説明(4)</strong><br/>
<code>RxCocoa</code> 内に <code>UITabBar+Rx.swift</code> があり、その中で <code>Rx</code> 的に扱えるように <code>didSelectItem</code> が定義されています。<br/>
ここでは、それを用いて、 <code>UITabBar</code> のタブ項目をタップしたら、 <code>didSelectTabBarItem</code> メソッドを呼び出すように処理を書いています。</p>

<p><strong>説明(5)</strong><br/>
ここは1つ1つの処理が長くなり過ぎないように、単にメソッド分けしているだけです。<br/>
<code>tag</code> の <code>0</code> 〜 <code>3</code> で判別して処理分けしているのですが、<br/>
直で数字で <code>switch</code> 文を利用したくないので <code>TabBarItemTag</code> を定義しています。</p>

<p>```objective-c
// TabBarItemTag.swift
enum TabBarItemTag: Int {</p>

<pre><code>case start = 0
case stop
case footView
case settings
</code></pre>

<p>}
```</p>

<p>単にこれだけですが、何をタップした時にどんな処理をするのかが、こちらの方がひと目でわかりますよね。</p>

<p><strong>説明(6)</strong><br/>
ここで具体的に「STOP」をタップされた場合の処理を書いています。<br/>
重要なのは、</p>

<p>```objective-c
// 位置情報の取得停止をViewModelにバインディング
Observable.just(Void())</p>

<pre><code>.bind(to: strongSelf.viewModel.stopUpdatingLocation)
.disposed(by: strongSelf.disposeBag)
</code></pre>

<p>```</p>

<p>の部分です。<br/>
「位置情報の計測を停止しますか？」という質問に「OK」と答えた際に実行される処理で、<br/>
<code>View</code> から <code>ViewModel</code> に指示が出ていることを伝えています。<br/>
(<code>Void</code>型のデータを <code>viewModel.stopUpdatingLocation</code> にバインディングしています。)</p>

<p>このような形で <code>View</code> と <code>ViewModel</code> は双方向データバインディングな関係を構築しています。</p>

<h4>今後の展望とリリース時期について</h4>

<p>ざっくりと <code>MVVM</code> で実装したソースコードを説明してきましたが、<br/>
冒頭でも述べた通り、まだアプリは完成しておりません&hellip;</p>

<p>そこで今後の展望ですが、下記2点となります。</p>

<ul>
<li><code>RxSwift</code> らしい書き方に修正する

<ul>
<li>学習しながら実装していた経緯もあり、無用に <code>PublishSubject</code> や <code>BehaviorRelay</code> を利用している箇所があります。</li>
<li>上記を <code>Driver</code> に置き換えることで視認性の向上に繋がると考えています。</li>
</ul>
</li>
<li>テストの拡充

<ul>
<li>正直、まだ十分にテストが書けていません&hellip;</li>
<li>折角、疎結合を意識しながら構築しているのでテストは書き切りたいと思っています。</li>
</ul>
</li>
</ul>


<p>それらを満たした上で、リリース時期は1月末を見込んでいます。<br/>
極力、早期なリリースを目指していきたいと思います。</p>

<h3>まとめ</h3>

<p>さて如何でしたでしょうか？<br/>
今回は5年前の個人開発アプリの再構築について紹介させて頂きました。</p>

<p>個人開発すると、業務で学んだ技術の復習になることもあるでしょうし、<br/>
新たな技術の学びにも繋がるかと思います。</p>

<p>筆者もめげずにこれからも新しい技術を学び続け、個人開発した結果をアウトプットしていきたいなと思います。<br/>
と言ったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RxSwiftを勉強してみよう！(4) ~ 成功処理と失敗処理の書き方 ~]]></title>
    <link href="http://grandbig.github.io/blog/2018/10/20/rxswift-4/"/>
    <updated>2018-10-20T13:20:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2018/10/20/rxswift-4</id>
    <content type="html"><![CDATA[<h3>はじめに</h3>

<p>本日は <code>RxSwift</code> で、『ある条件のときのみ <code>Observer</code> に伝える』方法について見ていきたいと思います。<br/>
これは例えば、</p>

<ul>
<li>処理が成功した場合のみ、何か次のアクションを実行させる</li>
<li>処理の成功/失敗で次のアクション内容を変更する</li>
</ul>


<p>場合に必要な書き方です。<br/>
では具体的に見ていきましょう。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h3>サンプルを元に書き方を学ぼう</h3>

<p>具体的なサンプルを見ながら書き方を学んでいきたいと思います。<br/>
今回のサンプルのアーキテクチャは <code>MVVM</code> を採用します。</p>

<p>各役割は</p>

<ul>
<li><code>Model</code> : ビジネスロジック</li>
<li><code>View</code> : ユーザ操作のキャッチと実描画処理</li>
<li><code>ViewModel</code> : プレゼンテーションロジック</li>
</ul>


<p>となります。<br/>
早速、サンプルを見ていきましょう。</p>

<h4>検索ボタンをタップした結果を表現する</h4>

<p>サンプルを例に考えます。</p>

<h5>サンプルの前提</h5>

<ul>
<li>検索ボタンをタップすると、レストラン検索APIを叩く</li>
<li>レストラン検索APIの取得が成功した場合、マップにレストランの場所を示すマーカを配置する</li>
<li>レストラン検索APIの取得が失敗した場合、エラーメッセージを表示する</li>
</ul>


<h5>Viewにユーザ操作のキャッチ部分を書く</h5>

<p>まずは、 <code>ViewController.swift</code> に「ユーザ操作のキャッチ」部分を書きます。<br/>
※必要のない処理は省略します。</p>

<p>```objective-c
// ViewController.swift
import UIKit
import RxSwift
import RxCocoa
import GoogleMaps</p>

<p>class ViewController: UIViewController, Injectable {</p>

<pre><code>...
// MARK: - IBOutlets
@IBOutlet weak private var mapView: GMSMapView!
@IBOutlet weak private var searchButton: UIButton!

// MARK: - Properties
private let viewModel: ViewModel
...

override func viewDidLoad() {
    super.viewDidLoad()
    ...
    bind()
}

func bind() {
  // ユーザの検索ボタンのタップ操作をキャッチ
  searchButton.rx.tap
      .bind(to: viewModel.searchButtonDidTap)
      .disposed(by: disposeBag)
}
...
</code></pre>

<p>}
```</p>

<h5>ViewModelにViewからのインプットをハンドリング&amp;レストラン検索APIを叩く</h5>

<p>続いて、上記で書いた <code>viewModel.searchButtonDidTap</code> を <code>ViewModel</code> に定義します。<br/>
<code>View</code> からユーザのタップ操作が伝えられた時に、レストラン検索APIを叩く処理も書きます。</p>

<p>```objective-c
// ViewModel.swift
import Foundation
import RxSwift
import RxCocoa
import GoogleMaps</p>

<p>final class ViewModel: Injectable {</p>

<pre><code>struct Dependency {
    let apiClient: GooglePlacesAPIClient
    let locationManager: LocationManagerClient
    let coordinate: CLLocationCoordinate2D
}
private let disposeBag = DisposeBag()
...

// MARK: PublishSubjects
private let searchButtonDidTapStream = PublishSubject&lt;Void&gt;()

// MARK: BehaviorSubjects
private let placesStream = BehaviorSubject&lt;Places&gt;(value: defaultPlaces)
private let errorStream = BehaviorSubject&lt;String&gt;(value: String())

init(with dependency: Dependency) {
    let apiClient = dependency.apiClient
    let locationManager = dependency.locationManager
    var coordinate = dependency.coordinate

    ...

    // 検索ボタンタップ時に、レストラン検索APIを叩く
    let state = searchButtonDidTapStream
        .flatMapLatest { _ -&gt; Observable&lt;Result&lt;Places&gt;&gt; in
            return apiClient.fetchRestaurants(coordinate: coordinate)
        }

    ...
}
</code></pre>

<p>}</p>

<p>// MARK: Input
extension ViewModel {</p>

<pre><code>var searchButtonDidTap: AnyObserver&lt;()&gt; {
    return searchButtonDidTapStream.asObserver()
}
</code></pre>

<p>}</p>

<p>// MARK: Output
extension ViewModel {</p>

<pre><code>var places: Observable&lt;Places&gt; {
    return placesStream.asObservable()
}

var error: Observable&lt;String&gt; {
    return errorStream.asObservable()
}
</code></pre>

<p>}
```</p>

<p>上記のように、 <code>View</code> からのインプットとして <code>searchButtonDidTap</code> プロパティを用意します。<br/>
インプットがあった場合に、 <code>searchButtonDidTapStream.asObserver()</code> することで、呼び出しを伝搬する仕組みになっています。<br/>
その中で <code>apiClient.fetchRestaurants(coordinate: coordinate)</code> を叩いています。</p>

<h5>ViewModelにレストラン検索APIの取得成功/失敗の処理を書く：パターン１</h5>

<p>この <code>apiClient.fetchRestaurants(coordinate: coordinate)</code> の結果次第で <code>View</code> に表示させる処理を変えたいと思います。<br/>
<code>GooglePlacesAPIClient</code> クラスの <code>fetchRestaurants</code> の戻り値の定義は以下とします。</p>

<p><code>objective-c
func fetchRestaurants(coordinate: CLLocationCoordinate2D) -&gt; Observable&lt;Result&lt;Places&gt;&gt;
</code></p>

<p>上記の <code>Result</code> と <code>Places</code> の定義は以下とします。</p>

<p>```objective-c
// Result.swift
enum Result<T> {</p>

<pre><code>case success(T)
case failure(error: Error)
</code></pre>

<p>}</p>

<p>// Places.swift
public struct Places: Codable {</p>

<pre><code>public var results: [Place]
public var status: String
public var htmlAttributions: [String]
</code></pre>

<p>}
```</p>

<p><code>Place</code> の定義の紹介は省略します。</p>

<p>準備ができたので、レストラン検索APIの取得成功/失敗の処理を見ていきましょう。</p>

<p>```objective-c
// ViewModel.swift
private static let defaultPlaces = Places(results: [], status: R.string.common.ok(), htmlAttributions: [])</p>

<p>&hellip;</p>

<p>// 検索ボタンタップ時
let state = searchButtonDidTapStream</p>

<pre><code>.flatMapLatest { _ -&gt; Observable&lt;Result&lt;Places&gt;&gt; in
    return apiClient.fetchRestaurants(coordinate: coordinate)
}
</code></pre>

<p>// 処理が成功した場合
state</p>

<pre><code>.flatMapLatest { result -&gt; Observable&lt;Places&gt; in
    switch result {
    case let .success(value):
        return Observable.just(value)
    default:
        return Observable.just(ViewModel.defaultPlaces)
    }
}
.bind(to: placesStream)
.disposed(by: disposeBag)
</code></pre>

<p>// 処理が失敗した場合
state</p>

<pre><code>.flatMapLatest { result -&gt; Observable&lt;String&gt; in
    switch result {
    case let .failure(error):
        return Observable.just(error.localizedDescription)
    default:
        return Observable.just(String())
    }
}
.bind(to: errorStream)
.disposed(by: disposeBag)
</code></pre>

<p>```</p>

<p>上記では、処理が成功した場合と失敗した場合の処理を書いています。<br/>
処理が成功した場合はアウトプットである <code>placesStream</code> を経由して <code>View</code> に描画指示を出しています。<br/>
処理が失敗した場合はアウトプットである <code>errorStream</code> を経由して <code>View</code> に描画指示を出しています。</p>

<h5>Viewに描画処理を書く</h5>

<p><code>ViewModel</code> から指示の渡った後に <code>View</code> で実際に描画する処理を書きます。</p>

<p>```objective-c
// ViewController.swift
private func bind() {
  &hellip;
  viewModel.places</p>

<pre><code>  .bind { [weak self] places in
      guard let strongSelf = self else { return }
      let results = places.results
      if results.count &gt; 0 {
          strongSelf.mapView.clear()
          results.forEach({ (place) in
              // マップにマーカを配置します
              strongSelf.putMarker(place: place)
          })
      }
  }
  .disposed(by: disposeBag)
</code></pre>

<p>  viewModel.error</p>

<pre><code>  .bind { [weak self] message in
      guard let strongSelf = self else { return }
      if message.count == 0 { return }
      // エラーメッセージをアラートに表示します
      strongSelf.showAlert(message: message, completion: {})
  }
  .disposed(by: disposeBag)
</code></pre>

<p>}
```</p>

<h5>ViewModelにレストラン検索APIの取得成功/失敗の処理を書く：パターン２</h5>

<p>パターン１で手法を一つ書きましたが、筆者的には</p>

<ul>
<li><code>View</code> に条件分岐などのロジックが必要になってしまう</li>
<li><code>ViewModel</code> で <code>bind</code> 先のオブジェクトの型は1つなので無駄な処理を書かざるを得ない

<ul>
<li>処理成功の場合の <code>return Observable.just(ViewModel.defaultPlaces)</code></li>
<li>処理失敗の場合の <code>return Observable.just(String())</code></li>
</ul>
</li>
</ul>


<p>というところが微妙だと感じています。</p>

<p>上記を踏まえて、もう１つ別の方法を書きます。</p>

<p>```objective-c
// ViewModel.swift
// 検索ボタンタップ時
searchButtonDidTapStream</p>

<pre><code>.flatMapLatest { _ -&gt; Observable&lt;Result&lt;Places&gt;&gt; in
    return apiClient.fetchRestaurants(coordinate: coordinate)
}.subscribe { [weak self] event in
    guard let strongSelf = self else { return }
    guard let element = event.element else { return }
    switch element {
    case let .success(result):
        Observable.just(result)
            .bind(to: strongSelf.placesStream)
            .disposed(by: strongSelf.disposeBag)
    case let .failure(error):
        Observable.just(error.localizedDescription)
            .bind(to: strongSelf.errorStream)
            .disposed(by: strongSelf.disposeBag)
    }
</code></pre>

<p>}.disposed(by: disposeBag)
```</p>

<p>これであれば、 <code>View</code> の方のロジックも下記のように多少減らすことができ、スッキリします。<br/>
( あっても困らない条件分岐ではありますけどね&hellip; )</p>

<p>```objective-c
// ViewController.swift
private func bind() {
  &hellip;
  viewModel.places</p>

<pre><code>  .bind { [weak self] places in
      guard let strongSelf = self else { return }
      let results = places.results
      strongSelf.mapView.clear()
      results.forEach({ (place) in
          // マップにマーカを配置します
          strongSelf.putMarker(place: place)
      })
  }
  .disposed(by: disposeBag)
</code></pre>

<p>  viewModel.error</p>

<pre><code>  .bind { [weak self] message in
      guard let strongSelf = self else { return }
      // エラーメッセージをアラートに表示します
      strongSelf.showAlert(message: message, completion: {})
  }
  .disposed(by: disposeBag)
</code></pre>

<p>}
```</p>

<h3>まとめ</h3>

<p>さて如何でしたでしょうか？<br/>
筆者的には、まだまだ全然 <code>RxSwift</code> の修行が足りないので、もっと良い書き方を学んでいきたいと思います。<br/>
と言ったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[カスタムDelegateのRx対応]]></title>
    <link href="http://grandbig.github.io/blog/2018/10/14/popuppickerview-rx/"/>
    <updated>2018-10-14T22:52:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2018/10/14/popuppickerview-rx</id>
    <content type="html"><![CDATA[<h3>はじめに</h3>

<p>先日、<a href="https://grandbig.github.io/blog/2018/10/06/rx-delegate/">GeolocationSampleから学ぶdelegateのRx対応</a>を紹介しました。<br/>
今回は<a href="https://grandbig.github.io/blog/2018/10/13/popuppickerview/">下からニュッと出るPickerを作ろう！</a>で作成した <code>PickerView</code> に実装されている <code>Delegate</code> を <code>Rx</code> 対応させたいと思います。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h3>PickerViewクラスの確認</h3>

<p>まずは、元となる <code>PickerView</code> クラスを提示します。</p>

<p>```objective-c
import Foundation
import UIKit</p>

<p>/// ピッカービュー
public class PickerView: UIView {</p>

<pre><code>// MARK: - IBOutlets
@IBOutlet weak var toolBar: UIToolbar!
@IBOutlet weak var picker: UIPickerView!

// MARK: - Static Properties
static private let screenWidth = UIScreen.main.bounds.size.width
static private let screenHeight = UIScreen.main.bounds.size.height
static private let defaultPickerHeight: CGFloat = 260.0
static private let duration = 0.2

// MARK: - Properties
public weak var delegate: PickerViewDelegate?
private var selectItems = [String]()
private var selectedRowIndex: Int = 0

// MARK: - Initial Methods
required init(frame: CGRect = CGRect(x: 0, y: screenHeight, width: screenWidth, height: defaultPickerHeight),
              selectItems: [String]) {
    var frame = frame
    if let safeAreaTopInsets = UIApplication.shared.keyWindow?.safeAreaInsets.top, safeAreaTopInsets &gt; CGFloat(0.0) {
        // iPhoneX , XS, XS MAX, XRの場合はUIPickerViewの高さを調整する
        frame = CGRect(x: 0, y: frame.origin.y, width: frame.size.width, height: (frame.size.height + 100.0))
    }
    super.init(frame: frame)
    self.selectItems = selectItems
    self.xibViewSet()
}

required init?(coder aDecoder: NSCoder) {
    super.init(coder: aDecoder)!
    self.xibViewSet()
}

internal func xibViewSet() {
    if let view = R.nib.pickerView.firstView(owner: self) {
        view.frame = self.bounds
        self.addSubview(view)

        picker.delegate = self
        picker.dataSource = self
        picker.showsSelectionIndicator = true
    }
}

// MARK: - Picker Move Function
// PickerViewを表示する
func showPickerView() {
    let pickerViewWidth = self.frame.size.width
    let pickerViewHeight = self.frame.size.height
    let pickerViewYPosition = PickerView.screenHeight - pickerViewHeight
    UIView.animate(withDuration: PickerView.duration) {
        self.frame = CGRect.init(x: 0, y: pickerViewYPosition, width: pickerViewWidth, height: pickerViewHeight)
    }
}

// PickerViewを非表示にする
func hiddenPickerView() {
    let pickerViewWidth = self.frame.size.width
    let pickerViewHeight = self.frame.size.height
    UIView.animate(withDuration: PickerView.duration) {
        self.frame = CGRect.init(x: 0, y: PickerView.screenHeight, width: pickerViewWidth, height: pickerViewHeight)
    }
}

// MARK: - IBActions
@IBAction func cancelSelection(_ sender: Any) {
    delegate?.closePickerView()
    hiddenPickerView()
}

@IBAction func doneSelection(_ sender: Any) {
    delegate?.selectedItem(index: selectedRowIndex, title: selectItems[selectedRowIndex])
    hiddenPickerView()
}
</code></pre>

<p>}</p>

<p>/// MARK: &ndash; UIPickerViewDelegate
extension PickerView: UIPickerViewDelegate {</p>

<pre><code>public func pickerView(_ pickerView: UIPickerView, titleForRow row: Int, forComponent component: Int) -&gt; String? {
    return selectItems[row]
}

public func pickerView(_ pickerView: UIPickerView, didSelectRow row: Int, inComponent component: Int) {
    selectedRowIndex = row
}
</code></pre>

<p>}</p>

<p>/// MARK: &ndash; UIPickerViewDataSource
extension PickerView: UIPickerViewDataSource {</p>

<pre><code>public func numberOfComponents(in pickerView: UIPickerView) -&gt; Int {
    return 1
}

public func pickerView(_ pickerView: UIPickerView, numberOfRowsInComponent component: Int) -&gt; Int {
    return selectItems.count
}
</code></pre>

<p>}</p>

<p>/// MARK: &ndash; PickerViewDelegate
@objc
public protocol PickerViewDelegate: class {</p>

<pre><code>func selectedItem(index: Int, title: String)
func closePickerView()
</code></pre>

<p>}
```</p>

<p>では早速 <code>Rx</code> 対応させていきましょう。</p>

<h3>DelegateProxyとDelegateProxyTypeへの対応</h3>

<p>基本的には、 <code>CLLocationManagerDelegate</code> と同じです。<br/>
<code>DelegateProxy</code> と <code>DelegateProxyType</code> を継承したクラスを実装します。</p>

<p>```objective-c
import Foundation
import RxSwift
import RxCocoa</p>

<p>// 説明(1)
extension PickerView: HasDelegate {</p>

<pre><code>public typealias Delegate = PickerViewDelegate
</code></pre>

<p>}</p>

<p>public class RxPickerViewDelegateProxy: DelegateProxy&lt;PickerView, PickerViewDelegate>,</p>

<pre><code>DelegateProxyType,
PickerViewDelegate {

public init(pickerView: PickerView) {
    super.init(parentObject: pickerView, delegateProxy: RxPickerViewDelegateProxy.self)
}

// 説明(2)
public static func registerKnownImplementations() {
    self.register { RxPickerViewDelegateProxy(pickerView: $0) }
}

// 説明(3)
internal lazy var selectedItemSubject = PublishSubject&lt;(Int, String)&gt;()
internal lazy var closePickerViewSubject = PublishSubject&lt;Void&gt;()

// 説明(4)
public func selectedItem(index: Int, title: String) {
    selectedItemSubject.onNext((index, title))
}

public func closePickerView() {
    closePickerViewSubject.onNext(Void())
}

// 説明(5)
deinit {
    self.selectedItemSubject.on(.completed)
    self.closePickerViewSubject.on(.completed)
}
</code></pre>

<p>}
```</p>

<p>細かく見ていきましょう。</p>

<h4>説明(1)</h4>

<p><code>currentDelegate</code> および <code>setCurrentDelegate</code> に対応する代わりに、 <code>HasDelegate</code> を継承させましょう。</p>

<h4>説明(2)</h4>

<p>自身で定義した <code>DelegateProxy</code> の継承クラスを登録するために、 <code>registerKnownImplementations</code> 内で <code>DelegateProxySubclass.register()</code> を実行します。</p>

<h4>説明(3)</h4>

<p><code>delegate</code> メソッドが呼び出されて処理が実行されたことを <code>Subscriber</code> に伝えるために、 <code>PublishSubject</code> 型のプロパティを用意します。</p>

<h4>説明(4)</h4>

<p><code>PickerViewDelegate</code> の <code>selectedItem(index:title:)</code> と <code>closePickerView()</code> メソッドは必須メソッドです。<br/>
<code>RxPickerViewDelegateProxy</code> はもちろん <code>PickerViewDelegate</code> も継承しますので、上記2つのメソッドを定義する必要があります。</p>

<p>これが呼び出されたタイミングで <code>Subscriber</code> に伝えるために、 <code>PublishSubject.onNext(element:)</code> を実行します。</p>

<h4>説明(5)</h4>

<p><code>deinit</code> が呼ばれるタイミングで、初期化したオブジェクトが破棄されるので、<br/>
<code>PublishSubject</code> からイベント送信完了を知らせるように実装しましょう。</p>

<h3>ReactiveへのPickerViewの適応</h3>

<p>これも <code>CLLocationManager</code> と適応方法は同じです。<br/>
まずは、全体像から&hellip;</p>

<p>```objective-c
// PickerView+Rx.swift
import Foundation
import RxSwift
import RxCocoa</p>

<p>extension Reactive where Base: PickerView {</p>

<pre><code>// 説明(1)
public var delegate: DelegateProxy&lt;PickerView, PickerViewDelegate&gt; {
    return RxPickerViewDelegateProxy.proxy(for: base)
}

// 説明(2)
public var selectedItem: Observable&lt;(Int, String)&gt; {
    return RxPickerViewDelegateProxy.proxy(for: base).selectedItemSubject.asObservable()
}

public var closePickerView: Observable&lt;Void&gt; {
    return RxPickerViewDelegateProxy.proxy(for: base).closePickerViewSubject.asObservable()
}
</code></pre>

<p>}
```</p>

<p>1つずつ説明します。</p>

<h4>説明(1)</h4>

<p><code>delegate</code> を <code>DelegateProxy</code> 型として定義します。<br/>
<code>DelegateProxy</code> の取得は <code>DelegateProxyType</code> プロトコルの <code>proxy</code> メソッドを利用します。</p>

<h4>説明(2)</h4>

<p>各 <code>delegate</code> メソッドが実行されたことを補足(監視)するために <code>Observable</code> 型の <code>selectedItem</code> と <code>closePickerView</code> を用意します。</p>

<h3>利用方法</h3>

<p>では、早速利用してみましょう。</p>

<p>```objective-c
// ViewController.swift</p>

<p>private let disposeBag = DisposeBag()</p>

<p>private func bind() {
  pickerView?.rx.selectedItem</p>

<pre><code>  .asObservable()
  .subscribe({ [weak self] event in
      // Subscriberとして補足した情報を取得
      guard let strongSelf = self else { return }
      guard let index = event.element?.0 else { return }
      guard let title = event.element?.1 else { return }

      Observable.just(index, title)
          // ViewModelにsampleActionが定義されているとします
          .bind(to: strongSelf.viewModel.sampleAction)
          .disposed(by: strongSelf.disposeBag)
          })
          .disposed(by: disposeBag)
</code></pre>

<p>}
```</p>

<p>上記のような形で <code>ViewController</code> にて <code>Subscriber</code> としてアクションを補足し、 <code>ViewModel</code> に伝えることができるでしょう。</p>

<h3>まとめ</h3>

<p>さて、如何でしたでしょうか？<br/>
1つ1つの意味を理解することはもちろん大切ですが、<br/>
何だか型にはまって書き方を覚えれば、自身で <code>Rx</code> 対応が簡単にできる気がしてきますね。</p>

<p><code>Rx</code> の癖が強いが故に、慣れれば利用しやすいということなのでしょう。<br/>
と言ったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GeolocationSampleから学ぶdelegateのRx対応]]></title>
    <link href="http://grandbig.github.io/blog/2018/10/06/rx-delegate/"/>
    <updated>2018-10-06T11:16:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2018/10/06/rx-delegate</id>
    <content type="html"><![CDATA[<h3>はじめに</h3>

<p><code>RxSwift</code> を利用して <code>MVVM</code> アーキテクチャでアプリを開発することがあるでしょう。<br/>
その際に、ボタンタップやネットワーク通信であれば、何もやらずとも <code>RxSwift</code> が対応してくれていたり、 <code>RxSwift</code> に対応しているライブラリがあったりします。</p>

<p>しかし、デフォルトでは <code>RxSwift</code> に対応していない場合も当然あります。<br/>
ではそんなとき、どのようにして対応すれば良いでしょうか。</p>

<p>今日は、 <code>delegate</code> の <code>Rx</code> 対応について公式サンプルの <code>GeolocationSample</code> を元に説明してみたいと思います。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h3>delegateのRx対応方法</h3>

<p>早速具体的に方法を見ていきましょう。<br/>
今回は公式サンプルの <code>GeolocationSample</code> を元に、 <code>CLLocationManagerDelegate</code> を <code>Rx</code> に対応させる方法を説明します。</p>

<h4>DelegateProxyとDelegateProxyTypeへの対応</h4>

<p><code>delegate</code> の <code>Rx</code> 対応でまず必要なことは</p>

<ul>
<li><code>DelegateProxy</code> クラスを継承するクラスを作成すること</li>
<li><code>DelegateProxyType</code> プロトコルを継承するクラスを作成すること</li>
</ul>


<p>です。<br/>
ここでは上記2つの条件を満たした <code>RxCLLocationManagerDelegateProxy</code> クラスを作ることとします。</p>

<h5>DelegateProxyの説明</h5>

<p><code>DelegateProxy.swift</code> を見てみると、下記のように定義されています。</p>

<p>```objective-c
// DelegateProxy.swift</p>

<p>/// Base class for <code>DelegateProxyType</code> protocol.
///
/// This implementation is not thread safe and can be used only from one thread (Main thread).
open class DelegateProxy&lt;P: AnyObject, D>: _RXDelegateProxy {</p>

<pre><code>public typealias ParentObject = P
public typealias Delegate = D
...
</code></pre>

<p>}
```</p>

<p>この <code>DelegateProxy</code> は <code>DelegateProxyType</code> プロトコルのベースクラスと説明されています。<br/>
<code>DelegateProxy</code> はジェネリッククラスであり、2つのパラメータ <code>P</code> と <code>D</code> を持ちます。</p>

<p>ここで、 <code>P</code> と <code>D</code> について説明します。</p>

<ul>
<li><code>D</code> :<br/>
<code>Rx</code> に対応させたい <code>delegate</code> を指定します<br/>
<code>D</code> は <code>Delegate</code> の頭文字と思われます</li>
<li><code>P</code> :<br/>
<code>delegate</code> である <code>D</code> をプロパティとして持つオブジェクトを指定します<br/>
<code>P</code> は <code>ParentObject</code> の頭文字と思われます</li>
</ul>


<p>今回の場合は、<br/>
<code>DelegateProxy&lt;CLLocationManager, CLLocationManagerDelegate&gt;</code> になります。</p>

<h5>DelegateProxyTypeの説明</h5>

<p><code>DelegateProxyType.swift</code> の中身を見てみると、下記のように説明されています。</p>

<p>```objective-c
// DelegateProxyType.swift</p>

<p>/**
<code>DelegateProxyType</code> protocol enables using both normal delegates and Rx observable sequences with
views that can have only one delegate/datasource registered.
&hellip;</p>

<p>*/
```</p>

<p>意訳すると、<br/>
<code>DelegateProxyType</code> は <code>delegate</code> と <code>Rx</code> との紐付けを実現するプロトコル<br/>
であることを指しています。</p>

<p>方式は図示化されていますので、見てみると何となく理解できると思います。<br/>
図では <code>UIScrollViewDelegate</code> を例に説明されています。</p>

<p>```objective-c
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+
|                                           |                         <br/>
| UIView subclass (UIScrollView)            |                         <br/>
|                                           |
+&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+</p>

<pre><code>        |                                                           
        | Delegate                                                  
        |                                                           
        |                                                           
</code></pre>

<p>+&mdash;&mdash;&mdash;&mdash;&mdash;-v&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+                         <br/>
|                                           |                         <br/>
| Delegate proxy : DelegateProxyType        +&mdash;&mdash;&ndash;+&mdash;&mdash;>  Observable<T1>
|                , UIScrollViewDelegate     |     |
+&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+     +&mdash;&mdash;>  Observable<T2></p>

<pre><code>        |                                     |                     
        |                                     +----&gt;  Observable&lt;T3&gt;
        |                                     |                     
        | forwards events                     |
        | to custom delegate                  |
        |                                     v                     
</code></pre>

<p>+&mdash;&mdash;&mdash;&mdash;&mdash;-v&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+                         <br/>
|                                           |                         <br/>
| Custom delegate (UIScrollViewDelegate)    |                         <br/>
|                                           |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+ <br/>
```</p>

<p>また <code>DelegateProxyType</code> は以下3つの <code>static</code> メソッドを定義しているため、<br/>
<code>DelegateProxyType</code> を継承すると、必ずこの3つのメソッドを持つ必要があります。</p>

<ul>
<li><code>registerKnownImplementations</code><br/>
このメソッドの中で必ず <code>DelegateProxySubclass.register()</code> を実行します。<br/>
これをすることで自身で定義した <code>DelegateProxy</code> の継承クラスを登録することができます。</li>
<li><code>currentDelegate</code><br/>
<code>ParentObject</code> の持つ <code>delegate</code> を返却する処理を書きます。</li>
<li><code>setCurrentDelegate</code><br/>
<code>ParentObject</code> に持つべき <code>delegate</code> を設定する処理を書きます。</li>
</ul>


<p>特に特殊なことをしない場合は、<br/>
<code>delegate</code> をプロパティとして持つオブジェクトである <code>ParentObject</code>に<br/>
<code>HasDelegate</code> プロトコルを継承させます。 　</p>

<p>```objective-c
extension CLLocationManager: HasDelegate {</p>

<pre><code>public typealias Delegate = CLLocationManagerDelegate
</code></pre>

<p>}
```</p>

<p>これにより、 <code>currentDelegate</code> と <code>setCurrentDelegate</code> を省略することができます。</p>

<h5>対応したコードを書いてみる</h5>

<p>基本的な説明は以上として、実際にコードに起こしてみましょう。<br/>
まずは結果から。</p>

<p>```objective-c
import RxSwift      // ここは必須
import RxCocoa      // ここは必須
import CoreLocation //  CLLocationManagerDelegateはCoreLocation内に定義されています</p>

<p>// currentDelegateとsetCurrentDelegateの役割を担います
extension CLLocationManager: HasDelegate {</p>

<pre><code>public typealias Delegate = CLLocationManagerDelegate
</code></pre>

<p>}</p>

<p>// DelegateProxy, DelegateProxyType, CLLocationManagerDelegateを継承
// DelegateをRxに対応させるために、元となるDelegateも継承が必須です
public class RxCLLocationManagerDelegateProxy: DelegateProxy&lt;CLLocationManager, CLLocationManagerDelegate>,</p>

<pre><code>DelegateProxyType,
CLLocationManagerDelegate {

// 初期化処理
public init(locationManager: CLLocationManager) {
    super.init(parentObject: locationManager, delegateProxy: RxCLLocationManagerDelegateProxy.self)
}

// 必須のstaticメソッド
public static func registerKnownImplementations() {
    // 説明(1)
    self.register { (locationManager) -&gt; RxCLLocationManagerDelegateProxy in
        RxCLLocationManagerDelegateProxy(locationManager: locationManager)
    }
}

// 説明(2)
internal lazy var didUpdateLocationsSubject = PublishSubject&lt;[CLLocation]&gt;()
internal lazy var didFailWithErrorSubject = PublishSubject&lt;Error&gt;()

// 説明(3)
public func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
    _forwardToDelegate?.locationManager(manager, didUpdateLocations: locations)
    didUpdateLocationsSubject.onNext(locations)
}

public func locationManager(_ manager: CLLocationManager, didFailWithError error: Error) {
    _forwardToDelegate?.locationManager(manager, didFailWithError: error)
    didFailWithErrorSubject.onNext(error)
}

// 説明(4)
deinit {
    self.didUpdateLocationsSubject.on(.completed)
    self.didFailWithErrorSubject.on(.completed)
}
</code></pre>

<p>}
```</p>

<p>上記ソースコードを一部補足説明します。</p>

<h6>説明(1)</h6>

<p><code>registerKnownImplementations</code> で説明した通り <code>register</code> メソッドを実行しています。<br/>
<code>register</code> メソッドは、</p>

<p>```objective-c
/// Store DelegateProxy subclass to factory.
/// When make &lsquo;Rx<em>DelegateProxy&rsquo; subclass, call &lsquo;Rx</em>DelegateProxySubclass.register(for:_)&rsquo; 1 time, or use it in DelegateProxyFactory
/// &lsquo;Rx*DelegateProxy&rsquo; can have one subclass implementation per concrete ParentObject type.
/// Should call it from concrete DelegateProxy type, not generic.
public static func register<Parent>(make: @escaping (Parent) &ndash;> Self) {</p>

<pre><code>self.factory.extend(make: make)
</code></pre>

<p>}
```</p>

<p>と定義されています。</p>

<p>クロージャの引数に <code>ParentObject</code> を必要とし、<br/>
そのクラス自身を戻り値を必要としているため、<br/>
<code>ParentObject</code> として <code>locationManager</code> を渡し、<br/>
それを元に初期化した <code>RxCLLocationManagerDelegateProxy</code> オブジェクトを戻り値として渡しています。</p>

<p>ここは説明のため省略書きしませんでしたが、</p>

<p>```objective-c
public static func registerKnownImplementations() {</p>

<pre><code>self.register { RxCLLocationManagerDelegateProxy(locationManager: $0) }
</code></pre>

<p>}
```</p>

<p>とも当然書けます。</p>

<h6>説明(2)</h6>

<p><code>PublishSubject</code> 型のプロパティを2つ定義しています。</p>

<p><code>objective-c
internal lazy var didUpdateLocationsSubject = PublishSubject&lt;[CLLocation]&gt;()
internal lazy var didFailWithErrorSubject = PublishSubject&lt;Error&gt;()
</code></p>

<p>これは説明(3)にも関わるのですが、<br/>
<code>delegate</code> メソッドが呼び出されて処理が実行されたことを <code>Subscriber</code> に伝えるために定義が必要となります。</p>

<h6>説明(3)</h6>

<p><code>delegate</code> メソッドを <code>Rx</code> で対応するための方法が、まさにココで直接的に書かれています。</p>

<p>```objective-c
public func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {</p>

<pre><code>_forwardToDelegate?.locationManager(manager, didUpdateLocations: locations)
didUpdateLocationsSubject.onNext(locations)
</code></pre>

<p>}
```</p>

<p>今回は、 <code>didUpdateLocations</code> で取得した <code>locations</code> の情報を <code>Rx</code> 連携させるために、上記のように記述しています。<br/>
先程説明した <code>PublishSubject</code> が <code>Subscriber</code> にメソッドの実行タイミングでデータを伝える方法ですが、<br/>
<code>didUpdateLocationsSubject.onNext(locations)</code> で実行しています。</p>

<p><code>_forwardToDelegate?.locationManager(manager, didUpdateLocations: locations)</code> はメモリ観点から<br/>
<code>delegate</code> を引き続き利用していることを伝えるために利用しているように見えます。</p>

<h6>説明(4)</h6>

<p>最後に <code>deinit</code> 内で実行している処理ですが、<br/>
<code>deinit</code> が呼ばれるということは初期化したオブジェクトが破棄される時なので、イベントが送られることはないはずです。<br/>
よって <code>PublishSubject</code> からイベント送信完了を知らせるように実装しましょう。</p>

<h4>ReactiveへのCLLocationManagerの適応</h4>

<p>事前準備が整ったため、実際に <code>CLLocationManager</code> を <code>Rx</code> 適応させてみます。</p>

<p><code>RxSwift</code> では下記のように書くことで拡張できる仕組みを用意しています。</p>

<p>```objective-c
// CLLocationManager+Rx.swift
import CoreLocation
import RxSwift
import RxCocoa</p>

<p>extension Reactive where Base: CLLocationManager {</p>

<pre><code>...
</code></pre>

<p>}
```</p>

<p>これが可能な理由は <code>Reactive.swift</code> を見てみると良いでしょう。</p>

<p>```objective-c
public struct Reactive<Base> {</p>

<pre><code>/// Base object to extend.
public let base: Base

/// Creates extensions with base object.
///
/// - parameter base: Base object.
public init(_ base: Base) {
    self.base = base
}
</code></pre>

<p>}
```</p>

<p>そして、拡張した後にやることは下記です。</p>

<ul>
<li><code>delegate</code> のラッパーを生成する</li>
<li>各 <code>delegate</code> メソッドに対応したラッパープロパティを生成する</li>
<li>キャストメソッドを用意する</li>
</ul>


<p>1つずつ説明していきましょう。</p>

<h5>delegateのラッパーを生成する</h5>

<p>このラッパーは <code>delegate</code> を <code>DelegateProxy</code> 型として定義します。<br/>
この <code>delegate</code> はもちろん <code>readOnly</code> で値の取得のみできるものとします。<br/>
<code>DelegateProxy</code> の取得は <code>DelegateProxyType</code> プロトコルの <code>proxy</code> メソッドを利用します。</p>

<p><code>``objective-c
/**
Reactive wrapper for</code>delegate`.</p>

<p>For more information take a look at <code>DelegateProxyType</code> protocol documentation.
*/
public var delegate: DelegateProxy&lt;CLLocationManager, CLLocationManagerDelegate> {</p>

<pre><code>return RxCLLocationManagerDelegateProxy.proxy(for: base)
</code></pre>

<p>}
```</p>

<h5>各delegateメソッドに対応したラッパープロパティを生成する</h5>

<p><code>RxCLLocationManagerDelegateProxy</code> で <code>didUpdateLocations</code> と <code>didFailWithError</code> の <code>delegate</code> メソッドに対応しました。<br/>
これらのメソッドに対応したラッパープロパティは以下のように実装します。</p>

<p>```objective-c
// MARK: Responding to Location Events</p>

<p>/<em>*
 Reactive wrapper for <code>delegate</code> message.
 </em>/
 public var didUpdateLocations: Observable&lt;[CLLocation]> {</p>

<pre><code>return RxCLLocationManagerDelegateProxy.proxy(for: base).didUpdateLocationsSubject.asObservable()
</code></pre>

<p>}</p>

<p>/<em>*
 Reactive wrapper for <code>delegate</code> message.
 </em>/
public var didFailWithError: Observable<Error> {</p>

<pre><code>return RxCLLocationManagerDelegateProxy.proxy(for: base).didFailWithErrorSubject.asObservable()
</code></pre>

<p>}
```</p>

<p>これらも <code>readOnly</code> で値のみを <code>Observable</code> 型で取得できるように定義しています。</p>

<h5>キャストメソッドを用意する</h5>

<p>キャストメソッドを用意する理由は、<br/>
あるメソッドの処理の完了タイミングで何らかの処理を実行させたい<br/>
<code>methodInvoked</code> を利用するときに必要になります。</p>

<p>処理は下記の通りです。<br/>
<code>Optional</code> 型の場合とそうでない場合が必要になる可能性がありますので、2種類用意しています。</p>

<p>```objective-c
fileprivate func castOrThrow<T>(_ resultType: T.Type, _ object: Any) throws &ndash;> T {</p>

<pre><code>guard let returnValue = object as? T else {
    throw RxCocoaError.castingError(object: object, targetType: resultType)
}

return returnValue
</code></pre>

<p>}</p>

<p>fileprivate func castOptionalOrThrow<T>(_ resultType: T.Type, _ object: Any) throws &ndash;> T? {</p>

<pre><code>if NSNull().isEqual(object) {
    return nil
}

guard let returnValue = object as? T else {
    throw RxCocoaError.castingError(object: object, targetType: resultType)
}

return returnValue
</code></pre>

<p>}
```</p>

<p>今回の場合、端末の位置情報を利用するので、 <code>CLLocationManagerDelegate</code> の <code>didChangeAuthorization</code> のハンドリングが必須になります。<br/>
この <code>delegate</code> メソッドは定期的に繰り返し利用する必要はありません。<br/>
状態が変わって、その情報を必要となったタイミングでだけ利用できれば良いのです。<br/>
よって <code>methodInvoked</code> を利用してプロパティを定義します。</p>

<p>```objective-c
// MARK: Responding to Authorization Changes</p>

<p>/<em>*
 Reactive wrapper for <code>delegate</code> message.
 </em>/
public var didChangeAuthorizationStatus: Observable<CLAuthorizationStatus> {</p>

<pre><code>return delegate.methodInvoked(#selector(CLLocationManagerDelegate.locationManager(_:didChangeAuthorization:)))
    .map { a in
        let number = try castOrThrow(NSNumber.self, a[1])
        return CLAuthorizationStatus(rawValue: Int32(number.intValue)) ?? .notDetermined
}
</code></pre>

<p>}
```</p>

<p>以上で必要な対応は全て完了です。</p>

<h3>Rxに対応したdelegateの使い方</h3>

<p>自作した <code>Rx</code> 対応後の <code>delegate</code> を利用する例も見ていきましょう。</p>

<h4>処理ロジックの実装</h4>

<p>公式サンプルでは処理ロジックに相当する <code>GeolocationService.swift</code> を下記のように実装しています。</p>

<p>```objective-c
// GeolocationService.swift
import CoreLocation
import RxSwift
import RxCocoa</p>

<p>class GeolocationService {</p>

<pre><code>static let instance = GeolocationService()
// 説明(1)
private (set) var authorized: Driver&lt;Bool&gt;
private (set) var location: Driver&lt;CLLocationCoordinate2D&gt;

private let locationManager = CLLocationManager()

private init() {

    locationManager.distanceFilter = kCLDistanceFilterNone
    locationManager.desiredAccuracy = kCLLocationAccuracyBestForNavigation

    // 説明(2)
    authorized = Observable.deferred { [weak locationManager] in
            let status = CLLocationManager.authorizationStatus()
            guard let locationManager = locationManager else {
                return Observable.just(status)
            }
            return locationManager
                .rx.didChangeAuthorizationStatus
                .startWith(status)
        }
        .asDriver(onErrorJustReturn: CLAuthorizationStatus.notDetermined)
        .map {
            switch $0 {
            case .authorizedAlways:
                return true
            default:
                return false
            }
        }

    // 説明(3)
    location = locationManager.rx.didUpdateLocations
        .asDriver(onErrorJustReturn: [])
        .flatMap {
            return $0.last.map(Driver.just) ?? Driver.empty()
        }
        .map { $0.coordinate }

    locationManager.requestAlwaysAuthorization()
    locationManager.startUpdatingLocation()
}
</code></pre>

<p>}
```</p>

<p>1つずつ説明していきましょう。</p>

<h5>説明(1)</h5>

<p>今回のサンプルは、</p>

<ul>
<li>位置情報の利用を許可したら、画面が切り替わる</li>
<li>取得した最新の位置情報を画面に表示する</li>
</ul>


<p>という、データ結果を画面に直接反映させる処理が含まれています。<br/>
よって、</p>

<p><code>objective-c
private (set) var authorized: Driver&lt;Bool&gt;
private (set) var location: Driver&lt;CLLocationCoordinate2D&gt;
</code></p>

<p>のように <code>Driver</code> として定義しています。</p>

<h5>説明(2)</h5>

<p><code>authorized</code> は <code>delegate</code> メソッドである <code>didChangeAuthorization</code> が呼び出されたタイミングで値が変更される必要があります。 <br/>
今回は、<br/>
<code>Subscribe</code> するまでは <code>Observable</code> を生成せずに、 <code>Subscribe</code> されたタイミングで <code>Observable</code> を返す <code>Observable</code> を生成する<br/>
<code>deferred</code> メソッドを利用しています。</p>

<p>```objective-c
authorized = Observable.deferred { [weak locationManager] in</p>

<pre><code>    let status = CLLocationManager.authorizationStatus()
    guard let locationManager = locationManager else {
        return Observable.just(status)
    }
    // didChangeAuthorizationStatusからauthorizedの値を取得
    return locationManager
        .rx.didChangeAuthorizationStatus
        .startWith(status)
}
// エラーが発生した場合は .notDetermined で返却する
.asDriver(onErrorJustReturn: CLAuthorizationStatus.notDetermined)
.map {
    // .authorizedAlwaysの場合のみauthorizedにtrueを格納する
    switch $0 {
    case .authorizedAlways:
        return true
    default:
        return false
    }
}
</code></pre>

<p>```</p>

<h5>説明(3)</h5>

<p>最新の位置情報を取得したタイミングで通知します。</p>

<p>```objective-c
location = locationManager.rx.didUpdateLocations</p>

<pre><code>// エラーが発生した場合は、空配列で返却する
.asDriver(onErrorJustReturn: [])
// 位置情報が格納されている場合はその値を、位置情報がない場合は空を返却する
.flatMap {
    return $0.last.map(Driver.just) ?? Driver.empty()
}
// CLLocationCoordinate2Dの値を返却する
.map { $0.coordinate }
</code></pre>

<p>```</p>

<h4>Viewロジックの実装</h4>

<p>サンプルでは下記のように実装しています。</p>

<p>```objective-c
// GeolocationViewController.swift
import UIKit
import CoreLocation
import RxSwift
import RxCocoa</p>

<p>// 説明(1)
private extension Reactive where Base: UILabel {</p>

<pre><code>var coordinates: Binder&lt;CLLocationCoordinate2D&gt; {
    return Binder(base) { label, location in
        label.text = "Lat: \(location.latitude)\nLon: \(location.longitude)"
    }
}
</code></pre>

<p>}</p>

<p>class GeolocationViewController: ViewController {</p>

<pre><code>@IBOutlet weak private var noGeolocationView: UIView!
@IBOutlet weak private var button: UIButton!
@IBOutlet weak private var button2: UIButton!
@IBOutlet weak var label: UILabel!

override func viewDidLoad() {
    super.viewDidLoad()

    view.addSubview(noGeolocationView)

    let geolocationService = GeolocationService.instance

    // 説明(2)
    geolocationService.authorized
        .drive(noGeolocationView.rx.isHidden)
        .disposed(by: disposeBag)

    // 説明(3)
    geolocationService.location
        .drive(label.rx.coordinates)
        .disposed(by: disposeBag)
    ...
}
...
</code></pre>

<p>}
```</p>

<p>1つずつ説明していきましょう。</p>

<h5>説明(1)</h5>

<p>画面に位置情報を表示するために <code>UILabel</code> を独自に <code>Rx</code> に対応させています。<br/>
これは <code>CLLocationManager</code> を拡張した方法と同じですね。</p>

<h5>説明(2)</h5>

<p><code>authorized</code> が <code>true</code> の場合に <code>noGeolocationView</code> を非表示にするよう実装しています。</p>

<h5>説明(3)</h5>

<p>取得できた最新の位置情報を説明(1)で拡張した機能を利用して <code>UILabel</code> に表示するようにしています。</p>

<p>以上で <code>Rx</code> に対応させた <code>delegate</code> を利用することができました。</p>

<h3>まとめ</h3>

<p>さて、如何でしたでしょうか。<br/>
形式に沿って実装をすることで簡単に拡張することはできますが、<br/>
実装1つ1つを理解することでより深く <code>RxSwift</code> を現場で活用できるかと思います。</p>

<p>まだまだ筆者も理解が乏しいところがあるので、もっと深く勉強を続けていきたいと思います。<br/>
ということで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RxSwiftを勉強してみよう！(3)]]></title>
    <link href="http://grandbig.github.io/blog/2016/08/30/rxswift-3/"/>
    <updated>2016-08-30T16:42:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2016/08/30/rxswift-3</id>
    <content type="html"><![CDATA[<h3>RxSwiftのメソッドを見てみよう</h3>

<p>前回に引き続きRxSwiftを勉強したいと思います。<br/>
今回は<a href="https://github.com/ReactiveX/RxSwift/blob/master/Documentation/API.md">GitHub: Reactive/RxSwift API一覧</a>からメインのメソッドを見ていきたいと思います。</p>

<h4>asObservable</h4>

<p>これは<code>ReactiveX</code>で定義されている<code>From</code>オペレータと同義です。<br/>
様々なオブジェクトを<code>Observable</code>型のデータに変換するためのオペレータです。</p>

<p>利用例は下記です。</p>

<p>```objective-c
let disposeBag = DisposeBag()   // 自動unsubscribeのために必要</p>

<p>let array: [Int] = [1, 2, 3, 4, 5]
let variable = Variable(array)
variable.asObservable.subscribe { (event) in</p>

<pre><code>print("Event is \(event)")
</code></pre>

<p>}.addDisposableTo(disposeBag)</p>

<p>variable.value = [6, 7, 8]</p>

<p>// 結果は下記です。
Event is Next([1, 2, 3, 4, 5])
Event is Next([6, 7, 8])
Event is Completed
```</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h4>create</h4>

<p>0から<code>Observable</code>型のデータを生成するためのオペレータです。</p>

<p>```objective-c
let disposeBag = DisposeBag()   // 自動unsubscribeのために必要</p>

<p>let source = Observable.create { (observer: AnyObserver<Int>) &ndash;> Disposable in</p>

<pre><code>observer.onNext(1)
observer.onCompleted()

return AnonymousDisposable {
    print("Disposed")
}
</code></pre>

<p>}</p>

<p>source.subscribeNext { (elem) in</p>

<pre><code>print("Event is \(elem)")
</code></pre>

<p>}.addDisposableTo(disposeBag)</p>

<p>// 結果は下記です
Event is 1
Disposed
```</p>

<h4>deferred</h4>

<p>Subscribeされたタイミングで<code>Observable</code>型のデータを生成するオペレータです。</p>

<p>```objective-c
let disposeBag = DisposeBag()   // 自動unsubscribeのために必要</p>

<p>let source = Observable.deferred { () &ndash;> Observable<Int> in</p>

<pre><code>return Observable.just(1)
</code></pre>

<p>}
source.subscribeNext { (elem) in</p>

<pre><code>print("Elem is \(elem)")
</code></pre>

<p>}.addDisposableTo(disposeBag)</p>

<p>// 結果は下記です
Event is 1
```</p>

<h4>empty</h4>

<p>空の(何の値も持たない)<code>Observable</code>型のデータを生成するオペレータです。<br/>
通常通り、終了処理は実行されます。</p>

<p>```objective-c
let disposeBag = DisposeBag()   // 自動unsubscribeのために必要</p>

<p>let source: Observable<Int> = Observable.empty()
source.subscribeNext { (elem) in</p>

<pre><code>print("Elem is \(elem)")
</code></pre>

<p>}.addDisposableTo(disposeBag)</p>

<p>// 結果は下記です。
// 空のため何も出力されません
```</p>

<h4>never</h4>

<p>空の(何の値も持たない)<code>Observable</code>型のデータを生成するオペレータです。<br/>
<code>empty</code>と異なるのは終了処理が実行されないことです。</p>

<p>```objective-c
let disposeBag = DisposeBag()   // 自動unsubscribeのために必要</p>

<p>let source: Observable<Int> = Observable.never()
source.subscribeNext { (elem) in</p>

<pre><code>print("Elem is \(elem)")
</code></pre>

<p>}.addDisposableTo(disposeBag)</p>

<p>// 結果は下記です。
// 空のため何も出力されません
```</p>

<h4>error</h4>

<p>空の(何の値も持たない)<code>Observable</code>型のデータを生成するオペレータです。<br/>
<code>empty</code>, <code>never</code>と異なり、エラーを持った終了処理を実行します。</p>

<p>```objective-c
let disposeBag = DisposeBag()   // 自動unsubscribeのために必要</p>

<p>let error = NSError(domain: &ldquo;test&rdquo;, code: -1, userInfo: nil)
let source: Observable<Int> = Observable.error(error)
source.subscribeError { (error) in</p>

<pre><code>print("Error is \(error)")
</code></pre>

<p>}.addDisposableTo(disposeBag)</p>

<p>// 結果は下記です。
Error is Error Domain=test Code=-1 &ldquo;(null)&rdquo;
```</p>

<h4>toObservable</h4>

<p>様々なオブジェクトを<code>Observable</code>型のデータに変換するためのオペレータです。<br/>
<code>asObservable</code>とは利用方法が異なります。</p>

<p>```objective-c
let disposeBag = DisposeBag()   // 自動unsubscribeのために必要</p>

<p>let array: [Int] = [1, 2, 3]
array.toObservable().subscribeNext { (elem) in</p>

<pre><code>print("Number is \(elem)")
</code></pre>

<p>}.addDisposableTo(disposeBag)</p>

<p>// 結果は下記です。
Number is 1
Number is 2
Number is 3
```</p>

<h4>interval</h4>

<p>一定期間あけて処理を実行するためのオペレータです。<br/>
<code>JavaScript</code>で言うところの<code>setTimeInterval</code>です。</p>

<p>```objective-c
let disposeBag = DisposeBag()   // 自動unsubscribeのために必要</p>

<p>let timer: Observable<Int> = Observable.interval(5.0, scheduler: MainScheduler.instance)
timer.subscribeNext { (count) in</p>

<pre><code>print("log output")
</code></pre>

<p>}.addDisposableTo(disposeBag)</p>

<p>// 結果は下記です。
// 5秒後に実行されます。
log output
```</p>

<h4>just</h4>

<p>引数に指定した特定の型を返却する<code>Observable</code>型のデータを生成するためのオペレータです。</p>

<p>```objective-c
let disposeBag = DisposeBag()   // 自動unsubscribeのために必要</p>

<p>let source = Observable.just(1)
source.subscribeNext { (elem) in</p>

<pre><code>print("Elem is \(elem)")
</code></pre>

<p>}.addDisposableTo(disposeBag)</p>

<p>// 結果は下記です。
Elem is 1
```</p>

<h4>of</h4>

<p>様々なオブジェクトを<code>Observable</code>型のデータに変換するためのオペレータです。<br/>
<code>asObservable</code>や<code>toObservable</code>とは利用方法が異なります。</p>

<p>```objective-c
let disposeBag = DisposeBag()   // 自動unsubscribeのために必要</p>

<p>let source = Observable.of(1)
source.subscribeNext { (elem) in</p>

<pre><code>print("Elem is \(elem)")
</code></pre>

<p>}.addDisposableTo(disposeBag)</p>

<p>// 結果は下記です。
Elem is 1
```</p>

<h4>range</h4>

<p>特定の範囲の<code>Int</code>型を持つ<code>Observable</code>型データを生成するオペレータです。</p>

<p>```objective-c
let disposeBag = DisposeBag()   // 自動unsubscribeのために必要</p>

<p>let source: Observable<Int> = Observable.range(start: 1, count: 3)
source.subscribeNext { (elem) in</p>

<pre><code>print("Elem is \(elem)")
</code></pre>

<p>}.addDisposableTo(disposeBag)</p>

<p>// 結果は下記です。
Elem is 1
Elem is 2
Elem is 3
```</p>

<h4>repeatElement</h4>

<p>指定した回数、処理を実行するときに利用する<code>Observable</code>型データを生成するオペレータです。<br/>
<code>take</code>メソッドを利用して回数を指定します。</p>

<p>```objective-c
let disposeBag = DisposeBag()   // 自動unsubscribeのために必要</p>

<p>let source = Observable.repeatElement(1).take(3)
source.subscribeNext { (elem) in</p>

<pre><code>print("Elem is \(elem)")
</code></pre>

<p>}.addDisposableTo(disposeBag)</p>

<p>// 結果は下記です。
Elem is 1
Elem is 1
Elem is 1
```</p>

<h4>timer</h4>

<p>一定時間経過後に処理を実行したい場合に利用するオペレータです。<br/>
<code>JavaScript</code>で言うところの<code>setTimeout</code>です。</p>

<p>```objective-c
let timer: Observable<Int> = Observable.timer(5.0, scheduler: MainScheduler.instance)
timer.subscribeNext { (count) in</p>

<pre><code>print("log output")
</code></pre>

<p>}.addDisposableTo(disposeBag)
```</p>

<h3>まとめ</h3>

<p>さて、今回は<code>Creating Observables</code>のみを取り上げさせて頂きましたが、いかがでしたでしょうか？<br/>
筆者もイマイチ使い方がわからなかったオペレータがたくさんあったので、多少なりとも使えそうな気がしてきました。<br/>
<code>Transforming Observables</code>, <code>Filtering Observables</code> &hellip;. と全て見ていけると良いのですが、結構数が多いですね。<br/>
時間があるときに続きを書きたいと思います。</p>

<p>と言ったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
</feed>
