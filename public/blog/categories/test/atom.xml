<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: test | Takahiro Octopress Blog]]></title>
  <link href="http://grandbig.github.io/blog/categories/test/atom.xml" rel="self"/>
  <link href="http://grandbig.github.io/"/>
  <updated>2020-11-01T14:32:02+09:00</updated>
  <id>http://grandbig.github.io/</id>
  <author>
    <name><![CDATA[Takahiro]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[XCTestでViewModelのテストを書いてみよう！]]></title>
    <link href="http://grandbig.github.io/blog/2019/01/30/xctest-2/"/>
    <updated>2019-01-30T11:57:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2019/01/30/xctest-2</id>
    <content type="html"><![CDATA[<h3>はじめに</h3>

<p>今回は、 <code>MVVM</code> アーキテクチャでiOSアプリを書いた場合の <code>Unit Test</code> について記事を書こうと思います。</p>

<p>だいぶ<a href="http://grandbig.github.io/blog/2016/01/11/xctest/">以前</a>に <code>XCTest</code> と <code>XCUITest</code> の初歩について紹介しましたが、<br/>
本記事では特に <code>XCTest</code> を用いた <code>Unit Test</code> に焦点をあてます。</p>

<p>では、早速見ていきましょう。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h3>前提</h3>

<p>まずは、 <code>Unit Test</code> を書くにあたっての前提について確認しておきたいと思います。</p>

<h4>利用するソースコード</h4>

<p>今回説明に利用するソースコードは<a href="https://github.com/grandbig/footStepMeter">足跡計 v1.0.4</a>にします。</p>

<p>主な機能は下記の通りです。</p>

<ul>
<li>様々な精度で歩行ルートを記録可能</li>
<li>複数の歩行ルートを記録可能</li>
<li>歩行ルート履歴をいつでも閲覧可能</li>
<li>歩行ルート記録をメールで送信可能</li>
<li>不要になった歩行ルート記録は削除可能</li>
</ul>


<p>また、実際のアプリ画面は下記の通りです。</p>

<p><img src="/images/xctest-2_1.png" alt="足跡計 v1.0.4の画面キャプチャ" /></p>

<h4>利用しているOSSライブラリ</h4>

<p>このアプリで利用しているOSSライブラリは下記の通りです。</p>

<ul>
<li><a href="https://github.com/ReactiveX/RxSwift">RxSwift</a>

<ul>
<li><code>MVVM</code> アーキテクチャでアプリを構成するために利用しています。</li>
<li><code>RxCocoa</code> は <code>RxSwift</code> と基本的にはセットで利用します。</li>
<li><code>RxTest</code> はテストコードを書く時に利用します。</li>
</ul>
</li>
<li><a href="https://github.com/RxSwiftCommunity/RxDataSources">RxDataSources</a>

<ul>
<li><code>UITableView</code> 関連の処理を <code>Rx</code> 書く時のサポートとなるため利用しています。</li>
</ul>
</li>
<li><a href="https://github.com/realm/realm-cocoa">RealmSwift</a>

<ul>
<li>位置情報をアプリローカルに保存するために利用しています。</li>
</ul>
</li>
<li><a href="https://github.com/mac-cain13/R.swift">R.swift</a>

<ul>
<li>文字列のベタ書きやそれに寄るスペルミス等を防ぐために利用しています。</li>
</ul>
</li>
<li><a href="https://github.com/mono0926/LicensePlist">LicensePlist</a>

<ul>
<li>ライセンスページをアプリ外に配置するために利用しています。</li>
</ul>
</li>
</ul>


<h3>テストコードのサンプル1</h3>

<p>それでは実際にテストコードを見ていきましょう。</p>

<p>まず1つ目のサンプルとしては、下記画面のテストを取り上げて説明します。</p>

<p><img src="/images/xctest-2_2.png" alt="設定画面" /></p>

<p>この画面は、</p>

<ul>
<li>メイン画面の <code>UITabBar</code> の4項目目をタップして画面遷移した先の設定画面</li>
<li>この設定画面は <code>UITableView</code> で構成されたテーブルビューの画面</li>
<li>表示されている2項目は文言固定</li>
</ul>


<p>という仕様になっています。</p>

<h4>ViewModelのソースコード</h4>

<p>テストを書く前にそもそもの実装を紹介します。</p>

<h5>SettingView.strings</h5>

<p>文字列べた書きを避けるために <code>R.swift</code> を利用しているので、</p>

<p><code>objective-c
// SettingView.strings
"title" = "SETTINGS";
"footprintHistory" = "FOOTPRINT HISTORY";
"aboutApp" = "ABOUT APP";
</code></p>

<p>のように定義しています。</p>

<h5>Injectable.swift</h5>

<p>ここは <code>ViewModel</code> クラスの <code>DI</code> 化をするために用意した <code>Protocol</code> になります。</p>

<p>```objective-c
// Injectable.swift
protocol Injectable {</p>

<pre><code>associatedtype Dependency
init(with dependency: Dependency)
</code></pre>

<p>}</p>

<p>extension Injectable where Dependency == Void {</p>

<pre><code>init() {
    self.init(with: ())
}
</code></pre>

<p>}
```</p>

<h5>SettingSectionModel.swift</h5>

<p>本画面ではテーブルビューの描画時に <code>RxDataSources</code> を利用しているため、その準備が必要です。</p>

<p>```objective-c
// SettingSectionModel.swift
import RxDataSources</p>

<p>struct SettingSectionModel {</p>

<pre><code>var items: [Item]
</code></pre>

<p>}
extension SettingSectionModel: SectionModelType {</p>

<pre><code>typealias Item = String

init(original: SettingSectionModel, items: [Item]) {
    self = original
    self.items = items
}
</code></pre>

<p>}
```</p>

<h5>SettingViewModel.swift</h5>

<p>そして、 <code>ViewModel</code> のクラスです。</p>

<p>```objective-c
// SettingViewModel.swift
import Foundation
import RxSwift
import RxCocoa</p>

<p>final class SettingViewModel: Injectable {</p>

<pre><code>struct Dependency {
}

// MARK: - Properties
private let disposeBag = DisposeBag()
private var sectionModels = [SettingSectionModel]()

// MARK: BehaviorRelays
let viewDidLoadStream = BehaviorRelay&lt;[SettingSectionModel]&gt;(value: [])

// MARK: Initial method
init(with dependency: Dependency) {

    Observable.deferred {() -&gt; Observable&lt;[SettingSectionModel]&gt; in
        let items = [R.string.settingView.footprintHistory(), R.string.settingView.aboutApp()]
        self.sectionModels = [SettingSectionModel(items: items)]
        return Observable.just(self.sectionModels)
        }
        .bind(to: viewDidLoadStream)
        .disposed(by: disposeBag)
}
</code></pre>

<p>}
```</p>

<p>初期ロード時に、固定文言をセットしたテーブルビューを表示する必要があるため、<br/>
画面初期化時に即時に <code>Subscribe</code> するようにしており、<br/>
それを <code>Observable.deferred</code> で捕捉して、必要な値を <code>viewDidLoadStream</code> にバインディングする形で <code>View</code> に返しています。</p>

<h4>ViewModelのテストコード</h4>

<p>ではテストを書いていきます。</p>

<p>ここで書きたいテストは、</p>

<ul>
<li>When: 初期ロード時に</li>
<li>What: <code>RxDataSources</code> で処理可能な <code>SettingSectionModel</code> の形をした2つの固定文言を</li>
<li>How: <code>viewDidLoadStream</code> 経由で</li>
</ul>


<p>渡ってくることになります。</p>

<p>それを表したテストコードが下記の通りです。</p>

<p>```objective-c
// SettingViewModelTests.swift
import XCTest
import RxSwift
import RxCocoa
import RxTest
@testable import footStepMeter</p>

<p>class SettingViewModelTests: XCTestCase {</p>

<pre><code>// 説明(1)
var viewModel: SettingViewModel!
let scheduler = TestScheduler(initialClock: 0)

// 説明(2)
override func setUp() {
    super.setUp()

    let dependency = SettingViewModel.Dependency()
    viewModel = SettingViewModel(with: dependency)
}

override func tearDown() {
    super.tearDown()
}

// 説明(3)
func testViewDidLoadStream() {
    let disposeBag = DisposeBag()
    let settingSectionModels = scheduler.createObserver([SettingSectionModel].self)

    viewModel.viewDidLoadStream
        .bind(to: settingSectionModels)
        .disposed(by: disposeBag)

    scheduler.start()

    // 想定されるテスト結果の定義
    let items = [R.string.settingView.footprintHistory(), R.string.settingView.aboutApp()]
    let mock = [SettingSectionModel(items: items)]
    let expectedItems = [Recorded.next(0, mock)]

    // 実際の実行結果
    let element = settingSectionModels.events.first!.value.element

    // 想定結果と実行結果を比較
    XCTAssertEqual(element!.first!.items, expectedItems.first!.value.element!.first!.items)
}
</code></pre>

<p>}
```</p>

<h5>説明(1)</h5>

<p>テスト対象となる <code>SettingViewModel</code> とテストの実行タイミングを測る上で必要な <code>TestScheduler</code> を定義しています。</p>

<h5>説明(2)</h5>

<p>テスト実施前のセットアップとして、 <code>SettingViewModel</code> を初期化しています。</p>

<h5>説明(3)</h5>

<p>ここで具体的にテストを書いています。</p>

<ul>
<li>ストリームを捕捉する <code>Observer</code> として <code>settingSectionModels</code> を定義</li>
<li>それを <code>viewDidLoadStream</code> に流れた時のバインディング先として設定</li>
<li>固定文言2つが <code>RxDataSources</code> 用の形で流れてくるため、そのモックデータを定義</li>
<li>初期ロード時に流れるはずなので <code>[Recorded.next(0, mock)]</code> と設定</li>
<li>想定結果と実行結果を <code>XCTAssertEqual</code> を用いて比較</li>
</ul>


<h3>テストコードのサンプル2</h3>

<p>続いて、2つ目のサンプルですが、下記のテストの一部を紹介します。</p>

<p><img src="/images/xctest-2_3.png" alt="足跡履歴一覧画面" /></p>

<p>この画面は、</p>

<ul>
<li>設定画面の <code>FOOTPRINT HISTORY</code> をタップした時に画面遷移した先の足跡履歴一覧画面</li>
<li>この足跡履歴一覧画面は <code>UITableView</code> で構成されたテーブルビューの画面</li>
<li>各項目はアプリローカルに保存された情報から取得して表示している</li>
</ul>


<p>という仕様になっています。</p>

<p>幾つか他にも機能があるため、サンプル1よりもテスト項目数は多くなるのですが、説明のため上記1つに絞ります。</p>

<h4>ViewModelのソースコード</h4>

<p>さて、そもそものソースコードですが、 <code>Injectable.swift</code> は先程と同じなので省略します。</p>

<h5>FootprintRecordSectionModel.swift</h5>

<p>サンプル1と同じく、本画面ではテーブルビューの描画時に <code>RxDataSources</code> を利用しているため、その準備が必要です。</p>

<p>```objective-c
// FootprintRecordSectionModel.swift
import RxDataSources</p>

<p>struct FootprintRecordSectionModel {</p>

<pre><code>var items: [Item]
</code></pre>

<p>}
extension FootprintRecordSectionModel: SectionModelType {</p>

<pre><code>typealias Item = (String, Int)

init(original: FootprintRecordSectionModel, items: [Item]) {
    self = original
    self.items = items
}
</code></pre>

<p>}
```</p>

<p>各行に表示する内容が、</p>

<ul>
<li>保存データのタイトル</li>
<li>その足跡数</li>
</ul>


<p>となっていて、対にしてデータを返却するために <code>(String, Int)</code> とタプルで書いています。</p>

<h5>RealmManager.swift</h5>

<p>今回のテストでは、アプリ内部に保存したデータを取得する処理を扱うため、その処理を実装する必要があります。</p>

<p>```objective-c
// RealmManager.swift
import Foundation
import CoreLocation
import RxSwift
import RealmSwift</p>

<p>protocol RealmManagerClient {</p>

<pre><code>// MARK: - Protocol Properties
var title: String { get set }

// MARK: - Protocol Methods
func setSaveTitle(_ title: String)
func createFootprint(location: CLLocation)
func fetchFootprints() -&gt; Results&lt;Footprint&gt;?
func fetchFootprints() -&gt; Observable&lt;Results&lt;Footprint&gt;?&gt;
func fetchFootprintsByTitle(_ text: String) -&gt; Observable&lt;Results&lt;Footprint&gt;?&gt;
func existsByTitle(_ text: String) -&gt; Observable&lt;Bool&gt;
func distinctByTitle() -&gt; [(String, Int)]
func distinctByTitle() -&gt; Observable&lt;[(String, Int)]&gt;
func countFootprints() -&gt; Observable&lt;Int&gt;
func countFootprintsByTitle(_ text: String) -&gt; Observable&lt;Int&gt;
func delete(_ text: String) -&gt; Observable&lt;Error?&gt;
</code></pre>

<p>}</p>

<p>final class RealmManager: NSObject, RealmManagerClient {</p>

<pre><code>...

func distinctByTitle() -&gt; [(String, Int)] {
    do {
        let realm = try Realm()
        if let titles = realm.objects(Footprint.self).sorted(byKeyPath: "id", ascending: false)
            .value(forKey: "title") as? [String], let distinctTitles = NSOrderedSet(array: titles).array as? [String] {
            var distinctFootprints = [(String, Int)]()
            for title in distinctTitles {
                let count = realm.objects(Footprint.self).filter("title == '\(title)'").count
                distinctFootprints.append((title, count))
            }
            return distinctFootprints
        }
        return []
    } catch _ as NSError {
        return []
    }
}

...
</code></pre>

<p>}
```</p>

<p>今回直接扱う処理以外は省略して書きました。<br/>
基本的な <code>CRUD</code> の処理に加えて、本アプリ固有のビジネスロジックが存在します。<br/>
※ <code>protocol</code> 部分を書いたのは、後のテストコードに関わるためです。</p>

<h5>FootprintRecordViewModel</h5>

<p>冒頭に説明した通り、混乱を避けるため、今回のテストコードで利用しない部分はあえてコードを省略しています。</p>

<p>```objective-c
// FootprintRecordViewModel.swift
import Foundation
import RxSwift
import RxCocoa
import RealmSwift</p>

<p>final class FootprintRecordViewModel: Injectable {</p>

<pre><code>struct Dependency {
    let realmManager: RealmManagerClient
}

// MARK: - Properties
private let disposeBag = DisposeBag()
private var sectionModels = [FootprintRecordSectionModel]()

// MARK: BehaviorRelays
let savedRecordStream = BehaviorRelay&lt;[FootprintRecordSectionModel]&gt;(value: [])

// MARK: Initial method
init(with dependency: Dependency) {
    let realmManager = dependency.realmManager

    Observable.deferred {() -&gt; Observable&lt;[FootprintRecordSectionModel]&gt; in
        self.sectionModels = [FootprintRecordSectionModel(items: realmManager.distinctByTitle())]
        return Observable.just(self.sectionModels)
        }
        .bind(to: savedRecordStream)
        .disposed(by: disposeBag)
}
</code></pre>

<p>}
```</p>

<p>サンプル1と基本的には同じです。<br/>
返却値をアプリ内部に保存したデータにする必要があるため、<br/>
<code>realmManager.distinctByTitle()</code> を利用しています。</p>

<h4>ViewModelのテストコード</h4>

<p>ではテストを書いていきます。</p>

<p>ここで書きたいテストは、</p>

<ul>
<li>When: 初期ロード時に</li>
<li>What: <code>RxDataSources</code> で処理可能な <code>FootprintRecordSectionModel</code> の形をした保存済み足跡情報を</li>
<li>How: <code>savedRecordStream</code> 経由で</li>
</ul>


<p>渡ってくることになります。</p>

<p>それを表したテストコードが下記の通りです。</p>

<p>```objective-c
// FootprintRecordViewModelTests.swift
import XCTest
import RxSwift
import RxCocoa
import RxTest
import CoreLocation
import RealmSwift</p>

<p>@testable import footStepMeter</p>

<p>class FootprintRecordViewModelTests: XCTestCase {</p>

<pre><code>// 説明(1)
var viewModel: FootprintRecordViewModel!
let scheduler = TestScheduler(initialClock: 0)
static let realm = try! Realm(configuration: Realm.Configuration(inMemoryIdentifier: "inMemory"))

// 説明(2)
/// テスト用のモックRealmManagerClient
final class MockRealmManagerClient: RealmManagerClient {
    var title: String = String()

    func setSaveTitle(_ title: String) {
    }

    func createFootprint(location: CLLocation) {
    }

    func fetchFootprints() -&gt; Results&lt;Footprint&gt;? {
        return nil
    }

    func fetchFootprints() -&gt; Observable&lt;Results&lt;Footprint&gt;?&gt; {
        return Observable.just(FootprintRecordViewModelTests.mockFootprints())
    }

    func fetchFootprintsByTitle(_ text: String) -&gt; Observable&lt;Results&lt;Footprint&gt;?&gt; {
        return Observable.just(FootprintRecordViewModelTests.mockFootprints())
    }

    func existsByTitle(_ text: String) -&gt; Observable&lt;Bool&gt; {
        return Observable.just(false)
    }

    func distinctByTitle() -&gt; [(String, Int)] {
        return FootprintRecordViewModelTests.mockDistinctData()
    }

    func distinctByTitle() -&gt; Observable&lt;[(String, Int)]&gt; {
        return Observable.just(FootprintRecordViewModelTests.mockDistinctData())
    }

    func countFootprints() -&gt; Observable&lt;Int&gt; {
        return Observable.just(10)
    }

    func countFootprintsByTitle(_ text: String) -&gt; Observable&lt;Int&gt; {
        return Observable.just(10)
    }

    func delete(_ text: String) -&gt; Observable&lt;Error?&gt; {
        return Observable.just(nil)
    }
}

static let mockFootprints = { () -&gt; Results&lt;Footprint&gt;? in
    return realm.objects(Footprint.self).sorted(byKeyPath: "id")
}

static let mockDistinctData = { () -&gt; [(String, Int)] in
    return [("test1", 1), ("test2", 3)]
}

private func setUpInitialFootprint() {
    let footprint = Footprint()
    footprint.id = 1
    footprint.title = String()
    footprint.latitude = 35.0
    footprint.longitude = 137.0
    footprint.accuracy = 65.0
    footprint.speed = 1.0
    footprint.direction = 0.0
    try! FootprintRecordViewModelTests.realm.write {
        FootprintRecordViewModelTests.realm.create(Footprint.self, value: footprint, update: false)
    }
}

// 説明(3)
override func setUp() {
    super.setUp()
    // 初めにinMemoryに保存するデータを構築
    setUpInitialFootprint()

    let dependency = FootprintRecordViewModel.Dependency(realmManager: MockRealmManagerClient())
    viewModel = FootprintRecordViewModel(with: dependency)
}

// 説明(4)
override func tearDown() {
    super.tearDown()

    // inMemoryのデータは全て削除
    try! FootprintRecordViewModelTests.realm.write {
        FootprintRecordViewModelTests.realm.deleteAll()
    }
}

// 説明(5)
/// 初期ロード時に指定したデータが正しい順番&amp;内容でデータバインディングできることの確認
func testSavedRecordStream() {
    let disposeBag = DisposeBag()
    let footprintSectionModels = scheduler.createObserver([FootprintRecordSectionModel].self)

    viewModel.savedRecordStream
        .bind(to: footprintSectionModels)
        .disposed(by: disposeBag)

    scheduler.start()

    // 想定されるテスト結果の定義
    let items = [("test1", 1), ("test2", 3)]
    let mock = [FootprintRecordSectionModel(items: items)]
    let expectedItems = [Recorded.next(0, mock)]

    // 実際の実行結果
    let element = footprintSectionModels.events.first!.value.element

    // 想定結果と実行結果の比較
    XCTAssertEqual(element!.first!.items.first!.0, expectedItems.first!.value.element!.first!.items.first!.0)
    XCTAssertEqual(element!.first!.items.first!.1, expectedItems.first!.value.element!.first!.items.first!.1)
    XCTAssertEqual(element!.first!.items[1].0, expectedItems.first!.value.element!.first!.items[1].0)
    XCTAssertEqual(element!.first!.items[1].1, expectedItems.first!.value.element!.first!.items[1].1)
}
...
</code></pre>

<p>}
```</p>

<h5>説明(1)</h5>

<p><code>viewModel</code> と <code>scheduler</code> はサンプル1と同じです。<br/>
 今回、ここで下記定義を追加しています。</p>

<p> <code>objective-c
static let realm = try! Realm(configuration: Realm.Configuration(inMemoryIdentifier: "inMemory"))
</code></p>

<p>これは、このテスト対象が『 <code>RealmSwift</code> に保存したデータを利用する処理であること』が理由です。<br/>
<code>RealmSwift</code> では特にモックデータを返却するような仕組みはないため、自身で実装する必要があります。</p>

<p>最も簡単な方法が <strong>インメモリで一時保存したモックデータを利用する</strong> といったものになります。</p>

<h5>説明(2)</h5>

<p><code>RealmSwift</code> に保存したデータを取得するために <code>FootprintRecordViewModel</code> 内では <code>RealmManagerClient</code> を利用しています。</p>

<p>下記より、</p>

<ul>
<li><code>FootprintRecordViewModel</code> の初期化時に <code>RealmManagerClient</code> 型のオブジェクトを渡す</li>
<li><code>RealmManagerClient</code> は <code>protocol</code> として定義している</li>
</ul>


<p>各メソッドの返却値をテスト用に自由にカスタマイズ可能です。<br/>
ここでは <code>RealmManagerClient</code> に準拠した <code>MockRealmManagerClient</code> を 定義して、<br/>
<code>FootprintRecordViewModel</code> の初期化時の引数に渡しています。</p>

<h5>説明(3)</h5>

<p>セットアップで <code>RealmSwift</code> に、計測した足跡履歴が保存されている状態とします。</p>

<h5>説明(4)</h5>

<p>一応、今回は <strong>インメモリで保存している</strong> ので、アプリが終了したタイミングでメモリから解放されるはずではあるのですが、<br/>
テスト終了時に必ず実行する処理として <code>tearDown</code> メソッド内に <strong>インメモリで保存したデータの削除</strong> を仕込んでいます。</p>

<h5>説明(5)</h5>

<p>ここはサンプル1と同じですね。</p>

<ul>
<li>ストリームを捕捉する <code>Observer</code> として <code>footprintSectionModels</code> を定義</li>
<li>それを <code>savedRecordStream</code> に流れた時のバインディング先として設定</li>
<li>固定文言2つが <code>RxDataSources</code> 用の形で流れてくるため、そのモックデータを定義</li>
<li>初期ロード時に流れるはずなので <code>[Recorded.next(0, mock)]</code> と設定</li>
<li>想定結果と実行結果を <code>XCTAssertEqual</code> を用いて比較

<ul>
<li>モックデータとして2つのデータを用意しているので、両方比較して想定通りであることを確認します</li>
<li>これはデータの並び順まで想定通りであることを確認したいためです</li>
</ul>
</li>
</ul>


<h3>まとめ</h3>

<p>さて、如何でしたでしょうか？<br/>
以上が <code>Unit Test</code> の書き方の事例紹介になります。<br/>
iOSの <code>Unit Test</code> では、</p>

<ul>
<li><code>protocol</code> 準拠してマニュアルモックを実装する</li>
<li>初期化時に、上記を渡すことでテストデータとして利用できる</li>
</ul>


<p>ことが重要だと思っています。</p>

<p>ここを始めから念頭に置きつつ実装しないと、テストコードが書けずに苦労することになるでしょう。<br/>
(もしくはテストコードを書くために、元々の実装を見直すことになりかねません。)</p>

<p>と言ったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[QuickでSwiftコードのUnitテストをしよう！(2)]]></title>
    <link href="http://grandbig.github.io/blog/2017/05/06/quick-2/"/>
    <updated>2017-05-06T19:39:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2017/05/06/quick-2</id>
    <content type="html"><![CDATA[<h3>はじめに</h3>

<p>今回は久しぶりに<code>Quick</code>を使ったSwiftコードでのUnitテストについて見ていきたいと思います。<br/>
<a href="https://grandbig.github.io/blog/2016/01/16/quick/">前回</a>記事を書いてから実に1年以上経過しました。<br/>
当時、筆者はテスト駆動型での開発を業務で実行することがありませんでした。
最近は当たり前に単体テストを書かずにコードを書くことがありえないという開発環境になってきました。<br/>
しかし、それはWEBの世界に閉じており、iOSの世界では未だ、単体テストを書く工数が見合わないといった話が議論されていたりします。<br/>
言わんとすることはわからんでもないものの、WEBの世界でもテスト駆動型開発が広まるまではきっと同じような話をしていたのではないかと思ったりしています。<br/>
つまり、今後はiOSでも単体テストを書かないなんてありえないといった世界になるのでは？と期待しているのです。</p>

<p>そんな期待を抱きつつ、本記事を書いていきたいと思います。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h3>テスト内容</h3>

<p>今回テスト内容として<code>Realm</code>に関わる処理を取り上げたいと思います。<br/>
狙いとしてはSpring BootでWEBアプリケーションを開発したときで言うところの<code>Repository</code>に関するテストといったイメージになります。</p>

<h3>テスト対象処理</h3>

<p>さて、具体的なテストの対象となる処理を書きます。</p>

<p>```objective-c
// ViewController.swift
import UIKit
import RealmSwift</p>

<p>class ViewController: UIViewController {
  &lt;省略></p>

<p>  // IDからデータを検索
  func searchEngineerById(_ id: Int) &ndash;> Engineer? {</p>

<pre><code>let realm = try! Realm()
let engineers = realm.objects(Engineer.self).filter("id == \(id)")
if engineers.count &gt; 0 {
  return engineers[0]
}
return nil
</code></pre>

<p>  }</p>

<p>  // 名前からデータを検索
  func searchEngineerByName(_ name: String) &ndash;> Results<Engineer>? {</p>

<pre><code>let realm = try! Realm()
let engineers = realm.objects(Engineer.self).filter("name == '\(name)'")
if engineers.count &gt; 0 {
  return engineers
}
return nil
</code></pre>

<p>  }</p>

<p>  // 保存しているデータ数を取得
  func countEngineer() &ndash;> Int {</p>

<pre><code>let realm = try! Realm()
return realm.objects(Engineer.self).count
</code></pre>

<p>  }</p>

<p>  // 新規データ作成
  func createEngineer(name: String, level: Int, skills: [String]) {</p>

<pre><code>if searchEngineerByName(name) != nil {
  // 既に検索結果がある場合は処理を終了
  return
}

// 検索結果がない場合は処理を継続
let skillList = List&lt;Skill&gt;()
for skill in skills {
  let newSkill = Skill()
  newSkill.name = skill
  skillList.append(newSkill)
}

let engineer = Engineer()
engineer.id = countEngineer()
engineer.name = name
engineer.level = level
engineer.skills.append(objectsIn: skillList)
let realm = try! Realm()

try! realm.write {
  realm.create(Engineer.self, value: engineer, update: false)
}
</code></pre>

<p>  }</p>

<p>  // IDを元にレベルを更新
  func updateEngineerLevelById(_ id: Int, level: Int) &ndash;> Bool {</p>

<pre><code>if let engineer = searchEngineerById(id) {
  // 検索結果がある場合は処理を継続
  let realm = try! Realm()
  try! realm.write {
    engineer.level = level
  }
  return true
}

// 検索結果がない場合は処理を終了
return false
</code></pre>

<p>  }</p>

<p>  // IDを元にスキルを更新
  func updateEngineerSkillById(_ id: Int, skills: [String]) &ndash;> Bool {</p>

<pre><code>if let engineer = searchEngineerById(id) {
  // 検索結果がある場合は処理を継続
  let realm = try! Realm()
  try! realm.write {
    for skill in skills {
      let newSkill = Skill()
      newSkill.name = skill
      engineer.skills.append(newSkill)
    }
  }
  return true
}

// 検索結果がない場合は処理を終了
return false
</code></pre>

<p>  }
}
```</p>

<h3>Quickの導入方法</h3>

<p>Swift3になっていることもあるので、念のためQuickの導入方法を書いておきたいと思います。<br/>
(<code>Realm</code>も使っていることに注意してください。)</p>

<p><code>CocoaPods</code>にて導入します。</p>

<p>```objective-c</p>

<h1>Podfile</h1>

<p>use_frameworks!</p>

<p>target &ldquo;QuickTestSample&rdquo; do
  # Normal libraries
  pod &lsquo;RealmSwift&rsquo;</p>

<p>  abstract_target &lsquo;Tests&rsquo; do</p>

<pre><code>inherit! :search_paths
target "QuickTestSampleTests"
target "QuickTestSampleUITests"

pod 'Quick'
pod 'Nimble'
</code></pre>

<p>  end
end</p>

<p>post_install do |installer|
  installer.pods_project.targets.each do |target|</p>

<pre><code>target.build_configurations.each do |config|
  config.build_settings['SWIFT_VERSION'] = '3.0'
end
</code></pre>

<p>  end
end
```</p>

<h3>Quickでのテストコードの実装</h3>

<p>早速、Quickでのテストコードを実装していきましょう。</p>

<h4>Quickでテスト実行するための準備</h4>

<p>Quickでテストを実行するためには、テスト用に用意されたファイルのクラスを変更する必要があります。</p>

<p>```objective-c
// QuickTestSampleTests
import XCTest
import Quick
import Nimble
@testable import QuickTestSample</p>

<p>class QuickTestSampleTests: QuickSpec {
  override func spec() {</p>

<pre><code>...
</code></pre>

<p>  }
}
```</p>

<h4>テスト用データの作成について</h4>

<p>今回、<code>Realm</code>関連の処理を実装するにあたって悩んだのが、モック用のデータをどうするかという問題です。<br/>
今回取り上げている処理がかなりシンプルな処理であるため、<strong>manual mocking</strong> で作成するのも微妙です。</p>

<p>結果、下記のように実装しました。</p>

<p>```objective-c
// QuickTestSampleTests
import XCTest
import Quick
import Nimble
import RealmSwift   // 追加
@testable import QuickTestSample</p>

<p>class QuickTestSampleTests: QuickSpec {</p>

<p>  override func spec() {</p>

<pre><code>describe("Realm Database") {
  // テスト用のRealmデータ保存ファイルを作成
  // 保存場所はdefault.realmと同じでファイル名のみtest.realmに変更
  var config = Realm.Configuration()
  config.fileURL = config.fileURL!.deletingLastPathComponent().appendingPathComponent("test.realm")
  Realm.Configuration.defaultConfiguration = config
  // 上記の設定情報を利用してRealmを扱う
  let realm = try! Realm(configuration: config)

  beforeEach {
    // テスト用にモックデータを追加
    let engineer = Engineer()
    engineer.name = "mock_name"
    engineer.level = 1
    let skill = Skill()
    skill.name = "mock_skill_name"
    engineer.skills.append(skill)

    try! realm.write {
      realm.create(Engineer.self, value: engineer, update: false)
    }

    expect(engineer).notTo(beNil())
  }

  &lt;省略&gt;

  afterEach {
    // テスト終了後にデータを全て削除
    try! realm.write {
      realm.deleteAll()
    }
  }
}
</code></pre>

<p>  }<br/>
}
```</p>

<p>このように、最低限必要なモックデータをテスト用の<code>Realm</code>のデータベースに作成してみました。<br/>
<code>Realm</code>の使い方さえ間違えなければ、こちらでテストしたい独自処理には影響を与えないはずです。</p>

<p>上記のソースコードにコメントとして書いていますが、ポイントとしては下記の通りです。</p>

<ul>
<li>実際のアプリで利用する<code>Realm</code>ファイルとは別のテスト用の<code>Realm</code>ファイルを利用する</li>
<li>テスト実行前にテスト用のモックデータを作成する</li>
<li>テスト実行後はテスト用のモックデータを全て削除する</li>
</ul>


<h4>テストの記載箇所</h4>

<p>さて、実際にテストを実装すると下記のようになります。</p>

<p>```objective-c
// QuickTestSampleTests
&lt;省略></p>

<p>override func spec() {
  var subject: ViewController!
  describe(&ldquo;Realm Database&rdquo;) {</p>

<pre><code>beforeEach {
  &lt;省略&gt;
}

describe("searchEngineerById") {
  it("find realm data by id") {
    let engineer = subject.searchEngineerById(0)
    expect(engineer).notTo(beNil())
    expect(engineer?.name).to(equal("mock_name"))
  }
}

afterEach {
  &lt;省略&gt;
}
</code></pre>

<p>  }
}</p>

<p>&lt;省略>
```</p>

<p>ポイント次の通りです。</p>

<ul>
<li>テストの内容は<code>beforeEach</code>と<code>afterEach</code>の間に書く</li>
<li>メソッドごとにテストを記載していることをわかりやすくするために、<code>describe</code>でメソッドごとにくくる</li>
<li>テストで確かめたい内容次第で<code>notTo</code> / <code>to</code> / <code>equal</code> などを使い分ける</li>
</ul>


<h4>テストの内容</h4>

<p>では、テスト内容の詳細を個別に見ていきたいと思います。</p>

<h5>searchEngineerByIdのテスト</h5>

<p>まずは、<code>searchEngineerById</code>のテストを書きます。<br/>
このメソッドは検索成功時に<code>Engineer</code>型のオブジェクトを返し、検索失敗時には<code>nil</code>を返します。</p>

<p>そのため、このメソッドに対するテストとしては、</p>

<ul>
<li>検索成功：取得内容の整合性をチェック</li>
<li>検索失敗：<code>nil</code>であることをチェック</li>
</ul>


<p>を書くことになります。</p>

<p>```objective-c
// QuickTestSampleTests
describe(&ldquo;searchEngineerById&rdquo;) {
  // 取得内容の整合性チェック
  it(&ldquo;find realm data by id&rdquo;) {</p>

<pre><code>let engineer = subject.searchEngineerById(0)
expect(engineer).notTo(beNil())
expect(engineer?.name).to(equal("mock_name"))
expect(engineer?.skills[0].name).to(equal("mock_skill_name"))
</code></pre>

<p>  }</p>

<p>  // nilであることのチェック
  it(&ldquo;cannot find realm data by id&rdquo;) {</p>

<pre><code>let engineer = subject.searchEngineerById(1)
expect(engineer).to(beNil())
</code></pre>

<p>  }
}
```</p>

<h5>searchEngineerByNameのテスト</h5>

<p>続いて、<code>searchEngineerByName</code>のテストを書きます。<br/>
このメソッドは検索成功時に<code>List&lt;Engineer&gt;</code>型のオブジェクトを返し、検索失敗時には<code>nil</code>を返します。</p>

<p>そのため、このメソッドに対するテストとしては、</p>

<ul>
<li>検索成功：取得内容の整合性およびカウント数のチェック</li>
<li>検索失敗：<code>nil</code>であることをチェック</li>
</ul>


<p>を書くことになります。</p>

<p>```objective-c
describe(&ldquo;searchEngineerByName&rdquo;) {
  // 取得内容の整合性およびカウント数のチェック
  it(&ldquo;find realm data by name&rdquo;) {</p>

<pre><code>let engineers = subject.searchEngineerByName("mock_name")
expect(engineers).notTo(beNil())
expect(engineers?.count).to(equal(1))
expect(engineers?[0].name).to(equal("mock_name"))
expect(engineers?[0].skills[0].name).to(equal("mock_skill_name"))
</code></pre>

<p>  }</p>

<p>  // nilであることのチェック
  it(&ldquo;cannot find realm data by name&rdquo;) {</p>

<pre><code>let engineers = subject.searchEngineerByName("mock_mistake_name")
expect(engineers).to(beNil())
</code></pre>

<p>  }
}
```</p>

<h5>countEngineerのテスト</h5>

<p>次は<code>countEngineer</code>のテストを書きます。<br/>
このメソッドは検索成功時にデータのレコード数を返却します。<br/>
検索失敗時の処理は独自実装していないため成功時のテストのみ書きます。</p>

<p>```objective-c
describe(&ldquo;countEngineer&rdquo;) {
  // カウント数のチェック
  it(&ldquo;count realm data&rdquo;) {</p>

<pre><code>let count = subject.countEngineer()
expect(count).to(equal(1))
</code></pre>

<p>  }
}
```</p>

<h5>createEngineerのテスト</h5>

<p>今度は<code>createEngineer</code>のテストを書きます。<br/>
このメソッドは同名の<code>Engineer</code>オブジェクトが保存されている場合は、新規オブジェクトを作成しないということがポイントです。</p>

<p>そのため、このメソッドに対するテストとしては、</p>

<ul>
<li>新規<code>Engineer</code>オブジェクト作成が成功した場合：取得内容の整合性およびカウント数のチェック</li>
<li>新規<code>Engineer</code>オブジェクト作成が失敗した場合：カウント数が変わっていないことをチェック</li>
</ul>


<p>を書くことになります。</p>

<p>```objective-c
describe(&ldquo;createEngineer&rdquo;) {
  // カウント数が変わっていないことのチェック
  it(&ldquo;cannot create engineer&rdquo;) {</p>

<pre><code>subject.createEngineer(name: "mock_name", level: 1, skills: ["swift"])
let engineers = subject.searchEngineerByName("mock_name")
expect(engineers).notTo(beNil())
expect(engineers?.count).to(equal(1))
</code></pre>

<p>  }</p>

<p>  // 取得内容の整合性およびカウント数のチェック
  it(&ldquo;create new engineer&rdquo;) {</p>

<pre><code>subject.createEngineer(name: "takahiro", level: 1, skills: ["swift", "spring boot", "react.js"])
let engineers = subject.searchEngineerByName("takahiro")
expect(engineers).notTo(beNil())
expect(engineers?.count).to(equal(1))
expect(engineers?[0].name).to(equal("takahiro"))
expect(engineers?[0].skills.count).to(equal(3))
expect(engineers?[0].skills[0].name).to(equal("swift"))
expect(engineers?[0].skills[1].name).to(equal("spring boot"))
expect(engineers?[0].skills[2].name).to(equal("react.js"))
</code></pre>

<p>  }
}
```</p>

<h5>updateEngineerLevelByIdのテスト</h5>

<p><code>updateEngineerLevelById</code>のテストを書きます。<br/>
このメソッドは成功可否に応じて<code>true / false</code>を返却します。</p>

<p>そのため、このメソッドに対するテストとしては、</p>

<ul>
<li>更新成功：<code>true</code>であることをチェック</li>
<li>更新失敗：<code>false</code>であることをチェック</li>
</ul>


<p>を書くことになります。</p>

<p>```objective-c
describe(&ldquo;updateEngineerLevelById&rdquo;) {
  // trueであることをチェック
  it(&ldquo;update level for realm data by id&rdquo;) {</p>

<pre><code>let updated = subject.updateEngineerLevelById(0, level: 2)
let engineer = subject.searchEngineerById(0)
expect(updated).to(beTrue())
expect(engineer?.level).to(equal(2))
</code></pre>

<p>  }</p>

<p>  // falseであることをチェック
  it(&ldquo;cannot update level for realm data by id&rdquo;) {</p>

<pre><code>let updated = subject.updateEngineerLevelById(2, level: 2)
expect(updated).to(beFalse())
</code></pre>

<p>  }
}
```</p>

<h5>updateEngineerSkillByIdのテスト</h5>

<p><code>updateEngineerSkillById</code>のテストを書きます。<br/>
このメソッドは成功可否に応じて<code>true / false</code>を返却します。</p>

<p>そのため、このメソッドに対するテストとしては、</p>

<ul>
<li>更新成功：<code>true</code>であることをチェック</li>
<li>更新失敗：<code>false</code>であることをチェック</li>
</ul>


<p>を書くことになります。</p>

<p>```objective-c
describe(&ldquo;updateEngineerSkillById&rdquo;) {
  // trueであることをチェック
  it(&ldquo;update skill for realm data by id&rdquo;) {</p>

<pre><code>let updated = subject.updateEngineerSkillById(0, skills: ["mock_skill_name_2"])
let engineer = subject.searchEngineerById(0)
expect(updated).to(beTrue())
expect(engineer?.skills.count).to(equal(2))
expect(engineer?.skills[0].name).to(equal("mock_skill_name"))
expect(engineer?.skills[1].name).to(equal("mock_skill_name_2"))
</code></pre>

<p>  }</p>

<p>  // falseであることをチェック
  it(&ldquo;cannot update skill for realm data by id&rdquo;) {</p>

<pre><code>let updated = subject.updateEngineerSkillById(2, skills: ["mock_skill_name_2"])
expect(updated).to(beFalse())
</code></pre>

<p>  }
}
```</p>

<h3>Quickでのテストコードの書式</h3>

<p>今回新たに出た書式についてまとめておきます。</p>

<h4>notTo</h4>

<p>対象と異なることを期待するときに利用します。</p>

<ul>
<li>書式例：<code>expect(engineer).notTo(beNil())</code></li>
<li>期待値：<code>engineer</code>オブジェクトが<code>nil</code>でない</li>
</ul>


<h4>to</h4>

<p>対象と一致することを期待するときに利用します。</p>

<h5>equalと組み合わせた場合</h5>

<ul>
<li>書式例：<code>expect(engineer?.name).to(equal("mock_name"))</code></li>
<li>期待値：<code>engineer</code>オブジェクトの<code>name</code>プロパティが<code>mock_name</code>と一致すること</li>
</ul>


<h5>beTrue / beFalseと組み合わせた場合</h5>

<ul>
<li>書式例：<code>expect(updated).to(beTrue())</code></li>
<li>期待値：<code>updated</code>の値が<code>true</code>と一致すること</li>
</ul>


<h4>beNil / equal / beTrue / beFalse</h4>

<p>それぞれ、</p>

<ul>
<li>beNil()：<code>nil</code>であること</li>
<li>equal()：引数の値であること(数字や文字列などを引数に設定します)</li>
<li>beTrue()：<code>true</code>であること</li>
<li>beFalse()：<code>false</code>であること</li>
</ul>


<p>を意味します。</p>

<h3>まとめ</h3>

<p>さて如何でしたでしょうか。<br/>
今回は最近の経験を元にiOSでテスト駆動型の開発をするなら&hellip;をイメージして書いてみました。<br/>
次はもっと複雑なパターンのテストを試しに書いてみても良いかなと思いつつ、本日はここまで。</p>

<p>参考:</p>

<ul>
<li><a href="https://realm.io/jp/docs/swift/latest/#realm-3">Realm公式ドキュメント</a></li>
<li><a href="https://news.realm.io/jp/news/rachel-bobbins-testing-view-controllers-quick/">Quickを使ってビューコントローラをテストする</a></li>
<li><a href="https://github.com/Quick/Quick/blob/master/Documentation/ja/ConfiguringQuick.md">Quickの挙動をカスタマイズしましょう</a></li>
<li><a href="https://github.com/Quick/Quick/blob/master/Documentation/ja/QuickExamplesAndGroups.md">QuickのExamplesとExample Groupsで、たくさんのテストでも整理整頓</a></li>
</ul>


<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[QuickでSwiftコードのUnitテストをしよう！]]></title>
    <link href="http://grandbig.github.io/blog/2016/01/16/quick/"/>
    <updated>2016-01-16T19:49:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2016/01/16/quick</id>
    <content type="html"><![CDATA[<h4>Quickフレームワークを使おう！</h4>

<p>先日、XCTestによるiOSアプリのUnit TestとUI Testについて記事を書きました。<br/>
もちろんXCTestを使って、テストをすることに問題はありません。<br/>
ですが、XCTestは非常に独特な書式で、初めて使う人には取っ付きにくいかと思います。</p>

<p>そんな中、注目を集めているiOSアプリ用のテストフレームワークが<a href="https://github.com/Quick/Quick">Quick</a>です。<br/>
GitHubに書かれている通り、<a href="https://github.com/rspec/rspec">RSpec</a> / <a href="https://github.com/specta/specta">Specta</a> / <a href="https://github.com/onsi/ginkgo">Ginkgo</a>にインスパイアされて開発されているため、親しみやすい書式でテストコードを書くことができます。<br/>
(筆者もこれを機に親しもうと思います笑)</p>

<p>これまでiOSアプリのテストコードは独特で&hellip;と避けてきた方がいましたら、ぜひ <strong>Quick</strong> を導入してみて頂ければと思います。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h4>Quickの導入方法</h4>

<p>では、Quickを導入しましょう。<br/>
GitHubにも書いてありますが、CocoaPodsでの導入方法は下記です。<br/>
※ 説明用のプロジェクト名を <strong>QuickSample</strong> とします。</p>

<p>１．Podfileの作成</p>

<p>```objective-c</p>

<h1>Podfile</h1>

<p>use_frameworks!</p>

<p>def testing_pods</p>

<pre><code>pod 'Quick', '~&gt; 0.8.0'
pod 'Nimble', '3.0.0'
</code></pre>

<p>end</p>

<p>target &lsquo;QuickSampleTests&rsquo; do</p>

<pre><code>testing_pods
</code></pre>

<p>end</p>

<p>target &lsquo;QuickSampleUITests&rsquo; do</p>

<pre><code>testing_pods
</code></pre>

<p>end
```</p>

<p>２．CocoaPodsコマンドを実行<br/>
Podfileと同階層で<code>pod install</code>を実行</p>

<p>３．テストファイルを用意<br/>
プロジェクト作成時に<code>QuickSampleTests.swift</code>を作成しておいたので、それを編集します。</p>

<p>```objective-c
// QuickSampleTests.swift
import XCTest
import Quick
import Nimble
@testable import QuickSample</p>

<p>class QuickSampleTests: QuickSpec {</p>

<pre><code>override func spec() {
    // ここにテストコードを書いていきます。
}
</code></pre>

<p>}
```</p>

<p>これで<code>QuickSpec</code>をオーバーライドしたテスト用クラスになりました。<br/>
最低限の準備はこれで完了です。</p>

<h4>Quickでのテストコードの書式</h4>

<p>続いて、基本的なテストコードの書式を見ていきましょう。</p>

<p>１．<code>describe</code>：『何のテストをするのか』を記述</p>

<p>```objective-c
// テストコード
override func spec() {</p>

<pre><code>describe("天気情報をログ出力する") {
    // 「天気情報をログ出力する」ことをテストするためのコードを書いていきます。
}
</code></pre>

<p>}
```</p>

<p>２．<code>context</code>：『どういった条件のテストをするのか』を記述</p>

<p>```objective-c
// テストコード
override func spec() {</p>

<pre><code>describe("天気情報をログ出力する") {
    context("晴れの場合") {
        // 天気が晴れの場合のテスト
    }

    context("雨の場合") {
        // 天気が雨の場合のテスト
    }
}
</code></pre>

<p>}
```</p>

<p>３．<code>it</code>：『このテストはこういった結果になる』ということを記述</p>

<p>```objective-c
// テストコード
override func spec() {</p>

<pre><code>describe("天気情報をログ出力する") {
    context("晴れの場合") {
        // 天気が晴れの場合のテスト
        it("print out 'sunny'") {
            // 実行するテストコードをここに記述します
        }
    }

    &lt;省略&gt;
}
</code></pre>

<p>}
```</p>

<p>４．<code>expect('☓☓☓').to(△△△)</code>：『「☓☓☓」が「△△△」と等しい結果になる』ことを記述<br/>
ここは説明のために、テスト対象を<code>Weather.swift</code>として下記のようなコードだとします。<br/>
あくまでも<code>expect('☓☓☓').to(△△△)</code>の説明であるため、<code>Weather.getWeather</code>の処理は超簡単にしています。</p>

<p>```objective-c
// Weather.swift
class Weather:NSObject {</p>

<pre><code>&lt;省略&gt;

func getWeather() -&gt; String {
    return "sunny"
}

&lt;省略&gt;
</code></pre>

<p>}
```</p>

<p>続いてテストコードです。</p>

<p>```objective-c
// テストコード
override func spec() {</p>

<pre><code>describe("天気情報をログ出力する") {
    context("晴れの場合") {
        // 天気が晴れの場合のテスト
        it("print out 'sunny'") {
            let weather = Weather().getWeather()
            expect(weather).to(contain("sunny"))
        }
    }

    &lt;省略&gt;
}
</code></pre>

<p>}
```</p>

<p>補足すると、</p>

<p>・戻り値と期待値が完全一致する場合：<code>to(equal(△△△))</code><br/>
・戻り値が期待値の一部を含む場合：<code>to(contain(△△△))</code></p>

<p>といったように使い分けましょう。</p>

<p>５．非同期処理のテストをする場合<br/>
これまで同期処理を見てきましたが、今度は非同期処理を見ていきましょう。</p>

<p><code>Weather.swift</code>クラスに非同期処理を追加します。</p>

<p>```objective-c
// Weather.swift
class Weather:NSObject {</p>

<pre><code>&lt;省略&gt;

func getAsyncWeather(closure:(String) -&gt; Void) {
    Alamofire.request(.GET, "http://api.openweathermap.org/data/2.5/weather?APPID=&lt;自身のAPPIDを指定&gt;", parameters:
        ["q":"Tokyo,jp"]).response { (request, response, data, error) -&gt; Void in
        if(error == nil) {
            do {
                let dataDict = try NSJSONSerialization.JSONObjectWithData(data!, options: NSJSONReadingOptions.AllowFragments)
                let weatherArray:[AnyObject] = dataDict["weather"] as! [AnyObject]
                let weather:AnyObject = weatherArray[0]
                let description:String = weather["description"] as! String
                closure(description)
            } catch {
                clouser("exception")
            }
        }
}

&lt;省略&gt;
</code></pre>

<p>}
```</p>

<p>XCTestでも説明しましたが、<br/>
Swiftではスタブの代わりに <strong>manual mocking</strong> という手法を採用しています。<br/>
なので、通信処理はテストコード内で継承したクラスを作成して、そちらで定数を返すようにしましょう。</p>

<p>```objective-c
// テストコード
override func spec() {</p>

<pre><code>// manual mockingのための用意
class WeatherMock:Weather {
    override func getAsyncWeather(closure:(String) -&gt; Void) {
        closure("sunny")
    }
}

describe("天気情報を取得する") {
    context("晴れの場合") {
        // 天気が晴れの場合のテスト
        it("print out 'sunny'") {
            var result:String = ""
            let wm:WeatherMock = WeatherMock()
            wm.getAsyncWeather{(weather) -&gt; Void in
                result = weather
            }
            expect(result).toEventually(equal("sunny"))"
        }
    }

    &lt;省略&gt;
}
</code></pre>

<p>}
```</p>

<p>因みに、非同期処理では、<code>to</code>ではなく<code>toEventually</code>を利用します。<br/>
<code>expect(result).toEventually(equal("sunny"), timeout: 10)</code>と書けば、<br/>
任意のタイムアウトを設定可能です。</p>

<p>その他のメソッドを探したい場合は、<br/>
<strong>Pods > Nimble > ObjCExpectation.swift > NMBExpectation</strong> を確認してみてください。<br/>
また、<a href="https://github.com/Quick/Nimble">GitHubのNimble</a>も参考になります。</p>

<h4>Quickでのテスト結果</h4>

<p>テストの実行方法はXCTestと同じです。<br/>
<strong>Xcodeメニュー > Product > Test</strong> を選択してテストを実行しましょう。</p>

<p>結果は同じく、Xcodeの左メニューに表示されます。</p>

<p><img src="/images/quick.png" alt="Xcodeのテスト結果" /></p>

<p>また、ログでも細かな結果が出力されますので、<br/>
(少し見づらいですが)なぜかテストが成功しないといったことがあれば、<br/>
積極的に確認してみましょう。</p>

<p>さて、いかがでしたでしょうか？<br/>
今のところは <strong>XCTest</strong> もしくは <strong>Quick</strong> によるUnit テストが主流になると思います。<br/>
開発者の使いやすさに合わせて選んでみてください。</p>

<p>と言ったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SwiftでXCTestを使って単体テストとUIテストをしてみよう！]]></title>
    <link href="http://grandbig.github.io/blog/2016/01/11/xctest/"/>
    <updated>2016-01-11T19:17:00+09:00</updated>
    <id>http://grandbig.github.io/blog/2016/01/11/xctest</id>
    <content type="html"><![CDATA[<h4>iOSアプリケーション開発でのテストとは</h4>

<p>さて、本日はiOSアプリケーションを開発する際のテストについて書きたいと思います。<br/>
元々、Objective-Cでは下記のテスト用のライブラリが使われてきました。</p>

<ul>
<li><a href="https://github.com/kiwi-bdd/Kiwi">Kiwi</a></li>
<li><a href="https://github.com/gh-unit/gh-unit">GHUnit</a></li>
<li><a href="https://github.com/specta/specta">Specta</a></li>
</ul>


<p>しかし、これらはあくまでもObjective-C時代にApple公式のテストフレームワークが充実する以前から活躍していたものです。今後、Swiftが普及するにつれて、これらのテストフレームワークもSwiftに最適化したものになっていくかもしれません。<br/>
とは言え、AppleもいつまでもOSSのテストフレームワークがなければならない状況は避け、Xcode内で完結することを目指していくかもしれません。<br/>
後ほど詳しく説明しますが、Xcode7からUIテストが新たに追加されたのも、その流れだと思っています。</p>

<p>本日は特に <strong>XCTest</strong> に焦点をあてた、iOSにおけるテストについて見ていきたいと思います。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h4>XCTestでUnit Test</h4>

<p>早速、XCTestの使い方について見ていきましょう。<br/>
Xcode7ではプロジェクトを新規作成する際にXCTest用のTargetを作成するか否かを選ぶことができます。<br/>
初めにチェックを入れていない場合は、途中で追加することが可能ですが、単体テストをすることは大切なので、チェックはつけておきましょう。</p>

<p><img src="/images/xctest_1.png" alt="プロジェクト作成時にXCTest用のTargetを作成" /></p>

<p>今回テストするソースコードは下記のようなシンプルなものにします。</p>

<p>```objective-c
import UIKit
import Alamofire</p>

<p>class ViewController: UIViewController {</p>

<pre><code>override func viewDidLoad() {
    super.viewDidLoad()
}

override func didReceiveMemoryWarning() {
    super.didReceiveMemoryWarning()
}

func showWeather() {
    self.getWeather{(description) -&gt; Void in
        print(description)
    }
}

func getWeather(closure:(String) -&gt; Void) {
    Alamofire.request(.GET, "http://api.openweathermap.org/data/2.5/weather?APPID=&lt;自身のAPPIDを指定&gt;", parameters:
        ["q":"Tokyo"]).response { (request, response, data, error) -&gt; Void in
        if(error == nil) {
            do {
                let dataDict = try NSJSONSerialization.JSONObjectWithData(data!, options: NSJSONReadingOptions.AllowFragments)
                let weatherArray:[AnyObject] = dataDict["weather"] as! [AnyObject]
                let weather:AnyObject = weatherArray[0]
                let description:String = weather["description"] as! String

                // アラートを表示
                self.showAlert(description)
            } catch {
                print("例外が発生しました！")
            }
        }
    }
}
</code></pre>

<p>}
```</p>

<p>今回は <strong>showWeather</strong> メソッドのUnit Testを書いていきます。<br/>
上記コードを見て頂くと、 <strong>showWeather</strong> メソッドは <strong>Open Weather Map API</strong> を使って東京の天気を取得し、それをログとして出力していることがわかると思います。<br/>
前半の <strong>Alamofire</strong> を使った通信処理はOSSライブラリを使っているわけで、この通信処理のテストがしたいわけではありません。<br/>
筆者が実施したいテストは後半の <strong>Open Weather Map API</strong> を使って <strong>取得した天気情報をログに出力する</strong> 部分です。<br/>
(本来はテストするまでもないのですが、テストの手法や考え方をメインに説明したいので、ソースは超簡単にしています。)</p>

<p>それを踏まえた上で、実際にテストコードを書いてみましょう。<br/>
&lt;Project名>Tests.swiftファイルを選択します。</p>

<p>```objective-c
import XCTest
@testable import SimpleApplication</p>

<p>class SimpleApplicationTests: XCTestCase {</p>

<pre><code>override func setUp() {
    super.setUp()
}

override func tearDown() {
    super.tearDown()
}

func testShowWeather() {
    class VCMock:ViewController {
        override func getWeather(closure:(String) -&gt; Void) {
            closure("test weather")
        }
    }

    let vcm:VCMock = VCMock()
    vcm.showWeather()
}
</code></pre>

<p>}
```</p>

<p>ポイントは</p>

<ol>
<li>テストメソッドの定義<br/>
テストメソッドは、 <strong>test + &lt;任意の文字列></strong> で命名しましょう。</li>
<li>スタブの定義<br/>
Swiftは <strong>manual mocking</strong> という手法を取ります。<br/>
これはテスト対象クラスを継承したクラスを定義し、テストしたいメソッドをオーバーライドします。<br/>
返却値等を固定文字列とすることで、スタブの作成となります。</li>
</ol>


<p>の2点です。</p>

<p>では、このテストを実行してみます。</p>

<p>まず、実行Targetに <strong>&lt;Project名>Tests</strong> を選択できるようにSchemeを編集します。</p>

<p><img src="/images/xctest_2.png" alt="Manage Schemes..." /></p>

<p><img src="/images/xctest_3.png" alt="Add Scheme" /></p>

<p><img src="/images/xctest_4.png" alt="Choose Testsファイル" /></p>

<p><img src="/images/xctest_5.png" alt="Set Scheme" /><br/>
実行するSchemeを <strong>&lt;Project名>Tests</strong> に設定し、実行デバイスをシミュレータにします。<br/>
(実機ではテスト実行できないからです。)</p>

<p><img src="/images/xctest_6.png" alt="Testを実行" /><br/>
Xcodeメニュー > Product > Test を選択してテストを実行します。</p>

<p><img src="/images/xctest_7.png" alt="テスト結果の確認" /><br/>
左メニューおよびコード上からテスト結果を確認できます。</p>

<p>メソッドが増えるごとにテストメソッドを増やしていきましょう。<br/>
テストファイルはクラス別に作成しておくと、第三者から見ても見やすいと思います。</p>

<h4>XCTestでUI Test</h4>

<p>続いて、Xcode7から追加されたUI Testの方法を見ていきたいと思います。<br/>
冒頭で説明した通り、プロジェクト作成時に <strong>include UI Tests</strong> を選択しておくことで、 <strong>&lt;Project名>UITests.swift</strong> ファイルが作成されます。</p>

<p>では、UI Test用に少しコードを修正してみます。</p>

<p>```objective-c
import UIKit
import Alamofire</p>

<p>class ViewController: UIViewController {</p>

<pre><code>override func viewDidLoad() {
    super.viewDidLoad()
}

override func didReceiveMemoryWarning() {
    super.didReceiveMemoryWarning()
}

@IBAction func getWeatherAction(sender: AnyObject) {
    self.getWeather { (description) -&gt; Void in
        self.showAlert(description)
    }
}

func getWeather(closure:(String) -&gt; Void) {
    Alamofire.request(.GET, "http://api.openweathermap.org/data/2.5/weather?APPID=&lt;自身のAPPIDを指定&gt;", parameters:
        ["q":"Tokyo"]).response { (request, response, data, error) -&gt; Void in
        if(error == nil) {
            do {
                let dataDict = try NSJSONSerialization.JSONObjectWithData(data!, options: NSJSONReadingOptions.AllowFragments)
                let weatherArray:[AnyObject] = dataDict["weather"] as! [AnyObject]
                let weather:AnyObject = weatherArray[0]
                let description:String = weather["description"] as! String

                // アラートを表示
                self.showAlert(description)
            } catch {
                print("例外が発生しました！")
            }
        }
    }
}

func showAlert(message:String) {
    let alertController:UIAlertController = UIAlertController(title: "確認", message: message, preferredStyle: .Alert)
    let okAction:UIAlertAction = UIAlertAction(title: "OK", style: .Default) { (alert) -&gt; Void in
        // OKを選択したときに実行される処理
    }
    alertController.addAction(okAction)

    presentViewController(alertController, animated: true, completion: nil)
}
</code></pre>

<p>}
```</p>

<p>これに伴い、画面にボタンを配置しました。<br/>
このボタンをタップすると、天気情報をアラートで表示してくれます。</p>

<p><img src="/images/xctest_8.png" alt="ボタンを配置" /></p>

<p><img src="/images/xctest_9.png" alt="アラートを表示" /></p>

<p>では、UI Testのテストコードを作成します。<br/>
UI Testの場合は、Xcodeの <strong>UI recording</strong> 機能を使って、手作業でコードを修正していきます。</p>

<p><img src="/images/xctest_10.png" alt="UI recording 開始ボタンをタップ" /></p>

<p><img src="/images/xctest_11.png" alt="UI recording 終了ボタンをタップ" /></p>

<p>すると、下記のようなコードが生成されました。</p>

<p>```objective-c
func testShowWeatherAlert() {</p>

<pre><code>let app = XCUIApplication()
app.buttons["GET Weather"].tap()
app.alerts["\U78ba\U8a8d"].collectionViews.buttons["OK"].tap()
</code></pre>

<p>}
```</p>

<p>しかし、このままではエラーが表示されるはずです。<br/>
理由はアラートのタイトルを日本語にしていたため、ASCIIコードで表示されてしまっているからです。<br/>
もし、指し示しているASCIIコードが理解できないようであれば、<a href="http://web-apps.nbookmark.com/ascii-converter/">ASCIIコード変換機</a>を使ってください。</p>

<p>ASCIIコード部分を修正した結果が下記となります。</p>

<p>```objective-c
func testShowWeatherAlert() {</p>

<pre><code>let app = XCUIApplication()
app.buttons["GET Weather"].tap()
app.alerts["確認"].collectionViews.buttons["OK"].tap()
</code></pre>

<p>}
```</p>

<p>テストコードが作成できましたので、実行Targetに &lt;Project名>UITests を選択できるようにSchemeを編集します。</p>

<p><img src="/images/xctest_12.png" alt="Manage Schemes..." /></p>

<p><img src="/images/xctest_13.png" alt="Add Scheme" /></p>

<p><img src="/images/xctest_14.png" alt="Choose Testsファイル" /></p>

<p><img src="/images/xctest_15.png" alt="Set Scheme" /><br/>
実行するSchemeを &lt;Project名>UITests に設定し、実行デバイスをシミュレータにします。<br/>
(実機ではテスト実行できないからです。)</p>

<p><img src="/images/xctest_6.png" alt="Testを実行" /><br/>
Xcodeメニュー > Product > Test を選択してテストを実行します。</p>

<p><img src="/images/xctest_16.png" alt="テスト結果の確認" /><br/>
左メニューおよびコード上からテスト結果を確認できます。</p>

<p>Unit Testと同様にメソッドが増えるごとにテストメソッドを増やしていきましょう。<br/>
テストファイルはクラス別に作成しておくと、第三者から見ても見やすいと思います。</p>

<p>いかがだったでしょうか？<br/>
今回は超簡単なサンプルコードで基本的なことについて説明しましたが、今後深く使っていくことで躓くこともあるかもしれません。<br/>
その際にはまたブログにて説明したいと思います。<br/>
ぜひ、単体テストとUIテストを駆使して、バグの少ないアプリを作っていきたいものです。</p>

<p>と言ったところで本日はここまで。</p>

<script async src="http://grandbig.github.io//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<p><ins class="adsbygoogle"style="display:inline-block;width:320px;height:100px"data-ad-client="ca-pub-2881241309408290"data-ad-slot="6603059167"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
  </entry>
  
</feed>
